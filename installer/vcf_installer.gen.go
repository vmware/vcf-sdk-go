// © Broadcom. All Rights Reserved.
// The term “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.
// SPDX-License-Identifier: BSD-2-Clause
//
// Package installer provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package installer

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for InstallerSpecType.
const (
	External         InstallerSpecType = "External"
	Internal         InstallerSpecType = "Internal"
	InternalExternal InstallerSpecType = "Internal, External"
)

// Defines values for ProxyConfigurationTransferProtocol.
const (
	HTTP  ProxyConfigurationTransferProtocol = "HTTP"
	HTTPS ProxyConfigurationTransferProtocol = "HTTPS"
)

// Defines values for ResourcePoolSpecCpuSharesLevel.
const (
	ResourcePoolSpecCpuSharesLevelCustomhighlownormal ResourcePoolSpecCpuSharesLevel = "custom,high,low,normal"
)

// Defines values for ResourcePoolSpecMemorySharesLevel.
const (
	ResourcePoolSpecMemorySharesLevelCustomhighlownormal ResourcePoolSpecMemorySharesLevel = "custom,high,low,normal"
)

// Defines values for ResourcePoolSpecType.
const (
	Compute    ResourcePoolSpecType = "compute"
	Management ResourcePoolSpecType = "management"
	Network    ResourcePoolSpecType = "network"
)

// Defines values for SddcNetworkConfigProfileSpecStorageType.
const (
	FC      SddcNetworkConfigProfileSpecStorageType = "FC"
	NFS     SddcNetworkConfigProfileSpecStorageType = "NFS"
	VSAN    SddcNetworkConfigProfileSpecStorageType = "VSAN"
	VSANESA SddcNetworkConfigProfileSpecStorageType = "VSAN_ESA"
)

// Defines values for SetCeipStatusJSONBody.
const (
	DISABLED        SetCeipStatusJSONBody = "DISABLED"
	DISABLING       SetCeipStatusJSONBody = "DISABLING"
	DISABLINGFAILED SetCeipStatusJSONBody = "DISABLING_FAILED"
	ENABLED         SetCeipStatusJSONBody = "ENABLED"
	ENABLING        SetCeipStatusJSONBody = "ENABLING"
	ENABLINGFAILED  SetCeipStatusJSONBody = "ENABLING_FAILED"
)

// AlternativeApplicableSddcManagerVersion Version of Target SDDC Manager
type AlternativeApplicableSddcManagerVersion struct {
	// Version Version of target SDDC manger
	Version *string `json:"version,omitempty"`
}

// ApplianceInfo Appliance Information
type ApplianceInfo struct {
	// Role Appliance Role
	Role *string `json:"role,omitempty"`

	// Version Appliance version
	Version *string `json:"version,omitempty"`
}

// Bundle Bundle contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
type Bundle struct {
	// ApplicabilityOrder Bundle Applicability Order
	ApplicabilityOrder *int32 `json:"applicabilityOrder,omitempty"`

	// ApplicabilityStatus Bundle Applicability Status
	ApplicabilityStatus *string `json:"applicabilityStatus,omitempty"`

	// Components Bundle Components
	Components *[]BundleComponent `json:"components,omitempty"`

	// Description Bundle Description
	Description *string `json:"description,omitempty"`

	// DownloadStatus Bundle Download Status
	DownloadStatus *string `json:"downloadStatus,omitempty"`

	// Id Bundle ID
	Id *string `json:"id,omitempty"`

	// IsCompliant Is compliant with the current VCF version
	IsCompliant *bool `json:"isCompliant,omitempty"`

	// IsCumulative Is Bundle Cumulative
	IsCumulative *bool `json:"isCumulative,omitempty"`

	// IsPartiallyUpgraded Is Bundle partially upgraded
	IsPartiallyUpgraded *bool `json:"isPartiallyUpgraded,omitempty"`

	// ReleasedDate Bundle Release Date
	ReleasedDate *string `json:"releasedDate,omitempty"`

	// Severity Bundle Severity
	Severity *string `json:"severity,omitempty"`

	// SizeMB Bundle Size in MB
	SizeMB *float64 `json:"sizeMB,omitempty"`

	// Type Bundle Type
	Type *string `json:"type,omitempty"`

	// Vendor Bundle Vendor
	Vendor *string `json:"vendor,omitempty"`

	// Version Bundle Version
	Version *string `json:"version,omitempty"`
}

// BundleComponent Bundle Software Component
type BundleComponent struct {
	// Description Bundle Component Description
	Description *string `json:"description,omitempty"`

	// FromVersion Bundle Component's from/source version before Upgrade
	FromVersion *string `json:"fromVersion,omitempty"`

	// Id ID of Resource/Software Component
	Id *string `json:"id,omitempty"`

	// ImageType Bundle Component Image Type
	ImageType *string `json:"imageType,omitempty"`

	// ReleasedDate Bundle Component Release Date
	ReleasedDate *string `json:"releasedDate,omitempty"`

	// ToVersion Bundle Component's to/target version after Upgrade
	ToVersion *string `json:"toVersion,omitempty"`

	// Type Type of Resource/Software Component
	Type *string `json:"type,omitempty"`

	// Vendor Bundle Component Vendor
	Vendor *string `json:"vendor,omitempty"`
}

// BundleDownloadSpec Bundle Download Specification. This specification gets used in the Bundle Download API
type BundleDownloadSpec struct {
	// CancelNow Flag for cancelling the download. If true, scheduledTimestamp/downloadNow is ignored
	CancelNow *bool `json:"cancelNow,omitempty"`

	// DownloadNow Flag for enabling Download Now. If true, scheduledTimestamp is ignored
	DownloadNow *bool `json:"downloadNow,omitempty"`

	// ScheduledTimestamp Bundle Download Scheduled Time
	ScheduledTimestamp *string `json:"scheduledTimestamp,omitempty"`
}

// BundleDownloadStatusInfo Model for download status for the bundle of a release component.
type BundleDownloadStatusInfo struct {
	// BundleId The bundle ID associated with a component version.
	BundleId *string `json:"bundleId,omitempty"`

	// ComponentType The type of the component that the bundle represents.
	ComponentType *string `json:"componentType,omitempty"`

	// DownloadEndTime The time when the download finished or interrupted.
	DownloadEndTime *int64 `json:"downloadEndTime,omitempty"`

	// DownloadId The task ID of the download.
	DownloadId *string `json:"downloadId,omitempty"`

	// DownloadScheduledTime The time when the download was scheduled to start.
	DownloadScheduledTime int64 `json:"downloadScheduledTime"`

	// DownloadStartTime The time when the download started.
	DownloadStartTime *int64 `json:"downloadStartTime,omitempty"`

	// DownloadStatus The current status of the download.
	DownloadStatus string `json:"downloadStatus"`

	// DownloadedSize The size of the file part that was downloaded so far.
	DownloadedSize *int64 `json:"downloadedSize,omitempty"`

	// IsDownloadCancellable True if download can be cancelled.
	IsDownloadCancellable bool `json:"isDownloadCancellable"`

	// IsDownloadable Indicates whether the bundle for this component version is downloadable currently or not.
	IsDownloadable *bool `json:"isDownloadable,omitempty"`

	// Message In case of failed download, the error message.
	Message *string `json:"message,omitempty"`

	// Version The version (patch version) of the component.
	Version *string `json:"version,omitempty"`
}

// BundleUpdateSpec Bundle Update Specification
type BundleUpdateSpec struct {
	// BundleDownloadSpec Bundle Download Specification. This specification gets used in the Bundle Download API
	BundleDownloadSpec *BundleDownloadSpec `json:"bundleDownloadSpec,omitempty"`
}

// BundleUploadSpec Bundle Upload Specification
type BundleUploadSpec struct {
	// BundleFilePath Bundle Upload File Path
	BundleFilePath string `json:"bundleFilePath"`

	// CompatibilitySetsFilePath [Deprecated] Path to the software compatibility sets file
	// Deprecated:
	CompatibilitySetsFilePath *string `json:"compatibilitySetsFilePath,omitempty"`

	// ManifestFilePath Bundle Upload Manifest File Path
	ManifestFilePath string `json:"manifestFilePath"`

	// PartnerExtensionSpec Specification for partner extensions. This specification is used in the Bundle Upload API
	PartnerExtensionSpec *PartnerExtensionSpec `json:"partnerExtensionSpec,omitempty"`

	// SignatureFilePath Bundle Upload Signature File Path
	SignatureFilePath *string `json:"signatureFilePath,omitempty"`
}

// Ceip Defines VCF CEIP status and instance id
type Ceip struct {
	// InstanceId Instance Id of VCF
	InstanceId *string `json:"instanceId,omitempty"`

	// Status CEIP status
	Status string `json:"status"`
}

// CustomPatch Patch or Install info from Product Version Catalog.
type CustomPatch struct {
	// Artifacts Patch rest model that is located in the Product Version Catalog.
	Artifacts *CustomPatchArtifact `json:"artifacts,omitempty"`

	// Date Time of publish of the product e.g. 2020-06-08T02:20:15.844Z
	Date *string `json:"date,omitempty"`

	// ProductVersion Product version of the install/patch bundle
	ProductVersion *string `json:"productVersion,omitempty"`
}

// CustomPatchArtifact Patch rest model that is located in the Product Version Catalog.
type CustomPatchArtifact struct {
	// Bundles List of bundle artifacts for corresponding product patch/install version
	Bundles *[]CustomPatchBundleInfo `json:"bundles,omitempty"`
}

// CustomPatchBundleInfo Patch/Install bundle info from ProductVersionCatalog.
type CustomPatchBundleInfo struct {
	// Id Bundle id
	Id *string `json:"id,omitempty"`

	// Name Patch/Install bundle name
	Name *string `json:"name,omitempty"`

	// Size Binary size
	Size *int64 `json:"size,omitempty"`

	// Type Type of bundle. ex) PATCH, INSTALL
	Type *string `json:"type,omitempty"`
}

// CustomPatches Model for supported product install/patches associated with a VCF/VVF release
type CustomPatches struct {
	// Patches Patches used for the product version catalog
	Patches *map[string][]CustomPatch `json:"patches,omitempty"`

	// ReleaseVersion VCF/VVF release version
	ReleaseVersion *string `json:"releaseVersion,omitempty"`
}

// DepotAccount VMware Depot Account Information
type DepotAccount struct {
	// DownloadToken This field is mandatory when downloadToken is used for online depot authentication and authorization. downloadToken should be generated from the broadcom support portal https://support.broadcom.com
	DownloadToken *string `json:"downloadToken,omitempty"`

	// Message Message explaining depot status
	Message *string `json:"message,omitempty"`

	// Password Depot Password for Access. This field is optional when downloadToken is used for online depot authentication and authorization.
	Password *string `json:"password,omitempty"`

	// Status Depot Status
	Status *string `json:"status,omitempty"`

	// Username Depot Username for Access. This field is optional when downloadToken is used for online depot authentication and authorization.
	Username *string `json:"username,omitempty"`
}

// DepotConfiguration Depot Configuration
type DepotConfiguration struct {
	// Hostname IP/Hostname of the depot
	Hostname string `json:"hostname"`

	// IsOfflineDepot Flag indicating if the depot is in offline mode
	IsOfflineDepot bool `json:"isOfflineDepot"`

	// Port Port of the depot
	Port int32 `json:"port"`
}

// DepotSettings VMware Depot Settings. At least one of vmwareAccount, dellEmcSupportAccount or offlineAccount value must be provided
type DepotSettings struct {
	// DellEmcSupportAccount VMware Depot Account Information
	DellEmcSupportAccount *DepotAccount `json:"dellEmcSupportAccount,omitempty"`

	// DepotConfiguration Depot Configuration
	DepotConfiguration *DepotConfiguration `json:"depotConfiguration,omitempty"`

	// OfflineAccount VMware Depot Account Information
	OfflineAccount *DepotAccount `json:"offlineAccount,omitempty"`

	// VmwareAccount VMware Depot Account Information
	VmwareAccount *DepotAccount `json:"vmwareAccount,omitempty"`
}

// DepotSyncInfo Depot Sync Information
type DepotSyncInfo struct {
	// ErrorMessage Depot sync error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// LastSyncCompletionTimestamp The completion timestamp of the last sync operation
	LastSyncCompletionTimestamp *string `json:"lastSyncCompletionTimestamp,omitempty"`

	// SyncStatus Depot sync status
	SyncStatus *string `json:"syncStatus,omitempty"`
}

// DnsSpec Spec contains parameters of Domain Name System
type DnsSpec struct {
	// Nameservers Nameservers to be configured for vCenter/ESXi's/NSX. The first is the primary nameserver. Maximum allowed is two entries
	Nameservers *[]string `json:"nameservers,omitempty"`

	// Subdomain Tenant Sub domain. Includes the full domain suffix
	Subdomain string `json:"subdomain"`
}

// DocumentationLink Represents a documentation link's url string and label
type DocumentationLink struct {
	// Label Label of the documentation link
	Label *string `json:"label,omitempty"`

	// Url URL string of the documentation link
	Url *string `json:"url,omitempty"`
}

// DomainFutureRelease Model for releases with details if applicable to current domain version or not.
type DomainFutureRelease struct {
	// AlternativeApplicableSddcManagerVersions List of AlternativeApplicableSddcManagerVersions
	AlternativeApplicableSddcManagerVersions *[]AlternativeApplicableSddcManagerVersion `json:"alternativeApplicableSddcManagerVersions,omitempty"`

	// ApplicabilityStatus Whether bundle is applicable or not.
	ApplicabilityStatus *string `json:"applicabilityStatus,omitempty"`

	// Bom Release bill of materials
	Bom *[]ProductVersion `json:"bom,omitempty"`

	// Description Release description with all major features.
	Description *string `json:"description,omitempty"`

	// Eol Release eol information e.g. 2020-06-08T02:20:15.844Z in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	Eol *string `json:"eol,omitempty"`

	// IsApplicable [Deprecated] Whether bundle is applicable or not.
	// Deprecated:
	IsApplicable *bool `json:"isApplicable,omitempty"`

	// MinCompatibleVcfVersion Minimum compatible VCF version, used to represent compatibility of SDDC Manager and VMware BOM components
	MinCompatibleVcfVersion *string `json:"minCompatibleVcfVersion,omitempty"`

	// MinInstallerVersion Minimum installer version, e.g. 9.0.0.0
	MinInstallerVersion *string `json:"minInstallerVersion,omitempty"`

	// NotApplicableReason [Deprecated] Incompatibility reason for not applicable.
	// Deprecated:
	NotApplicableReason *string `json:"notApplicableReason,omitempty"`

	// PatchBundles List of patch bundles in this release
	PatchBundles *[]PatchBundle `json:"patchBundles,omitempty"`

	// Product Name of the product e.g. "VCF"
	Product *string `json:"product,omitempty"`

	// ReasonNotApplicable A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
	ReasonNotApplicable *MessagePack `json:"reasonNotApplicable,omitempty"`

	// ReasonsNotApplicable List of Incompatibility details for not applicable
	ReasonsNotApplicable *[]MessagePack `json:"reasonsNotApplicable,omitempty"`

	// ReleaseDate Release date e.g. 2020-06-08T02:20:15.844Z in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	ReleaseDate *string `json:"releaseDate,omitempty"`

	// Sku Release sku specific patch and bill of materials
	Sku *[]SkuBomDetails `json:"sku,omitempty"`

	// Updates Collection of release updates
	Updates *[]ReleaseUpdate `json:"updates,omitempty"`

	// UpgradeOrder Custom upgrade order. Comma separated list of components in upgrade order. Supported components types: NSX_T_MANAGER, VCENTER, ESX_HOST.
	UpgradeOrder *string `json:"upgradeOrder,omitempty"`

	// Version Version of the release
	Version *string `json:"version,omitempty"`

	// Warnings List of warning messages for product compatibility
	Warnings *[]MessagePack `json:"warnings,omitempty"`
}

// DvsSpec Spec contains parameters for DVS
type DvsSpec struct {
	// DvsName vSphere Distributed Switch Name. It will be auto-generated if blank
	DvsName *string `json:"dvsName,omitempty"`

	// LagSpecs List of LAGs to be associated with the vSphere Distributed Switch
	LagSpecs *[]LagSpec `json:"lagSpecs,omitempty"`

	// Mtu Distributed vSphere Switch MTU (default value is 9000)
	Mtu *int32 `json:"mtu,omitempty"`

	// Networks Types of networks in this Distributed vSphere Switch. One among: VSAN, VMOTION, MANAGEMENT, VM_MANAGEMENT, NFS or any custom network types defined in networkSpecs
	Networks *[]string `json:"networks,omitempty"`

	// NsxTeamings The teaming policies to be associated with the uplink profile in NSX
	NsxTeamings *[]TeamingSpec `json:"nsxTeamings,omitempty"`

	// NsxtSwitchConfig This specification contains the configurations to be associated with the vSphere Distributed Switch managed by NSX
	NsxtSwitchConfig *NsxtSwitchConfig `json:"nsxtSwitchConfig,omitempty"`

	// VmnicsToUplinks List of vmnic to uplink mapping
	VmnicsToUplinks []VmnicToUplink `json:"vmnicsToUplinks"`
}

// Error Error response containing a minor error code, a localized error message, a localized remediation message and optionally a reference token to correlate the error with the logs
type Error struct {
	// Arguments The arguments used to localize the message, Can be used by scripts to automate the error processing.
	Arguments *[]string `json:"arguments,omitempty"`

	// Causes The underlying cause exceptions.
	Causes *[]ErrorCause `json:"causes,omitempty"`

	// Context The error context (e.g. the component where it occurred).
	Context *map[string]string `json:"context,omitempty"`

	// ErrorCode The minor error code
	ErrorCode *string `json:"errorCode,omitempty"`

	// ErrorType The error type
	ErrorType *string `json:"errorType,omitempty"`

	// Label The localized label message
	Label *string `json:"label,omitempty"`

	// Message The localized error message
	Message *string `json:"message,omitempty"`

	// NestedErrors The nested errors when the error is a composite one
	NestedErrors *[]Error `json:"nestedErrors,omitempty"`

	// ReferenceToken A reference token correlating the error with the relevant detailed error logs. Should be sent to the service provider when reporting issues.
	ReferenceToken *string `json:"referenceToken,omitempty"`

	// RemediationMessage The localized remediation error message
	RemediationMessage *string `json:"remediationMessage,omitempty"`

	// RemediationUrl The URL string for remediation documentation link
	RemediationUrl *string `json:"remediationUrl,omitempty"`
}

// ErrorCause Describes a single error cause
type ErrorCause struct {
	// Message The message describing the reason for the error
	Message *string `json:"message,omitempty"`

	// Type The type of the error cause
	Type *string `json:"type,omitempty"`
}

// FcSpec Cluster storage configuration for VMFS on FC
type FcSpec struct {
	// DatastoreName Datastore name used for cluster creation
	DatastoreName string `json:"datastoreName"`
}

// FlexibleProductPatch Model for product async/hot patches with their supported product versions
type FlexibleProductPatch struct {
	// ProductType product type of patch
	ProductType *string `json:"productType,omitempty"`

	// Versions supported versions of patch
	Versions *[]string `json:"versions,omitempty"`
}

// FlexibleProductPatches Model for supported product async/hot patches associated with a VCF release
type FlexibleProductPatches struct {
	// Patches List of available patches on the VCF release
	Patches *[]FlexibleProductPatch `json:"patches,omitempty"`

	// Version Domain VCF release version
	Version *string `json:"version,omitempty"`
}

// InstallerSpec VCF Installer Installer Specification
type InstallerSpec struct {
	// ApplianceFqdn Appliance FQDN
	ApplianceFqdn *string `json:"applianceFqdn,omitempty"`

	// Type Installer type
	Type *InstallerSpecType `json:"type,omitempty"`
}

// InstallerSpecType Installer type
type InstallerSpecType string

// IpAddressPoolRangeSpec This specification contains the parameters required to create an IP address range
type IpAddressPoolRangeSpec struct {
	// End The last IP Address of the IP Address Range
	End string `json:"end"`

	// Start The first IP Address of the IP Address Range
	Start string `json:"start"`
}

// IpAddressPoolSpec This specification contains the parameters required to create or reuse an IP address pool.
type IpAddressPoolSpec struct {
	// Description Description of the IP address pool
	Description *string `json:"description,omitempty"`

	// IgnoreUnavailableNsxtCluster Ignore unavailable NSX cluster(s) during IP pool spec validation
	IgnoreUnavailableNsxtCluster *bool `json:"ignoreUnavailableNsxtCluster,omitempty"`

	// Name Name of the IP address pool
	Name string `json:"name"`

	// Subnets List of IP address pool subnet specification
	Subnets *[]IpAddressPoolSubnetSpec `json:"subnets,omitempty"`
}

// IpAddressPoolSubnetSpec This specification contains the parameters required to create an IP address pool subnet
type IpAddressPoolSubnetSpec struct {
	// Cidr The subnet representation, contains the network address and the prefix length
	Cidr string `json:"cidr"`

	// Gateway The default gateway address of the network
	Gateway string `json:"gateway"`

	// IpAddressPoolRanges List of the IP allocation ranges. Atleast 1 IP address range has to be specified
	IpAddressPoolRanges []IpAddressPoolRangeSpec `json:"ipAddressPoolRanges"`
}

// IpRange Spec contains parameters for range of IP addresses
type IpRange struct {
	// EndIpAddress End IP Address
	EndIpAddress string `json:"endIpAddress"`

	// StartIpAddress Start IP Address
	StartIpAddress string `json:"startIpAddress"`
}

// LagSpec This specification contains VDS (vSphere distributed switch) LAG configurations
type LagSpec struct {
	// LacpMode LACP mode of this LAG
	LacpMode string `json:"lacpMode"`

	// LacpTimeoutMode LACP timeout mode of this LAG
	LacpTimeoutMode string `json:"lacpTimeoutMode"`

	// LoadBalancingMode Load balancing mode of this LAG
	LoadBalancingMode string `json:"loadBalancingMode"`

	// Name LAG name
	Name string `json:"name"`

	// UplinksCount Number of uplinks/ports in this LAG
	UplinksCount int32 `json:"uplinksCount"`
}

// MessagePack A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
type MessagePack struct {
	// Arguments The arguments used to localize the message. Can be used by scripts to automate the response processing.
	Arguments *[]string `json:"arguments,omitempty"`

	// Bundle The local resource bundle details
	Bundle *string `json:"bundle,omitempty"`

	// Component The component the message belongs to
	Component *string `json:"component,omitempty"`

	// Message The localized message (if not provided by another property)
	Message *string `json:"message,omitempty"`

	// MessageKey The machine-readable key of the message
	MessageKey string `json:"messageKey"`
}

// NasVolumeSpec NAS configuration for NFS based cluster
type NasVolumeSpec struct {
	// EnableBindToVmknic Indicates whether to bind the created NFS datastore to the VMkernel NIC created based on NFS Network Spec. This is to prevent unintentional flow of NFS traffic through any other VMkernel NIC, if such connectivity exists.
	EnableBindToVmknic *bool `json:"enableBindToVmknic,omitempty"`

	// Path Shared directory path used for NFS based cluster creation
	Path string `json:"path"`

	// ReadOnly Readonly is used to identify whether to mount the directory as readOnly or not
	ReadOnly bool `json:"readOnly"`

	// ServerName NFS Server name used for cluster creation
	ServerName []string `json:"serverName"`

	// UserTag User tag used to annotate NFS share
	UserTag *string `json:"userTag,omitempty"`
}

// NfsDatastoreSpec This specification contains cluster storage configuration for NFS
type NfsDatastoreSpec struct {
	// DatastoreName Datastore name used for cluster creation
	DatastoreName string `json:"datastoreName"`

	// NasVolume NAS configuration for NFS based cluster
	NasVolume NasVolumeSpec `json:"nasVolume"`
}

// NodeAddress Node address.
type NodeAddress struct {
	// Type Address type. One among: fqdn, ipv4
	Type *string `json:"type,omitempty"`

	// Value Address value.
	Value *string `json:"value,omitempty"`
}

// NsxAdapterInfo NSX Adapter information registered in Vcf Operations instance.
type NsxAdapterInfo struct {
	// Address NSX address.
	Address string `json:"address"`

	// Id Adapter ID.
	Id string `json:"id"`

	// Name Adapter name.
	Name string `json:"name"`

	// VcenterAddress vCenter address.
	VcenterAddress *string `json:"vcenterAddress,omitempty"`
}

// NsxtManagerSpec Spec contains parameters for NSX manager
type NsxtManagerSpec struct {
	// Hostname NSX Manager hostname
	Hostname *string `json:"hostname,omitempty"`
}

// NsxtSwitchConfig This specification contains the configurations to be associated with the vSphere Distributed Switch managed by NSX
type NsxtSwitchConfig struct {
	// HostSwitchOperationalMode Operational mode type of a Host Switch. Applicable only for the VI Workload Domains.
	HostSwitchOperationalMode *string `json:"hostSwitchOperationalMode,omitempty"`

	// IpAssignmentType Ip Assignment Type of a Host Switch
	IpAssignmentType *string `json:"ipAssignmentType,omitempty"`

	// TransportZones The list of transport zones to be associated with the vSphere Distributed Switch managed by NSX
	TransportZones []TransportZone `json:"transportZones"`
}

// PageMetadata Represents pageable elements pagination metadata
type PageMetadata struct {
	// PageNumber Returns the current page number
	PageNumber *int32 `json:"pageNumber,omitempty"`

	// PageSize Returns the number of elements in the current page
	PageSize *int32 `json:"pageSize,omitempty"`

	// TotalElements Returns the total number of elements
	TotalElements *int32 `json:"totalElements,omitempty"`

	// TotalPages Returns the total number of pages
	TotalPages *int32 `json:"totalPages,omitempty"`
}

// PageOfBundle defines model for PageOfBundle.
type PageOfBundle struct {
	// Elements The list of elements included in this page
	Elements *[]Bundle `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfBundleDownloadStatusInfo defines model for PageOfBundleDownloadStatusInfo.
type PageOfBundleDownloadStatusInfo struct {
	// Elements The list of elements included in this page
	Elements *[]BundleDownloadStatusInfo `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfDomainFutureRelease defines model for PageOfDomainFutureRelease.
type PageOfDomainFutureRelease struct {
	// Elements The list of elements included in this page
	Elements *[]DomainFutureRelease `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfRelease defines model for PageOfRelease.
type PageOfRelease struct {
	// Elements The list of elements included in this page
	Elements *[]Release `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfReleaseComponentDetail Paginated response containing the list of release component detail.
type PageOfReleaseComponentDetail struct {
	// Elements The list of elements included in this page
	Elements *[]ReleaseComponentDetail `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfSddcTask defines model for PageOfSddcTask.
type PageOfSddcTask struct {
	// Elements The list of elements included in this page
	Elements *[]SddcTask `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfTask defines model for PageOfTask.
type PageOfTask struct {
	// Elements The list of elements included in this page
	Elements *[]Task `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfTrustedCertificate defines model for PageOfTrustedCertificate.
type PageOfTrustedCertificate struct {
	// Elements The list of elements included in this page
	Elements *[]TrustedCertificate `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfValidation defines model for PageOfValidation.
type PageOfValidation struct {
	// Elements The list of elements included in this page
	Elements *[]Validation `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfVcfService defines model for PageOfVcfService.
type PageOfVcfService struct {
	// Elements The list of elements included in this page
	Elements *[]VcfService `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PartnerExtensionSpec Specification for partner extensions. This specification is used in the Bundle Upload API
type PartnerExtensionSpec struct {
	// PartnerBundleMetadataFilePath Path to the bundle metadata file. The metadata file can have details of multiple bundles
	PartnerBundleMetadataFilePath *string `json:"partnerBundleMetadataFilePath,omitempty"`

	// PartnerBundleVersion Version of partner bundle to be uploaded. Should match one of the bundle versions available in the partner bundle metadata file
	PartnerBundleVersion *string `json:"partnerBundleVersion,omitempty"`
}

// PatchBundle Model for patch bundle in a release
type PatchBundle struct {
	// BundleElements Bundle elements of the patch bundle
	BundleElements *[]string `json:"bundleElements,omitempty"`

	// BundleId Bundle ID of the patch bundle
	BundleId *string `json:"bundleId,omitempty"`

	// BundleType Bundle type of the patch bundle
	BundleType *string `json:"bundleType,omitempty"`

	// CumulativeFromVcfVersion Minimum VCF version that this patch bundle can be directly applied on
	CumulativeFromVcfVersion *string `json:"cumulativeFromVcfVersion,omitempty"`
}

// ProductReleaseComponent Product Release Component
type ProductReleaseComponent struct {
	// AutomatedInstall automated Install
	AutomatedInstall *bool `json:"automatedInstall,omitempty"`

	// Name Product name
	Name *string `json:"name,omitempty"`

	// PublicName Product public name
	PublicName *string `json:"publicName,omitempty"`

	// Sku SKU of the install/patch bundle
	Sku *string `json:"sku,omitempty"`

	// Versions Product version details
	Versions *[]CustomPatch `json:"versions,omitempty"`
}

// ProductVersion Details of the product/component for the release.
type ProductVersion struct {
	// AdditionalMetadata any additional metadata
	AdditionalMetadata *string `json:"additionalMetadata,omitempty"`

	// AutomatedInstall Automated install or not, e.g. true
	AutomatedInstall *bool `json:"automatedInstall,omitempty"`

	// ChangeId Build or CLN for the product, e.g 11675023
	ChangeId *string `json:"changeId,omitempty"`

	// LifecycleManagedBy Lifecycle is managed by whom, e.g. SDDC_MANAGER_VCF
	LifecycleManagedBy *string `json:"lifecycleManagedBy,omitempty"`

	// Name Name of the product. e.g ESX
	Name *string `json:"name,omitempty"`

	// PublicName Public name of the product, e.g VMware ESXi
	PublicName *string `json:"publicName,omitempty"`

	// ReleaseURL URL for the release.
	ReleaseURL *string `json:"releaseURL,omitempty"`

	// Version Version for the product, e.g 6.7.0-11675023
	Version *string `json:"version,omitempty"`
}

// ProxyConfiguration Proxy Configuration
type ProxyConfiguration struct {
	// Host IP address/FQDN of proxy server. This must be set if proxy is enabled.
	Host *string `json:"host,omitempty"`

	// IsAuthenticated If proxy authentication is required, isAuthenticated must be enabled and username and password should be set.
	IsAuthenticated *bool `json:"isAuthenticated,omitempty"`

	// IsConfigured Defines if the proxy is configured.
	IsConfigured *bool `json:"isConfigured,omitempty"`

	// IsEnabled Defines if the proxy configuration is enabled. To disable the proxy, this should be set to false.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Password User password to connect, will return null on reading
	Password *string `json:"password,omitempty"`

	// Port Port of proxy server. This must be set if proxy is enabled.
	Port *int32 `json:"port,omitempty"`

	// TransferProtocol Proxy transfer protocol, default value is HTTP
	TransferProtocol *ProxyConfigurationTransferProtocol `json:"transferProtocol,omitempty"`

	// Username User name to connect
	Username *string `json:"username,omitempty"`
}

// ProxyConfigurationTransferProtocol Proxy transfer protocol, default value is HTTP
type ProxyConfigurationTransferProtocol string

// RefreshToken This contains refresh token id for the user API access.
type RefreshToken struct {
	// Id Refresh token id that can be used to request new access token
	Id *string `json:"id,omitempty"`
}

// Release Model for releases with their description and product version
type Release struct {
	// Bom Release bill of materials
	Bom *[]ProductVersion `json:"bom,omitempty"`

	// Description Release description with all major features.
	Description *string `json:"description,omitempty"`

	// Eol Release eol information e.g. 2020-06-08T02:20:15.844Z in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	Eol *string `json:"eol,omitempty"`

	// IsApplicable [Deprecated] Whether bundle is applicable or not.
	// Deprecated:
	IsApplicable *bool `json:"isApplicable,omitempty"`

	// MinCompatibleVcfVersion Minimum compatible VCF version, used to represent compatibility of SDDC Manager and VMware BOM components
	MinCompatibleVcfVersion *string `json:"minCompatibleVcfVersion,omitempty"`

	// MinInstallerVersion Minimum installer version, e.g. 9.0.0.0
	MinInstallerVersion *string `json:"minInstallerVersion,omitempty"`

	// NotApplicableReason [Deprecated] Incompatibility reason for not applicable.
	// Deprecated:
	NotApplicableReason *string `json:"notApplicableReason,omitempty"`

	// PatchBundles List of patch bundles in this release
	PatchBundles *[]PatchBundle `json:"patchBundles,omitempty"`

	// Product Name of the product e.g. "VCF"
	Product *string `json:"product,omitempty"`

	// ReleaseDate Release date e.g. 2020-06-08T02:20:15.844Z in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	ReleaseDate *string `json:"releaseDate,omitempty"`

	// Sku Release sku specific patch and bill of materials
	Sku *[]SkuBomDetails `json:"sku,omitempty"`

	// Updates Collection of release updates
	Updates *[]ReleaseUpdate `json:"updates,omitempty"`

	// UpgradeOrder Custom upgrade order. Comma separated list of components in upgrade order. Supported components types: NSX_T_MANAGER, VCENTER, ESX_HOST.
	UpgradeOrder *string `json:"upgradeOrder,omitempty"`

	// Version Version of the release
	Version *string `json:"version,omitempty"`
}

// ReleaseComponentDetail Model for Release Component Detail
type ReleaseComponentDetail struct {
	// Components VCF/VVF release elements
	Components *[]ProductReleaseComponent `json:"components,omitempty"`

	// ReleaseVersion VCF/VVF release version
	ReleaseVersion *string `json:"releaseVersion,omitempty"`
}

// ReleaseUpdate Update to a given release
type ReleaseUpdate struct {
	// BaseProductVersion Base product version for the release
	BaseProductVersion *string `json:"baseProductVersion,omitempty"`

	// Description Description of the release update
	Description *string `json:"description,omitempty"`

	// Id Release version
	Id *string `json:"id,omitempty"`

	// ProductName Product name for which the release update is provided
	ProductName *string `json:"productName,omitempty"`

	// ReleaseDate Release date e.g. 2020-06-08T02:20:15.844Z in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	ReleaseDate *string `json:"releaseDate,omitempty"`

	// ReleaseUpdateURL URL to the release update
	ReleaseUpdateURL *string `json:"releaseUpdateURL,omitempty"`
}

// Resource Represents the resource in the system
type Resource struct {
	// Fqdn Resource FQDN
	Fqdn *string `json:"fqdn,omitempty"`

	// Name Name of the resource
	Name *string `json:"name,omitempty"`

	// ResourceId Resource ID
	ResourceId string `json:"resourceId"`

	// Sans Subject alternative name(s)
	Sans *[]string `json:"sans,omitempty"`

	// Type Resource type
	Type string `json:"type"`
}

// ResourcePoolSpec Spec contains parameters for Resource Pool
type ResourcePoolSpec struct {
	// CpuLimit CPU limit, default -1 (unlimited)
	CpuLimit *int64 `json:"cpuLimit,omitempty"`

	// CpuReservationExpandable Is CPU reservation expandable, default true
	CpuReservationExpandable *bool `json:"cpuReservationExpandable,omitempty"`

	// CpuReservationMhz CPU reservation in Mhz, default 0
	CpuReservationMhz *int64 `json:"cpuReservationMhz,omitempty"`

	// CpuReservationPercentage CPU reservation percentage, from 0 to 100, default 0
	CpuReservationPercentage *int32 `json:"cpuReservationPercentage,omitempty"`

	// CpuSharesLevel CPU shares level, default 'normal'
	CpuSharesLevel *ResourcePoolSpecCpuSharesLevel `json:"cpuSharesLevel,omitempty"`

	// CpuSharesValue CPU shares value, only relevant when shares level is 'custom', default 0
	CpuSharesValue *int32 `json:"cpuSharesValue,omitempty"`

	// MemoryLimit Memory limit, default -1 (unlimited)
	MemoryLimit *int64 `json:"memoryLimit,omitempty"`

	// MemoryReservationExpandable Is Memory reservation expandable, default true
	MemoryReservationExpandable *bool `json:"memoryReservationExpandable,omitempty"`

	// MemoryReservationMb Memory reservation in MB, default 0
	MemoryReservationMb *int64 `json:"memoryReservationMb,omitempty"`

	// MemoryReservationPercentage Memory reservation percentage, from 0 to 100, default 0
	MemoryReservationPercentage *int32 `json:"memoryReservationPercentage,omitempty"`

	// MemorySharesLevel Memory shares level. default 'normal'
	MemorySharesLevel *ResourcePoolSpecMemorySharesLevel `json:"memorySharesLevel,omitempty"`

	// MemorySharesValue Memory shares value, only relevant when shares level is 'custom', default 0
	MemorySharesValue *int32 `json:"memorySharesValue,omitempty"`

	// Name Resource Pool name. It will be auto-generated if blank
	Name *string `json:"name,omitempty"`

	// Type Type of resource pool. One among: management, compute, network
	Type *ResourcePoolSpecType `json:"type,omitempty"`
}

// ResourcePoolSpecCpuSharesLevel CPU shares level, default 'normal'
type ResourcePoolSpecCpuSharesLevel string

// ResourcePoolSpecMemorySharesLevel Memory shares level. default 'normal'
type ResourcePoolSpecMemorySharesLevel string

// ResourcePoolSpecType Type of resource pool. One among: management, compute, network
type ResourcePoolSpecType string

// RootCaCerts Spec contains Root Certificate Authority parameters
type RootCaCerts struct {
	// Alias Certificate alias
	Alias *string `json:"alias,omitempty"`

	// CertChain List of Base64 encoded certificates
	CertChain *[]string `json:"certChain,omitempty"`
}

// SddcClusterSpec Spec contains parameters for vCenter Cluster
type SddcClusterSpec struct {
	// ClusterEvcMode EVC mode for vSphere cluster, if needed
	ClusterEvcMode *string `json:"clusterEvcMode,omitempty"`

	// ClusterName vCenter Cluster Name. It will be auto-generated if blank.
	ClusterName *string `json:"clusterName,omitempty"`

	// DatacenterName vCenter Datacenter Name. It will be auto-generated if blank.
	DatacenterName *string `json:"datacenterName,omitempty"`

	// ResourcePoolSpecs List of Resource Pool Specification. If blank, no resource pools will be created. However, if you want to create resource pool, Management Resource Pool is required to be present in the list.
	ResourcePoolSpecs *[]ResourcePoolSpec `json:"resourcePoolSpecs,omitempty"`
}

// SddcCredentials Credentials contains the username and password
type SddcCredentials struct {
	// Password Password
	Password string `json:"password"`

	// Username Username
	Username *string `json:"username,omitempty"`
}

// SddcDatastoreSpec This specification contains cluster storage configuration
type SddcDatastoreSpec struct {
	// ExistingDatastoreName Name of an existing datastore that is to be used when converting an existing environment.
	ExistingDatastoreName *string `json:"existingDatastoreName,omitempty"`

	// NfsDatastoreSpec This specification contains cluster storage configuration for NFS
	NfsDatastoreSpec *NfsDatastoreSpec `json:"nfsDatastoreSpec,omitempty"`

	// VmfsDatastoreSpec Cluster storage configuration for VMFS
	VmfsDatastoreSpec *VmfsDatastoreSpec `json:"vmfsDatastoreSpec,omitempty"`

	// VsanSpec Spec contains parameters of Virtual SAN
	VsanSpec *VsanSpec `json:"vsanSpec,omitempty"`
}

// SddcHostSpec Spec contains parameters for Host
type SddcHostSpec struct {
	// Credentials Credentials contains the username and password
	Credentials *SddcCredentials `json:"credentials,omitempty"`

	// Hostname ESX hostname. This value will be prefixed to the DNS subdomain name and should not include the domain name itself. Must also adhere to RFC 1123 naming conventions
	Hostname string `json:"hostname"`

	// SshThumbprint ESX host SSH thumbprint (RSA SHA256) in new deployment scenario or ESX host SSH key (RSA, ECDSA) in reuse existing deployment scenario
	SshThumbprint *string `json:"sshThumbprint,omitempty"`

	// SslThumbprint ESX host SSL thumbprint (SHA256)
	SslThumbprint *string `json:"sslThumbprint,omitempty"`
}

// SddcInstallerRequest Spec contains parameters for Host
type SddcInstallerRequest struct {
	// Endpoints List of ESXi/vCenter in which the appliance will check for itself
	Endpoints []SddcHostSpec `json:"endpoints"`

	// Subdomain Tenant Sub domain. Includes the full domain suffix
	Subdomain string `json:"subdomain"`
}

// SddcManagerSpec Client input parameters for SDDC Manager Virtual Machine
type SddcManagerSpec struct {
	// Hostname SDDC Manager Hostname.
	Hostname string `json:"hostname"`

	// LocalUserPassword The local account is a built-in admin account in VCF that can be used in emergency scenarios. The password of this account must be at least 12 characters long. It also must contain at-least 1 uppercase, 1 lowercase, 1 special character specified in braces [!%@$^#?] and 1 digit. In addition, a character cannot be repeated more than 3 times consecutively. If blank, the password will be auto-generated.
	LocalUserPassword *string `json:"localUserPassword,omitempty"`

	// RootPassword Password for the 'root' user on SDDC Manager appliance. It needs to be a strong password with at least one alphabet and one special character and at least 8 characters in length. If blank, the SDDC Local Admin Password will be used (if provided) or password will be auto-generated.
	RootPassword *string `json:"rootPassword,omitempty"`

	// SshPassword Password for the 'vcf' user on SDDC Manager appliance. It needs to be a strong password with at least one alphabet and one special character and at least 8 characters in length. If blank, the SDDC Local Admin Password will be used (if provided) or password will be auto-generated.
	SshPassword *string `json:"sshPassword,omitempty"`

	// SslThumbprint SSL thumbprint (SHA256) of the product's certificate. Need to be populated when using existing deployment in order to establish trust with the existing product.
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// UseExistingDeployment Import existing deployment or deploy one.
	UseExistingDeployment *bool `json:"useExistingDeployment,omitempty"`

	// Version Version
	Version *string `json:"version,omitempty"`
}

// SddcMilestoneTask Represents a SDDC Milestone
type SddcMilestoneTask struct {
	// CreationTimestamp SDDC Milestone Creation Time
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Description SDDC Milestone Description
	Description *string `json:"description,omitempty"`

	// Name SDDC Milestone Name
	Name *string `json:"name,omitempty"`

	// Status SDDC Milestone Task Status
	Status *string `json:"status,omitempty"`

	// UpdateTimestamp Last Update Time of SDDC Milestone
	UpdateTimestamp *string `json:"updateTimestamp,omitempty"`
}

// SddcNetworkConfigProfile Network configuration profile which can be used to configure the networking stack of the Management Domain.
type SddcNetworkConfigProfile struct {
	// Description Description of the profile
	Description *string `json:"description,omitempty"`

	// DvsNameToPortgroupSpecs Map of vSphere Distributed Switch name to portgroup/network specs
	DvsNameToPortgroupSpecs *map[string][]SddcNetworkSpec `json:"dvsNameToPortgroupSpecs,omitempty"`

	// DvsSpecs vSphere Distributed Switches topology
	DvsSpecs *[]DvsSpec `json:"dvsSpecs,omitempty"`

	// Id Id of the profile. One among: "DEFAULT", "STORAGE_SEPARATION", "NSX_SEPARATION", "STORAGE_NSX_SEPARATION"
	Id *string `json:"id,omitempty"`

	// Name Name of the profile
	Name *string `json:"name,omitempty"`
}

// SddcNetworkConfigProfileResponse Response holding pre-configured network profiles and list of common physical NICs.
type SddcNetworkConfigProfileResponse struct {
	// CommonPhysicalNics List of physical NICs common to all hosts.
	CommonPhysicalNics *[]SddcPhysicalNic `json:"commonPhysicalNics,omitempty"`

	// Profiles List of pre-configured network profiles
	Profiles *[]SddcNetworkConfigProfile `json:"profiles,omitempty"`
}

// SddcNetworkConfigProfileSpec This specification contains the parameters needed to get pre-configured network profiles which to facilitate the configuration of the networking stack during Management Domain creation
type SddcNetworkConfigProfileSpec struct {
	// HostSpecs List of hosts which will be used for the Management Domain
	HostSpecs []SddcHostSpec `json:"hostSpecs"`

	// NsxConfigType NSX Config Type
	NsxConfigType *string `json:"nsxConfigType,omitempty"`

	// StorageType Storage type of the Management Domain
	StorageType SddcNetworkConfigProfileSpecStorageType `json:"storageType"`

	// Subdomain Tenant Sub domain. Includes the full domain suffix
	Subdomain *string `json:"subdomain,omitempty"`
}

// SddcNetworkConfigProfileSpecStorageType Storage type of the Management Domain
type SddcNetworkConfigProfileSpecStorageType string

// SddcNetworkSpec Defines a network spec
type SddcNetworkSpec struct {
	// ActiveUplinks Active Uplinks for teaming policy, specify uplink1 for failover_explicit VSAN Teaming Policy
	ActiveUplinks *[]string `json:"activeUplinks,omitempty"`

	// Gateway Gateway
	Gateway *string `json:"gateway,omitempty"`

	// IncludeIpAddress IP Addresses to be included
	IncludeIpAddress *[]string `json:"includeIpAddress,omitempty"`

	// IncludeIpAddressRanges IP Address ranges to be included
	IncludeIpAddressRanges *[]IpRange `json:"includeIpAddressRanges,omitempty"`

	// Mtu MTU size
	Mtu *int32 `json:"mtu,omitempty"`

	// NetworkType Network Type. One among: VSAN, VMOTION, MANAGEMENT, VM_MANAGEMENT, NFS or any custom network type
	NetworkType string `json:"networkType"`

	// PortGroupKey Name of the Distributed Portgroup to be created. It will be autogenerated if null
	PortGroupKey *string `json:"portGroupKey,omitempty"`

	// StandbyUplinks Standby Uplinks for teaming policy, specify uplink2 for failover_explicit VSAN Teaming Policy
	StandbyUplinks *[]string `json:"standbyUplinks,omitempty"`

	// Subnet Subnet
	Subnet *string `json:"subnet,omitempty"`

	// SubnetMask Subnet Mask
	SubnetMask *string `json:"subnetMask,omitempty"`

	// TeamingPolicy Teaming Policy for VSAN and VMOTION network types, Default is loadbalance_loadbased. One among:loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, loadbalance_loadbased
	TeamingPolicy *string `json:"teamingPolicy,omitempty"`

	// VlanId VLAN ID
	VlanId int32 `json:"vlanId"`
}

// SddcNsxtSpec Spec contains parameters for NSX deployment and configurations
type SddcNsxtSpec struct {
	// EnableEdgeClusterSync Enable NSX Edge Cluster synchronization. Applicable only when NSX exists and is being imported. If enabled and your NSX deployment has one or more Edge clusters, the import process will add the discovered Edge node VMs to the VCF inventory, including their user credentials. As part of this process, a one-time reset of the Edge node credential passwords will be done. The updated passwords may be retrieved from the VCF credential store if desired. Once an Edge cluster's node VMs have been imported, any node VMs added to that Edge cluster will also be imported and subject to the same one-time password reset.
	EnableEdgeClusterSync *bool `json:"enableEdgeClusterSync,omitempty"`

	// IpAddressPoolSpec This specification contains the parameters required to create or reuse an IP address pool.
	IpAddressPoolSpec *IpAddressPoolSpec `json:"ipAddressPoolSpec,omitempty"`

	// NsxtAdminPassword NSX admin password. The password must be at least 12 characters long. Must contain at-least 1 uppercase, 1 lowercase, 1 special character and 1 digit. In addition, a character cannot be repeated 3 or more times consectively. If blank, the SDDC Local Admin Password will be used (if provided) or password will be auto-generated.
	NsxtAdminPassword *string `json:"nsxtAdminPassword,omitempty"`

	// NsxtAuditPassword NSX audit password. The password must be at least 12 characters long. Must contain at-least 1 uppercase, 1 lowercase, 1 special character and 1 digit. In addition, a character cannot be repeated 3 or more times consectively. If blank, the SDDC Local Admin Password will be used (if provided) or password will be auto-generated.
	NsxtAuditPassword *string `json:"nsxtAuditPassword,omitempty"`

	// NsxtManagerSize NSX Manager size. One among: medium, large,xlarge. Default value if not provided is medium
	NsxtManagerSize *string `json:"nsxtManagerSize,omitempty"`

	// NsxtManagers NSX Managers
	NsxtManagers []NsxtManagerSpec `json:"nsxtManagers"`

	// RootNsxtManagerPassword NSX root password. The password must be at least 12 characters long. Must contain at-least 1 uppercase, 1 lowercase, 1 special character and 1 digit. In addition, a character cannot be repeated 3 or more times consectively. If blank, the SDDC Local Admin Password will be used (if provided) or password will be auto-generated.
	RootNsxtManagerPassword *string `json:"rootNsxtManagerPassword,omitempty"`

	// SkipNsxOverlayOverManagementNetwork Flag that indicates if the Overlay over Management Network configuration will be skipped. Applicable only when vCenter is existing and being converted.
	SkipNsxOverlayOverManagementNetwork *bool `json:"skipNsxOverlayOverManagementNetwork,omitempty"`

	// SslThumbprint SSL thumbprint (SHA256) of the product's certificate. Need to be populated when using existing deployment in order to establish trust with the existing product.
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// TransportVlanId Transport VLAN ID. Default '0' if not specified
	TransportVlanId *int32 `json:"transportVlanId,omitempty"`

	// UseExistingDeployment Import existing deployment or deploy one.
	UseExistingDeployment *bool `json:"useExistingDeployment,omitempty"`

	// Version Version
	Version *string `json:"version,omitempty"`

	// VipFqdn Hostname for VIP so that common SSL certificates can be installed across all managers.
	VipFqdn string `json:"vipFqdn"`
}

// SddcPhysicalNic Physical NIC information which can be shared between multiple hosts
type SddcPhysicalNic struct {
	// DeviceName Device name of the physical NIC
	DeviceName *string `json:"deviceName,omitempty"`
	IsSmartNic *bool   `json:"isSmartNic,omitempty"`
	SmartNic   *bool   `json:"smartNic,omitempty"`

	// SpeedMb Speed of the physical NIC
	SpeedMb *int64 `json:"speedMb,omitempty"`
}

// SddcSpec VCF Installer specification
type SddcSpec struct {
	// CeipEnabled Enable VCF Customer Experience Improvement Program
	CeipEnabled *bool `json:"ceipEnabled,omitempty"`

	// ClusterSpec Spec contains parameters for vCenter Cluster
	ClusterSpec *SddcClusterSpec `json:"clusterSpec,omitempty"`

	// DatastoreSpec This specification contains cluster storage configuration
	DatastoreSpec *SddcDatastoreSpec `json:"datastoreSpec,omitempty"`

	// DnsSpec Spec contains parameters of Domain Name System
	DnsSpec DnsSpec `json:"dnsSpec"`

	// DvsSpecs List of vSphere Distributed Switches to be created. For VCF only: if blank, a default single one will be created for all types of traffic connected to vmnic0 and vmnic1
	DvsSpecs *[]DvsSpec `json:"dvsSpecs,omitempty"`

	// HostSpecs List of ESXi to be added to the Management Cluster
	HostSpecs *[]SddcHostSpec `json:"hostSpecs,omitempty"`

	// ManagementPoolName Name for the network pool to be created and associated with the Management Cluster
	ManagementPoolName *string `json:"managementPoolName,omitempty"`

	// NetworkSpecs List of Networks which be created and used for Management Cluster
	NetworkSpecs []SddcNetworkSpec `json:"networkSpecs"`

	// NsxtSpec Spec contains parameters for NSX deployment and configurations
	NsxtSpec *SddcNsxtSpec `json:"nsxtSpec,omitempty"`

	// NtpServers List of NTP servers to be used for configuring Management Appliances
	NtpServers *[]string `json:"ntpServers,omitempty"`

	// SddcId Client string that identifies an SDDC by name or instance name. Used for management domain name. Can contain only letters, numbers and the following symbols: '-'. Minimum length 3, maximum length 20.
	SddcId string `json:"sddcId"`

	// SddcManagerSpec Client input parameters for SDDC Manager Virtual Machine
	SddcManagerSpec *SddcManagerSpec `json:"sddcManagerSpec,omitempty"`

	// SecuritySpec Spec contains security settings
	SecuritySpec *SecuritySpec `json:"securitySpec,omitempty"`

	// SkipEsxThumbprintValidation Skip ESXi thumbprint validation. Applies to both converting an existing environment and deploying a new one
	SkipEsxThumbprintValidation *bool `json:"skipEsxThumbprintValidation,omitempty"`

	// SkipGatewayPingValidation Skip networks gateway connectivity validation
	SkipGatewayPingValidation *bool `json:"skipGatewayPingValidation,omitempty"`

	// VcenterSpec Spec contains parameters for vCenter
	VcenterSpec SddcVcenterSpec `json:"vcenterSpec"`

	// VcfAutomationSpec Specification for VCF Automation
	VcfAutomationSpec *VcfAutomationSpec `json:"vcfAutomationSpec,omitempty"`

	// VcfInstanceName VCF Instance name. Minumum length 3, maximum length 300
	VcfInstanceName *string `json:"vcfInstanceName,omitempty"`

	// VcfOperationsCollectorSpec Specification for VCF Operations collector
	VcfOperationsCollectorSpec *VcfOperationsCollectorSpec `json:"vcfOperationsCollectorSpec,omitempty"`

	// VcfOperationsFleetManagementSpec Specification for VCF Operations fleet management
	VcfOperationsFleetManagementSpec *VcfOperationsFleetManagementSpec `json:"vcfOperationsFleetManagementSpec,omitempty"`

	// VcfOperationsSpec Specification for VCF Operations
	VcfOperationsSpec *VcfOperationsSpec `json:"vcfOperationsSpec,omitempty"`

	// Version Version
	Version *string `json:"version,omitempty"`

	// WorkflowType Type of workflow to initiate creation and/or validation of SDDC
	WorkflowType *string `json:"workflowType,omitempty"`
}

// SddcSubTask Represents a SDDC sub-task
type SddcSubTask struct {
	// CreationTimestamp Sub-Task Creation Time
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Description Sub-Task Description
	Description *string `json:"description,omitempty"`

	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// LocalizableDescriptionPack A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
	LocalizableDescriptionPack *MessagePack `json:"localizableDescriptionPack,omitempty"`

	// LocalizableNamePack A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
	LocalizableNamePack *MessagePack `json:"localizableNamePack,omitempty"`

	// Name Sub-Task Name
	Name *string `json:"name,omitempty"`

	// ProcessingStateDescription Processing category description, e.g., VC Deployment, VSAN configuration etc
	ProcessingStateDescription *string `json:"processingStateDescription,omitempty"`

	// ProcessingStateName Processing category name, e.g., VC Deployment, VSAN configuration etc
	ProcessingStateName *string `json:"processingStateName,omitempty"`

	// SddcId SDDC ID
	SddcId *string `json:"sddcId,omitempty"`

	// Status Task Status
	Status *string `json:"status,omitempty"`

	// UpdateTimestamp Last Update Time of Sub-Task
	UpdateTimestamp *string `json:"updateTimestamp,omitempty"`
}

// SddcTask Represents a SDDC task
type SddcTask struct {
	// CreationTimestamp SDDC Task creation timestamp
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Id SDDC ID
	Id *string `json:"id,omitempty"`

	// LocalizableNamePack A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
	LocalizableNamePack *MessagePack `json:"localizableNamePack,omitempty"`

	// Milestones Milestones of the workflow
	Milestones *[]SddcMilestoneTask `json:"milestones,omitempty"`

	// Name Task name
	Name *string `json:"name,omitempty"`

	// SddcSubTasks All SDDC Sub-Tasks
	SddcSubTasks *[]SddcSubTask `json:"sddcSubTasks,omitempty"`

	// Status SDDC Task status. One among: IN_PROGRESS, COMPLETED_WITH_SUCCESS, ROLLBACK_SUCCESS, COMPLETED_WITH_FAILURE
	Status *string `json:"status,omitempty"`
}

// SddcVcenterSpec Spec contains parameters for vCenter
type SddcVcenterSpec struct {
	// AdminUserSsoPassword Admin user sso password. Password needs to be a strong password with at least one Uppercase character, one lowercase character, one digit and one special character specified in braces [!$%^] and 8-20 characters in length,and 3 maximum identical adjacent characters!. If blank, the SDDC Local Admin Password will be used (if provided) or password will be auto-generated.
	AdminUserSsoPassword *string `json:"adminUserSsoPassword,omitempty"`

	// AdminUserSsoUsername Admin user sso username. If blank, administrator username will be used.
	AdminUserSsoUsername *string `json:"adminUserSsoUsername,omitempty"`

	// RootVcenterPassword vCenter root password. The password must be between 15 characters and 20 characters long. It must also contain at least one uppercase and lowercase letter, one number, and one character from '! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { &Iota; } ~' and all characters must be ASCII. Space is not allowed in password. For VCF only: if blank, the SDDC Local Admin Password will be used (if provided) or password will be auto-generated.
	RootVcenterPassword string `json:"rootVcenterPassword"`

	// SslThumbprint SSL thumbprint (SHA256) of the product's certificate. Need to be populated when using existing deployment in order to establish trust with the existing product.
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// SsoDomain PSC SSO Domain
	SsoDomain *string `json:"ssoDomain,omitempty"`

	// StorageSize vCenter Virtual Machine Storage size. One among:lstorage, xlstorage
	StorageSize *string `json:"storageSize,omitempty"`

	// UseExistingDeployment Import existing deployment or deploy one.
	UseExistingDeployment *bool `json:"useExistingDeployment,omitempty"`

	// VcenterHostname vCenter hostname address.
	VcenterHostname string `json:"vcenterHostname"`

	// Version Version
	Version *string `json:"version,omitempty"`

	// VmSize vCenter Virtual Machine size. One among:xlarge, large, medium, small, tiny
	VmSize *string `json:"vmSize,omitempty"`
}

// SecuritySpec Spec contains security settings
type SecuritySpec struct {
	// EsxiCertsMode ESXi certificates mode. One among:Custom, VMCA
	EsxiCertsMode *string `json:"esxiCertsMode,omitempty"`

	// RootCaCerts Root Certificate Authority certificate list
	RootCaCerts *[]RootCaCerts `json:"rootCaCerts,omitempty"`
}

// SkuBomDetails Model for sku with their name, description, patchBundles and bom
type SkuBomDetails struct {
	// Bom Sku specific bill of materials
	Bom *[]ProductVersion `json:"bom,omitempty"`

	// Description Description to be shown in release page
	Description *string `json:"description,omitempty"`

	// Name SKU name
	Name *string `json:"name,omitempty"`

	// SkuSpecificPatchBundles List of patch bundles in this release
	SkuSpecificPatchBundles *[]SkuSpecificPatchBundles `json:"skuSpecificPatchBundles,omitempty"`
}

// SkuSpecificPatchBundles Model for Sku specific patch bundle in a release
type SkuSpecificPatchBundles struct {
	// BundleType Bundle type of the patch bundle
	BundleType *string `json:"bundleType,omitempty"`

	// BundleVersion Bundle Version of the product
	BundleVersion *string `json:"bundleVersion,omitempty"`

	// Version Product version
	Version *string `json:"version,omitempty"`
}

// Stage Represents a Stage
type Stage struct {
	// CompletionTimestamp Stage completion timestamp
	CompletionTimestamp *string `json:"completionTimestamp,omitempty"`
	CreationTimestamp   string  `json:"creationTimestamp"`

	// Description Stage description
	Description *string `json:"description,omitempty"`

	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// Name Stage name
	Name *string `json:"name,omitempty"`

	// Status Stage status
	Status *string `json:"status,omitempty"`

	// Type Stage type
	Type *string `json:"type,omitempty"`
}

// SubTask Represents a sub-task
type SubTask struct {
	// CompletionTimestamp Sub-task completion timestamp
	CompletionTimestamp *string `json:"completionTimestamp,omitempty"`

	// CreationTimestamp Sub-task creation timestamp
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Description Sub-task description
	Description *string `json:"description,omitempty"`

	// DocumentationLink Represents a documentation link's url string and label
	DocumentationLink *DocumentationLink `json:"documentationLink,omitempty"`

	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// Name Sub-task name
	Name *string `json:"name,omitempty"`

	// Resources List of resources associated with sub-task
	Resources *[]Resource `json:"resources,omitempty"`

	// Stages List of stages of the sub-task
	Stages *[]Stage `json:"stages,omitempty"`

	// Status Sub-task status
	Status *string `json:"status,omitempty"`

	// SubTasks List of child subtasks associated with this subtask
	SubTasks *[]SubTask `json:"subTasks,omitempty"`

	// Type Sub-task type
	Type *string `json:"type,omitempty"`
}

// System Represents a system
type System struct {
	// Id The identifier of the system
	Id *string `json:"id,omitempty"`

	// MaxAllowedDomainsInSubscription The maximum number of domains allowed in subscription mode
	MaxAllowedDomainsInSubscription *int32 `json:"maxAllowedDomainsInSubscription,omitempty"`
}

// SystemUpdateSpec Contains the parameters required to perform update operation on system
type SystemUpdateSpec struct {
	// MaxAllowedDomainsInSubscription new limit of amount of domains in subscription mode
	MaxAllowedDomainsInSubscription int32 `json:"maxAllowedDomainsInSubscription"`
}

// Task Represents a task
type Task struct {
	// CompletionTimestamp Task completion timestamp
	CompletionTimestamp *string `json:"completionTimestamp,omitempty"`

	// CreationTimestamp Task creation timestamp
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// Id Task ID
	Id *string `json:"id,omitempty"`

	// IsCancellable Represents task can be cancellable or not.
	IsCancellable *bool `json:"isCancellable,omitempty"`

	// IsRetryable Indicates whether a task is eligible for retry or not.
	IsRetryable *bool `json:"isRetryable,omitempty"`

	// LocalizableDescriptionPack A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
	LocalizableDescriptionPack *MessagePack `json:"localizableDescriptionPack,omitempty"`

	// Name Task name
	Name *string `json:"name,omitempty"`

	// ResolutionStatus Resolution state
	ResolutionStatus *string `json:"resolutionStatus,omitempty"`

	// Resources List of resources associated with task
	Resources *[]Resource `json:"resources,omitempty"`

	// Status Task status
	Status *string `json:"status,omitempty"`

	// SubTasks List of sub-tasks of the task
	SubTasks *[]SubTask `json:"subTasks,omitempty"`

	// Type Operation that is represented by the Task in machine readable format.  The value is controlled by the owners/producers of the Task. The convention is <resource>_<operation>
	Type *string `json:"type,omitempty"`
}

// TeamingSpec This specification contains the teaming policies associated with the uplink profile.
type TeamingSpec struct {
	// ActiveUplinks The list of active uplinks
	ActiveUplinks []string `json:"activeUplinks"`

	// Policy The teaming policy associated with the uplink profile
	Policy string `json:"policy"`

	// StandByUplinks The list of stand by uplinks
	StandByUplinks *[]string `json:"standByUplinks,omitempty"`
}

// TokenCreationSpec The spec used to sign the token
type TokenCreationSpec struct {
	// ApiKey API Key
	ApiKey *string `json:"apiKey,omitempty"`

	// IdToken Id Token
	IdToken *string `json:"idToken,omitempty"`

	// Password User Password
	Password *string `json:"password,omitempty"`

	// Username Username
	Username *string `json:"username,omitempty"`
}

// TokenPair This contains the access token and the refresh token for the user API access.
type TokenPair struct {
	// AccessToken Bearer token that can be used to make public API calls
	AccessToken *string `json:"accessToken,omitempty"`

	// RefreshToken This contains refresh token id for the user API access.
	RefreshToken *RefreshToken `json:"refreshToken,omitempty"`
}

// TransportZone The transport zone to be associated with the vSphere Distributed Switch managed by NSX
type TransportZone struct {
	// Name The name of the transport zone
	Name *string `json:"name,omitempty"`

	// TransportType The type of the transport zone
	TransportType string `json:"transportType"`
}

// TrustedCertificate The Trusted Certificate details.
type TrustedCertificate struct {
	// Alias Certificate alias
	Alias string `json:"alias"`

	// Certificate Certificate in PEM format
	Certificate string `json:"certificate"`
}

// TrustedCertificateSpec This specification contains certificate & certificate usage
type TrustedCertificateSpec struct {
	// Certificate Certificate in PEM format
	Certificate string `json:"certificate"`

	// CertificateUsageType Certificate usage
	// Deprecated:
	CertificateUsageType *string `json:"certificateUsageType,omitempty"`
}

// Validation Represents a validation with a list of one or more validation checks that are performed as part of the validation
type Validation struct {
	AdditionalProperties *map[string]string `json:"additionalProperties,omitempty"`

	// Description Description of the validation
	Description *string `json:"description,omitempty"`

	// ExecutionStatus Execution status of the validation. One among: IN_PROGRESS, FAILED, COMPLETED, UNKNOWN, SKIPPED, CANCELLED, CANCELLATION_IN_PROGRESS
	ExecutionStatus *string `json:"executionStatus,omitempty"`

	// Id ID of the validation
	Id *string `json:"id,omitempty"`

	// ResultStatus Result status of the validation after it has completed its execution. One among: SUCCEEDED, FAILED, WARNING, UNKNOWN, CANCELLATION_IN_PROGRESS
	ResultStatus *string `json:"resultStatus,omitempty"`

	// ValidationChecks List of one or more validation checks that are performed as part of the validation
	ValidationChecks *[]ValidationCheck `json:"validationChecks,omitempty"`
}

// ValidationCheck Represents a validation check
type ValidationCheck struct {
	// Acknowledge Flag indicating whether the validation check requires acknowledgment
	Acknowledge *bool `json:"acknowledge,omitempty"`

	// Description Description of the validation check
	Description *string `json:"description,omitempty"`

	// ErrorResponse Error response containing a minor error code, a localized error message, a localized remediation message and optionally a reference token to correlate the error with the logs
	ErrorResponse *Error `json:"errorResponse,omitempty"`

	// ResultStatus Result status of the validation check after it has completed its execution
	ResultStatus string `json:"resultStatus"`

	// Severity Severity of the validation check
	Severity *string `json:"severity,omitempty"`
}

// VcenterAdapterInfo vCenter Adapter information registered in Vcf Operations instance.
type VcenterAdapterInfo struct {
	// Address vCenter address.
	Address string `json:"address"`

	// Id Adapter ID.
	Id string `json:"id"`

	// Name Adapter name.
	Name string `json:"name"`
}

// VcenterDiscoveryResult Topology discovery result from querying vCenter instance.
type VcenterDiscoveryResult struct {
	// NsxInfo NSX instance associated with vCenter instance.
	NsxInfo *VcenterNsxInfo `json:"nsxInfo,omitempty"`

	// VcenterBuildNumber vCenter build number.
	VcenterBuildNumber *string `json:"vcenterBuildNumber,omitempty"`

	// VcenterVersion vCenter version.
	VcenterVersion *string `json:"vcenterVersion,omitempty"`
}

// VcenterDiscoverySpec vCenter specification holding endpoint information which to query for topology/discovery data.
type VcenterDiscoverySpec struct {
	// Address vCenter address.
	Address string `json:"address"`

	// Password SSO password.
	Password string `json:"password"`

	// SslThumbprint vCenter SSL thumbprint (SHA256)
	SslThumbprint string `json:"sslThumbprint"`

	// Username SSO username.
	Username string `json:"username"`
}

// VcenterNsxInfo NSX instance associated with vCenter instance.
type VcenterNsxInfo struct {
	// Address NSX address.
	Address string `json:"address"`
}

// VcfAutomation VCF Automation
type VcfAutomation struct {
	// DeploymentStatus VCF Automation deployment status. One among: NOT_FOUND, NOT_STARTED, IN_PROGRESS, FAILED, SUCCEEDED
	DeploymentStatus *string `json:"deploymentStatus,omitempty"`

	// DeploymentType VCF Automation deployment type. One among: NEW, EXISTING
	DeploymentType *string `json:"deploymentType,omitempty"`

	// Fqdn FQDN
	Fqdn *string `json:"fqdn,omitempty"`
}

// VcfAutomationNodeInfo VCF Automation node information.
type VcfAutomationNodeInfo struct {
	// Addresses Node addresses.
	Addresses *[]NodeAddress `json:"addresses,omitempty"`

	// CertificateThumbprints Certificate thumbprints (SHA256).
	CertificateThumbprints *[]string `json:"certificateThumbprints,omitempty"`

	// Name Node name.
	Name *string `json:"name,omitempty"`
}

// VcfAutomationSpec Specification for VCF Automation
type VcfAutomationSpec struct {
	// AdminUserPassword Admin user password. If blank the password will be auto-generated.
	AdminUserPassword *string `json:"adminUserPassword,omitempty"`

	// Hostname Host name
	Hostname string `json:"hostname"`

	// InternalClusterCidr Internal Cluster CIDR. One among: 198.18.0.0/15, 240.0.0.0/15, 250.0.0.0/15
	InternalClusterCidr *string `json:"internalClusterCidr,omitempty"`

	// IpPool List of IP addresses.  For Standard deployment model two IP addresses need to be specified and for High Availability four IP addresses need to be specified
	IpPool *[]string `json:"ipPool,omitempty"`

	// NodePrefix Node Prefix. It cannot be blank and must begin and end with an alphanumeric character, and can only contain lowercase alphanumeric characters or hyphens.
	NodePrefix *string `json:"nodePrefix,omitempty"`

	// SslThumbprint SSL thumbprint (SHA256) of the product's certificate. Need to be populated when using existing deployment in order to establish trust with the existing product.
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// UseExistingDeployment Import existing deployment or deploy one.
	UseExistingDeployment *bool `json:"useExistingDeployment,omitempty"`

	// Version Version
	Version *string `json:"version,omitempty"`
}

// VcfManagementComponents VCF Management Components
type VcfManagementComponents struct {
	// VcfAutomation VCF Automation
	VcfAutomation *VcfAutomation `json:"vcfAutomation,omitempty"`

	// VcfOperations VCF Operations
	VcfOperations *VcfOperations `json:"vcfOperations,omitempty"`

	// VcfOperationsCollector VCF Operations collector
	VcfOperationsCollector *VcfOperationsCollector `json:"vcfOperationsCollector,omitempty"`

	// VcfOperationsFleetManagement VCF Operations fleet management
	VcfOperationsFleetManagement *VcfOperationsFleetManagement `json:"vcfOperationsFleetManagement,omitempty"`
}

// VcfOperations VCF Operations
type VcfOperations struct {
	// DeploymentStatus VCF Operations deployment status. One among: NOT_FOUND, NOT_STARTED, IN_PROGRESS, FAILED, SUCCEEDED
	DeploymentStatus *string `json:"deploymentStatus,omitempty"`

	// DeploymentType VCF Operations deployment type. One among: NEW, EXISTING
	DeploymentType *string `json:"deploymentType,omitempty"`

	// LoadBalancerFqdn Load Balancer FQDN
	LoadBalancerFqdn *string `json:"loadBalancerFqdn,omitempty"`

	// Nodes List of nodes
	Nodes *[]VcfOperationsNodeDetails `json:"nodes,omitempty"`
}

// VcfOperationsCollector VCF Operations collector
type VcfOperationsCollector struct {
	// DeploymentStatus VCF Operations collector deployment status. One among: NOT_FOUND, NOT_STARTED, IN_PROGRESS, FAILED, SUCCEEDED
	DeploymentStatus *string `json:"deploymentStatus,omitempty"`

	// DeploymentType VCF Operations collector deployment type. Only valid value is: NEW
	DeploymentType *string `json:"deploymentType,omitempty"`

	// Fqdn FQDN
	Fqdn *string `json:"fqdn,omitempty"`
}

// VcfOperationsCollectorSpec Specification for VCF Operations collector
type VcfOperationsCollectorSpec struct {
	// ApplianceSize VCF Operations collector appliance size. One among: small, standard. Default value if not provided is small
	ApplianceSize *string `json:"applianceSize,omitempty"`

	// Hostname Host name
	Hostname string `json:"hostname"`

	// RootUserPassword Root user password.
	RootUserPassword *string `json:"rootUserPassword,omitempty"`

	// SslThumbprint SSL thumbprint (SHA256) of the product's certificate. Need to be populated when using existing deployment in order to establish trust with the existing product.
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// UseExistingDeployment Import existing deployment or deploy one.
	UseExistingDeployment *bool `json:"useExistingDeployment,omitempty"`

	// Version Version
	Version *string `json:"version,omitempty"`
}

// VcfOperationsDiscoveryResult Topology discovery result from querying VCF Operations instance.
type VcfOperationsDiscoveryResult struct {
	// NsxAdapters Registered NSX adapters.
	NsxAdapters *[]NsxAdapterInfo `json:"nsxAdapters,omitempty"`

	// VcenterAdapters Registered vCenter adapters.
	VcenterAdapters *[]VcenterAdapterInfo `json:"vcenterAdapters,omitempty"`

	// VcfAutomationNodes VCF Automation nodes info.
	VcfAutomationNodes *[]VcfAutomationNodeInfo `json:"vcfAutomationNodes,omitempty"`

	// VcfOperationsBuildNumber VCF Operations instance build number.
	VcfOperationsBuildNumber string `json:"vcfOperationsBuildNumber"`

	// VcfOperationsManagementNode VCF Operations Management node information.
	VcfOperationsManagementNode *VcfOperationsManagementNodeInfo `json:"vcfOperationsManagementNode,omitempty"`

	// VcfOperationsNodes VCF Operations nodes info.
	VcfOperationsNodes []VcfOperationsNodeInfo `json:"vcfOperationsNodes"`

	// VcfOperationsVersion VCF Operations instance version.
	VcfOperationsVersion string `json:"vcfOperationsVersion"`
}

// VcfOperationsDiscoverySpec VCF Operations specification holding endpoint information which to query for topology/discovery data.
type VcfOperationsDiscoverySpec struct {
	// Address VCF Operations instance address.
	Address string `json:"address"`

	// AdminPassword Admin password.
	AdminPassword string `json:"adminPassword"`

	// AdminUsername Admin username. Can be omitted.
	AdminUsername *string `json:"adminUsername,omitempty"`

	// SslThumbprint VCF Operations SSL thumbprint (SHA256).
	SslThumbprint string `json:"sslThumbprint"`
}

// VcfOperationsFleetManagement VCF Operations fleet management
type VcfOperationsFleetManagement struct {
	// DeploymentStatus VCF Operations fleet management deployment status. One among: NOT_FOUND, NOT_STARTED, IN_PROGRESS, FAILED, SUCCEEDED
	DeploymentStatus *string `json:"deploymentStatus,omitempty"`

	// DeploymentType VCF Operations fleet management deployment type. One among: NEW, EXISTING
	DeploymentType *string `json:"deploymentType,omitempty"`

	// Fqdn FQDN
	Fqdn *string `json:"fqdn,omitempty"`
}

// VcfOperationsFleetManagementSpec Specification for VCF Operations fleet management
type VcfOperationsFleetManagementSpec struct {
	// AdminUserPassword Admin user password. If blank the password will be auto-generated.
	AdminUserPassword *string `json:"adminUserPassword,omitempty"`

	// Hostname Host name
	Hostname string `json:"hostname"`

	// RootUserPassword Root user password. Password should be at least 15 characters in length. If blank the password will be auto-generated.
	RootUserPassword *string `json:"rootUserPassword,omitempty"`

	// SslThumbprint SSL thumbprint (SHA256) of the product's certificate. Need to be populated when using existing deployment in order to establish trust with the existing product.
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// UseExistingDeployment Import existing deployment or deploy one.
	UseExistingDeployment *bool `json:"useExistingDeployment,omitempty"`

	// Version Version
	Version *string `json:"version,omitempty"`
}

// VcfOperationsManagementNodeInfo VCF Operations Management node information.
type VcfOperationsManagementNodeInfo struct {
	// Addresses Node addresses.
	Addresses *[]NodeAddress `json:"addresses,omitempty"`

	// CertificateThumbprints Certificate thumbprints (SHA256).
	CertificateThumbprints *[]string `json:"certificateThumbprints,omitempty"`

	// Name Node name.
	Name *string `json:"name,omitempty"`
}

// VcfOperationsNode Specification for VCF Operations Node
type VcfOperationsNode struct {
	// Hostname Host name
	Hostname string `json:"hostname"`

	// RootUserPassword Root user password.
	RootUserPassword *string `json:"rootUserPassword,omitempty"`

	// SslThumbprint SSL thumbprint (SHA256) of the node certificate. Need to be populated when using existing VCF Ops deployment.
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// Type Node type. One among: master, replica, data
	Type *string `json:"type,omitempty"`
}

// VcfOperationsNodeDetails VCF Operations node details
type VcfOperationsNodeDetails struct {
	// Fqdn FQDN
	Fqdn *string `json:"fqdn,omitempty"`

	// Type Node type. One among: master, replica, data
	Type *string `json:"type,omitempty"`
}

// VcfOperationsNodeInfo VCF Operations node information.
type VcfOperationsNodeInfo struct {
	// Address Node address.
	Address *string `json:"address,omitempty"`

	// Name Node name.
	Name *string `json:"name,omitempty"`

	// Type Node type. One among: master, replica, data, witness, cloudproxy
	Type *string `json:"type,omitempty"`
}

// VcfOperationsSpec Specification for VCF Operations
type VcfOperationsSpec struct {
	// AdminUserPassword Admin user password. If blank the password will be auto-generated.
	AdminUserPassword *string `json:"adminUserPassword,omitempty"`

	// ApplianceSize VCF Operations appliance size. One among: xsmall, small, medium, large, xlarge for Simple deployment model and one among: medium, large, xlarge for High Availability. Default value if not provided is medium for both deployment models.
	ApplianceSize *string `json:"applianceSize,omitempty"`

	// LoadBalancerFqdn Load Balancer FQDN
	LoadBalancerFqdn *string `json:"loadBalancerFqdn,omitempty"`

	// Nodes List of nodes
	Nodes []VcfOperationsNode `json:"nodes"`

	// UseExistingDeployment Import existing deployment or deploy one.
	UseExistingDeployment *bool `json:"useExistingDeployment,omitempty"`

	// Version Version
	Version *string `json:"version,omitempty"`
}

// VcfService VCF service representation
type VcfService struct {
	// Id ID of the service
	Id *string `json:"id,omitempty"`

	// Name Name of the service
	Name *string `json:"name,omitempty"`

	// Status Status of the service
	Status *string `json:"status,omitempty"`

	// Version Version of the service
	Version *string `json:"version,omitempty"`
}

// VmfsDatastoreSpec Cluster storage configuration for VMFS
type VmfsDatastoreSpec struct {
	// FcSpec Cluster storage configuration for VMFS on FC
	FcSpec *[]FcSpec `json:"fcSpec,omitempty"`
}

// VmnicToUplink This specification contains vmnic to uplink configurations for vSphere host.
type VmnicToUplink struct {
	// Id VmNic ID of vSphere host to be associated with VDS, once added to cluster
	Id string `json:"id"`

	// Uplink The uplink name of the vSphere Distributed Switch to be associated
	Uplink string `json:"uplink"`
}

// VsanEsaConfig This spec contains cluster vSAN ESA configuration
type VsanEsaConfig struct {
	// Enabled Whether the vSAN ESA is enabled.
	Enabled *bool `json:"enabled,omitempty"`
}

// VsanSpec Spec contains parameters of Virtual SAN
type VsanSpec struct {
	// DatastoreName Datastore Name. It will be auto-generated if blank
	DatastoreName *string `json:"datastoreName,omitempty"`

	// EsaConfig This spec contains cluster vSAN ESA configuration
	EsaConfig *VsanEsaConfig `json:"esaConfig,omitempty"`

	// FailuresToTolerate Host failures to tolerate
	FailuresToTolerate *int32 `json:"failuresToTolerate,omitempty"`

	// VsanDedup VSAN feature Deduplication and Compression flag, one flag for both features
	VsanDedup *bool `json:"vsanDedup,omitempty"`
}

// GetBundlesParams defines parameters for GetBundles.
type GetBundlesParams struct {
	// ProductType The type of the product
	ProductType *string `form:"productType,omitempty" json:"productType,omitempty"`

	// IsCompliant Is compliant with the current VCF version?
	IsCompliant *bool `form:"isCompliant,omitempty" json:"isCompliant,omitempty"`

	// BundleType The type of the bundle
	BundleType *string `form:"bundleType,omitempty" json:"bundleType,omitempty"`
}

// GetBundlesForSkipUpgradeParams defines parameters for GetBundlesForSkipUpgrade.
type GetBundlesForSkipUpgradeParams struct {
	// TargetVersion [Deprecated] Target domain VCF version
	TargetVersion *string `form:"targetVersion,omitempty" json:"targetVersion,omitempty"`
}

// GetBundleDownloadStatusParams defines parameters for GetBundleDownloadStatus.
type GetBundleDownloadStatusParams struct {
	// ReleaseVersion Get download status for bundles that are associated with a specific release.
	ReleaseVersion *string `form:"releaseVersion,omitempty" json:"releaseVersion,omitempty"`

	// BundleId Get the download status for a specific bundle by bundleId.
	BundleId *string `form:"bundleId,omitempty" json:"bundleId,omitempty"`

	// ImageType The image type of the bundle, either INSTALL or PATCH
	ImageType *string `form:"imageType,omitempty" json:"imageType,omitempty"`
}

// DeleteBundleParams defines parameters for DeleteBundle.
type DeleteBundleParams struct {
	// BinaryFilesOnly binaryFilesOnly, if true, only binary files from storage will be deleted
	BinaryFilesOnly *bool `form:"binaryFilesOnly,omitempty" json:"binaryFilesOnly,omitempty"`
}

// GetReleasesParams defines parameters for GetReleases.
type GetReleasesParams struct {
	// DomainId Domain ID to get current release of the domain
	DomainId *string `form:"domainId,omitempty" json:"domainId,omitempty"`

	// VersionEq Release version to get its release
	VersionEq *string `form:"versionEq,omitempty" json:"versionEq,omitempty"`

	// VersionGt Release version to get its future releases
	VersionGt *string `form:"versionGt,omitempty" json:"versionGt,omitempty"`

	// VersionGe Release version to get its current & future releases
	VersionGe *string `form:"versionGe,omitempty" json:"versionGe,omitempty"`

	// ApplicableForVersion Release version to get applicable releases
	ApplicableForVersion *string `form:"applicableForVersion,omitempty" json:"applicableForVersion,omitempty"`

	// MinInstallerVersionLe Releases with minInstallerVersion less than given minInstallerVersion
	MinInstallerVersionLe *string `form:"minInstallerVersionLe,omitempty" json:"minInstallerVersionLe,omitempty"`

	// GetFutureReleases [Deprecated] Get all future releases for a given domain
	GetFutureReleases *bool `form:"getFutureReleases,omitempty" json:"getFutureReleases,omitempty"`

	// IncludeOnlyCompatible Filter only compatible releases on the system
	IncludeOnlyCompatible *bool `form:"includeOnlyCompatible,omitempty" json:"includeOnlyCompatible,omitempty"`
}

// GetCustomPatchesBySkuParams defines parameters for GetCustomPatchesBySku.
type GetCustomPatchesBySkuParams struct {
	// Sku SKU (VCF or VVF)
	Sku string `form:"sku" json:"sku"`

	// ReleaseVersion Release Version
	ReleaseVersion string `form:"releaseVersion" json:"releaseVersion"`

	// ImageType Image type for the image you want to retrieve.
	ImageType *string `form:"imageType,omitempty" json:"imageType,omitempty"`
}

// GetCustomPatchesParams defines parameters for GetCustomPatches.
type GetCustomPatchesParams struct {
	// VcfRelease VCF Release
	VcfRelease *string `form:"vcfRelease,omitempty" json:"vcfRelease,omitempty"`

	// ProductType Product Type
	ProductType *string `form:"productType,omitempty" json:"productType,omitempty"`
}

// GetReleaseComponentsBySkuParams defines parameters for GetReleaseComponentsBySku.
type GetReleaseComponentsBySkuParams struct {
	// ReleaseVersion VCF Release Version
	ReleaseVersion *string `form:"releaseVersion,omitempty" json:"releaseVersion,omitempty"`

	// ImageType image type for the image you want to retrieve.
	ImageType *string `form:"imageType,omitempty" json:"imageType,omitempty"`

	// AutomatedInstall Automated Install. If true, list all automated Install product. if false or empty, filter will not be applied. Applicable only for VCF 9.0.0.0 and above releases releases
	AutomatedInstall *bool `form:"automatedInstall,omitempty" json:"automatedInstall,omitempty"`

	// LifecycleManagedBy Lifecycle managed by
	LifecycleManagedBy *string `form:"lifecycleManagedBy,omitempty" json:"lifecycleManagedBy,omitempty"`

	// ReleaseType List of release types
	ReleaseType *[]string `form:"releaseType,omitempty" json:"releaseType,omitempty"`

	// MatchWithReleaseType Match with release type for provided releaseVersion
	MatchWithReleaseType *string `form:"matchWithReleaseType,omitempty" json:"matchWithReleaseType,omitempty"`
}

// DeploySddcParams defines parameters for DeploySddc.
type DeploySddcParams struct {
	// SkipValidations Skips validations
	SkipValidations *bool `form:"skipValidations,omitempty" json:"skipValidations,omitempty"`
}

// RetrySddcParams defines parameters for RetrySddc.
type RetrySddcParams struct {
	// SkipValidations Skips validations
	SkipValidations *bool `form:"skipValidations,omitempty" json:"skipValidations,omitempty"`
}

// SetCeipStatusJSONBody defines parameters for SetCeipStatus.
type SetCeipStatusJSONBody string

// DeleteDepotSettingsParams defines parameters for DeleteDepotSettings.
type DeleteDepotSettingsParams struct {
	// DepotType Depot Type
	DepotType *string `form:"depotType,omitempty" json:"depotType,omitempty"`
}

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	// Limit The number of elements to be returned in the result
	Limit        *int32  `form:"limit,omitempty" json:"limit,omitempty"`
	TaskStatus   *string `form:"taskStatus,omitempty" json:"taskStatus,omitempty"`
	TaskType     *string `form:"taskType,omitempty" json:"taskType,omitempty"`
	ResourceId   *string `form:"resourceId,omitempty" json:"resourceId,omitempty"`
	ResourceType *string `form:"resourceType,omitempty" json:"resourceType,omitempty"`

	// CompletedAfter A time based filter to get tasks which are completed after the given timestamp. A task is completed if its status is 'Successful' or 'Failed'. Time is in milliseconds.
	CompletedAfter *int64 `form:"completedAfter,omitempty" json:"completedAfter,omitempty"`

	// PageNumber Page number.
	PageNumber *int32 `form:"pageNumber,omitempty" json:"pageNumber,omitempty"`

	// PageSize Size of the page you want to retrieve. Max page size allowed is 100.
	PageSize       *int32  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	OrderDirection *string `form:"orderDirection,omitempty" json:"orderDirection,omitempty"`
	OrderBy        *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// TaskName Search filter when task name contains text.
	TaskName      *string `form:"taskName,omitempty" json:"taskName,omitempty"`
	DoLiveRefresh *bool   `form:"doLiveRefresh,omitempty" json:"doLiveRefresh,omitempty"`
}

// RefreshAccessTokenJSONBody defines parameters for RefreshAccessToken.
type RefreshAccessTokenJSONBody = string

// InvalidateRefreshTokenJSONBody defines parameters for InvalidateRefreshToken.
type InvalidateRefreshTokenJSONBody = string

// UploadBundleJSONRequestBody defines body for UploadBundle for application/json ContentType.
type UploadBundleJSONRequestBody = BundleUploadSpec

// StartBundleDownloadByIDJSONRequestBody defines body for StartBundleDownloadByID for application/json ContentType.
type StartBundleDownloadByIDJSONRequestBody = BundleUpdateSpec

// AddTrustedCertificateJSONRequestBody defines body for AddTrustedCertificate for application/json ContentType.
type AddTrustedCertificateJSONRequestBody = TrustedCertificateSpec

// DeploySddcJSONRequestBody defines body for DeploySddc for application/json ContentType.
type DeploySddcJSONRequestBody = SddcSpec

// GetInstallerTypeJSONRequestBody defines body for GetInstallerType for application/json ContentType.
type GetInstallerTypeJSONRequestBody = SddcInstallerRequest

// GetNetworkConfigProfilesJSONRequestBody defines body for GetNetworkConfigProfiles for application/json ContentType.
type GetNetworkConfigProfilesJSONRequestBody = SddcNetworkConfigProfileSpec

// ValidateSddcSpecJSONRequestBody defines body for ValidateSddcSpec for application/json ContentType.
type ValidateSddcSpecJSONRequestBody = SddcSpec

// DiscoverVcenterJSONRequestBody defines body for DiscoverVcenter for application/json ContentType.
type DiscoverVcenterJSONRequestBody = VcenterDiscoverySpec

// DiscoverVcfOpsJSONRequestBody defines body for DiscoverVcfOps for application/json ContentType.
type DiscoverVcfOpsJSONRequestBody = VcfOperationsDiscoverySpec

// RetrySddcJSONRequestBody defines body for RetrySddc for application/json ContentType.
type RetrySddcJSONRequestBody = SddcSpec

// UpdateSystemConfigurationJSONRequestBody defines body for UpdateSystemConfiguration for application/json ContentType.
type UpdateSystemConfigurationJSONRequestBody = SystemUpdateSpec

// SetCeipStatusJSONRequestBody defines body for SetCeipStatus for application/json ContentType.
type SetCeipStatusJSONRequestBody SetCeipStatusJSONBody

// UpdateProxyConfigurationJSONRequestBody defines body for UpdateProxyConfiguration for application/json ContentType.
type UpdateProxyConfigurationJSONRequestBody = ProxyConfiguration

// UpdateDepotSettingsJSONRequestBody defines body for UpdateDepotSettings for application/json ContentType.
type UpdateDepotSettingsJSONRequestBody = DepotSettings

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody = TokenCreationSpec

// RefreshAccessTokenJSONRequestBody defines body for RefreshAccessToken for application/json ContentType.
type RefreshAccessTokenJSONRequestBody = RefreshAccessTokenJSONBody

// InvalidateRefreshTokenJSONRequestBody defines body for InvalidateRefreshToken for application/json ContentType.
type InvalidateRefreshTokenJSONRequestBody = InvalidateRefreshTokenJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetBundles request
	GetBundles(ctx context.Context, params *GetBundlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadBundleWithBody request with any body
	UploadBundleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadBundle(ctx context.Context, body UploadBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBundlesForSkipUpgrade request
	GetBundlesForSkipUpgrade(ctx context.Context, id string, params *GetBundlesForSkipUpgradeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBundleDownloadStatus request
	GetBundleDownloadStatus(ctx context.Context, params *GetBundleDownloadStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBundle request
	DeleteBundle(ctx context.Context, id string, params *DeleteBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBundle request
	GetBundle(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartBundleDownloadByIDWithBody request with any body
	StartBundleDownloadByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartBundleDownloadByID(ctx context.Context, id string, body StartBundleDownloadByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleases request
	GetReleases(ctx context.Context, params *GetReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomPatchesBySku request
	GetCustomPatchesBySku(ctx context.Context, params *GetCustomPatchesBySkuParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomPatches request
	GetCustomPatches(ctx context.Context, domainId string, params *GetCustomPatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFutureReleases request
	GetFutureReleases(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemRelease request
	GetSystemRelease(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleaseComponentsBySku request
	GetReleaseComponentsBySku(ctx context.Context, sku string, params *GetReleaseComponentsBySkuParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTrustedCertificates request
	GetTrustedCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTrustedCertificateWithBody request with any body
	AddTrustedCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTrustedCertificate(ctx context.Context, body AddTrustedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTrustedCertificate request
	DeleteTrustedCertificate(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSddcTasks request
	GetSddcTasks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeploySddcWithBody request with any body
	DeploySddcWithBody(ctx context.Context, params *DeploySddcParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeploySddc(ctx context.Context, params *DeploySddcParams, body DeploySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstallerTypeWithBody request with any body
	GetInstallerTypeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetInstallerType(ctx context.Context, body GetInstallerTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestSddcTask request
	GetLatestSddcTask(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkConfigProfilesWithBody request with any body
	GetNetworkConfigProfilesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetNetworkConfigProfiles(ctx context.Context, body GetNetworkConfigProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSddcSpecValidations request
	GetSddcSpecValidations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateSddcSpecWithBody request with any body
	ValidateSddcSpecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateSddcSpec(ctx context.Context, body ValidateSddcSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestSddcSpecValidation request
	GetLatestSddcSpecValidation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSddcSpecValidation request
	GetSddcSpecValidation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiscoverVcenterWithBody request with any body
	DiscoverVcenterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DiscoverVcenter(ctx context.Context, body DiscoverVcenterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiscoverVcfOpsWithBody request with any body
	DiscoverVcfOpsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DiscoverVcfOps(ctx context.Context, body DiscoverVcfOpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSddcTaskByID request
	GetSddcTaskByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrySddcWithBody request with any body
	RetrySddcWithBody(ctx context.Context, id string, params *RetrySddcParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RetrySddc(ctx context.Context, id string, params *RetrySddcParams, body RetrySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSddcSpecByID request
	GetSddcSpecByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemConfiguration request
	GetSystemConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSystemConfigurationWithBody request with any body
	UpdateSystemConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSystemConfiguration(ctx context.Context, body UpdateSystemConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplianceInfo request
	GetApplianceInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCeipStatus request
	GetCeipStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCeipStatusWithBody request with any body
	SetCeipStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetCeipStatus(ctx context.Context, body SetCeipStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProxyConfiguration request
	GetProxyConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProxyConfigurationWithBody request with any body
	UpdateProxyConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProxyConfiguration(ctx context.Context, body UpdateProxyConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDepotSettings request
	DeleteDepotSettings(ctx context.Context, params *DeleteDepotSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDepotSettings request
	GetDepotSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDepotSettingsWithBody request with any body
	UpdateDepotSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDepotSettings(ctx context.Context, body UpdateDepotSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDepotSyncInfo request
	GetDepotSyncInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncDepotMetadata request
	SyncDepotMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemVcfManagementComponents request
	GetSystemVcfManagementComponents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTasks request
	GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelTask request
	CancelTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTask request
	GetTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryTask request
	RetryTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshAccessTokenWithBody request with any body
	RefreshAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshAccessToken(ctx context.Context, body RefreshAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InvalidateRefreshTokenWithBody request with any body
	InvalidateRefreshTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InvalidateRefreshToken(ctx context.Context, body InvalidateRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVcfServices request
	GetVcfServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVcfService request
	GetVcfService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetBundles(ctx context.Context, params *GetBundlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBundlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadBundleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadBundleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadBundle(ctx context.Context, body UploadBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadBundleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBundlesForSkipUpgrade(ctx context.Context, id string, params *GetBundlesForSkipUpgradeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBundlesForSkipUpgradeRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBundleDownloadStatus(ctx context.Context, params *GetBundleDownloadStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBundleDownloadStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBundle(ctx context.Context, id string, params *DeleteBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBundleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBundle(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBundleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBundleDownloadByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBundleDownloadByIDRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBundleDownloadByID(ctx context.Context, id string, body StartBundleDownloadByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBundleDownloadByIDRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleases(ctx context.Context, params *GetReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomPatchesBySku(ctx context.Context, params *GetCustomPatchesBySkuParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomPatchesBySkuRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomPatches(ctx context.Context, domainId string, params *GetCustomPatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomPatchesRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFutureReleases(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFutureReleasesRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemRelease(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemReleaseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleaseComponentsBySku(ctx context.Context, sku string, params *GetReleaseComponentsBySkuParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleaseComponentsBySkuRequest(c.Server, sku, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrustedCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTrustedCertificatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTrustedCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTrustedCertificateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTrustedCertificate(ctx context.Context, body AddTrustedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTrustedCertificateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTrustedCertificate(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTrustedCertificateRequest(c.Server, alias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSddcTasks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSddcTasksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeploySddcWithBody(ctx context.Context, params *DeploySddcParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeploySddcRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeploySddc(ctx context.Context, params *DeploySddcParams, body DeploySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeploySddcRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstallerTypeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstallerTypeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstallerType(ctx context.Context, body GetInstallerTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstallerTypeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestSddcTask(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestSddcTaskRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkConfigProfilesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkConfigProfilesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkConfigProfiles(ctx context.Context, body GetNetworkConfigProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkConfigProfilesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSddcSpecValidations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSddcSpecValidationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateSddcSpecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateSddcSpecRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateSddcSpec(ctx context.Context, body ValidateSddcSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateSddcSpecRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestSddcSpecValidation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestSddcSpecValidationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSddcSpecValidation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSddcSpecValidationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscoverVcenterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscoverVcenterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscoverVcenter(ctx context.Context, body DiscoverVcenterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscoverVcenterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscoverVcfOpsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscoverVcfOpsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscoverVcfOps(ctx context.Context, body DiscoverVcfOpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscoverVcfOpsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSddcTaskByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSddcTaskByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrySddcWithBody(ctx context.Context, id string, params *RetrySddcParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrySddcRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrySddc(ctx context.Context, id string, params *RetrySddcParams, body RetrySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrySddcRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSddcSpecByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSddcSpecByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSystemConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSystemConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSystemConfiguration(ctx context.Context, body UpdateSystemConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSystemConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplianceInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplianceInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCeipStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCeipStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCeipStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCeipStatusRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCeipStatus(ctx context.Context, body SetCeipStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCeipStatusRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProxyConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProxyConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProxyConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProxyConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProxyConfiguration(ctx context.Context, body UpdateProxyConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProxyConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDepotSettings(ctx context.Context, params *DeleteDepotSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDepotSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDepotSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDepotSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDepotSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDepotSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDepotSettings(ctx context.Context, body UpdateDepotSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDepotSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDepotSyncInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDepotSyncInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncDepotMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncDepotMetadataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemVcfManagementComponents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemVcfManagementComponentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshAccessToken(ctx context.Context, body RefreshAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshAccessTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvalidateRefreshTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvalidateRefreshTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvalidateRefreshToken(ctx context.Context, body InvalidateRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvalidateRefreshTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVcfServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVcfServicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVcfService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVcfServiceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetBundlesRequest generates requests for GetBundles
func NewGetBundlesRequest(server string, params *GetBundlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProductType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productType", runtime.ParamLocationQuery, *params.ProductType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsCompliant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isCompliant", runtime.ParamLocationQuery, *params.IsCompliant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BundleType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundleType", runtime.ParamLocationQuery, *params.BundleType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadBundleRequest calls the generic UploadBundle builder with application/json body
func NewUploadBundleRequest(server string, body UploadBundleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadBundleRequestWithBody(server, "application/json", bodyReader)
}

// NewUploadBundleRequestWithBody generates requests for UploadBundle with any type of body
func NewUploadBundleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBundlesForSkipUpgradeRequest generates requests for GetBundlesForSkipUpgrade
func NewGetBundlesForSkipUpgradeRequest(server string, id string, params *GetBundlesForSkipUpgradeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TargetVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "targetVersion", runtime.ParamLocationQuery, *params.TargetVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBundleDownloadStatusRequest generates requests for GetBundleDownloadStatus
func NewGetBundleDownloadStatusRequest(server string, params *GetBundleDownloadStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles/download-status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReleaseVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "releaseVersion", runtime.ParamLocationQuery, *params.ReleaseVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BundleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundleId", runtime.ParamLocationQuery, *params.BundleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageType", runtime.ParamLocationQuery, *params.ImageType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBundleRequest generates requests for DeleteBundle
func NewDeleteBundleRequest(server string, id string, params *DeleteBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BinaryFilesOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "binaryFilesOnly", runtime.ParamLocationQuery, *params.BinaryFilesOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBundleRequest generates requests for GetBundle
func NewGetBundleRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartBundleDownloadByIDRequest calls the generic StartBundleDownloadByID builder with application/json body
func NewStartBundleDownloadByIDRequest(server string, id string, body StartBundleDownloadByIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartBundleDownloadByIDRequestWithBody(server, id, "application/json", bodyReader)
}

// NewStartBundleDownloadByIDRequestWithBody generates requests for StartBundleDownloadByID with any type of body
func NewStartBundleDownloadByIDRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReleasesRequest generates requests for GetReleases
func NewGetReleasesRequest(server string, params *GetReleasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DomainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainId", runtime.ParamLocationQuery, *params.DomainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VersionEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "versionEq", runtime.ParamLocationQuery, *params.VersionEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VersionGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "versionGt", runtime.ParamLocationQuery, *params.VersionGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VersionGe != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "versionGe", runtime.ParamLocationQuery, *params.VersionGe); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ApplicableForVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applicableForVersion", runtime.ParamLocationQuery, *params.ApplicableForVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinInstallerVersionLe != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minInstallerVersionLe", runtime.ParamLocationQuery, *params.MinInstallerVersionLe); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetFutureReleases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getFutureReleases", runtime.ParamLocationQuery, *params.GetFutureReleases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOnlyCompatible != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeOnlyCompatible", runtime.ParamLocationQuery, *params.IncludeOnlyCompatible); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomPatchesBySkuRequest generates requests for GetCustomPatchesBySku
func NewGetCustomPatchesBySkuRequest(server string, params *GetCustomPatchesBySkuParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/custom-patches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sku", runtime.ParamLocationQuery, params.Sku); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "releaseVersion", runtime.ParamLocationQuery, params.ReleaseVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ImageType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageType", runtime.ParamLocationQuery, *params.ImageType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomPatchesRequest generates requests for GetCustomPatches
func NewGetCustomPatchesRequest(server string, domainId string, params *GetCustomPatchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/domains/%s/custom-patches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.VcfRelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vcfRelease", runtime.ParamLocationQuery, *params.VcfRelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productType", runtime.ParamLocationQuery, *params.ProductType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFutureReleasesRequest generates requests for GetFutureReleases
func NewGetFutureReleasesRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/domains/%s/future-releases", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemReleaseRequest generates requests for GetSystemRelease
func NewGetSystemReleaseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/system")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReleaseComponentsBySkuRequest generates requests for GetReleaseComponentsBySku
func NewGetReleaseComponentsBySkuRequest(server string, sku string, params *GetReleaseComponentsBySkuParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/%s/release-components", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReleaseVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "releaseVersion", runtime.ParamLocationQuery, *params.ReleaseVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageType", runtime.ParamLocationQuery, *params.ImageType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AutomatedInstall != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "automatedInstall", runtime.ParamLocationQuery, *params.AutomatedInstall); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LifecycleManagedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lifecycleManagedBy", runtime.ParamLocationQuery, *params.LifecycleManagedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReleaseType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "releaseType", runtime.ParamLocationQuery, *params.ReleaseType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MatchWithReleaseType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matchWithReleaseType", runtime.ParamLocationQuery, *params.MatchWithReleaseType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTrustedCertificatesRequest generates requests for GetTrustedCertificates
func NewGetTrustedCertificatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddc-manager/trusted-certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTrustedCertificateRequest calls the generic AddTrustedCertificate builder with application/json body
func NewAddTrustedCertificateRequest(server string, body AddTrustedCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTrustedCertificateRequestWithBody(server, "application/json", bodyReader)
}

// NewAddTrustedCertificateRequestWithBody generates requests for AddTrustedCertificate with any type of body
func NewAddTrustedCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddc-manager/trusted-certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTrustedCertificateRequest generates requests for DeleteTrustedCertificate
func NewDeleteTrustedCertificateRequest(server string, alias string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddc-manager/trusted-certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSddcTasksRequest generates requests for GetSddcTasks
func NewGetSddcTasksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeploySddcRequest calls the generic DeploySddc builder with application/json body
func NewDeploySddcRequest(server string, params *DeploySddcParams, body DeploySddcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeploySddcRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeploySddcRequestWithBody generates requests for DeploySddc with any type of body
func NewDeploySddcRequestWithBody(server string, params *DeploySddcParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipValidations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipValidations", runtime.ParamLocationQuery, *params.SkipValidations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInstallerTypeRequest calls the generic GetInstallerType builder with application/json body
func NewGetInstallerTypeRequest(server string, body GetInstallerTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetInstallerTypeRequestWithBody(server, "application/json", bodyReader)
}

// NewGetInstallerTypeRequestWithBody generates requests for GetInstallerType with any type of body
func NewGetInstallerTypeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/installer-mode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLatestSddcTaskRequest generates requests for GetLatestSddcTask
func NewGetLatestSddcTaskRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkConfigProfilesRequest calls the generic GetNetworkConfigProfiles builder with application/json body
func NewGetNetworkConfigProfilesRequest(server string, body GetNetworkConfigProfilesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetNetworkConfigProfilesRequestWithBody(server, "application/json", bodyReader)
}

// NewGetNetworkConfigProfilesRequestWithBody generates requests for GetNetworkConfigProfiles with any type of body
func NewGetNetworkConfigProfilesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/network-config-profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSddcSpecValidationsRequest generates requests for GetSddcSpecValidations
func NewGetSddcSpecValidationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateSddcSpecRequest calls the generic ValidateSddcSpec builder with application/json body
func NewValidateSddcSpecRequest(server string, body ValidateSddcSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateSddcSpecRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateSddcSpecRequestWithBody generates requests for ValidateSddcSpec with any type of body
func NewValidateSddcSpecRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLatestSddcSpecValidationRequest generates requests for GetLatestSddcSpecValidation
func NewGetLatestSddcSpecValidationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/validations/latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSddcSpecValidationRequest generates requests for GetSddcSpecValidation
func NewGetSddcSpecValidationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiscoverVcenterRequest calls the generic DiscoverVcenter builder with application/json body
func NewDiscoverVcenterRequest(server string, body DiscoverVcenterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDiscoverVcenterRequestWithBody(server, "application/json", bodyReader)
}

// NewDiscoverVcenterRequestWithBody generates requests for DiscoverVcenter with any type of body
func NewDiscoverVcenterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/vcenter-discovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDiscoverVcfOpsRequest calls the generic DiscoverVcfOps builder with application/json body
func NewDiscoverVcfOpsRequest(server string, body DiscoverVcfOpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDiscoverVcfOpsRequestWithBody(server, "application/json", bodyReader)
}

// NewDiscoverVcfOpsRequestWithBody generates requests for DiscoverVcfOps with any type of body
func NewDiscoverVcfOpsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/vcfops-discovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSddcTaskByIDRequest generates requests for GetSddcTaskByID
func NewGetSddcTaskByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrySddcRequest calls the generic RetrySddc builder with application/json body
func NewRetrySddcRequest(server string, id string, params *RetrySddcParams, body RetrySddcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRetrySddcRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewRetrySddcRequestWithBody generates requests for RetrySddc with any type of body
func NewRetrySddcRequestWithBody(server string, id string, params *RetrySddcParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipValidations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipValidations", runtime.ParamLocationQuery, *params.SkipValidations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSddcSpecByIDRequest generates requests for GetSddcSpecByID
func NewGetSddcSpecByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/%s/spec", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemConfigurationRequest generates requests for GetSystemConfiguration
func NewGetSystemConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSystemConfigurationRequest calls the generic UpdateSystemConfiguration builder with application/json body
func NewUpdateSystemConfigurationRequest(server string, body UpdateSystemConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSystemConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateSystemConfigurationRequestWithBody generates requests for UpdateSystemConfiguration with any type of body
func NewUpdateSystemConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetApplianceInfoRequest generates requests for GetApplianceInfo
func NewGetApplianceInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/appliance-info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCeipStatusRequest generates requests for GetCeipStatus
func NewGetCeipStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/ceip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetCeipStatusRequest calls the generic SetCeipStatus builder with application/json body
func NewSetCeipStatusRequest(server string, body SetCeipStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetCeipStatusRequestWithBody(server, "application/json", bodyReader)
}

// NewSetCeipStatusRequestWithBody generates requests for SetCeipStatus with any type of body
func NewSetCeipStatusRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/ceip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProxyConfigurationRequest generates requests for GetProxyConfiguration
func NewGetProxyConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/proxy-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProxyConfigurationRequest calls the generic UpdateProxyConfiguration builder with application/json body
func NewUpdateProxyConfigurationRequest(server string, body UpdateProxyConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProxyConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateProxyConfigurationRequestWithBody generates requests for UpdateProxyConfiguration with any type of body
func NewUpdateProxyConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/proxy-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDepotSettingsRequest generates requests for DeleteDepotSettings
func NewDeleteDepotSettingsRequest(server string, params *DeleteDepotSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/depot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DepotType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depotType", runtime.ParamLocationQuery, *params.DepotType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDepotSettingsRequest generates requests for GetDepotSettings
func NewGetDepotSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/depot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDepotSettingsRequest calls the generic UpdateDepotSettings builder with application/json body
func NewUpdateDepotSettingsRequest(server string, body UpdateDepotSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDepotSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateDepotSettingsRequestWithBody generates requests for UpdateDepotSettings with any type of body
func NewUpdateDepotSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/depot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDepotSyncInfoRequest generates requests for GetDepotSyncInfo
func NewGetDepotSyncInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/depot/depot-sync-info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncDepotMetadataRequest generates requests for SyncDepotMetadata
func NewSyncDepotMetadataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/depot/depot-sync-info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemVcfManagementComponentsRequest generates requests for GetSystemVcfManagementComponents
func NewGetSystemVcfManagementComponentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/vcf-management-components")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTasksRequest generates requests for GetTasks
func NewGetTasksRequest(server string, params *GetTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaskStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taskStatus", runtime.ParamLocationQuery, *params.TaskStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaskType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taskType", runtime.ParamLocationQuery, *params.TaskType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceId", runtime.ParamLocationQuery, *params.ResourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceType", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completedAfter", runtime.ParamLocationQuery, *params.CompletedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageNumber", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderDirection", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaskName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taskName", runtime.ParamLocationQuery, *params.TaskName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DoLiveRefresh != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "doLiveRefresh", runtime.ParamLocationQuery, *params.DoLiveRefresh); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelTaskRequest generates requests for CancelTask
func NewCancelTaskRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaskRequest generates requests for GetTask
func NewGetTaskRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetryTaskRequest generates requests for RetryTask
func NewRetryTaskRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshAccessTokenRequest calls the generic RefreshAccessToken builder with application/json body
func NewRefreshAccessTokenRequest(server string, body RefreshAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefreshAccessTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewRefreshAccessTokenRequestWithBody generates requests for RefreshAccessToken with any type of body
func NewRefreshAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tokens/access-token/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInvalidateRefreshTokenRequest calls the generic InvalidateRefreshToken builder with application/json body
func NewInvalidateRefreshTokenRequest(server string, body InvalidateRefreshTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInvalidateRefreshTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewInvalidateRefreshTokenRequestWithBody generates requests for InvalidateRefreshToken with any type of body
func NewInvalidateRefreshTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tokens/refresh-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVcfServicesRequest generates requests for GetVcfServices
func NewGetVcfServicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vcf-services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVcfServiceRequest generates requests for GetVcfService
func NewGetVcfServiceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vcf-services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetBundlesWithResponse request
	GetBundlesWithResponse(ctx context.Context, params *GetBundlesParams, reqEditors ...RequestEditorFn) (*GetBundlesResponse, error)

	// UploadBundleWithBodyWithResponse request with any body
	UploadBundleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadBundleResponse, error)

	UploadBundleWithResponse(ctx context.Context, body UploadBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadBundleResponse, error)

	// GetBundlesForSkipUpgradeWithResponse request
	GetBundlesForSkipUpgradeWithResponse(ctx context.Context, id string, params *GetBundlesForSkipUpgradeParams, reqEditors ...RequestEditorFn) (*GetBundlesForSkipUpgradeResponse, error)

	// GetBundleDownloadStatusWithResponse request
	GetBundleDownloadStatusWithResponse(ctx context.Context, params *GetBundleDownloadStatusParams, reqEditors ...RequestEditorFn) (*GetBundleDownloadStatusResponse, error)

	// DeleteBundleWithResponse request
	DeleteBundleWithResponse(ctx context.Context, id string, params *DeleteBundleParams, reqEditors ...RequestEditorFn) (*DeleteBundleResponse, error)

	// GetBundleWithResponse request
	GetBundleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBundleResponse, error)

	// StartBundleDownloadByIDWithBodyWithResponse request with any body
	StartBundleDownloadByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBundleDownloadByIDResponse, error)

	StartBundleDownloadByIDWithResponse(ctx context.Context, id string, body StartBundleDownloadByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*StartBundleDownloadByIDResponse, error)

	// GetReleasesWithResponse request
	GetReleasesWithResponse(ctx context.Context, params *GetReleasesParams, reqEditors ...RequestEditorFn) (*GetReleasesResponse, error)

	// GetCustomPatchesBySkuWithResponse request
	GetCustomPatchesBySkuWithResponse(ctx context.Context, params *GetCustomPatchesBySkuParams, reqEditors ...RequestEditorFn) (*GetCustomPatchesBySkuResponse, error)

	// GetCustomPatchesWithResponse request
	GetCustomPatchesWithResponse(ctx context.Context, domainId string, params *GetCustomPatchesParams, reqEditors ...RequestEditorFn) (*GetCustomPatchesResponse, error)

	// GetFutureReleasesWithResponse request
	GetFutureReleasesWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetFutureReleasesResponse, error)

	// GetSystemReleaseWithResponse request
	GetSystemReleaseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemReleaseResponse, error)

	// GetReleaseComponentsBySkuWithResponse request
	GetReleaseComponentsBySkuWithResponse(ctx context.Context, sku string, params *GetReleaseComponentsBySkuParams, reqEditors ...RequestEditorFn) (*GetReleaseComponentsBySkuResponse, error)

	// GetTrustedCertificatesWithResponse request
	GetTrustedCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTrustedCertificatesResponse, error)

	// AddTrustedCertificateWithBodyWithResponse request with any body
	AddTrustedCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTrustedCertificateResponse, error)

	AddTrustedCertificateWithResponse(ctx context.Context, body AddTrustedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTrustedCertificateResponse, error)

	// DeleteTrustedCertificateWithResponse request
	DeleteTrustedCertificateWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*DeleteTrustedCertificateResponse, error)

	// GetSddcTasksWithResponse request
	GetSddcTasksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSddcTasksResponse, error)

	// DeploySddcWithBodyWithResponse request with any body
	DeploySddcWithBodyWithResponse(ctx context.Context, params *DeploySddcParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeploySddcResponse, error)

	DeploySddcWithResponse(ctx context.Context, params *DeploySddcParams, body DeploySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*DeploySddcResponse, error)

	// GetInstallerTypeWithBodyWithResponse request with any body
	GetInstallerTypeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetInstallerTypeResponse, error)

	GetInstallerTypeWithResponse(ctx context.Context, body GetInstallerTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*GetInstallerTypeResponse, error)

	// GetLatestSddcTaskWithResponse request
	GetLatestSddcTaskWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestSddcTaskResponse, error)

	// GetNetworkConfigProfilesWithBodyWithResponse request with any body
	GetNetworkConfigProfilesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetNetworkConfigProfilesResponse, error)

	GetNetworkConfigProfilesWithResponse(ctx context.Context, body GetNetworkConfigProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetNetworkConfigProfilesResponse, error)

	// GetSddcSpecValidationsWithResponse request
	GetSddcSpecValidationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSddcSpecValidationsResponse, error)

	// ValidateSddcSpecWithBodyWithResponse request with any body
	ValidateSddcSpecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateSddcSpecResponse, error)

	ValidateSddcSpecWithResponse(ctx context.Context, body ValidateSddcSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateSddcSpecResponse, error)

	// GetLatestSddcSpecValidationWithResponse request
	GetLatestSddcSpecValidationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestSddcSpecValidationResponse, error)

	// GetSddcSpecValidationWithResponse request
	GetSddcSpecValidationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcSpecValidationResponse, error)

	// DiscoverVcenterWithBodyWithResponse request with any body
	DiscoverVcenterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DiscoverVcenterResponse, error)

	DiscoverVcenterWithResponse(ctx context.Context, body DiscoverVcenterJSONRequestBody, reqEditors ...RequestEditorFn) (*DiscoverVcenterResponse, error)

	// DiscoverVcfOpsWithBodyWithResponse request with any body
	DiscoverVcfOpsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DiscoverVcfOpsResponse, error)

	DiscoverVcfOpsWithResponse(ctx context.Context, body DiscoverVcfOpsJSONRequestBody, reqEditors ...RequestEditorFn) (*DiscoverVcfOpsResponse, error)

	// GetSddcTaskByIDWithResponse request
	GetSddcTaskByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcTaskByIDResponse, error)

	// RetrySddcWithBodyWithResponse request with any body
	RetrySddcWithBodyWithResponse(ctx context.Context, id string, params *RetrySddcParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RetrySddcResponse, error)

	RetrySddcWithResponse(ctx context.Context, id string, params *RetrySddcParams, body RetrySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*RetrySddcResponse, error)

	// GetSddcSpecByIDWithResponse request
	GetSddcSpecByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcSpecByIDResponse, error)

	// GetSystemConfigurationWithResponse request
	GetSystemConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemConfigurationResponse, error)

	// UpdateSystemConfigurationWithBodyWithResponse request with any body
	UpdateSystemConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSystemConfigurationResponse, error)

	UpdateSystemConfigurationWithResponse(ctx context.Context, body UpdateSystemConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSystemConfigurationResponse, error)

	// GetApplianceInfoWithResponse request
	GetApplianceInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplianceInfoResponse, error)

	// GetCeipStatusWithResponse request
	GetCeipStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCeipStatusResponse, error)

	// SetCeipStatusWithBodyWithResponse request with any body
	SetCeipStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCeipStatusResponse, error)

	SetCeipStatusWithResponse(ctx context.Context, body SetCeipStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCeipStatusResponse, error)

	// GetProxyConfigurationWithResponse request
	GetProxyConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProxyConfigurationResponse, error)

	// UpdateProxyConfigurationWithBodyWithResponse request with any body
	UpdateProxyConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProxyConfigurationResponse, error)

	UpdateProxyConfigurationWithResponse(ctx context.Context, body UpdateProxyConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProxyConfigurationResponse, error)

	// DeleteDepotSettingsWithResponse request
	DeleteDepotSettingsWithResponse(ctx context.Context, params *DeleteDepotSettingsParams, reqEditors ...RequestEditorFn) (*DeleteDepotSettingsResponse, error)

	// GetDepotSettingsWithResponse request
	GetDepotSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDepotSettingsResponse, error)

	// UpdateDepotSettingsWithBodyWithResponse request with any body
	UpdateDepotSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDepotSettingsResponse, error)

	UpdateDepotSettingsWithResponse(ctx context.Context, body UpdateDepotSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDepotSettingsResponse, error)

	// GetDepotSyncInfoWithResponse request
	GetDepotSyncInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDepotSyncInfoResponse, error)

	// SyncDepotMetadataWithResponse request
	SyncDepotMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncDepotMetadataResponse, error)

	// GetSystemVcfManagementComponentsWithResponse request
	GetSystemVcfManagementComponentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemVcfManagementComponentsResponse, error)

	// GetTasksWithResponse request
	GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error)

	// CancelTaskWithResponse request
	CancelTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CancelTaskResponse, error)

	// GetTaskWithResponse request
	GetTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTaskResponse, error)

	// RetryTaskWithResponse request
	RetryTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetryTaskResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// RefreshAccessTokenWithBodyWithResponse request with any body
	RefreshAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error)

	RefreshAccessTokenWithResponse(ctx context.Context, body RefreshAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error)

	// InvalidateRefreshTokenWithBodyWithResponse request with any body
	InvalidateRefreshTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvalidateRefreshTokenResponse, error)

	InvalidateRefreshTokenWithResponse(ctx context.Context, body InvalidateRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*InvalidateRefreshTokenResponse, error)

	// GetVcfServicesWithResponse request
	GetVcfServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVcfServicesResponse, error)

	// GetVcfServiceWithResponse request
	GetVcfServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVcfServiceResponse, error)
}

type GetBundlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfBundle
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetBundlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBundlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetBundlesResponse) GetBody() []byte {
	return r.Body
}

type UploadBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON410      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UploadBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r UploadBundleResponse) GetBody() []byte {
	return r.Body
}

type GetBundlesForSkipUpgradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfBundle
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetBundlesForSkipUpgradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBundlesForSkipUpgradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetBundlesForSkipUpgradeResponse) GetBody() []byte {
	return r.Body
}

type GetBundleDownloadStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfBundleDownloadStatusInfo
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetBundleDownloadStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBundleDownloadStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetBundleDownloadStatusResponse) GetBody() []byte {
	return r.Body
}

type DeleteBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r DeleteBundleResponse) GetBody() []byte {
	return r.Body
}

type GetBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bundle
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetBundleResponse) GetBody() []byte {
	return r.Body
}

type StartBundleDownloadByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StartBundleDownloadByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartBundleDownloadByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r StartBundleDownloadByIDResponse) GetBody() []byte {
	return r.Body
}

type GetReleasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfRelease
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetReleasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetReleasesResponse) GetBody() []byte {
	return r.Body
}

type GetCustomPatchesBySkuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomPatches
	JSON400      *Error
	JSON404      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCustomPatchesBySkuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomPatchesBySkuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetCustomPatchesBySkuResponse) GetBody() []byte {
	return r.Body
}

type GetCustomPatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlexibleProductPatches
	JSON400      *Error
	JSON404      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCustomPatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomPatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetCustomPatchesResponse) GetBody() []byte {
	return r.Body
}

type GetFutureReleasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfDomainFutureRelease
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetFutureReleasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFutureReleasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetFutureReleasesResponse) GetBody() []byte {
	return r.Body
}

type GetSystemReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Release
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetSystemReleaseResponse) GetBody() []byte {
	return r.Body
}

type GetReleaseComponentsBySkuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfReleaseComponentDetail
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetReleaseComponentsBySkuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleaseComponentsBySkuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetReleaseComponentsBySkuResponse) GetBody() []byte {
	return r.Body
}

type GetTrustedCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTrustedCertificate
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTrustedCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTrustedCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetTrustedCertificatesResponse) GetBody() []byte {
	return r.Body
}

type AddTrustedCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTrustedCertificate
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AddTrustedCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTrustedCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r AddTrustedCertificateResponse) GetBody() []byte {
	return r.Body
}

type DeleteTrustedCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTrustedCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTrustedCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r DeleteTrustedCertificateResponse) GetBody() []byte {
	return r.Body
}

type GetSddcTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfSddcTask
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSddcTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSddcTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetSddcTasksResponse) GetBody() []byte {
	return r.Body
}

type DeploySddcResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SddcTask
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeploySddcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeploySddcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r DeploySddcResponse) GetBody() []byte {
	return r.Body
}

type GetInstallerTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstallerSpec
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetInstallerTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstallerTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetInstallerTypeResponse) GetBody() []byte {
	return r.Body
}

type GetLatestSddcTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SddcTask
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLatestSddcTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestSddcTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetLatestSddcTaskResponse) GetBody() []byte {
	return r.Body
}

type GetNetworkConfigProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SddcNetworkConfigProfileResponse
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNetworkConfigProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkConfigProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetNetworkConfigProfilesResponse) GetBody() []byte {
	return r.Body
}

type GetSddcSpecValidationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfValidation
	JSON404      *Error
	JSON500      *Error
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r GetSddcSpecValidationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSddcSpecValidationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetSddcSpecValidationsResponse) GetBody() []byte {
	return r.Body
}

type ValidateSddcSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON202      *Validation
	JSON400      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateSddcSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateSddcSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r ValidateSddcSpecResponse) GetBody() []byte {
	return r.Body
}

type GetLatestSddcSpecValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLatestSddcSpecValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestSddcSpecValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetLatestSddcSpecValidationResponse) GetBody() []byte {
	return r.Body
}

type GetSddcSpecValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON404      *Error
	JSON500      *Error
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r GetSddcSpecValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSddcSpecValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetSddcSpecValidationResponse) GetBody() []byte {
	return r.Body
}

type DiscoverVcenterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VcenterDiscoveryResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DiscoverVcenterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiscoverVcenterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r DiscoverVcenterResponse) GetBody() []byte {
	return r.Body
}

type DiscoverVcfOpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VcfOperationsDiscoveryResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DiscoverVcfOpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiscoverVcfOpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r DiscoverVcfOpsResponse) GetBody() []byte {
	return r.Body
}

type GetSddcTaskByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SddcTask
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSddcTaskByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSddcTaskByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetSddcTaskByIDResponse) GetBody() []byte {
	return r.Body
}

type RetrySddcResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SddcTask
	JSON400      *Error
	JSON404      *Error
	JSON405      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RetrySddcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrySddcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r RetrySddcResponse) GetBody() []byte {
	return r.Body
}

type GetSddcSpecByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SddcSpec
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSddcSpecByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSddcSpecByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetSddcSpecByIDResponse) GetBody() []byte {
	return r.Body
}

type GetSystemConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *System
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetSystemConfigurationResponse) GetBody() []byte {
	return r.Body
}

type UpdateSystemConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSystemConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSystemConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r UpdateSystemConfigurationResponse) GetBody() []byte {
	return r.Body
}

type GetApplianceInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplianceInfo
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetApplianceInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplianceInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetApplianceInfoResponse) GetBody() []byte {
	return r.Body
}

type GetCeipStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ceip
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCeipStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCeipStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetCeipStatusResponse) GetBody() []byte {
	return r.Body
}

type SetCeipStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SetCeipStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCeipStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r SetCeipStatusResponse) GetBody() []byte {
	return r.Body
}

type GetProxyConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyConfiguration
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r GetProxyConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProxyConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetProxyConfigurationResponse) GetBody() []byte {
	return r.Body
}

type UpdateProxyConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateProxyConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProxyConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r UpdateProxyConfigurationResponse) GetBody() []byte {
	return r.Body
}

type DeleteDepotSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDepotSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDepotSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r DeleteDepotSettingsResponse) GetBody() []byte {
	return r.Body
}

type GetDepotSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DepotSettings
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDepotSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDepotSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetDepotSettingsResponse) GetBody() []byte {
	return r.Body
}

type UpdateDepotSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *DepotSettings
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateDepotSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDepotSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r UpdateDepotSettingsResponse) GetBody() []byte {
	return r.Body
}

type GetDepotSyncInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DepotSyncInfo
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDepotSyncInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDepotSyncInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetDepotSyncInfoResponse) GetBody() []byte {
	return r.Body
}

type SyncDepotMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *DepotSyncInfo
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SyncDepotMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncDepotMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r SyncDepotMetadataResponse) GetBody() []byte {
	return r.Body
}

type GetSystemVcfManagementComponentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VcfManagementComponents
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemVcfManagementComponentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemVcfManagementComponentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetSystemVcfManagementComponentsResponse) GetBody() []byte {
	return r.Body
}

type GetTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTask
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetTasksResponse) GetBody() []byte {
	return r.Body
}

type CancelTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CancelTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r CancelTaskResponse) GetBody() []byte {
	return r.Body
}

type GetTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Task
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetTaskResponse) GetBody() []byte {
	return r.Body
}

type RetryTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RetryTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r RetryTaskResponse) GetBody() []byte {
	return r.Body
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TokenPair
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r CreateTokenResponse) GetBody() []byte {
	return r.Body
}

type RefreshAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RefreshAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r RefreshAccessTokenResponse) GetBody() []byte {
	return r.Body
}

type InvalidateRefreshTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InvalidateRefreshTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InvalidateRefreshTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r InvalidateRefreshTokenResponse) GetBody() []byte {
	return r.Body
}

type GetVcfServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfVcfService
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVcfServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVcfServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetVcfServicesResponse) GetBody() []byte {
	return r.Body
}

type GetVcfServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VcfService
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVcfServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVcfServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBody returns the response body as a byte array
func (r GetVcfServiceResponse) GetBody() []byte {
	return r.Body
}

// GetBundlesWithResponse request returning *GetBundlesResponse
func (c *ClientWithResponses) GetBundlesWithResponse(ctx context.Context, params *GetBundlesParams, reqEditors ...RequestEditorFn) (*GetBundlesResponse, error) {
	rsp, err := c.GetBundles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBundlesResponse(rsp)
}

// UploadBundleWithBodyWithResponse request with arbitrary body returning *UploadBundleResponse
func (c *ClientWithResponses) UploadBundleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadBundleResponse, error) {
	rsp, err := c.UploadBundleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadBundleResponse(rsp)
}

func (c *ClientWithResponses) UploadBundleWithResponse(ctx context.Context, body UploadBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadBundleResponse, error) {
	rsp, err := c.UploadBundle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadBundleResponse(rsp)
}

// GetBundlesForSkipUpgradeWithResponse request returning *GetBundlesForSkipUpgradeResponse
func (c *ClientWithResponses) GetBundlesForSkipUpgradeWithResponse(ctx context.Context, id string, params *GetBundlesForSkipUpgradeParams, reqEditors ...RequestEditorFn) (*GetBundlesForSkipUpgradeResponse, error) {
	rsp, err := c.GetBundlesForSkipUpgrade(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBundlesForSkipUpgradeResponse(rsp)
}

// GetBundleDownloadStatusWithResponse request returning *GetBundleDownloadStatusResponse
func (c *ClientWithResponses) GetBundleDownloadStatusWithResponse(ctx context.Context, params *GetBundleDownloadStatusParams, reqEditors ...RequestEditorFn) (*GetBundleDownloadStatusResponse, error) {
	rsp, err := c.GetBundleDownloadStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBundleDownloadStatusResponse(rsp)
}

// DeleteBundleWithResponse request returning *DeleteBundleResponse
func (c *ClientWithResponses) DeleteBundleWithResponse(ctx context.Context, id string, params *DeleteBundleParams, reqEditors ...RequestEditorFn) (*DeleteBundleResponse, error) {
	rsp, err := c.DeleteBundle(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBundleResponse(rsp)
}

// GetBundleWithResponse request returning *GetBundleResponse
func (c *ClientWithResponses) GetBundleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBundleResponse, error) {
	rsp, err := c.GetBundle(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBundleResponse(rsp)
}

// StartBundleDownloadByIDWithBodyWithResponse request with arbitrary body returning *StartBundleDownloadByIDResponse
func (c *ClientWithResponses) StartBundleDownloadByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBundleDownloadByIDResponse, error) {
	rsp, err := c.StartBundleDownloadByIDWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBundleDownloadByIDResponse(rsp)
}

func (c *ClientWithResponses) StartBundleDownloadByIDWithResponse(ctx context.Context, id string, body StartBundleDownloadByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*StartBundleDownloadByIDResponse, error) {
	rsp, err := c.StartBundleDownloadByID(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBundleDownloadByIDResponse(rsp)
}

// GetReleasesWithResponse request returning *GetReleasesResponse
func (c *ClientWithResponses) GetReleasesWithResponse(ctx context.Context, params *GetReleasesParams, reqEditors ...RequestEditorFn) (*GetReleasesResponse, error) {
	rsp, err := c.GetReleases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReleasesResponse(rsp)
}

// GetCustomPatchesBySkuWithResponse request returning *GetCustomPatchesBySkuResponse
func (c *ClientWithResponses) GetCustomPatchesBySkuWithResponse(ctx context.Context, params *GetCustomPatchesBySkuParams, reqEditors ...RequestEditorFn) (*GetCustomPatchesBySkuResponse, error) {
	rsp, err := c.GetCustomPatchesBySku(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomPatchesBySkuResponse(rsp)
}

// GetCustomPatchesWithResponse request returning *GetCustomPatchesResponse
func (c *ClientWithResponses) GetCustomPatchesWithResponse(ctx context.Context, domainId string, params *GetCustomPatchesParams, reqEditors ...RequestEditorFn) (*GetCustomPatchesResponse, error) {
	rsp, err := c.GetCustomPatches(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomPatchesResponse(rsp)
}

// GetFutureReleasesWithResponse request returning *GetFutureReleasesResponse
func (c *ClientWithResponses) GetFutureReleasesWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetFutureReleasesResponse, error) {
	rsp, err := c.GetFutureReleases(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFutureReleasesResponse(rsp)
}

// GetSystemReleaseWithResponse request returning *GetSystemReleaseResponse
func (c *ClientWithResponses) GetSystemReleaseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemReleaseResponse, error) {
	rsp, err := c.GetSystemRelease(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemReleaseResponse(rsp)
}

// GetReleaseComponentsBySkuWithResponse request returning *GetReleaseComponentsBySkuResponse
func (c *ClientWithResponses) GetReleaseComponentsBySkuWithResponse(ctx context.Context, sku string, params *GetReleaseComponentsBySkuParams, reqEditors ...RequestEditorFn) (*GetReleaseComponentsBySkuResponse, error) {
	rsp, err := c.GetReleaseComponentsBySku(ctx, sku, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReleaseComponentsBySkuResponse(rsp)
}

// GetTrustedCertificatesWithResponse request returning *GetTrustedCertificatesResponse
func (c *ClientWithResponses) GetTrustedCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTrustedCertificatesResponse, error) {
	rsp, err := c.GetTrustedCertificates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTrustedCertificatesResponse(rsp)
}

// AddTrustedCertificateWithBodyWithResponse request with arbitrary body returning *AddTrustedCertificateResponse
func (c *ClientWithResponses) AddTrustedCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTrustedCertificateResponse, error) {
	rsp, err := c.AddTrustedCertificateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTrustedCertificateResponse(rsp)
}

func (c *ClientWithResponses) AddTrustedCertificateWithResponse(ctx context.Context, body AddTrustedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTrustedCertificateResponse, error) {
	rsp, err := c.AddTrustedCertificate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTrustedCertificateResponse(rsp)
}

// DeleteTrustedCertificateWithResponse request returning *DeleteTrustedCertificateResponse
func (c *ClientWithResponses) DeleteTrustedCertificateWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*DeleteTrustedCertificateResponse, error) {
	rsp, err := c.DeleteTrustedCertificate(ctx, alias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTrustedCertificateResponse(rsp)
}

// GetSddcTasksWithResponse request returning *GetSddcTasksResponse
func (c *ClientWithResponses) GetSddcTasksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSddcTasksResponse, error) {
	rsp, err := c.GetSddcTasks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSddcTasksResponse(rsp)
}

// DeploySddcWithBodyWithResponse request with arbitrary body returning *DeploySddcResponse
func (c *ClientWithResponses) DeploySddcWithBodyWithResponse(ctx context.Context, params *DeploySddcParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeploySddcResponse, error) {
	rsp, err := c.DeploySddcWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeploySddcResponse(rsp)
}

func (c *ClientWithResponses) DeploySddcWithResponse(ctx context.Context, params *DeploySddcParams, body DeploySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*DeploySddcResponse, error) {
	rsp, err := c.DeploySddc(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeploySddcResponse(rsp)
}

// GetInstallerTypeWithBodyWithResponse request with arbitrary body returning *GetInstallerTypeResponse
func (c *ClientWithResponses) GetInstallerTypeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetInstallerTypeResponse, error) {
	rsp, err := c.GetInstallerTypeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstallerTypeResponse(rsp)
}

func (c *ClientWithResponses) GetInstallerTypeWithResponse(ctx context.Context, body GetInstallerTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*GetInstallerTypeResponse, error) {
	rsp, err := c.GetInstallerType(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstallerTypeResponse(rsp)
}

// GetLatestSddcTaskWithResponse request returning *GetLatestSddcTaskResponse
func (c *ClientWithResponses) GetLatestSddcTaskWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestSddcTaskResponse, error) {
	rsp, err := c.GetLatestSddcTask(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestSddcTaskResponse(rsp)
}

// GetNetworkConfigProfilesWithBodyWithResponse request with arbitrary body returning *GetNetworkConfigProfilesResponse
func (c *ClientWithResponses) GetNetworkConfigProfilesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetNetworkConfigProfilesResponse, error) {
	rsp, err := c.GetNetworkConfigProfilesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkConfigProfilesResponse(rsp)
}

func (c *ClientWithResponses) GetNetworkConfigProfilesWithResponse(ctx context.Context, body GetNetworkConfigProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetNetworkConfigProfilesResponse, error) {
	rsp, err := c.GetNetworkConfigProfiles(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkConfigProfilesResponse(rsp)
}

// GetSddcSpecValidationsWithResponse request returning *GetSddcSpecValidationsResponse
func (c *ClientWithResponses) GetSddcSpecValidationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSddcSpecValidationsResponse, error) {
	rsp, err := c.GetSddcSpecValidations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSddcSpecValidationsResponse(rsp)
}

// ValidateSddcSpecWithBodyWithResponse request with arbitrary body returning *ValidateSddcSpecResponse
func (c *ClientWithResponses) ValidateSddcSpecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateSddcSpecResponse, error) {
	rsp, err := c.ValidateSddcSpecWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateSddcSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateSddcSpecWithResponse(ctx context.Context, body ValidateSddcSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateSddcSpecResponse, error) {
	rsp, err := c.ValidateSddcSpec(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateSddcSpecResponse(rsp)
}

// GetLatestSddcSpecValidationWithResponse request returning *GetLatestSddcSpecValidationResponse
func (c *ClientWithResponses) GetLatestSddcSpecValidationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestSddcSpecValidationResponse, error) {
	rsp, err := c.GetLatestSddcSpecValidation(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestSddcSpecValidationResponse(rsp)
}

// GetSddcSpecValidationWithResponse request returning *GetSddcSpecValidationResponse
func (c *ClientWithResponses) GetSddcSpecValidationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcSpecValidationResponse, error) {
	rsp, err := c.GetSddcSpecValidation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSddcSpecValidationResponse(rsp)
}

// DiscoverVcenterWithBodyWithResponse request with arbitrary body returning *DiscoverVcenterResponse
func (c *ClientWithResponses) DiscoverVcenterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DiscoverVcenterResponse, error) {
	rsp, err := c.DiscoverVcenterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscoverVcenterResponse(rsp)
}

func (c *ClientWithResponses) DiscoverVcenterWithResponse(ctx context.Context, body DiscoverVcenterJSONRequestBody, reqEditors ...RequestEditorFn) (*DiscoverVcenterResponse, error) {
	rsp, err := c.DiscoverVcenter(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscoverVcenterResponse(rsp)
}

// DiscoverVcfOpsWithBodyWithResponse request with arbitrary body returning *DiscoverVcfOpsResponse
func (c *ClientWithResponses) DiscoverVcfOpsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DiscoverVcfOpsResponse, error) {
	rsp, err := c.DiscoverVcfOpsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscoverVcfOpsResponse(rsp)
}

func (c *ClientWithResponses) DiscoverVcfOpsWithResponse(ctx context.Context, body DiscoverVcfOpsJSONRequestBody, reqEditors ...RequestEditorFn) (*DiscoverVcfOpsResponse, error) {
	rsp, err := c.DiscoverVcfOps(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscoverVcfOpsResponse(rsp)
}

// GetSddcTaskByIDWithResponse request returning *GetSddcTaskByIDResponse
func (c *ClientWithResponses) GetSddcTaskByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcTaskByIDResponse, error) {
	rsp, err := c.GetSddcTaskByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSddcTaskByIDResponse(rsp)
}

// RetrySddcWithBodyWithResponse request with arbitrary body returning *RetrySddcResponse
func (c *ClientWithResponses) RetrySddcWithBodyWithResponse(ctx context.Context, id string, params *RetrySddcParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RetrySddcResponse, error) {
	rsp, err := c.RetrySddcWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrySddcResponse(rsp)
}

func (c *ClientWithResponses) RetrySddcWithResponse(ctx context.Context, id string, params *RetrySddcParams, body RetrySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*RetrySddcResponse, error) {
	rsp, err := c.RetrySddc(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrySddcResponse(rsp)
}

// GetSddcSpecByIDWithResponse request returning *GetSddcSpecByIDResponse
func (c *ClientWithResponses) GetSddcSpecByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcSpecByIDResponse, error) {
	rsp, err := c.GetSddcSpecByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSddcSpecByIDResponse(rsp)
}

// GetSystemConfigurationWithResponse request returning *GetSystemConfigurationResponse
func (c *ClientWithResponses) GetSystemConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemConfigurationResponse, error) {
	rsp, err := c.GetSystemConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemConfigurationResponse(rsp)
}

// UpdateSystemConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateSystemConfigurationResponse
func (c *ClientWithResponses) UpdateSystemConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSystemConfigurationResponse, error) {
	rsp, err := c.UpdateSystemConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSystemConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateSystemConfigurationWithResponse(ctx context.Context, body UpdateSystemConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSystemConfigurationResponse, error) {
	rsp, err := c.UpdateSystemConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSystemConfigurationResponse(rsp)
}

// GetApplianceInfoWithResponse request returning *GetApplianceInfoResponse
func (c *ClientWithResponses) GetApplianceInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplianceInfoResponse, error) {
	rsp, err := c.GetApplianceInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplianceInfoResponse(rsp)
}

// GetCeipStatusWithResponse request returning *GetCeipStatusResponse
func (c *ClientWithResponses) GetCeipStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCeipStatusResponse, error) {
	rsp, err := c.GetCeipStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCeipStatusResponse(rsp)
}

// SetCeipStatusWithBodyWithResponse request with arbitrary body returning *SetCeipStatusResponse
func (c *ClientWithResponses) SetCeipStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCeipStatusResponse, error) {
	rsp, err := c.SetCeipStatusWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCeipStatusResponse(rsp)
}

func (c *ClientWithResponses) SetCeipStatusWithResponse(ctx context.Context, body SetCeipStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCeipStatusResponse, error) {
	rsp, err := c.SetCeipStatus(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCeipStatusResponse(rsp)
}

// GetProxyConfigurationWithResponse request returning *GetProxyConfigurationResponse
func (c *ClientWithResponses) GetProxyConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProxyConfigurationResponse, error) {
	rsp, err := c.GetProxyConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProxyConfigurationResponse(rsp)
}

// UpdateProxyConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateProxyConfigurationResponse
func (c *ClientWithResponses) UpdateProxyConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProxyConfigurationResponse, error) {
	rsp, err := c.UpdateProxyConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProxyConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateProxyConfigurationWithResponse(ctx context.Context, body UpdateProxyConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProxyConfigurationResponse, error) {
	rsp, err := c.UpdateProxyConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProxyConfigurationResponse(rsp)
}

// DeleteDepotSettingsWithResponse request returning *DeleteDepotSettingsResponse
func (c *ClientWithResponses) DeleteDepotSettingsWithResponse(ctx context.Context, params *DeleteDepotSettingsParams, reqEditors ...RequestEditorFn) (*DeleteDepotSettingsResponse, error) {
	rsp, err := c.DeleteDepotSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDepotSettingsResponse(rsp)
}

// GetDepotSettingsWithResponse request returning *GetDepotSettingsResponse
func (c *ClientWithResponses) GetDepotSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDepotSettingsResponse, error) {
	rsp, err := c.GetDepotSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDepotSettingsResponse(rsp)
}

// UpdateDepotSettingsWithBodyWithResponse request with arbitrary body returning *UpdateDepotSettingsResponse
func (c *ClientWithResponses) UpdateDepotSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDepotSettingsResponse, error) {
	rsp, err := c.UpdateDepotSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDepotSettingsResponse(rsp)
}

func (c *ClientWithResponses) UpdateDepotSettingsWithResponse(ctx context.Context, body UpdateDepotSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDepotSettingsResponse, error) {
	rsp, err := c.UpdateDepotSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDepotSettingsResponse(rsp)
}

// GetDepotSyncInfoWithResponse request returning *GetDepotSyncInfoResponse
func (c *ClientWithResponses) GetDepotSyncInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDepotSyncInfoResponse, error) {
	rsp, err := c.GetDepotSyncInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDepotSyncInfoResponse(rsp)
}

// SyncDepotMetadataWithResponse request returning *SyncDepotMetadataResponse
func (c *ClientWithResponses) SyncDepotMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncDepotMetadataResponse, error) {
	rsp, err := c.SyncDepotMetadata(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncDepotMetadataResponse(rsp)
}

// GetSystemVcfManagementComponentsWithResponse request returning *GetSystemVcfManagementComponentsResponse
func (c *ClientWithResponses) GetSystemVcfManagementComponentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemVcfManagementComponentsResponse, error) {
	rsp, err := c.GetSystemVcfManagementComponents(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemVcfManagementComponentsResponse(rsp)
}

// GetTasksWithResponse request returning *GetTasksResponse
func (c *ClientWithResponses) GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error) {
	rsp, err := c.GetTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTasksResponse(rsp)
}

// CancelTaskWithResponse request returning *CancelTaskResponse
func (c *ClientWithResponses) CancelTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CancelTaskResponse, error) {
	rsp, err := c.CancelTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelTaskResponse(rsp)
}

// GetTaskWithResponse request returning *GetTaskResponse
func (c *ClientWithResponses) GetTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTaskResponse, error) {
	rsp, err := c.GetTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaskResponse(rsp)
}

// RetryTaskWithResponse request returning *RetryTaskResponse
func (c *ClientWithResponses) RetryTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetryTaskResponse, error) {
	rsp, err := c.RetryTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryTaskResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// RefreshAccessTokenWithBodyWithResponse request with arbitrary body returning *RefreshAccessTokenResponse
func (c *ClientWithResponses) RefreshAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error) {
	rsp, err := c.RefreshAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) RefreshAccessTokenWithResponse(ctx context.Context, body RefreshAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error) {
	rsp, err := c.RefreshAccessToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshAccessTokenResponse(rsp)
}

// InvalidateRefreshTokenWithBodyWithResponse request with arbitrary body returning *InvalidateRefreshTokenResponse
func (c *ClientWithResponses) InvalidateRefreshTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvalidateRefreshTokenResponse, error) {
	rsp, err := c.InvalidateRefreshTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvalidateRefreshTokenResponse(rsp)
}

func (c *ClientWithResponses) InvalidateRefreshTokenWithResponse(ctx context.Context, body InvalidateRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*InvalidateRefreshTokenResponse, error) {
	rsp, err := c.InvalidateRefreshToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvalidateRefreshTokenResponse(rsp)
}

// GetVcfServicesWithResponse request returning *GetVcfServicesResponse
func (c *ClientWithResponses) GetVcfServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVcfServicesResponse, error) {
	rsp, err := c.GetVcfServices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVcfServicesResponse(rsp)
}

// GetVcfServiceWithResponse request returning *GetVcfServiceResponse
func (c *ClientWithResponses) GetVcfServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVcfServiceResponse, error) {
	rsp, err := c.GetVcfService(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVcfServiceResponse(rsp)
}

// ParseGetBundlesResponse parses an HTTP response from a GetBundlesWithResponse call
func ParseGetBundlesResponse(rsp *http.Response) (*GetBundlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBundlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfBundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadBundleResponse parses an HTTP response from a UploadBundleWithResponse call
func ParseUploadBundleResponse(rsp *http.Response) (*UploadBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBundlesForSkipUpgradeResponse parses an HTTP response from a GetBundlesForSkipUpgradeWithResponse call
func ParseGetBundlesForSkipUpgradeResponse(rsp *http.Response) (*GetBundlesForSkipUpgradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBundlesForSkipUpgradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfBundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBundleDownloadStatusResponse parses an HTTP response from a GetBundleDownloadStatusWithResponse call
func ParseGetBundleDownloadStatusResponse(rsp *http.Response) (*GetBundleDownloadStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBundleDownloadStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfBundleDownloadStatusInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBundleResponse parses an HTTP response from a DeleteBundleWithResponse call
func ParseDeleteBundleResponse(rsp *http.Response) (*DeleteBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBundleResponse parses an HTTP response from a GetBundleWithResponse call
func ParseGetBundleResponse(rsp *http.Response) (*GetBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartBundleDownloadByIDResponse parses an HTTP response from a StartBundleDownloadByIDWithResponse call
func ParseStartBundleDownloadByIDResponse(rsp *http.Response) (*StartBundleDownloadByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartBundleDownloadByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReleasesResponse parses an HTTP response from a GetReleasesWithResponse call
func ParseGetReleasesResponse(rsp *http.Response) (*GetReleasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReleasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfRelease
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomPatchesBySkuResponse parses an HTTP response from a GetCustomPatchesBySkuWithResponse call
func ParseGetCustomPatchesBySkuResponse(rsp *http.Response) (*GetCustomPatchesBySkuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomPatchesBySkuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomPatches
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomPatchesResponse parses an HTTP response from a GetCustomPatchesWithResponse call
func ParseGetCustomPatchesResponse(rsp *http.Response) (*GetCustomPatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomPatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlexibleProductPatches
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFutureReleasesResponse parses an HTTP response from a GetFutureReleasesWithResponse call
func ParseGetFutureReleasesResponse(rsp *http.Response) (*GetFutureReleasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFutureReleasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfDomainFutureRelease
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemReleaseResponse parses an HTTP response from a GetSystemReleaseWithResponse call
func ParseGetSystemReleaseResponse(rsp *http.Response) (*GetSystemReleaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReleaseComponentsBySkuResponse parses an HTTP response from a GetReleaseComponentsBySkuWithResponse call
func ParseGetReleaseComponentsBySkuResponse(rsp *http.Response) (*GetReleaseComponentsBySkuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReleaseComponentsBySkuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfReleaseComponentDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTrustedCertificatesResponse parses an HTTP response from a GetTrustedCertificatesWithResponse call
func ParseGetTrustedCertificatesResponse(rsp *http.Response) (*GetTrustedCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTrustedCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTrustedCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddTrustedCertificateResponse parses an HTTP response from a AddTrustedCertificateWithResponse call
func ParseAddTrustedCertificateResponse(rsp *http.Response) (*AddTrustedCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTrustedCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTrustedCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTrustedCertificateResponse parses an HTTP response from a DeleteTrustedCertificateWithResponse call
func ParseDeleteTrustedCertificateResponse(rsp *http.Response) (*DeleteTrustedCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTrustedCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSddcTasksResponse parses an HTTP response from a GetSddcTasksWithResponse call
func ParseGetSddcTasksResponse(rsp *http.Response) (*GetSddcTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSddcTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfSddcTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeploySddcResponse parses an HTTP response from a DeploySddcWithResponse call
func ParseDeploySddcResponse(rsp *http.Response) (*DeploySddcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeploySddcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SddcTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInstallerTypeResponse parses an HTTP response from a GetInstallerTypeWithResponse call
func ParseGetInstallerTypeResponse(rsp *http.Response) (*GetInstallerTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstallerTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstallerSpec
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLatestSddcTaskResponse parses an HTTP response from a GetLatestSddcTaskWithResponse call
func ParseGetLatestSddcTaskResponse(rsp *http.Response) (*GetLatestSddcTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestSddcTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SddcTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNetworkConfigProfilesResponse parses an HTTP response from a GetNetworkConfigProfilesWithResponse call
func ParseGetNetworkConfigProfilesResponse(rsp *http.Response) (*GetNetworkConfigProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkConfigProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SddcNetworkConfigProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSddcSpecValidationsResponse parses an HTTP response from a GetSddcSpecValidationsWithResponse call
func ParseGetSddcSpecValidationsResponse(rsp *http.Response) (*GetSddcSpecValidationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSddcSpecValidationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfValidation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseValidateSddcSpecResponse parses an HTTP response from a ValidateSddcSpecWithResponse call
func ParseValidateSddcSpecResponse(rsp *http.Response) (*ValidateSddcSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateSddcSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLatestSddcSpecValidationResponse parses an HTTP response from a GetLatestSddcSpecValidationWithResponse call
func ParseGetLatestSddcSpecValidationResponse(rsp *http.Response) (*GetLatestSddcSpecValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestSddcSpecValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSddcSpecValidationResponse parses an HTTP response from a GetSddcSpecValidationWithResponse call
func ParseGetSddcSpecValidationResponse(rsp *http.Response) (*GetSddcSpecValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSddcSpecValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDiscoverVcenterResponse parses an HTTP response from a DiscoverVcenterWithResponse call
func ParseDiscoverVcenterResponse(rsp *http.Response) (*DiscoverVcenterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DiscoverVcenterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VcenterDiscoveryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDiscoverVcfOpsResponse parses an HTTP response from a DiscoverVcfOpsWithResponse call
func ParseDiscoverVcfOpsResponse(rsp *http.Response) (*DiscoverVcfOpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DiscoverVcfOpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VcfOperationsDiscoveryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSddcTaskByIDResponse parses an HTTP response from a GetSddcTaskByIDWithResponse call
func ParseGetSddcTaskByIDResponse(rsp *http.Response) (*GetSddcTaskByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSddcTaskByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SddcTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRetrySddcResponse parses an HTTP response from a RetrySddcWithResponse call
func ParseRetrySddcResponse(rsp *http.Response) (*RetrySddcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrySddcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SddcTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSddcSpecByIDResponse parses an HTTP response from a GetSddcSpecByIDWithResponse call
func ParseGetSddcSpecByIDResponse(rsp *http.Response) (*GetSddcSpecByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSddcSpecByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SddcSpec
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemConfigurationResponse parses an HTTP response from a GetSystemConfigurationWithResponse call
func ParseGetSystemConfigurationResponse(rsp *http.Response) (*GetSystemConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest System
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSystemConfigurationResponse parses an HTTP response from a UpdateSystemConfigurationWithResponse call
func ParseUpdateSystemConfigurationResponse(rsp *http.Response) (*UpdateSystemConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSystemConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetApplianceInfoResponse parses an HTTP response from a GetApplianceInfoWithResponse call
func ParseGetApplianceInfoResponse(rsp *http.Response) (*GetApplianceInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplianceInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplianceInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCeipStatusResponse parses an HTTP response from a GetCeipStatusWithResponse call
func ParseGetCeipStatusResponse(rsp *http.Response) (*GetCeipStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCeipStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ceip
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetCeipStatusResponse parses an HTTP response from a SetCeipStatusWithResponse call
func ParseSetCeipStatusResponse(rsp *http.Response) (*SetCeipStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCeipStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProxyConfigurationResponse parses an HTTP response from a GetProxyConfigurationWithResponse call
func ParseGetProxyConfigurationResponse(rsp *http.Response) (*GetProxyConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProxyConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateProxyConfigurationResponse parses an HTTP response from a UpdateProxyConfigurationWithResponse call
func ParseUpdateProxyConfigurationResponse(rsp *http.Response) (*UpdateProxyConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProxyConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteDepotSettingsResponse parses an HTTP response from a DeleteDepotSettingsWithResponse call
func ParseDeleteDepotSettingsResponse(rsp *http.Response) (*DeleteDepotSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDepotSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDepotSettingsResponse parses an HTTP response from a GetDepotSettingsWithResponse call
func ParseGetDepotSettingsResponse(rsp *http.Response) (*GetDepotSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDepotSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DepotSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDepotSettingsResponse parses an HTTP response from a UpdateDepotSettingsWithResponse call
func ParseUpdateDepotSettingsResponse(rsp *http.Response) (*UpdateDepotSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDepotSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DepotSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDepotSyncInfoResponse parses an HTTP response from a GetDepotSyncInfoWithResponse call
func ParseGetDepotSyncInfoResponse(rsp *http.Response) (*GetDepotSyncInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDepotSyncInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DepotSyncInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSyncDepotMetadataResponse parses an HTTP response from a SyncDepotMetadataWithResponse call
func ParseSyncDepotMetadataResponse(rsp *http.Response) (*SyncDepotMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncDepotMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DepotSyncInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemVcfManagementComponentsResponse parses an HTTP response from a GetSystemVcfManagementComponentsWithResponse call
func ParseGetSystemVcfManagementComponentsResponse(rsp *http.Response) (*GetSystemVcfManagementComponentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemVcfManagementComponentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VcfManagementComponents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTasksResponse parses an HTTP response from a GetTasksWithResponse call
func ParseGetTasksResponse(rsp *http.Response) (*GetTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCancelTaskResponse parses an HTTP response from a CancelTaskWithResponse call
func ParseCancelTaskResponse(rsp *http.Response) (*CancelTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTaskResponse parses an HTTP response from a GetTaskWithResponse call
func ParseGetTaskResponse(rsp *http.Response) (*GetTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRetryTaskResponse parses an HTTP response from a RetryTaskWithResponse call
func ParseRetryTaskResponse(rsp *http.Response) (*RetryTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetryTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TokenPair
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRefreshAccessTokenResponse parses an HTTP response from a RefreshAccessTokenWithResponse call
func ParseRefreshAccessTokenResponse(rsp *http.Response) (*RefreshAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInvalidateRefreshTokenResponse parses an HTTP response from a InvalidateRefreshTokenWithResponse call
func ParseInvalidateRefreshTokenResponse(rsp *http.Response) (*InvalidateRefreshTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InvalidateRefreshTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVcfServicesResponse parses an HTTP response from a GetVcfServicesWithResponse call
func ParseGetVcfServicesResponse(rsp *http.Response) (*GetVcfServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVcfServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfVcfService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVcfServiceResponse parses an HTTP response from a GetVcfServiceWithResponse call
func ParseGetVcfServiceResponse(rsp *http.Response) (*GetVcfServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVcfServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VcfService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
