// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Manifest LCM 2.0 Manifest model that represents the metadata of the VMware Cloud foundation components and releases that Lyfe cycle manager utilises.
//
// swagger:model Manifest
type Manifest struct {

	// Async patches used by async patch tool
	AsyncPatches map[string]List `json:"asyncPatches,omitempty"`

	// Creation time for the manifest e.g. 2020-06-08T02:20:15.844Z, in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	// Required: true
	CreationTime *string `json:"creationTime"`

	// Date of publish of the manifest e.g. 2020-06-08T02:20:15.844Z, in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	// Required: true
	PublishedDate *string `json:"publishedDate"`

	// Collection of bundles that are recalled and their replacements, if applicable
	RecalledBundles []*BundleRecall `json:"recalledBundles"`

	// Releases of VCF in the ascending order of product version
	// Required: true
	Releases []*Release `json:"releases"`

	// Manifest sequence number which signifies an update in manifest
	// Required: true
	SequenceNumber *int32 `json:"sequenceNumber"`

	// Manifest version supported by VCF
	// Required: true
	Version *int32 `json:"version"`

	// VVS product release Id to VCF version mapping
	VvsMappings map[string]MapOfstringAndVvsVersionAliases `json:"vvsMappings,omitempty"`
}

// Validate validates this manifest
func (m *Manifest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAsyncPatches(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublishedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecalledBundles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReleases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSequenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVvsMappings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Manifest) validateAsyncPatches(formats strfmt.Registry) error {
	if swag.IsZero(m.AsyncPatches) { // not required
		return nil
	}

	for k := range m.AsyncPatches {

		if err := m.AsyncPatches[k].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("asyncPatches" + "." + k)
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("asyncPatches" + "." + k)
			}
			return err
		}

	}

	return nil
}

func (m *Manifest) validateCreationTime(formats strfmt.Registry) error {

	if err := validate.Required("creationTime", "body", m.CreationTime); err != nil {
		return err
	}

	return nil
}

func (m *Manifest) validatePublishedDate(formats strfmt.Registry) error {

	if err := validate.Required("publishedDate", "body", m.PublishedDate); err != nil {
		return err
	}

	return nil
}

func (m *Manifest) validateRecalledBundles(formats strfmt.Registry) error {
	if swag.IsZero(m.RecalledBundles) { // not required
		return nil
	}

	for i := 0; i < len(m.RecalledBundles); i++ {
		if swag.IsZero(m.RecalledBundles[i]) { // not required
			continue
		}

		if m.RecalledBundles[i] != nil {
			if err := m.RecalledBundles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recalledBundles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("recalledBundles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Manifest) validateReleases(formats strfmt.Registry) error {

	if err := validate.Required("releases", "body", m.Releases); err != nil {
		return err
	}

	for i := 0; i < len(m.Releases); i++ {
		if swag.IsZero(m.Releases[i]) { // not required
			continue
		}

		if m.Releases[i] != nil {
			if err := m.Releases[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("releases" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("releases" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Manifest) validateSequenceNumber(formats strfmt.Registry) error {

	if err := validate.Required("sequenceNumber", "body", m.SequenceNumber); err != nil {
		return err
	}

	return nil
}

func (m *Manifest) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *Manifest) validateVvsMappings(formats strfmt.Registry) error {
	if swag.IsZero(m.VvsMappings) { // not required
		return nil
	}

	for k := range m.VvsMappings {

		if val, ok := m.VvsMappings[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this manifest based on the context it is used
func (m *Manifest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAsyncPatches(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecalledBundles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReleases(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVvsMappings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Manifest) contextValidateAsyncPatches(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.AsyncPatches {

		if err := m.AsyncPatches[k].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("asyncPatches" + "." + k)
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("asyncPatches" + "." + k)
			}
			return err
		}

	}

	return nil
}

func (m *Manifest) contextValidateRecalledBundles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RecalledBundles); i++ {

		if m.RecalledBundles[i] != nil {
			if err := m.RecalledBundles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recalledBundles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("recalledBundles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Manifest) contextValidateReleases(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Releases); i++ {

		if m.Releases[i] != nil {
			if err := m.Releases[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("releases" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("releases" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Manifest) contextValidateVvsMappings(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.VvsMappings {

		if val, ok := m.VvsMappings[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Manifest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Manifest) UnmarshalBinary(b []byte) error {
	var res Manifest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
