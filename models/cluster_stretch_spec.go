// Code generated by go-swagger; DO NOT EDIT.

// Copyright 2023 VMware, Inc.
// SPDX-License-Identifier: BSD-2-Clause

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterStretchSpec This spec contains the parameters required to convert a Standard vSAN cluster to a Stretched cluster
//
// swagger:model ClusterStretchSpec
type ClusterStretchSpec struct {

	// Enable stretch of the cluster without licensing the AZ2 hosts.
	DeployWithoutLicenseKeys bool `json:"deployWithoutLicenseKeys,omitempty"`

	// List of vSphere host information from the free pool to consume in the workload domain
	// Required: true
	HostSpecs []*HostSpec `json:"hostSpecs"`

	// This parameter is required for stretching the clusters that host Edge Cluster VMs. It is an acknowledgement, that the necessary network configurations are considered for the edge cluster to work with vSAN stretched cluster during a failover.
	IsEdgeClusterConfiguredForMultiAZ bool `json:"isEdgeClusterConfiguredForMultiAZ,omitempty"`

	// The network profile to be associated with Secondary AZ Hosts in NSX.
	NetworkProfiles []*StretchClusterNetworkProfile `json:"networkProfiles"`

	// NSX configuration to be associated with the Secondary AZ Hosts
	NsxStretchClusterSpec *NsxStretchClusterSpec `json:"nsxStretchClusterSpec,omitempty"`

	// Secondary AZ Overlay Vlan Id. This field is deprecated. The secondary AZ overlay vlan id should be mentioned in the uplinkProfile field instead
	SecondaryAzOverlayVlanID int32 `json:"secondaryAzOverlayVlanId,omitempty"`

	// vSAN Network Pool Specs
	VSANNetworkSpecs []*VSANNetworkSpec `json:"vsanNetworkSpecs"`

	// Witness host information
	// Required: true
	WitnessSpec *WitnessSpec `json:"witnessSpec"`

	// Witness traffic to be shared with vSAN traffic
	WitnessTrafficSharedWithVSANTraffic bool `json:"witnessTrafficSharedWithVsanTraffic,omitempty"`
}

// Validate validates this cluster stretch spec
func (m *ClusterStretchSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHostSpecs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkProfiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNsxStretchClusterSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVSANNetworkSpecs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWitnessSpec(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterStretchSpec) validateHostSpecs(formats strfmt.Registry) error {

	if err := validate.Required("hostSpecs", "body", m.HostSpecs); err != nil {
		return err
	}

	for i := 0; i < len(m.HostSpecs); i++ {
		if swag.IsZero(m.HostSpecs[i]) { // not required
			continue
		}

		if m.HostSpecs[i] != nil {
			if err := m.HostSpecs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hostSpecs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hostSpecs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterStretchSpec) validateNetworkProfiles(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkProfiles) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkProfiles); i++ {
		if swag.IsZero(m.NetworkProfiles[i]) { // not required
			continue
		}

		if m.NetworkProfiles[i] != nil {
			if err := m.NetworkProfiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("networkProfiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("networkProfiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterStretchSpec) validateNsxStretchClusterSpec(formats strfmt.Registry) error {
	if swag.IsZero(m.NsxStretchClusterSpec) { // not required
		return nil
	}

	if m.NsxStretchClusterSpec != nil {
		if err := m.NsxStretchClusterSpec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsxStretchClusterSpec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nsxStretchClusterSpec")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStretchSpec) validateVSANNetworkSpecs(formats strfmt.Registry) error {
	if swag.IsZero(m.VSANNetworkSpecs) { // not required
		return nil
	}

	for i := 0; i < len(m.VSANNetworkSpecs); i++ {
		if swag.IsZero(m.VSANNetworkSpecs[i]) { // not required
			continue
		}

		if m.VSANNetworkSpecs[i] != nil {
			if err := m.VSANNetworkSpecs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vsanNetworkSpecs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vsanNetworkSpecs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterStretchSpec) validateWitnessSpec(formats strfmt.Registry) error {

	if err := validate.Required("witnessSpec", "body", m.WitnessSpec); err != nil {
		return err
	}

	if m.WitnessSpec != nil {
		if err := m.WitnessSpec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("witnessSpec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("witnessSpec")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster stretch spec based on the context it is used
func (m *ClusterStretchSpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateHostSpecs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkProfiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNsxStretchClusterSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVSANNetworkSpecs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWitnessSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterStretchSpec) contextValidateHostSpecs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HostSpecs); i++ {

		if m.HostSpecs[i] != nil {

			if swag.IsZero(m.HostSpecs[i]) { // not required
				return nil
			}

			if err := m.HostSpecs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hostSpecs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hostSpecs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterStretchSpec) contextValidateNetworkProfiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkProfiles); i++ {

		if m.NetworkProfiles[i] != nil {

			if swag.IsZero(m.NetworkProfiles[i]) { // not required
				return nil
			}

			if err := m.NetworkProfiles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("networkProfiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("networkProfiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterStretchSpec) contextValidateNsxStretchClusterSpec(ctx context.Context, formats strfmt.Registry) error {

	if m.NsxStretchClusterSpec != nil {

		if swag.IsZero(m.NsxStretchClusterSpec) { // not required
			return nil
		}

		if err := m.NsxStretchClusterSpec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsxStretchClusterSpec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nsxStretchClusterSpec")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStretchSpec) contextValidateVSANNetworkSpecs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VSANNetworkSpecs); i++ {

		if m.VSANNetworkSpecs[i] != nil {

			if swag.IsZero(m.VSANNetworkSpecs[i]) { // not required
				return nil
			}

			if err := m.VSANNetworkSpecs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vsanNetworkSpecs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vsanNetworkSpecs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterStretchSpec) contextValidateWitnessSpec(ctx context.Context, formats strfmt.Registry) error {

	if m.WitnessSpec != nil {

		if err := m.WitnessSpec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("witnessSpec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("witnessSpec")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterStretchSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterStretchSpec) UnmarshalBinary(b []byte) error {
	var res ClusterStretchSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
