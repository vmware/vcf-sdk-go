// © Broadcom. All Rights Reserved.
// The term “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.
// SPDX-License-Identifier: BSD-2-Clause
//
// Package vcf provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package vcf

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AssessmentOutputStatus.
const (
	COMPLETEDWITHFAILURE AssessmentOutputStatus = "COMPLETED_WITH_FAILURE"
	COMPLETEDWITHSUCCESS AssessmentOutputStatus = "COMPLETED_WITH_SUCCESS"
	INPROGRESS           AssessmentOutputStatus = "IN_PROGRESS"
)

// Defines values for ClassificationSource.
const (
	CLASSIFIER ClassificationSource = "CLASSIFIER"
	INHERITED  ClassificationSource = "INHERITED"
	USERINPUT  ClassificationSource = "USER_INPUT"
)

// Defines values for DataMetricUnit.
const (
	DataMetricUnitB  DataMetricUnit = "B"
	DataMetricUnitGB DataMetricUnit = "GB"
	DataMetricUnitKB DataMetricUnit = "KB"
	DataMetricUnitMB DataMetricUnit = "MB"
	DataMetricUnitPB DataMetricUnit = "PB"
	DataMetricUnitTB DataMetricUnit = "TB"
)

// Defines values for DomainInfoDomainType.
const (
	DomainInfoDomainTypeMANAGEMENT DomainInfoDomainType = "MANAGEMENT"
	DomainInfoDomainTypeVI         DomainInfoDomainType = "VI"
)

// Defines values for DomainIntegrationStatus.
const (
	DISABLED DomainIntegrationStatus = "DISABLED"
	ENABLED  DomainIntegrationStatus = "ENABLED"
)

// Defines values for FrequencyMetricUnit.
const (
	GHz FrequencyMetricUnit = "GHz"
	Hz  FrequencyMetricUnit = "Hz"
	KHz FrequencyMetricUnit = "KHz"
	MHz FrequencyMetricUnit = "MHz"
	THz FrequencyMetricUnit = "THz"
)

// Defines values for NsxtOidcSpecOidcType.
const (
	NsxtOidcSpecOidcTypeVcenter NsxtOidcSpecOidcType = "vcenter"
)

// Defines values for PhysicalNicUnit.
const (
	PhysicalNicUnitGB PhysicalNicUnit = "GB"
	PhysicalNicUnitKB PhysicalNicUnit = "KB"
	PhysicalNicUnitMB PhysicalNicUnit = "MB"
	PhysicalNicUnitPB PhysicalNicUnit = "PB"
	PhysicalNicUnitTB PhysicalNicUnit = "TB"
)

// Defines values for ProxyConfigurationTransferProtocol.
const (
	HTTP  ProxyConfigurationTransferProtocol = "HTTP"
	HTTPS ProxyConfigurationTransferProtocol = "HTTPS"
)

// Defines values for ResourceDomainInfoDomainType.
const (
	ResourceDomainInfoDomainTypeMANAGEMENT ResourceDomainInfoDomainType = "MANAGEMENT"
	ResourceDomainInfoDomainTypeVI         ResourceDomainInfoDomainType = "VI"
)

// Defines values for ResourcePoolSpecCpuSharesLevel.
const (
	ResourcePoolSpecCpuSharesLevelCustom ResourcePoolSpecCpuSharesLevel = "custom"
	ResourcePoolSpecCpuSharesLevelHigh   ResourcePoolSpecCpuSharesLevel = "high"
	ResourcePoolSpecCpuSharesLevelLow    ResourcePoolSpecCpuSharesLevel = "low"
	ResourcePoolSpecCpuSharesLevelNormal ResourcePoolSpecCpuSharesLevel = "normal"
)

// Defines values for ResourcePoolSpecMemorySharesLevel.
const (
	ResourcePoolSpecMemorySharesLevelCustom ResourcePoolSpecMemorySharesLevel = "custom"
	ResourcePoolSpecMemorySharesLevelHigh   ResourcePoolSpecMemorySharesLevel = "high"
	ResourcePoolSpecMemorySharesLevelLow    ResourcePoolSpecMemorySharesLevel = "low"
	ResourcePoolSpecMemorySharesLevelNormal ResourcePoolSpecMemorySharesLevel = "normal"
)

// Defines values for ResourcePoolSpecType.
const (
	ResourcePoolSpecTypeCompute    ResourcePoolSpecType = "compute"
	ResourcePoolSpecTypeManagement ResourcePoolSpecType = "management"
	ResourcePoolSpecTypeNetwork    ResourcePoolSpecType = "network"
)

// Defines values for ResourceWarningCreationSpecResourceType.
const (
	CLUSTER ResourceWarningCreationSpecResourceType = "CLUSTER"
	DOMAIN  ResourceWarningCreationSpecResourceType = "DOMAIN"
	HOST    ResourceWarningCreationSpecResourceType = "HOST"
)

// Defines values for ResourceWarningCreationSpecSeverity.
const (
	MAJOR ResourceWarningCreationSpecSeverity = "MAJOR"
	MINOR ResourceWarningCreationSpecSeverity = "MINOR"
)

// Defines values for ResourceWarningCreationSpecWarningType.
const (
	CONFIGURATION   ResourceWarningCreationSpecWarningType = "CONFIGURATION"
	OTHER           ResourceWarningCreationSpecWarningType = "OTHER"
	SKIPPEDRESOURCE ResourceWarningCreationSpecWarningType = "SKIPPED_RESOURCE"
	VALIDATION      ResourceWarningCreationSpecWarningType = "VALIDATION"
)

// Defines values for VrealizeProductNodeType.
const (
	VrealizeProductNodeTypeDATA            VrealizeProductNodeType = "DATA"
	VrealizeProductNodeTypeMASTER          VrealizeProductNodeType = "MASTER"
	VrealizeProductNodeTypeREMOTECOLLECTOR VrealizeProductNodeType = "REMOTE_COLLECTOR"
	VrealizeProductNodeTypeREPLICA         VrealizeProductNodeType = "REPLICA"
	VrealizeProductNodeTypeWORKER          VrealizeProductNodeType = "WORKER"
)

// Defines values for VropsNodeType.
const (
	VropsNodeTypeDATA            VropsNodeType = "DATA"
	VropsNodeTypeMASTER          VropsNodeType = "MASTER"
	VropsNodeTypeREMOTECOLLECTOR VropsNodeType = "REMOTE_COLLECTOR"
	VropsNodeTypeREPLICA         VropsNodeType = "REPLICA"
	VropsNodeTypeWORKER          VropsNodeType = "WORKER"
)

// Defines values for VxRailContextDatatype.
const (
	BOOLEAN VxRailContextDatatype = "BOOLEAN"
	INTEGER VxRailContextDatatype = "INTEGER"
	STRING  VxRailContextDatatype = "STRING"
)

// Defines values for GetSddcManagerUpgradablesParamsApplicabilityStatus.
const (
	APPLICABLENOTAPPLICABLE GetSddcManagerUpgradablesParamsApplicabilityStatus = "APPLICABLE, NOT_APPLICABLE"
)

// Defines values for ValidateBringupSpecParamsName.
const (
	CLOUDBUILDERREADYVALIDATION   ValidateBringupSpecParamsName = "CLOUDBUILDER_READY_VALIDATION"
	ESXIHOSTREADINESSVALIDATION   ValidateBringupSpecParamsName = "ESXI_HOST_READINESS_VALIDATION"
	HOSTIPDNSVALIDATION           ValidateBringupSpecParamsName = "HOST_IP_DNS_VALIDATION"
	JSONSPECVALIDATION            ValidateBringupSpecParamsName = "JSON_SPEC_VALIDATION"
	LICENSEKEYVALIDATION          ValidateBringupSpecParamsName = "LICENSE_KEY_VALIDATION"
	MANAGEMENTNETWORKSVALIDATION  ValidateBringupSpecParamsName = "MANAGEMENT_NETWORKS_VALIDATION"
	NETWORKCONFIGVALIDATION       ValidateBringupSpecParamsName = "NETWORK_CONFIG_VALIDATION"
	NETWORKCONNECTIVITYVALIDATION ValidateBringupSpecParamsName = "NETWORK_CONNECTIVITY_VALIDATION"
	NETWORKIPPOOLSVALIDATION      ValidateBringupSpecParamsName = "NETWORK_IP_POOLS_VALIDATION"
	NSXTNETWORKSVALIDATION        ValidateBringupSpecParamsName = "NSXT_NETWORKS_VALIDATION"
	PASSWORDSVALIDATION           ValidateBringupSpecParamsName = "PASSWORDS_VALIDATION"
	SECUREPLATFORMAUDIT           ValidateBringupSpecParamsName = "SECURE_PLATFORM_AUDIT"
	TIMESYNCVALIDATION            ValidateBringupSpecParamsName = "TIME_SYNC_VALIDATION"
	VALIDATEPROXYDETAIL           ValidateBringupSpecParamsName = "VALIDATE_PROXY_DETAIL"
	VSANAVAILABILITYVALIDATION    ValidateBringupSpecParamsName = "VSAN_AVAILABILITY_VALIDATION"
)

// Defines values for ExportBringupDetailReportParamsFormat.
const (
	Csv ExportBringupDetailReportParamsFormat = "csv"
	Pdf ExportBringupDetailReportParamsFormat = "pdf"
)

// Defines values for StartBringupSpecConversionParamsDesign.
const (
	EMS    StartBringupSpecConversionParamsDesign = "EMS"
	VXRAIL StartBringupSpecConversionParamsDesign = "VXRAIL"
)

// ALBControllerNodeFormFactor NSX ALB Cluster node form factor
type ALBControllerNodeFormFactor struct {
	// Disk Disk size of the NSX Advanced Load Balancer controller node in Bytes
	Disk *int64 `json:"disk,omitempty"`

	// Memory Memory size of the NSX Advanced Load Balancer controller node in Bytes
	Memory *int64 `json:"memory,omitempty"`

	// Type NSX Advanced Load Balancer controller node form factor type
	Type *string `json:"type,omitempty"`

	// Vcpu Number of virtual cpus on the NSX Advanced Load Balancer controller node
	Vcpu *int64 `json:"vcpu,omitempty"`
}

// ALBControllerNodeFormFactors NSX ALB Cluster node form factors
type ALBControllerNodeFormFactors struct {
	// FormFactors List of NSX ALB Cluster node form factor
	FormFactors *[]ALBControllerNodeFormFactor `json:"formFactors,omitempty"`
}

// AddOnInfo AddOn contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
type AddOnInfo struct {
	// DisplayName Add On display name
	DisplayName *string `json:"displayName,omitempty"`

	// DisplayVersion Add On display version
	DisplayVersion *string `json:"displayVersion,omitempty"`

	// Name Component name
	Name *string `json:"name,omitempty"`

	// Vendor vendor
	Vendor *string `json:"vendor,omitempty"`

	// Version Add on software version
	Version *string `json:"version,omitempty"`
}

// AdvancedOptions Advanced Options used to add Cluster
type AdvancedOptions struct {
	// EvcMode EVC mode for new cluster, if needed
	EvcMode *string `json:"evcMode,omitempty"`

	// HighAvailability This specification contains high availability settings
	HighAvailability *HighAvailability `json:"highAvailability,omitempty"`
}

// AliasSpec Alias Specification
type AliasSpec struct {
	// Aliases Aliases for bundle component type and version.
	Aliases []string `json:"aliases"`

	// ForceUpdate Flag for force update version alias configuration.
	ForceUpdate *bool `json:"forceUpdate,omitempty"`
}

// AlternativeApplicableSddcManagerVersion Version of Target SDDC Manager
type AlternativeApplicableSddcManagerVersion struct {
	// Version Version of target SDDC manger
	Version *string `json:"version,omitempty"`
}

// Applicability Represents all applicability requirements for a Configuration Drift
type Applicability struct {
	// SkuType SKU Type for this Configuration Drift
	SkuType string `json:"skuType"`

	// VersionApplicability List of product version related applicability
	VersionApplicability []VersionApplicability `json:"versionApplicability"`
}

// Artifact Patch rest model that is located in the Product Version Catalog, these models are consumed by LCM's Flex BOM workflows.
type Artifact struct {
	// Bundles List of bundle artifacts for corresponding product patch version
	Bundles *[]BundleInfo `json:"bundles,omitempty"`
}

// AssessmentMetadata Metadata about the assessment run that is triggered and passed to the result
type AssessmentMetadata struct {
	// Resources Resources of target state definitions that is going to be used for assessment
	Resources *[]AssessmentResource `json:"resources,omitempty"`

	// TargetVersion Version of target state definitions that is going to be used for assessment
	TargetVersion *string `json:"targetVersion,omitempty"`
}

// AssessmentOutput Result from the baseliner assessment run (execution result, presented artifacts or ask for extra info).
type AssessmentOutput struct {
	// CompletionTimestamp Assessment task completion timestamp
	CompletionTimestamp *string `json:"completionTimestamp,omitempty"`

	// DiscoveryProgress Information about the assessment run progress.
	DiscoveryProgress *DiscoveryProgress `json:"discoveryProgress,omitempty"`

	// InputValidationErrors Set of the input validation errors
	InputValidationErrors *[]Error `json:"inputValidationErrors,omitempty"`

	// PhysicalPresentedData Entity model representing the physical data output of the assessment workflow.
	PhysicalPresentedData *EntityRest `json:"physicalPresentedData,omitempty"`

	// PresentedArtifactsMap Extra assessment artefacts produced by the workflow
	PresentedArtifactsMap *map[string]map[string]interface{} `json:"presentedArtifactsMap,omitempty"`

	// RelatedAssessmentId Related assessment run id
	RelatedAssessmentId *string `json:"relatedAssessmentId,omitempty"`

	// Status Execution status
	Status *AssessmentOutputStatus `json:"status,omitempty"`

	// Timestamp Assessment task creation timestamp
	Timestamp *string `json:"timestamp,omitempty"`

	// ValidationResult Error response containing a minor error code, a localized error message, a localized remediation message and optionally a reference token to correlate the error with the logs
	ValidationResult *Error `json:"validationResult,omitempty"`
}

// AssessmentOutputStatus Execution status
type AssessmentOutputStatus string

// AssessmentPartialRetryInput Spec for assessment retry
type AssessmentPartialRetryInput struct {
	// ErrorIds List of error ids to retry
	ErrorIds []string `json:"errorIds"`

	// Options Options map (toggles) to control assessment flow. Available toggles 'discoveryCaching' - if set to true the assessment engine will use the Domain data (if present) from previous discovery execution. If any of the passed in the request domains is not present in the cache the Discovery is triggered for ALL domains (even the ones existing in the cache).
	Options *map[string]string `json:"options,omitempty"`
}

// AssessmentResource Resource information for the assessment
type AssessmentResource struct {
	// DomainId Domain ID of the resource
	DomainId *string `json:"domainId,omitempty"`

	// Id ID of the resource
	Id *string `json:"id,omitempty"`

	// Name Name of the resource
	Name *string `json:"name,omitempty"`

	// TargetVersion Target upgrade version for the resource
	TargetVersion *string `json:"targetVersion,omitempty"`

	// Type Type of the resource
	Type *string `json:"type,omitempty"`
}

// AssessmentTaskInfo A summary of an assessment execution
type AssessmentTaskInfo struct {
	// CompletionTimestamp Timestamp corresponding to the time when the assessment was finished
	CompletionTimestamp *int64 `json:"completionTimestamp,omitempty"`

	// DomainInputs The domains that have been assessed in the run associated to the given result
	DomainInputs *[]DomainInfo `json:"domainInputs,omitempty"`

	// Id The id of the assessment run
	Id *string `json:"id,omitempty"`

	// Metadata Metadata about the assessment run that is triggered and passed to the result
	Metadata *AssessmentMetadata `json:"metadata,omitempty"`

	// State The related task state of the run associated to the given result
	State *string `json:"state,omitempty"`

	// Timestamp Timestamp corresponding to the time when the assessment was initiated
	Timestamp *int64 `json:"timestamp,omitempty"`
}

// AssociatedTask Task association for a resource warning. Indicates in which task the resource warning occurred
type AssociatedTask struct {
	// SubTaskId ID of the subtask where the warning for the resource occurred
	SubTaskId *string `json:"subTaskId,omitempty"`

	// TaskId ID of the task where the warning for the resource occurred
	TaskId string `json:"taskId"`
}

// AsyncPatch Async patch bundle rest model that is located in the 2.0 manifest, these models are consumed by LCM's async patch workflows to determine if customer can download patch in list and apply.
type AsyncPatch struct {
	// InputSpecUrl Input spec URL of the async patch bundle
	InputSpecUrl *string `json:"inputSpecUrl,omitempty"`

	// ProductVersion Product version of the async patch bundle
	ProductVersion *string `json:"productVersion,omitempty"`

	// SddcHotPatchInfo Sddc hot patch info for each sddc manager service (lcm, dm, om, commonsvc)
	SddcHotPatchInfo *map[string][]SddcHotPatchInfo `json:"sddcHotPatchInfo,omitempty"`

	// SupportedSkuTypes Supported SKU types of the async patch bundle
	SupportedSkuTypes *[]string `json:"supportedSkuTypes,omitempty"`
}

// AuthenticatedResource Represents the credential resource in the system
type AuthenticatedResource struct {
	// DomainName Domain name (deprecated)
	// Deprecated:
	DomainName *string `json:"domainName,omitempty"`

	// DomainNames Domain names
	DomainNames []string `json:"domainNames"`

	// ResourceId Resource ID
	ResourceId string `json:"resourceId"`

	// ResourceIp Resource IP address
	ResourceIp string `json:"resourceIp"`

	// ResourceName Resource name
	ResourceName string `json:"resourceName"`

	// ResourceType Resource type
	ResourceType string `json:"resourceType"`
}

// AutoRotateCredentialPolicy Represents a auto-rotate policy for a credential
type AutoRotateCredentialPolicy struct {
	// FrequencyInDays Frequency in days
	FrequencyInDays *int32 `json:"frequencyInDays,omitempty"`

	// NextSchedule The timestamp at which auto-rotate for credential will run
	NextSchedule *string `json:"nextSchedule,omitempty"`
}

// AutoRotateCredentialPolicyInputSpec Represents password auto rotate config details
type AutoRotateCredentialPolicyInputSpec struct {
	// EnableAutoRotatePolicy  Enable or disable  auto rotate policy
	EnableAutoRotatePolicy bool `json:"enableAutoRotatePolicy"`

	// FrequencyInDays Frequency in days
	FrequencyInDays *int32 `json:"frequencyInDays,omitempty"`
}

// Avn Defines an Application virtual Network (AVN) and its attributes
type Avn struct {
	// DomainName AVN search domain
	DomainName *string `json:"domainName,omitempty"`

	// Gateway Gateway of the AVN subnet
	Gateway string `json:"gateway"`

	// Id The UUID of the AVN
	Id *string `json:"id,omitempty"`

	// Mtu MTU for the AVN
	Mtu int32 `json:"mtu"`

	// Name User provided name of the AVN
	Name string `json:"name"`

	// PortGroupName Port group name identifying the AVN on the distributed switch
	PortGroupName *string `json:"portGroupName,omitempty"`

	// RegionType The region type of AVN; X_REGION or REGION_A
	RegionType string `json:"regionType"`

	// RouterName Name of Tier-1 Gateway AVN is connected to
	RouterName *string `json:"routerName,omitempty"`

	// Subnet Subnet assigned to the AVN
	Subnet string `json:"subnet"`

	// SubnetMask Subnet mask for the network assigned to the AVN
	SubnetMask string `json:"subnetMask"`

	// VlanId VLAN ID for the VLAN backed AVN
	VlanId *int32 `json:"vlanId,omitempty"`
}

// AvnsCreationSpec Provide the spec to create the AVNs
type AvnsCreationSpec struct {
	// Avns The list of AVNs to be created
	Avns []Avn `json:"avns"`

	// EdgeClusterId The UUID of the Edge Cluster to associate VLAN AVNs
	EdgeClusterId *string `json:"edgeClusterId,omitempty"`
}

// BackupConfiguration Backup configuration used to configure backup of NSX and SDDC manager
type BackupConfiguration struct {
	// BackupLocations List of backup locations
	BackupLocations *[]BackupLocation `json:"backupLocations,omitempty"`

	// BackupSchedules List of backup schedules
	BackupSchedules *[]BackupSchedule `json:"backupSchedules,omitempty"`

	// Encryption Restore Specification
	Encryption *Encryption `json:"encryption,omitempty"`

	// IsConfigured Backup configuration status of both FTP server and passphrase
	IsConfigured *bool `json:"isConfigured,omitempty"`
}

// BackupConfigurationSpec Backup configuration Specification
type BackupConfigurationSpec struct {
	// BackupLocations List of backup locations
	BackupLocations *[]BackupLocation `json:"backupLocations,omitempty"`

	// BackupSchedules List of backup schedules
	BackupSchedules *[]BackupSchedule `json:"backupSchedules,omitempty"`

	// Encryption Restore Specification
	Encryption *Encryption `json:"encryption,omitempty"`
}

// BackupLocation Backup location to backup VCF resources
type BackupLocation struct {
	// DirectoryPath Full directory path to save the backup files
	DirectoryPath string `json:"directoryPath"`

	// Password Backup server password
	Password *string `json:"password,omitempty"`

	// Port Port number for the backup server to connect
	Port int32 `json:"port"`

	// Protocol Protocol to be used for transferring files
	Protocol string `json:"protocol"`

	// Server IP address or FQDN  of the backup server
	Server string `json:"server"`

	// SshFingerprint SSH fingerprint of the backup server
	SshFingerprint *string `json:"sshFingerprint,omitempty"`

	// Username Backup server username
	Username string `json:"username"`
}

// BackupResource Element specification to trigger backup
type BackupResource struct {
	// ResourceType Resource type
	ResourceType string `json:"resourceType"`
}

// BackupRetentionPolicy Backup retention policy for SDDC Manager comprising three attributes. Backup files are deleted if they do not satisfy any of the three attributes.
type BackupRetentionPolicy struct {
	// NumberOfDaysOfDailyBackups This attribute controls the number of daily backup files to retain, measured in days. Range 0 to 30 days. The system will filter the existing backup files, and retain one for every day for the specified number of days, counting back from the most recent backup.
	NumberOfDaysOfDailyBackups *int32 `json:"numberOfDaysOfDailyBackups,omitempty"`

	// NumberOfDaysOfHourlyBackups This attribute controls the number of hourly backup files to retain, measured in days. Range 0 to 14 days. The system will filter the existing backup files, and retain one for every hour for the specified number of days, counting back from the most recent backup.
	NumberOfDaysOfHourlyBackups *int32 `json:"numberOfDaysOfHourlyBackups,omitempty"`

	// NumberOfMostRecentBackups This attribute controls the number of recent backup files to retain. Range 1 to 600 backup files.
	NumberOfMostRecentBackups int32 `json:"numberOfMostRecentBackups"`
}

// BackupSchedule Backup schedule configuration
type BackupSchedule struct {
	// DaysOfWeek List of days of the week to schedule backup
	DaysOfWeek *[]string `json:"daysOfWeek,omitempty"`

	// Frequency Backup frequency
	Frequency string `json:"frequency"`

	// HourOfDay Hour of the day to schedule backup
	HourOfDay *int32 `json:"hourOfDay,omitempty"`

	// MinuteOfHour Minute of the hour to schedule backup
	MinuteOfHour *int32 `json:"minuteOfHour,omitempty"`

	// ResourceType Resource type to configure backup schedule
	ResourceType string `json:"resourceType"`

	// RetentionPolicy Backup retention policy for SDDC Manager comprising three attributes. Backup files are deleted if they do not satisfy any of the three attributes.
	RetentionPolicy *BackupRetentionPolicy `json:"retentionPolicy,omitempty"`

	// TakeBackupOnStateChange Enable/disable backups on state change. If enabled, SDDC Manager will take a backup after the successful completion of an operation that changes its state. This mode requires that scheduled backups be enabled.
	TakeBackupOnStateChange *bool `json:"takeBackupOnStateChange,omitempty"`

	// TakeScheduledBackups Enable/disable scheduled backups
	TakeScheduledBackups *bool `json:"takeScheduledBackups,omitempty"`
}

// BackupSpec Backup Specification
type BackupSpec struct {
	// Elements List of elements to be backed up
	Elements []BackupResource `json:"elements"`
}

// BackupTask defines model for BackupTask.
type BackupTask struct {
	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// Id Backup task ID
	Id *string `json:"id,omitempty"`

	// Name Backup task name
	Name *string `json:"name,omitempty"`

	// Resources Backup resources, to get the backup details
	Resources *[]Resource `json:"resources,omitempty"`

	// Status Backup task status
	Status *string `json:"status,omitempty"`
}

// BaseAlias Base Alias representation
type BaseAlias struct {
	// Aliases List of Alias versions
	Aliases *[]string `json:"aliases,omitempty"`

	// Version Base version
	Version *string `json:"version,omitempty"`
}

// BaseCredential Represents credentials of a resource in the system
type BaseCredential struct {
	// AccountType Account type
	AccountType *string `json:"accountType,omitempty"`

	// CredentialType Credential type
	CredentialType *string `json:"credentialType,omitempty"`

	// Password Password
	Password *string `json:"password,omitempty"`

	// Username Username
	Username string `json:"username"`
}

// BaseImageDetails BaseImage contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
type BaseImageDetails struct {
	// DisplayName BaseImage display name
	DisplayName *string `json:"displayName,omitempty"`

	// DisplayVersion BaseImage display version
	DisplayVersion *string `json:"displayVersion,omitempty"`

	// QuickPatchCompatibleVersions ESX Quick Patch compatible source image versions
	QuickPatchCompatibleVersions *[]Version `json:"quickPatchCompatibleVersions,omitempty"`

	// ReleaseDate BaseImage release date
	// Deprecated:
	ReleaseDate *string `json:"releaseDate,omitempty"`

	// ReleaseTimestamp Timestamp of BaseImage release
	ReleaseTimestamp *string `json:"releaseTimestamp,omitempty"`
}

// BaseImageInfo BaseImage contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
type BaseImageInfo struct {
	// Details BaseImage contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
	Details *BaseImageDetails `json:"details,omitempty"`

	// Version BaseImage Version
	Version *string `json:"version,omitempty"`
}

// BasicAuthDetails Basic auth details
type BasicAuthDetails struct {
	// Status Basic auth status
	Status string `json:"status"`

	// Username Basic auth username
	Username *string `json:"username,omitempty"`
}

// BgpPeerSpec This specification contains configuration inputs required for BGP configuration for an uplink
type BgpPeerSpec struct {
	// Asn ASN of Peer
	Asn int64 `json:"asn"`

	// Ip BGP Peer IP
	Ip string `json:"ip"`

	// Password BGP Peer Password
	Password string `json:"password"`
}

// Bundle Bundle contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
type Bundle struct {
	// ApplicabilityOrder Bundle Applicability Order
	ApplicabilityOrder *int32 `json:"applicabilityOrder,omitempty"`

	// ApplicabilityStatus Bundle Applicability Status
	ApplicabilityStatus *string `json:"applicabilityStatus,omitempty"`

	// Components Bundle Components
	Components *[]BundleComponent `json:"components,omitempty"`

	// Description Bundle Description
	Description *string `json:"description,omitempty"`

	// DownloadStatus Bundle Download Status
	DownloadStatus *string `json:"downloadStatus,omitempty"`

	// Id Bundle ID
	Id *string `json:"id,omitempty"`

	// IsCompliant Is compliant with the current VCF version
	IsCompliant *bool `json:"isCompliant,omitempty"`

	// IsCumulative Is Bundle Cumulative
	IsCumulative *bool `json:"isCumulative,omitempty"`

	// IsPartiallyUpgraded Is Bundle partially upgraded
	IsPartiallyUpgraded *bool `json:"isPartiallyUpgraded,omitempty"`

	// ReleasedDate Bundle Release Date
	ReleasedDate *string `json:"releasedDate,omitempty"`

	// Severity Bundle Severity
	Severity *string `json:"severity,omitempty"`

	// SizeMB Bundle Size in MB
	SizeMB *float64 `json:"sizeMB,omitempty"`

	// Type Bundle Type
	Type *string `json:"type,omitempty"`

	// Vendor Bundle Vendor
	Vendor *string `json:"vendor,omitempty"`

	// Version Bundle Version
	Version *string `json:"version,omitempty"`
}

// BundleComponent Bundle Software Component
type BundleComponent struct {
	// Description Bundle Component Description
	Description *string `json:"description,omitempty"`

	// FromVersion Bundle Component's from/source version before Upgrade
	FromVersion *string `json:"fromVersion,omitempty"`

	// Id ID of Resource/Software Component
	Id *string `json:"id,omitempty"`

	// ImageType Bundle Component Image Type
	ImageType *string `json:"imageType,omitempty"`

	// ReleasedDate Bundle Component Release Date
	ReleasedDate *string `json:"releasedDate,omitempty"`

	// ToVersion Bundle Component's to/target version after Upgrade
	ToVersion *string `json:"toVersion,omitempty"`

	// Type Type of Resource/Software Component
	Type *string `json:"type,omitempty"`

	// Vendor Bundle Component Vendor
	Vendor *string `json:"vendor,omitempty"`
}

// BundleDownloadSpec Bundle Download Specification. This specification gets used in the Bundle Download API
type BundleDownloadSpec struct {
	// CancelNow Flag for cancelling the download. If true, scheduledTimestamp/downloadNow is ignored
	CancelNow *bool `json:"cancelNow,omitempty"`

	// DownloadNow Flag for enabling Download Now. If true, scheduledTimestamp is ignored
	DownloadNow *bool `json:"downloadNow,omitempty"`

	// ScheduledTimestamp Bundle Download Scheduled Time
	ScheduledTimestamp *string `json:"scheduledTimestamp,omitempty"`
}

// BundleInfo Patch/Install bundle info to be used as part of ProductVersionCatalog patches.
type BundleInfo struct {
	// Id Bundle id
	Id *string `json:"id,omitempty"`

	// Name Patch/Install bundle name
	Name *string `json:"name,omitempty"`

	// Type Type of bundle. ex) PATCH, INSTALL
	Type *string `json:"type,omitempty"`
}

// BundleRecall Bundle Recall model for collection of bundles that are recalled with their replacements if applicable.
type BundleRecall struct {
	// RecalledBundleIds List of Bundle IDs that are recalled
	RecalledBundleIds *[]string `json:"recalledBundleIds,omitempty"`

	// ReplacementBundleIds List of Bundle IDs that act as replacement
	ReplacementBundleIds *[]string `json:"replacementBundleIds,omitempty"`

	// ReplacementBundleStatus Status of bundle replacement.
	ReplacementBundleStatus *string `json:"replacementBundleStatus,omitempty"`
}

// BundleUpdateSpec Bundle Update Specification
type BundleUpdateSpec struct {
	// BundleDownloadSpec Bundle Download Specification. This specification gets used in the Bundle Download API
	BundleDownloadSpec *BundleDownloadSpec `json:"bundleDownloadSpec,omitempty"`

	// CompatibilitySetsFilePath [Deprecated] Path to the software compatibility sets file
	// Deprecated:
	CompatibilitySetsFilePath *string `json:"compatibilitySetsFilePath,omitempty"`
}

// BundleUploadSpec Bundle Upload Specification
type BundleUploadSpec struct {
	// BundleFilePath Bundle Upload File Path
	BundleFilePath string `json:"bundleFilePath"`

	// CompatibilitySetsFilePath [Deprecated] Path to the software compatibility sets file
	// Deprecated:
	CompatibilitySetsFilePath *string `json:"compatibilitySetsFilePath,omitempty"`

	// ManifestFilePath Bundle Upload Manifest File Path
	ManifestFilePath string `json:"manifestFilePath"`

	// PartnerExtensionSpec Specification for partner extensions. This specification is used in the Bundle Upload API
	PartnerExtensionSpec *PartnerExtensionSpec `json:"partnerExtensionSpec,omitempty"`

	// SignatureFilePath Bundle Upload Signature File Path
	SignatureFilePath *string `json:"signatureFilePath,omitempty"`
}

// Capacity Represents a usage and capacity information of a Resource
type Capacity struct {
	// Cpu Represents CPU information
	Cpu *CpuInfo `json:"cpu,omitempty"`

	// Memory Represents a memory metric with used and total for a resource
	Memory *MemoryInfo `json:"memory,omitempty"`

	// Storage Represents a storage metric with used and total for a resource
	Storage *StorageInfo `json:"storage,omitempty"`
}

// Ceip Defines VCF CEIP status and instance id
type Ceip struct {
	// InstanceId Instance Id of VCF
	InstanceId *string `json:"instanceId,omitempty"`

	// Status CEIP status
	Status string `json:"status"`
}

// CeipUpdateSpec Specification for CEIP state change
type CeipUpdateSpec struct {
	// Status User provided CEIP operation
	Status string `json:"status"`
}

// Certificate Represents certificate and its attributes
type Certificate struct {
	// CaChain Certificate chain ordered from intermediate to root certificates
	CaChain *[]Certificate `json:"caChain,omitempty"`

	// Domain Domain of the resource certificate
	Domain *string `json:"domain,omitempty"`

	// ExpirationStatus Certificate expiry status
	ExpirationStatus *string `json:"expirationStatus,omitempty"`

	// GetCertificateError Error if certificate cannot be fetched
	GetCertificateError *string `json:"getCertificateError,omitempty"`

	// IsInstalled Whether the certificate is installed or not
	IsInstalled *bool `json:"isInstalled,omitempty"`

	// IssuedBy The certificate authority that issued the certificate
	IssuedBy *string `json:"issuedBy,omitempty"`

	// IssuedTo To whom the certificate is issued
	IssuedTo *string `json:"issuedTo,omitempty"`

	// KeySize The key size of the certificate
	KeySize *string `json:"keySize,omitempty"`

	// NotAfter The timestamp after which certificate is not valid
	NotAfter *string `json:"notAfter,omitempty"`

	// NotBefore The timestamp before which certificate is not valid
	NotBefore *string `json:"notBefore,omitempty"`

	// NumberOfDaysToExpire Number of days left for the certificate to expire
	NumberOfDaysToExpire *int32 `json:"numberOfDaysToExpire,omitempty"`

	// OperationMessage The last operation status message
	OperationMessage *string `json:"operationMessage,omitempty"`

	// OperationStatus The last operation status
	OperationStatus *string `json:"operationStatus,omitempty"`

	// OperationType The last operation type
	OperationType *string `json:"operationType,omitempty"`

	// PemEncoded The PEM encoded certificate content
	PemEncoded *string `json:"pemEncoded,omitempty"`

	// PublicKey The public key of the certificate
	PublicKey *string `json:"publicKey,omitempty"`

	// PublicKeyAlgorithm The public key algorithm of the certificate
	PublicKeyAlgorithm *string `json:"publicKeyAlgorithm,omitempty"`

	// ResourceName Resource fqdn
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Resource type
	ResourceType string `json:"resourceType"`

	// SerialNumber The serial number of the certificate
	SerialNumber *string `json:"serialNumber,omitempty"`

	// SignatureAlgorithm Algorithm used to sign the certificate
	SignatureAlgorithm *string `json:"signatureAlgorithm,omitempty"`

	// Subject Complete distinguished name to which the certificate is issued
	Subject *string `json:"subject,omitempty"`

	// SubjectAlternativeName The alternative names to which the certificate is issued
	SubjectAlternativeName *[]string `json:"subjectAlternativeName,omitempty"`

	// Thumbprint Thumbprint generated using certificate content
	Thumbprint *string `json:"thumbprint,omitempty"`

	// ThumbprintAlgorithm Algorithm used to generate thumbprint
	ThumbprintAlgorithm *string `json:"thumbprintAlgorithm,omitempty"`

	// Version The X.509 version of the certificate
	Version *string `json:"version,omitempty"`
}

// CertificateAuthority The Certificate Authority (CA) details
type CertificateAuthority struct {
	// CommonName OpenSSL CA domain name
	CommonName *string `json:"commonName,omitempty"`

	// Country ISO 3166 country code where company is legally registered
	Country *string `json:"country,omitempty"`

	// Id CA type. Only supports Microsoft and OpenSSL CAs
	Id *string `json:"id,omitempty"`

	// Locality The city or locality where company is legally registered
	Locality *string `json:"locality,omitempty"`

	// Organization The name under which company is legally registered
	Organization *string `json:"organization,omitempty"`

	// OrganizationUnit Organization with which the certificate is associated
	OrganizationUnit *string `json:"organizationUnit,omitempty"`

	// ServerUrl Microsoft CA server url
	ServerUrl *string `json:"serverUrl,omitempty"`

	// State The full name of the state where company is legally registered
	State *string `json:"state,omitempty"`

	// TemplateName Microsoft CA server template name
	TemplateName *string `json:"templateName,omitempty"`

	// Username Microsoft CA server username
	Username *string `json:"username,omitempty"`
}

// CertificateAuthorityCreationSpec This specification contains Certificate Authority (CA) creation details. Either openSSLCertificateAuthoritySpec or microsoftCertificateAuthoritySpec should be specified.
type CertificateAuthorityCreationSpec struct {
	// MicrosoftCertificateAuthoritySpec This specification contains Microsoft CA configuration details
	MicrosoftCertificateAuthoritySpec *MicrosoftCertificateAuthoritySpec `json:"microsoftCertificateAuthoritySpec,omitempty"`

	// OpenSSLCertificateAuthoritySpec This specification contains OpenSSL CA configuration details
	OpenSSLCertificateAuthoritySpec *OpenSSLCertificateAuthoritySpec `json:"openSSLCertificateAuthoritySpec,omitempty"`
}

// CertificateOperationSpec This specification contains certificate operation request details
type CertificateOperationSpec struct {
	// OperationType The Certificates operation type
	OperationType string `json:"operationType"`

	// Resources Resource(s) in a domain
	Resources *[]Resource `json:"resources,omitempty"`
}

// CertificateValidation The Certificate Validation details.
type CertificateValidation struct {
	// EndTimestamp End Timestamp
	EndTimestamp *string `json:"endTimestamp,omitempty"`

	// ResourceFqdn Resource FQDN
	ResourceFqdn string `json:"resourceFqdn"`

	// ResourceId Resource ID
	ResourceId string `json:"resourceId"`

	// StartTimestamp Start Timestamp
	StartTimestamp string `json:"startTimestamp"`

	// ValidationMessage Validation Message
	ValidationMessage *string `json:"validationMessage,omitempty"`

	// ValidationStatus Validation Status
	ValidationStatus string `json:"validationStatus"`
}

// CertificateValidationTask The Certificate Validation Task.
type CertificateValidationTask struct {
	// Completed Validation Task Completed
	Completed bool `json:"completed"`

	// EndTimestamp Validation Task End Time
	EndTimestamp *string `json:"endTimestamp,omitempty"`

	// StartTimestamp Validation Task Start Time
	StartTimestamp *string `json:"startTimestamp,omitempty"`

	// ValidationId Validation ID
	ValidationId string `json:"validationId"`

	// Validations Resource Certificate Validations
	Validations []CertificateValidation `json:"validations"`
}

// CertificatesGenerationSpec This specification contains certificates generation request details
type CertificatesGenerationSpec struct {
	// CaType CA type. Only supports Microsoft and OpenSSL CAs
	CaType string `json:"caType"`

	// Resources Resource(s) in a domain
	Resources *[]Resource `json:"resources,omitempty"`
}

// CheckSetCandidates Represents a check-set id that can be used to run checks for a resource
type CheckSetCandidates struct {
	// CheckSetId Id of the check-set
	CheckSetId *string `json:"checkSetId,omitempty"`

	// CheckSetName Name of the check-set
	CheckSetName *string `json:"checkSetName,omitempty"`

	// CheckSetType Type of the check-set
	CheckSetType *string `json:"checkSetType,omitempty"`
}

// CheckSetQueryDomainResources Spec representing a set of resources in a domain to query check-sets for
type CheckSetQueryDomainResources struct {
	// DomainId Id of the domain to search for resources in
	DomainId string `json:"domainId"`

	// Resources Resources in the domain to generate check-set candidates for
	Resources *[]CheckSetQueryResource `json:"resources,omitempty"`
}

// CheckSetQueryInput Check-set query input
type CheckSetQueryInput struct {
	// CheckSetType Type of the check sets to query for. e.g. 'UPGRADE'
	CheckSetType string `json:"checkSetType"`

	// Domains List of domain resources to query check-sets of the given type for
	Domains []CheckSetQueryDomainResources `json:"domains"`
}

// CheckSetQueryResource Resource input to query check-sets for
type CheckSetQueryResource struct {
	// ResourceId UUID of the resource, if used adds additional filtering
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceTargetVersion Upgrade target version for the resources
	ResourceTargetVersion *string `json:"resourceTargetVersion,omitempty"`

	// ResourceType Type of the resource
	ResourceType string `json:"resourceType"`
}

// CheckSetQueryResourceResult Represents a result of a check-set query call for a given resource
type CheckSetQueryResourceResult struct {
	// CheckSets Check set candidates to select from
	CheckSets *[]CheckSetCandidates `json:"checkSets,omitempty"`

	// Domain Information about the domain the resource belongs to
	Domain       *ResourceDomainInfo                `json:"domain,omitempty"`
	ExtraContext *map[string]map[string]interface{} `json:"extraContext,omitempty"`

	// ResourceId Id of the resource
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceName Name of the resource
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Type of the resource
	ResourceType *string `json:"resourceType,omitempty"`

	// ResourceVersion Current version of the resource
	ResourceVersion *string `json:"resourceVersion,omitempty"`
}

// CheckSetQueryResult Represents a result of a check-set query call
type CheckSetQueryResult struct {
	// QueryId Id of the query, to be provided in the selection API
	QueryId string `json:"queryId"`

	// Resources Resources with check-sets result from the query
	Resources []CheckSetQueryResourceResult `json:"resources"`
}

// CheckSetResourceSelection Represents a selection of check-set candidates over a given resource
type CheckSetResourceSelection struct {
	// CheckSets Information about the selected check-set candidates
	CheckSets []SelectedCheckSetCandidate `json:"checkSets"`

	// Domain Information about the assessed domain
	Domain *DomainInfo `json:"domain,omitempty"`

	// ResourceId Id of the resource
	ResourceId string `json:"resourceId"`

	// ResourceName Name of the resource
	ResourceName string `json:"resourceName"`

	// ResourceType Type of the resource
	ResourceType string `json:"resourceType"`
}

// CheckSetRunInput Check-set selection for resources
type CheckSetRunInput struct {
	// QueryId Id of the query the selection was based on
	QueryId string `json:"queryId"`

	// Resources Information about the resource and its selection
	Resources []CheckSetResourceSelection `json:"resources"`
}

// Classification Describes the source of the classification,classification can be acquired by a classifier, user input or inherited from a parent entity.
type Classification struct {
	// Description Description of the classification
	Description *string `json:"description,omitempty"`

	// Source Source of the classification
	Source *ClassificationSource `json:"source,omitempty"`

	// Type Type of the classification, e.g. domainType
	Type *string `json:"type,omitempty"`

	// Value Value of the classification, e.g. MGMT_DOMAIN
	Value *string `json:"value,omitempty"`
}

// ClassificationSource Source of the classification
type ClassificationSource string

// Cluster Cluster representation
type Cluster struct {
	// Capacity Represents a usage and capacity information of a Resource
	Capacity *Capacity `json:"capacity,omitempty"`

	// Domain Represents a domain reference
	Domain *DomainReference `json:"domain,omitempty"`

	// FailuresToTolerate Number of ESXi host failures to tolerate in the vSAN cluster. Applicable only for clusters with vSAN datastore
	FailuresToTolerate *int32 `json:"failuresToTolerate,omitempty"`

	// HciMeshData vSAN remote datastore mount related data for Cluster
	HciMeshData *HciMeshData `json:"hciMeshData,omitempty"`

	// Hosts List of hosts associated with the cluster
	Hosts *[]HostReference `json:"hosts,omitempty"`

	// Id ID of the cluster
	Id *string `json:"id,omitempty"`

	// IsDefault Status of the cluster if default or not
	IsDefault *bool `json:"isDefault,omitempty"`

	// IsImageBased Is cluster managed by vSphere Lifecycle Manager Images - true if managed, false if managed by vSphere Lifecycle Manager Baselines
	IsImageBased *bool `json:"isImageBased,omitempty"`

	// IsStretched Status of the cluster if Stretched or not
	IsStretched *bool `json:"isStretched,omitempty"`

	// ManagedObjectReferenceId Managed Object Reference Id of this cluster in vCenter
	ManagedObjectReferenceId *string `json:"managedObjectReferenceId,omitempty"`

	// Name Name of the cluster
	Name *string `json:"name,omitempty"`

	// PrimaryDatastoreName Name of the primary datastore
	PrimaryDatastoreName *string `json:"primaryDatastoreName,omitempty"`

	// PrimaryDatastoreType Storage type of the primary datastore
	PrimaryDatastoreType *string `json:"primaryDatastoreType,omitempty"`

	// Status Status of the cluster
	Status *string `json:"status,omitempty"`

	// Tags Deprecated, this list will always be returned empty
	// Deprecated:
	Tags *[]Tag `json:"tags,omitempty"`

	// Vcenter Represents a vCenter reference
	Vcenter *VcenterReference `json:"vcenter,omitempty"`

	// VdsSpecs Distributed switches to added to the cluster
	VdsSpecs *[]VdsSpec `json:"vdsSpecs,omitempty"`

	// VsanClusterMode vSAN cluster mode
	VsanClusterMode *string `json:"vsanClusterMode,omitempty"`
}

// ClusterCompactionSpec This specification contains the parameters required to remove one or more vSphere hosts from existing cluster in a workload domain
type ClusterCompactionSpec struct {
	// Force Force removal of vSphere host
	Force *bool `json:"force,omitempty"`

	// ForceByPassingSafeMinSize Remove dead hosts from cluster, bypassing validations. Forced removal may result in permanent data loss. Review recovery plan with VMware Support before using.
	ForceByPassingSafeMinSize *bool `json:"forceByPassingSafeMinSize,omitempty"`

	// Hosts List of vSphere hosts to be removed
	Hosts []HostReference `json:"hosts"`
}

// ClusterCreationSpec Cluster creation specification
type ClusterCreationSpec struct {
	// ComputeSpec This specification contains the parameters required to add each cluster to a workload domain
	ComputeSpec ComputeSpec `json:"computeSpec"`

	// DeployWithoutLicenseKeys Flag that indicates if the deployment should happen without license keys.
	DeployWithoutLicenseKeys *bool `json:"deployWithoutLicenseKeys,omitempty"`

	// DomainId ID of the domain to which the clusters will be added
	DomainId string `json:"domainId"`
}

// ClusterCriterion Represents a criterion for querying the cluster
type ClusterCriterion struct {
	// Arguments Arguments required for a particular criterion
	Arguments *map[string]string `json:"arguments,omitempty"`

	// Description Description of the criterion
	Description *string `json:"description,omitempty"`

	// Name Name of the criterion
	Name *string `json:"name,omitempty"`
}

// ClusterExpansionNetworkProfile This specification contains the host switch configurations for the NSX transport node.
type ClusterExpansionNetworkProfile struct {
	// Description The network profile description
	Description *string `json:"description,omitempty"`

	// Name The network profile name
	Name string `json:"name"`

	// NsxtHostSwitchConfigs The list of NSX host switch configurations
	NsxtHostSwitchConfigs []NsxtHostSwitchConfig `json:"nsxtHostSwitchConfigs"`
}

// ClusterExpansionNetworkSpec This specification contains cluster network configuration.
type ClusterExpansionNetworkSpec struct {
	// NetworkProfiles The list of network profiles
	NetworkProfiles []ClusterExpansionNetworkProfile `json:"networkProfiles"`

	// NsxClusterSpec This specification contains NSX configuration for cluster expansion
	NsxClusterSpec ClusterExpansionNsxSpec `json:"nsxClusterSpec"`
}

// ClusterExpansionNsxSpec This specification contains NSX configuration for cluster expansion
type ClusterExpansionNsxSpec struct {
	// IpAddressPoolsSpec The IP address pools specification
	IpAddressPoolsSpec *[]IpAddressPoolSpec `json:"ipAddressPoolsSpec,omitempty"`

	// UplinkProfiles The list of uplink profile specifications.
	UplinkProfiles []UplinkProfile `json:"uplinkProfiles"`
}

// ClusterExpansionSpec This specification contains the parameters required to add one or more vSphere hosts to an existing cluster in a workload domain
type ClusterExpansionSpec struct {
	// DeployWithoutLicenseKeys Flag that indicates if the deployment should happen without license keys.
	DeployWithoutLicenseKeys *bool `json:"deployWithoutLicenseKeys,omitempty"`

	// ForceHostAdditionInPresenceofDeadHosts Use to add host to a cluster with dead host(s). Bypasses validation of disconnected hosts and vSAN cluster health. Review recovery plan VMware Support before using. False if omitted. This property is deprecated and it has no effect when using it.
	// Deprecated:
	ForceHostAdditionInPresenceofDeadHosts *bool `json:"forceHostAdditionInPresenceofDeadHosts,omitempty"`

	// HostSpecs List of vSphere host information from the free pool to consume in the workload domain
	HostSpecs []HostSpec `json:"hostSpecs"`

	// InterRackExpansion Is inter-rack cluster(true for L2 non-uniform and L3 : At least one of management, uplink, Edge and host TEP networks is different for hosts of the cluster, false for L2 uniform :  All hosts in cluster have identical management, uplink, Edge and host TEP networks) expansion. Required, only if Cluster contains NSX Edge Cluster
	InterRackExpansion *bool `json:"interRackExpansion,omitempty"`

	// NetworkSpec This specification contains cluster network configuration.
	NetworkSpec *ClusterExpansionNetworkSpec `json:"networkSpec,omitempty"`

	// SkipThumbprintValidation Skip thumbprint validation for ESXi hosts during add host operation.
	// This property is deprecated.
	// Deprecated:
	SkipThumbprintValidation *bool `json:"skipThumbprintValidation,omitempty"`

	// VsanNetworkSpecs vSAN Network Pool Spec
	VsanNetworkSpecs *[]VSANNetworkSpec `json:"vsanNetworkSpecs,omitempty"`

	// WitnessSpec Spec contains the Witness host parameters that are part of each stretched cluster
	WitnessSpec *WitnessSpec `json:"witnessSpec,omitempty"`

	// WitnessTrafficSharedWithVsanTraffic Witness traffic to be shared with vSAN traffic
	WitnessTrafficSharedWithVsanTraffic *bool `json:"witnessTrafficSharedWithVsanTraffic,omitempty"`
}

// ClusterNetworkConfiguration Represents the cluster network configuration.
type ClusterNetworkConfiguration struct {
	// HostDetails List of host details
	HostDetails *[]HostDetail `json:"hostDetails,omitempty"`

	// IpAddressPools List of IP address pool configuration
	IpAddressPools *[]NsxtIpAddressPool `json:"ipAddressPools,omitempty"`

	// NetworkProfiles List of network profiles
	NetworkProfiles *[]NetworkProfileConfiguration `json:"networkProfiles,omitempty"`

	// NonVcfCreatedVds List of VDS names that is not present in VCF inventory
	NonVcfCreatedVds *[]string `json:"nonVcfCreatedVds,omitempty"`

	// UplinkProfiles List of uplink profile configuration
	UplinkProfiles *[]UplinkProfile `json:"uplinkProfiles,omitempty"`

	// VdsConfigurations List of VDS configuration
	VdsConfigurations *[]VdsConfiguration `json:"vdsConfigurations,omitempty"`
}

// ClusterNetworkConfigurationCriterion Represents criterion for querying the network properties of a cluster.
type ClusterNetworkConfigurationCriterion struct {
	// Arguments Arguments required for a particular criterion
	Arguments *map[string]string `json:"arguments,omitempty"`

	// Description Description of the criterion
	Description *string `json:"description,omitempty"`

	// Name Name of the criterion
	Name *string `json:"name,omitempty"`
}

// ClusterNetworkConfigurationQueryResponse Represents the cluster network configuration query response.
type ClusterNetworkConfigurationQueryResponse struct {
	// QueryInfo Represents the query info.
	QueryInfo *QueryInfo `json:"queryInfo,omitempty"`

	// Result Represents a page of elements of a single type
	Result *PageClusterNetworkConfiguration `json:"result,omitempty"`
}

// ClusterQueryResponse Represents a cluster query response.
type ClusterQueryResponse struct {
	// QueryInfo Represents the query info.
	QueryInfo *QueryInfo `json:"queryInfo,omitempty"`

	// Result Represents a page of elements of a single type
	Result *PageCluster `json:"result,omitempty"`
}

// ClusterReference Represents a reference to the cluster
type ClusterReference struct {
	// Id ID of the cluster
	Id string `json:"id"`

	// Name Name of the cluster
	Name *string `json:"name,omitempty"`
}

// ClusterSpec This specification contains the parameters required to add a cluster to a workload domain
type ClusterSpec struct {
	// AdvancedOptions Advanced Options used to add Cluster
	AdvancedOptions *AdvancedOptions `json:"advancedOptions,omitempty"`

	// ClusterImageId ID of the Cluster Image to be used with the Cluster
	ClusterImageId *string `json:"clusterImageId,omitempty"`

	// DatastoreSpec This specification contains cluster storage configuration
	DatastoreSpec DatastoreSpec `json:"datastoreSpec"`

	// HostSpecs List of vSphere host information from the free pool to consume in the workload domain
	HostSpecs []HostSpec `json:"hostSpecs"`

	// Name Name of the new cluster that will be added to the specified workload domain
	Name *string `json:"name,omitempty"`

	// NetworkSpec This specification contains cluster's network configuration.
	NetworkSpec NetworkSpec `json:"networkSpec"`

	// SkipThumbprintValidation Skip thumbprint validation for ESXi and VxRail Manager during add cluster/host operation.
	// This property is deprecated.
	// Deprecated:
	SkipThumbprintValidation *bool `json:"skipThumbprintValidation,omitempty"`

	// VxRailDetails Contains the VxRail Manager details
	VxRailDetails *VxRailDetails `json:"vxRailDetails,omitempty"`
}

// ClusterStretchNetworkSpec This specification contains network configuration for stretiching a vSan Cluster
type ClusterStretchNetworkSpec struct {
	// NetworkProfiles The network profile to be associated with Secondary AZ Hosts in NSX.
	NetworkProfiles []StretchClusterNetworkProfile `json:"networkProfiles"`

	// NsxClusterSpec This specification contains NSX configuration for Secondary AZ Hosts
	NsxClusterSpec NsxStretchClusterSpec `json:"nsxClusterSpec"`
}

// ClusterStretchSpec This spec contains the parameters required to convert a Standard vSAN cluster to a Stretched cluster
type ClusterStretchSpec struct {
	// DeployWithoutLicenseKeys Flag that indicates if the deployment should happen without license keys.
	DeployWithoutLicenseKeys *bool `json:"deployWithoutLicenseKeys,omitempty"`

	// HostSpecs List of vSphere host information from the free pool to consume in the workload domain
	HostSpecs []HostSpec `json:"hostSpecs"`

	// IsEdgeClusterConfiguredForMultiAZ Edge cluster configured for multi AZ
	IsEdgeClusterConfiguredForMultiAZ *bool `json:"isEdgeClusterConfiguredForMultiAZ,omitempty"`

	// NetworkSpec This specification contains network configuration for stretiching a vSan Cluster
	NetworkSpec *ClusterStretchNetworkSpec `json:"networkSpec,omitempty"`

	// SecondaryAzOverlayVlanId Secondary AZ Overlay Vlan Id. This field is deprecated. The secondary AZ overlay vlan id should be mentioned in the uplinkProfile field instead
	// Deprecated:
	SecondaryAzOverlayVlanId *int32 `json:"secondaryAzOverlayVlanId,omitempty"`

	// VsanNetworkSpecs vSAN Network Pool Specs
	VsanNetworkSpecs *[]VSANNetworkSpec `json:"vsanNetworkSpecs,omitempty"`

	// WitnessSpec Spec contains the Witness host parameters that are part of each stretched cluster
	WitnessSpec WitnessSpec `json:"witnessSpec"`

	// WitnessTrafficSharedWithVsanTraffic Witness traffic to be shared with vSAN traffic
	WitnessTrafficSharedWithVsanTraffic *bool `json:"witnessTrafficSharedWithVsanTraffic,omitempty"`
}

// ClusterUnstretchSpec This spec contains the parameters required to convert a Stretched cluster to a Standard vSAN cluster
type ClusterUnstretchSpec = map[string]interface{}

// ClusterUpdateSpec Cluster Update Data
type ClusterUpdateSpec struct {
	// ClusterCompactionSpec This specification contains the parameters required to remove one or more vSphere hosts from existing cluster in a workload domain
	ClusterCompactionSpec *ClusterCompactionSpec `json:"clusterCompactionSpec,omitempty"`

	// ClusterExpansionSpec This specification contains the parameters required to add one or more vSphere hosts to an existing cluster in a workload domain
	ClusterExpansionSpec *ClusterExpansionSpec `json:"clusterExpansionSpec,omitempty"`

	// ClusterStretchSpec This spec contains the parameters required to convert a Standard vSAN cluster to a Stretched cluster
	ClusterStretchSpec *ClusterStretchSpec `json:"clusterStretchSpec,omitempty"`

	// ClusterUnstretchSpec This spec contains the parameters required to convert a Stretched cluster to a Standard vSAN cluster
	ClusterUnstretchSpec *ClusterUnstretchSpec `json:"clusterUnstretchSpec,omitempty"`

	// MarkForDeletion Prepare the cluster for deletion
	MarkForDeletion *bool `json:"markForDeletion,omitempty"`

	// Name Cluster Name
	Name *string `json:"name,omitempty"`

	// PrepareForStretch Prepare the cluster for stretch
	PrepareForStretch *bool `json:"prepareForStretch,omitempty"`
}

// CompatibilityMatrix Model for metadata of compatibility matrix
type CompatibilityMatrix struct {
	// CompatibilityMatrixContent Content of the compatibility matrix
	CompatibilityMatrixContent string `json:"compatibilityMatrixContent"`

	// CompatibilityMatrixMetadata Model for metadata of compatibility matrix
	CompatibilityMatrixMetadata CompatibilityMatrixMetadata `json:"compatibilityMatrixMetadata"`

	// CompatibilityMatrixSource Source type of the compatibility matrix content
	CompatibilityMatrixSource string `json:"compatibilityMatrixSource"`
}

// CompatibilityMatrixMetadata Model for metadata of compatibility matrix
type CompatibilityMatrixMetadata struct {
	// ErrorMessage Error message for the compatibility matrix content
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// IsMissing existence of the compatibility matrix content
	IsMissing *bool `json:"isMissing,omitempty"`

	// IsStale staleness of the compatibility matrix content
	IsStale *bool `json:"isStale,omitempty"`

	// LastModifiedDate Last modified date of the compatibility matrix content
	LastModifiedDate *int64 `json:"lastModifiedDate,omitempty"`

	// Message Info message for the compatibility matrix content
	Message *string `json:"message,omitempty"`

	// WarningMessage Warning message for the compatibility matrix content
	WarningMessage *string `json:"warningMessage,omitempty"`
}

// ComplianceAudit Represents a compliance audit report
type ComplianceAudit struct {
	// AuditItems Compliance audit items
	AuditItems *[]ComplianceAuditItem `json:"auditItems,omitempty"`

	// CompletionTimestamp The timestamp at which audit was completed
	CompletionTimestamp *string `json:"completionTimestamp,omitempty"`

	// CompliantStatus Compliant status of overall task
	CompliantStatus *string `json:"compliantStatus,omitempty"`

	// ConfigurationEvaluationStatus Configuration evaluation status
	ConfigurationEvaluationStatus *string `json:"configurationEvaluationStatus,omitempty"`

	// ConfigurationEvaluationStatusDetails Details about evaluation status
	ConfigurationEvaluationStatusDetails *string `json:"configurationEvaluationStatusDetails,omitempty"`

	// CreationTimestamp The timestamp at which audit was initiated
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// DomainId Domain id
	DomainId *string `json:"domainId,omitempty"`

	// Id Compliance audit id
	Id *string `json:"id,omitempty"`

	// NumberOfAuditItems Number of audit items
	NumberOfAuditItems *int32 `json:"numberOfAuditItems,omitempty"`

	// NumberOfNonCompliantConfigurations Number of non compliant configurations
	NumberOfNonCompliantConfigurations *int32 `json:"numberOfNonCompliantConfigurations,omitempty"`

	// NumberOfSkippedConfigurations Number of configurations skipped
	NumberOfSkippedConfigurations *int32 `json:"numberOfSkippedConfigurations,omitempty"`

	// StandardType Compliance standard type
	StandardType *string `json:"standardType,omitempty"`

	// StandardVersion Compliance standard version
	StandardVersion *string `json:"standardVersion,omitempty"`

	// TotalConfigurationsEvaluated Total number of configurations evaluated
	TotalConfigurationsEvaluated *int32 `json:"totalConfigurationsEvaluated,omitempty"`
}

// ComplianceAuditItem Represents a compliance audit item
type ComplianceAuditItem struct {
	// ActualValue Actual value for compliance configuration
	ActualValue *string `json:"actualValue,omitempty"`

	// CitationReference Compliance configuration citation in compliance standard documentation
	CitationReference *string `json:"citationReference,omitempty"`

	// ComplianceAuditStatus Compliance audit task status
	ComplianceAuditStatus *string `json:"complianceAuditStatus,omitempty"`

	// ComplianceStatus Compliance status of the configuration
	ComplianceStatus *string `json:"complianceStatus,omitempty"`

	// ConfigurationId Compliance configuration id
	ConfigurationId *string `json:"configurationId,omitempty"`

	// ConfigurationTitle Compliance configuration title
	ConfigurationTitle *string `json:"configurationTitle,omitempty"`

	// ErrorMessage Error message if compliance audit fails
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// IsConfigurationRecommendedByStandard Whether the configuration is recommended by compliance standard
	IsConfigurationRecommendedByStandard *bool `json:"isConfigurationRecommendedByStandard,omitempty"`

	// RecommendedValue Recommended value for compliance configuration
	RecommendedValue *string `json:"recommendedValue,omitempty"`

	// RemediationStep Remediation steps if the configuration is non compliant
	RemediationStep *string `json:"remediationStep,omitempty"`

	// ResourceName Compliance resource name
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Compliance resource type
	ResourceType *string `json:"resourceType,omitempty"`

	// ResourceVersion Compliance resource version
	ResourceVersion *string `json:"resourceVersion,omitempty"`
}

// ComplianceAuditSpec This specification contains compliance to be audited
type ComplianceAuditSpec struct {
	// ComplianceResourcesConfigurationSpec Compliance resource and configuration spec
	ComplianceResourcesConfigurationSpec []ComplianceResourcesConfigurationSpec `json:"complianceResourcesConfigurationSpec"`

	// StandardType Compliance standard type
	StandardType string `json:"standardType"`

	// StandardVersion Compliance standard version
	StandardVersion string `json:"standardVersion"`
}

// ComplianceConfiguration Represents a compliance configuration
type ComplianceConfiguration struct {
	// ComplianceResourceStandardConfigurationDetails Compliance resource standard configuration details
	ComplianceResourceStandardConfigurationDetails *[]ComplianceResourceStandardConfiguration `json:"complianceResourceStandardConfigurationDetails,omitempty"`

	// ConfigurationId Compliance configuration id
	ConfigurationId *string `json:"configurationId,omitempty"`

	// ConfigurationTitle Compliance configuration title
	ConfigurationTitle *string `json:"configurationTitle,omitempty"`
}

// ComplianceResource This specification contains compliance resource details
type ComplianceResource struct {
	// ResourceName Compliance Resource FQDN
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Compliance Resource Type
	ResourceType string `json:"resourceType"`
}

// ComplianceResourceStandardConfiguration Represents a compliance resource and standard configuration
type ComplianceResourceStandardConfiguration struct {
	// ResourceType Compliance resource type
	ResourceType *string `json:"resourceType,omitempty"`

	// ResourceVersion Compliance resource version
	ResourceVersion *string `json:"resourceVersion,omitempty"`

	// StandardConfigurationDetails Compliance standard configuration
	StandardConfigurationDetails *[]ComplianceStandardConfiguration `json:"standardConfigurationDetails,omitempty"`
}

// ComplianceResourcesConfigurationSpec This specification contains compliance configuration and resource request details
type ComplianceResourcesConfigurationSpec struct {
	// ConfigurationId Compliance configuration id
	ConfigurationId *string `json:"configurationId,omitempty"`

	// Resources Compliance Resource details
	Resources []ComplianceResource `json:"resources"`
}

// ComplianceStandard Represents a compliance standard
type ComplianceStandard struct {
	// StandardType Compliance standard type
	StandardType *string `json:"standardType,omitempty"`

	// StandardVersions Compliance standard versions
	StandardVersions *[]string `json:"standardVersions,omitempty"`
}

// ComplianceStandardConfiguration Represents a compliance standard configuration
type ComplianceStandardConfiguration struct {
	// AuditProcedure How the configuration can be audited
	AuditProcedure *string `json:"auditProcedure,omitempty"`

	// CitationReference Citation reference of the configuration in the standard's documentation
	CitationReference *string `json:"citationReference,omitempty"`

	// IsAuditAutomated Whether an automated or manual audit is supported
	IsAuditAutomated *bool `json:"isAuditAutomated,omitempty"`

	// IsRecommendedByStandard Whether the config is recommended by the standard or it's a VMware best practice
	IsRecommendedByStandard *bool `json:"isRecommendedByStandard,omitempty"`

	// RecommendedValue Recommended value of the configuration by the standard
	RecommendedValue *string `json:"recommendedValue,omitempty"`

	// RemediationProcedure Remediation procedure if the configuration is not compliant
	RemediationProcedure *string `json:"remediationProcedure,omitempty"`

	// StandardType Compliance standard type
	StandardType *string `json:"standardType,omitempty"`

	// StandardVersion Compliance standard version
	StandardVersion *string `json:"standardVersion,omitempty"`
}

// ComplianceTask Represents a compliance task
type ComplianceTask struct {
	// ComplianceAuditId Compliance audit id
	ComplianceAuditId *string `json:"complianceAuditId,omitempty"`

	// Id Compliance task id
	Id *string `json:"id,omitempty"`

	// Status Compliance task status
	Status *string `json:"status,omitempty"`
}

// ComponentDetails Component contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
type ComponentDetails struct {
	// DisplayName Component display name
	DisplayName *string `json:"displayName,omitempty"`

	// DisplayVersion Component display version
	DisplayVersion *string `json:"displayVersion,omitempty"`

	// Vendor Component vendor
	Vendor *string `json:"vendor,omitempty"`
}

// ComponentInfo Component contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
type ComponentInfo struct {
	// Details Component contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
	Details *ComponentDetails `json:"details,omitempty"`

	// Version Component Version
	Version *string `json:"version,omitempty"`
}

// ComputeSpec This specification contains the parameters required to add each cluster to a workload domain
type ComputeSpec struct {
	// ClusterSpecs List of clusters to be added to workload domain
	ClusterSpecs []ClusterSpec `json:"clusterSpecs"`

	// SkipFailedHosts Skip failed ESXi Hosts and proceed with the rest of the ESXi Hosts during add Cluster. This is not supported for VCF VxRail.
	SkipFailedHosts *bool `json:"skipFailedHosts,omitempty"`
}

// ConfigDriftApplySpec Describes Configuration Reconciliation operations
type ConfigDriftApplySpec struct {
	// ReconciliationForResources List of Configuration Reconciliation for resource, mutually exclusive with reconciliationForDrifts
	ReconciliationForResources *[]ReconciliationForResource `json:"reconciliationForResources,omitempty"`
}

// ConfigDriftSpec Represents a Configuration Drift workflow
type ConfigDriftSpec struct {
	// Applicability Represents all applicability requirements for a Configuration Drift
	Applicability *Applicability `json:"applicability,omitempty"`

	// Description Description of the Configuration Drift
	Description *string `json:"description,omitempty"`

	// Id The UUID of the Configuration Drift
	Id *string `json:"id,omitempty"`

	// Name Name of the Configuration Drift
	Name *string `json:"name,omitempty"`

	// ResourceType The infrastructure resource on which this Configuration Drift operates
	ResourceType *string `json:"resourceType,omitempty"`

	// Type The type of Configuration Drift
	Type *string `json:"type,omitempty"`
}

// Cpu Represents information about CPUs on a host
type Cpu struct {
	// Cores Number of CPU cores
	Cores *int32 `json:"cores,omitempty"`

	// CpuCores Information about each of the CPU cores
	CpuCores *[]CpuCore `json:"cpuCores,omitempty"`

	// FrequencyMHz Total CPU frequency in MHz
	FrequencyMHz *float64 `json:"frequencyMHz,omitempty"`

	// UsedFrequencyMHz Used CPU frequency in MHz
	UsedFrequencyMHz *float64 `json:"usedFrequencyMHz,omitempty"`
}

// CpuCore Represents a CPU core
type CpuCore struct {
	// FrequencyMHz CPU frequency in MHz
	FrequencyMHz *float64 `json:"frequencyMHz,omitempty"`

	// Manufacturer Hardware manufacturer of the CPU
	Manufacturer *string `json:"manufacturer,omitempty"`

	// Model Hardware model of the CPU
	Model *string `json:"model,omitempty"`
}

// CpuInfo Represents CPU information
type CpuInfo struct {
	// NumberOfCPUPackages Number of CPU Packages
	NumberOfCPUPackages *int32 `json:"numberOfCPUPackages,omitempty"`

	// NumberOfCores Number of cores
	NumberOfCores *int32 `json:"numberOfCores,omitempty"`

	// Total Represents a single metric representing frequency
	Total *FrequencyMetric `json:"total,omitempty"`

	// Used Represents a single metric representing frequency
	Used *FrequencyMetric `json:"used,omitempty"`
}

// Credential Represents a credential and the resource to which it is associated with
type Credential struct {
	// AccountType Account type
	AccountType *string `json:"accountType,omitempty"`

	// AutoRotatePolicy Represents a auto-rotate policy for a credential
	AutoRotatePolicy *AutoRotateCredentialPolicy `json:"autoRotatePolicy,omitempty"`

	// CreationTimestamp The timestamp at which credential was created
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// CredentialType Credential type
	CredentialType *string `json:"credentialType,omitempty"`

	// Expiry Represents expiration details of the credential
	Expiry *ExpirationDetails `json:"expiry,omitempty"`

	// Id Credential ID
	Id *string `json:"id,omitempty"`

	// ModificationTimestamp The timestamp at which credential was last modified
	ModificationTimestamp *string `json:"modificationTimestamp,omitempty"`

	// Password Password
	Password *string `json:"password,omitempty"`

	// Resource Represents the credential resource in the system
	Resource *AuthenticatedResource `json:"resource,omitempty"`

	// Username Username
	Username *string `json:"username,omitempty"`
}

// CredentialExpirationCheck Represents credential expiration check details
type CredentialExpirationCheck struct {
	// CompletionTimestamp Completion timestamp
	CompletionTimestamp *string `json:"completionTimestamp,omitempty"`

	// CreationTimestamp Creation timestamp
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// Expiry Represents expiration details of the credential
	Expiry *ExpirationDetails `json:"expiry,omitempty"`

	// Id Credential ID
	Id *string `json:"id,omitempty"`

	// Resource Represents the credential resource in the system
	Resource *AuthenticatedResource `json:"resource,omitempty"`

	// Username Username
	Username *string `json:"username,omitempty"`
}

// CredentialsExpiration Represents a credentials expiration task response
type CredentialsExpiration struct {
	// CompletionTimestamp Completion timestamp
	CompletionTimestamp *string `json:"completionTimestamp,omitempty"`

	// CreationTimestamp Creation timestamp
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Elements List of one or more expiration checks that are performed as part of the credentials expiration task
	Elements *[]CredentialExpirationCheck `json:"elements,omitempty"`

	// Id ID of expiration task
	Id *string `json:"id,omitempty"`

	// Status Execution status of the expiration
	Status *string `json:"status,omitempty"`
}

// CredentialsExpirationSpec This specification contains password expiration fetch request details
type CredentialsExpirationSpec struct {
	// CredentialIds List of credential ids
	CredentialIds *[]string `json:"credentialIds,omitempty"`

	// DomainName Domain name
	DomainName *string `json:"domainName,omitempty"`

	// ResourceType Authenticated Resource Type
	ResourceType string `json:"resourceType"`
}

// CredentialsSubTask Represents the credentials sub-task in the system
type CredentialsSubTask struct {
	// CreationTimestamp Credential sub-task creation timestamp
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// CredentialType Credential sub-task credential type
	CredentialType *string `json:"credentialType,omitempty"`

	// DependentSubTasks List of dependent sub-tasks of the credential sub-task
	DependentSubTasks *[]CredentialsSubTask `json:"dependentSubTasks,omitempty"`

	// Description Credential sub-task description
	Description *string `json:"description,omitempty"`

	// EntityType Credential sub-task entity type
	EntityType *string `json:"entityType,omitempty"`

	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// Id Credential sub-task ID
	Id *string `json:"id,omitempty"`

	// Name Credential sub-task name
	Name *string `json:"name,omitempty"`

	// NewPassword Credential sub-task new password
	NewPassword *string `json:"newPassword,omitempty"`

	// OldPassword Credential sub-task old password
	OldPassword *string `json:"oldPassword,omitempty"`

	// ResourceName Resource name
	ResourceName *string `json:"resourceName,omitempty"`

	// Status Credential sub-task status
	Status *string `json:"status,omitempty"`

	// Username Credential sub-task username
	Username *string `json:"username,omitempty"`
}

// CredentialsTask Represents the credentials task in the system
type CredentialsTask struct {
	// CreationTimestamp Credential task creation timestamp
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// Id Credential task ID
	Id *string `json:"id,omitempty"`

	// IsAutoRotate Is Credential task an auto rotate task
	IsAutoRotate *bool `json:"isAutoRotate,omitempty"`

	// Name Credential task name
	Name *string `json:"name,omitempty"`

	// Status Credential task status
	Status *string `json:"status,omitempty"`

	// SubTasks List of credential sub-tasks of the credential task
	SubTasks *[]CredentialsSubTask `json:"subTasks,omitempty"`

	// Type Credential task type
	Type *string `json:"type,omitempty"`
}

// CredentialsUpdateSpec This specification contains password operation request details
type CredentialsUpdateSpec struct {
	// AutoRotatePolicy Represents password auto rotate config details
	AutoRotatePolicy *AutoRotateCredentialPolicyInputSpec `json:"autoRotatePolicy,omitempty"`

	// Elements List of resource credentials to be changed
	Elements []ResourceCredentials `json:"elements"`

	// OperationType Operation type
	OperationType string `json:"operationType"`
}

// Csr The Certificate Signing Request (CSR) details
type Csr struct {
	// CsrDecodedContent The CSR decoded content
	CsrDecodedContent *string `json:"csrDecodedContent,omitempty"`

	// CsrEncodedContent The CSR encoded content
	CsrEncodedContent *string `json:"csrEncodedContent,omitempty"`

	// Resource Represents the resource in the system
	Resource *Resource `json:"resource,omitempty"`
}

// CsrGenerationSpec This specification contains Certificate Signing Request (CSR) details
type CsrGenerationSpec struct {
	// Country ISO 3166 country code where company is legally registered
	Country string `json:"country"`

	// Email Contact email address
	Email *string `json:"email,omitempty"`

	// KeyAlgorithm The public key algorithm of the certificate
	KeyAlgorithm string `json:"keyAlgorithm"`

	// KeySize Certificate public key size
	KeySize string `json:"keySize"`

	// Locality The city or locality where company is legally registered
	Locality string `json:"locality"`

	// Organization The name under which company is legally registered
	Organization string `json:"organization"`

	// OrganizationUnit Organization with which the certificate is associated
	OrganizationUnit string `json:"organizationUnit"`

	// State The full name of the state where company is legally registered
	State string `json:"state"`
}

// CsrsGenerationSpec This specification contains CSR Generation request details
type CsrsGenerationSpec struct {
	// CsrGenerationSpec This specification contains Certificate Signing Request (CSR) details
	CsrGenerationSpec CsrGenerationSpec `json:"csrGenerationSpec"`

	// Resources Resource(s) in a domain
	Resources *[]Resource `json:"resources,omitempty"`
}

// CustomISOSpec Custom ISO Specifications for VUM Clusters Upgrade with Custom ISO
type CustomISOSpec struct {
	// Id Custom ISO Id for VUM Clusters Upgrade
	Id string `json:"id"`
}

// CustomIso Custom Iso contains bits to install/update the appropriate Cloud Foundation software components and vendor add ons in your management domain or workload domain hosts.
type CustomIso struct {
	// Id Custom Iso Id
	Id *string `json:"id,omitempty"`

	// Name Custom Image Name
	Name *string `json:"name,omitempty"`

	// UploadedTimestamp Date when the ISO was uploaded
	UploadedTimestamp *string `json:"uploadedTimestamp,omitempty"`

	// Vendor Vendor of the Custom Iso
	Vendor *string `json:"vendor,omitempty"`

	// Version Custom Iso ESXi Version
	Version *string `json:"version,omitempty"`
}

// CustomIsoRenameSpec Custom Iso rename spec contains the name field in which the new name is to be entered
type CustomIsoRenameSpec struct {
	// Name Custom Iso name
	Name string `json:"name"`
}

// DataMetric Represents a single metric representing digital data
type DataMetric struct {
	// Unit Unit of the metric
	Unit *DataMetricUnit `json:"unit,omitempty"`

	// Value Value of the metric
	Value *float64 `json:"value,omitempty"`
}

// DataMetricUnit Unit of the metric
type DataMetricUnit string

// Datastore Represents a datastore in the system
type Datastore struct {
	// DatastoreType Datastore Type
	DatastoreType *string `json:"datastoreType,omitempty"`

	// FreeCapacityGB Free storage capacity in GB
	FreeCapacityGB *float64 `json:"freeCapacityGB,omitempty"`

	// Id Id of the datastore
	Id *string `json:"id,omitempty"`

	// Name Name of the datastore
	Name *string `json:"name,omitempty"`

	// Tags List of assigned tags for the datastore
	Tags *[]Tag `json:"tags,omitempty"`

	// TotalCapacityGB Total storage capacity in GB
	TotalCapacityGB *float64 `json:"totalCapacityGB,omitempty"`

	// Url URL of the datastore
	Url *string `json:"url,omitempty"`

	// VcDatacenterName Name of the vCenter datacenter that this datastore resides
	VcDatacenterName *string `json:"vcDatacenterName,omitempty"`

	// VcInstanceUuid Instance UUID of the vCenter that manages this datastore
	VcInstanceUuid *string `json:"vcInstanceUuid,omitempty"`

	// VmCount Number of VMs on the datastore
	VmCount *int32 `json:"vmCount,omitempty"`
}

// DatastoreCriterion Represents a criterion for querying the datastores
type DatastoreCriterion struct {
	// Arguments Arguments required for a particular criterion
	Arguments *map[string]string `json:"arguments,omitempty"`

	// Description Description of the criterion
	Description *string `json:"description,omitempty"`

	// Name Name of the criterion for querying datastores
	Name *string `json:"name,omitempty"`
}

// DatastoreMountSpec Datastore Mount Spec
type DatastoreMountSpec struct {
	// DatastoreSpec This specification contains cluster storage configuration
	DatastoreSpec DatastoreSpec `json:"datastoreSpec"`
}

// DatastoreQueryResponse Represents a datastore query response.
type DatastoreQueryResponse struct {
	// QueryInfo Represents the query info.
	QueryInfo *QueryInfo `json:"queryInfo,omitempty"`

	// Result Represents a page of elements of a single type
	Result *PageDatastore `json:"result,omitempty"`
}

// DatastoreSpec This specification contains cluster storage configuration
type DatastoreSpec struct {
	// NfsDatastoreSpecs Cluster storage configuration for NFS
	NfsDatastoreSpecs *[]NfsDatastoreSpec `json:"nfsDatastoreSpecs,omitempty"`

	// VmfsDatastoreSpec Cluster storage configuration for VMFS
	VmfsDatastoreSpec *VmfsDatastoreSpec `json:"vmfsDatastoreSpec,omitempty"`

	// VsanDatastoreSpec This specification contains cluster storage configuration for vSAN
	VsanDatastoreSpec *VsanDatastoreSpec `json:"vsanDatastoreSpec,omitempty"`

	// VsanRemoteDatastoreClusterSpec vSAN remote datastore configuration for the cluster
	VsanRemoteDatastoreClusterSpec *VsanRemoteDatastoreClusterSpec `json:"vsanRemoteDatastoreClusterSpec,omitempty"`

	// VvolDatastoreSpecs Cluster storage configuration for VVOL
	VvolDatastoreSpecs *[]VvolDatastoreSpec `json:"vvolDatastoreSpecs,omitempty"`
}

// DepotAccount VMware Depot Account Information
type DepotAccount struct {
	// Message Message explaining depot status
	Message *string `json:"message,omitempty"`

	// Password Depot Password for Access
	Password string `json:"password"`

	// Status Depot Status
	Status *string `json:"status,omitempty"`

	// Username Depot Username for Access
	Username string `json:"username"`
}

// DepotConfiguration Depot Configuration
type DepotConfiguration struct {
	// Hostname IP/Hostname of the depot
	Hostname string `json:"hostname"`

	// IsOfflineDepot Flag indicating if the depot is in offline mode
	IsOfflineDepot bool `json:"isOfflineDepot"`

	// Port Port of the depot
	Port int32 `json:"port"`
}

// DepotSettings VMware Depot Settings. At least one of vmwareAccount, dellEmcSupportAccount or offlineAccount value must be provided
type DepotSettings struct {
	// DellEmcSupportAccount VMware Depot Account Information
	DellEmcSupportAccount *DepotAccount `json:"dellEmcSupportAccount,omitempty"`

	// DepotConfiguration Depot Configuration
	DepotConfiguration *DepotConfiguration `json:"depotConfiguration,omitempty"`

	// OfflineAccount VMware Depot Account Information
	OfflineAccount *DepotAccount `json:"offlineAccount,omitempty"`

	// VmwareAccount VMware Depot Account Information
	VmwareAccount *DepotAccount `json:"vmwareAccount,omitempty"`
}

// DiscoveryProgress Information about the assessment run progress.
type DiscoveryProgress struct {
	// PercentageComplete Percentage completed
	PercentageComplete *int32 `json:"percentageComplete,omitempty"`

	// ProgressMessages Progress messages
	ProgressMessages *[]string `json:"progressMessages,omitempty"`
}

// Disk Represents a disk
type Disk struct {
	// CapacityMB Total capacity of the disk in MB
	CapacityMB *float64 `json:"capacityMB,omitempty"`

	// DiskType Type of the disk
	DiskType *string `json:"diskType,omitempty"`

	// Manufacturer Hardware manufacturer of the disk
	Manufacturer *string `json:"manufacturer,omitempty"`

	// Model Hardware model of the disk
	Model *string `json:"model,omitempty"`
}

// DnsConfiguration DNS Configuration
type DnsConfiguration struct {
	// DnsServers List of DNS servers. A maximum of 2 DNS servers are allowed
	DnsServers []DnsServer `json:"dnsServers"`
}

// DnsServer DNS server details
type DnsServer struct {
	// IpAddress IP address/FQDN of DNS server
	IpAddress string `json:"ipAddress"`

	// IsPrimary Is DNS server primary
	IsPrimary bool `json:"isPrimary"`
}

// DnsSpec Spec contains parameters of Domain Name System
type DnsSpec struct {
	// Domain Tenant domain. Parent tenant domain including TLD suffix. This property is deprecated in favor of subdomain.
	// Deprecated:
	Domain *string `json:"domain,omitempty"`

	// Nameserver Primary nameserver to be configured for vCenter/ESXi's/NSX. Deprecated in favor of 'nameservers'
	// Deprecated:
	Nameserver *string `json:"nameserver,omitempty"`

	// Nameservers Nameservers to be configured for vCenter/ESXi's/NSX. The first is the primary nameserver. Maximum allowed is two entries
	Nameservers *[]string `json:"nameservers,omitempty"`

	// SecondaryNameserver Secondary nameserver to be configured for vCenter/ESXi's/NSX. Deprecated in favor of 'nameservers'
	// Deprecated:
	SecondaryNameserver *string `json:"secondaryNameserver,omitempty"`

	// Subdomain Tenant Sub domain. Includes the full domain suffix
	Subdomain string `json:"subdomain"`
}

// Domain Represents a domain
type Domain struct {
	// Capacity Represents a usage and capacity information of a Resource
	Capacity *Capacity `json:"capacity,omitempty"`

	// Clusters List of clusters associated with the workload domain
	Clusters *[]ClusterReference `json:"clusters,omitempty"`

	// ElmStatus ELM status of the domain: ISOLATED, IN_TRANSIT, or LINKED
	ElmStatus *string `json:"elmStatus,omitempty"`

	// Id ID of the workload domain
	Id *string `json:"id,omitempty"`

	// IsManagementSsoDomain Shows whether the workload domain is joined to the Management domain SSO
	IsManagementSsoDomain *bool `json:"isManagementSsoDomain,omitempty"`

	// IsNetworkSeparationEnabled Domain network separation status
	IsNetworkSeparationEnabled *bool `json:"isNetworkSeparationEnabled,omitempty"`

	// IsPrimaryDomainForNsx Is Primary Domain of NSX
	IsPrimaryDomainForNsx *bool `json:"isPrimaryDomainForNsx,omitempty"`

	// IsSecurityEnabled Domain security status
	IsSecurityEnabled *bool `json:"isSecurityEnabled,omitempty"`

	// LicensingInfo Represents a Licensing information
	LicensingInfo *LicensingInfoReference `json:"licensingInfo,omitempty"`

	// LifecycleManagementMode Lifecycle Management mode of the domain
	LifecycleManagementMode *string `json:"lifecycleManagementMode,omitempty"`

	// Name Name of the workload domain
	Name *string `json:"name,omitempty"`

	// NsxtCluster Represents an NSX Cluster reference
	NsxtCluster *NsxTClusterReference `json:"nsxtCluster,omitempty"`

	// OrgName Organization name of the workload domain
	OrgName *string `json:"orgName,omitempty"`

	// Owners List of users owning the workload domain
	Owners *[]string `json:"owners,omitempty"`

	// SsoId ID of the SSO domain associated with the workload domain
	SsoId *string `json:"ssoId,omitempty"`

	// SsoName Name of the SSO domain associated with the workload domain
	SsoName *string `json:"ssoName,omitempty"`

	// Status Status of the workload domain
	Status *string `json:"status,omitempty"`

	// Tags Deprecated, this list will always be returned empty
	// Deprecated:
	Tags *[]Tag `json:"tags,omitempty"`

	// Type Type of the workload domain
	Type *string `json:"type,omitempty"`

	// UpgradeState Workload domain upgrade state
	UpgradeState *string `json:"upgradeState,omitempty"`

	// UpgradeStatus Represents upgrade status of a domain
	UpgradeStatus *UpgradeStatus `json:"upgradeStatus,omitempty"`

	// Vcenters List of vCenters associated with the workload domain
	Vcenters *[]VcenterReference `json:"vcenters,omitempty"`

	// VraIntegrationStatus Status that represents the workload domain integration with VMware Aria Automation
	VraIntegrationStatus *string `json:"vraIntegrationStatus,omitempty"`

	// VrliIntegrationStatus Status that represents the workload domain integration with VMware Aria Operations for Logs
	VrliIntegrationStatus *string `json:"vrliIntegrationStatus,omitempty"`

	// VropsIntegrationStatus Status that represents the workload domain integration with VMware Aria Operations
	VropsIntegrationStatus *string `json:"vropsIntegrationStatus,omitempty"`
}

// DomainCreationSpec Domain Creation Spec
type DomainCreationSpec struct {
	// ComputeSpec This specification contains the parameters required to add each cluster to a workload domain
	ComputeSpec ComputeSpec `json:"computeSpec"`

	// DeployWithoutLicenseKeys Flag that indicates if the deployment should happen without license keys
	DeployWithoutLicenseKeys *bool `json:"deployWithoutLicenseKeys,omitempty"`

	// DomainName Name of the workload domain
	DomainName *string `json:"domainName,omitempty"`

	// NsxTSpec This specification contains the parameters required to install and configure NSX in a workload domain
	NsxTSpec *NsxTSpec `json:"nsxTSpec,omitempty"`

	// OrgName Organization name of the workload domain
	OrgName *string `json:"orgName,omitempty"`

	// SecuritySpec Spec contains security settings
	SecuritySpec *SecuritySpec `json:"securitySpec,omitempty"`

	// SsoDomainSpec Spec for the SSO configuration in a VMware Cloud Foundation Domain
	SsoDomainSpec *SsoDomainSpec `json:"ssoDomainSpec,omitempty"`

	// VcenterSpec This specification contains the installation and configuration of vCenter in a workload domain
	VcenterSpec VcenterSpec `json:"vcenterSpec"`
}

// DomainFutureRelease Model for releases with details if applicable to current domain version or not.
type DomainFutureRelease struct {
	// AlternativeApplicableSddcManagerVersions List of AlternativeApplicableSddcManagerVersions
	AlternativeApplicableSddcManagerVersions *[]AlternativeApplicableSddcManagerVersion `json:"alternativeApplicableSddcManagerVersions,omitempty"`

	// ApplicabilityStatus Whether bundle is applicable or not.
	ApplicabilityStatus *string `json:"applicabilityStatus,omitempty"`

	// Bom Release bill of materials
	Bom *[]ProductVersion `json:"bom,omitempty"`

	// Description Release description with all major features.
	Description *string `json:"description,omitempty"`

	// Eol Release eol information e.g. 2020-06-08T02:20:15.844Z in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	Eol *string `json:"eol,omitempty"`

	// IsApplicable [Deprecated] Whether bundle is applicable or not.
	// Deprecated:
	IsApplicable *bool `json:"isApplicable,omitempty"`

	// MinCompatibleVcfVersion Minimum compatible VCF version, used to represent compatibility of SDDC Manager and VMware BOM components
	MinCompatibleVcfVersion *string `json:"minCompatibleVcfVersion,omitempty"`

	// NotApplicableReason [Deprecated] Incompatibility reason for not applicable.
	// Deprecated:
	NotApplicableReason *string `json:"notApplicableReason,omitempty"`

	// PatchBundles List of patch bundles in this release
	PatchBundles *[]PatchBundle `json:"patchBundles,omitempty"`

	// Product Name of the product e.g. "VCF"
	Product *string `json:"product,omitempty"`

	// ReasonNotApplicable A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
	ReasonNotApplicable *MessagePack `json:"reasonNotApplicable,omitempty"`

	// ReasonsNotApplicable List of Incompatibility details for not applicable
	ReasonsNotApplicable *[]MessagePack `json:"reasonsNotApplicable,omitempty"`

	// ReleaseDate Release date e.g. 2020-06-08T02:20:15.844Z in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	ReleaseDate *string `json:"releaseDate,omitempty"`

	// Sku Release sku specific patch and bill of materials
	Sku *[]SkuBomDetails `json:"sku,omitempty"`

	// Updates Collection of release updates
	Updates *[]ReleaseUpdate `json:"updates,omitempty"`

	// UpgradeOrder Custom upgrade order. Comma separated list of components in upgrade order. Supported components types: NSX_T_MANAGER, VCENTER, ESX_HOST.
	UpgradeOrder *string `json:"upgradeOrder,omitempty"`

	// Version Version of the release
	Version *string `json:"version,omitempty"`

	// Warnings List of warning messages for product compatibility
	Warnings *[]MessagePack `json:"warnings,omitempty"`
}

// DomainInfo Information about the assessed domain
type DomainInfo struct {
	// DomainId Id of the domain
	DomainId *string `json:"domainId,omitempty"`

	// DomainName Name of the domain
	DomainName *string `json:"domainName,omitempty"`

	// DomainType Type of the domain
	DomainType *DomainInfoDomainType `json:"domainType,omitempty"`
}

// DomainInfoDomainType Type of the domain
type DomainInfoDomainType string

// DomainIntegration This specification contains information related to the existing VMware Aria Operations instance deployment
type DomainIntegration struct {
	// DomainId The ID of the workload domain
	DomainId *string `json:"domainId,omitempty"`

	// Status The association status of the workload domain
	Status DomainIntegrationStatus `json:"status"`
}

// DomainIntegrationStatus The association status of the workload domain
type DomainIntegrationStatus string

// DomainReference Represents a domain reference
type DomainReference struct {
	// Id ID of the domain
	Id string `json:"id"`

	// Name Name of the domain
	Name *string `json:"name,omitempty"`

	// Type Type of the domain
	Type *string `json:"type,omitempty"`
}

// DomainRelease Target domain VCF version
type DomainRelease struct {
	// Patches Target product release and patch versions
	Patches *[]TargetProductVersion `json:"patches,omitempty"`

	// TargetSddcManagerVersion Target SDDC Manager version
	TargetSddcManagerVersion *string `json:"targetSddcManagerVersion,omitempty"`

	// TargetVersion Target version
	TargetVersion *string `json:"targetVersion,omitempty"`

	// TargetVxRailVersion Target VxRail version
	TargetVxRailVersion *string `json:"targetVxRailVersion,omitempty"`
}

// DomainReleaseView Model for domain release view.
type DomainReleaseView struct {
	// DomainId Domain ID
	DomainId string `json:"domainId"`

	// IsCustomizedBom Identifier for VCF Release vs Customized BOM
	IsCustomizedBom *bool `json:"isCustomizedBom,omitempty"`

	// Patches Target product release and patch versions
	Patches *[]TargetProductVersion `json:"patches,omitempty"`

	// TargetSddcManagerVersion Target SDDC Manager version
	TargetSddcManagerVersion *string `json:"targetSddcManagerVersion,omitempty"`

	// TargetVersion Target upgrade version of the domain
	TargetVersion string `json:"targetVersion"`

	// TargetVxRailVersion Target VxRail version
	TargetVxRailVersion *string `json:"targetVxRailVersion,omitempty"`
}

// DomainUpdateSpec Domain Update Data
type DomainUpdateSpec struct {
	// ClusterSpec This specification contains the parameters required to add a cluster to a workload domain
	ClusterSpec *ClusterSpec `json:"clusterSpec,omitempty"`

	// IsolationSpec Domain Isolation Details
	IsolationSpec *IsolationSpec `json:"isolationSpec,omitempty"`

	// MarkForDeletion Enable deletion for the domain
	MarkForDeletion *bool `json:"markForDeletion,omitempty"`

	// Name Name of the domain
	Name *string `json:"name,omitempty"`

	// NsxTSpec This specification contains the parameters required to install and configure NSX in a workload domain
	NsxTSpec *NsxTSpec `json:"nsxTSpec,omitempty"`
}

// Domains Domains and Clusters for SOS operation.
type Domains struct {
	// ClusterNames Clusters for the operation
	ClusterNames *[]string `json:"clusterNames,omitempty"`

	// DomainName Domain name
	DomainName *string `json:"domainName,omitempty"`
}

// DvsSpec Spec contains parameters for DVS
type DvsSpec struct {
	// DvsName vSphere Distributed Switch Name. It will be auto-generated if blank
	DvsName *string `json:"dvsName,omitempty"`

	// IsUsedByNsxt Flag indicating whether the Distributed vSphere Switch is used by NSX.
	// This property is deprecated in favor of nsxtSwitchConfig field
	// Deprecated:
	IsUsedByNsxt *bool `json:"isUsedByNsxt,omitempty"`

	// Mtu Distributed vSphere Switch MTU (default value is 9000)
	Mtu *int32 `json:"mtu,omitempty"`

	// Networks Types of networks in this Distributed vSphere Switch. One among: VSAN, VMOTION, MANAGEMENT, VM_MANAGEMENT or any custom network types defined in networkSpecs
	Networks *[]string `json:"networks,omitempty"`

	// NiocSpecs List of Network IO Control Specification for networks
	NiocSpecs *[]NiocSpec `json:"niocSpecs,omitempty"`

	// NsxTeamings The teaming policies to be associated with the uplink profile in NSX
	NsxTeamings *[]TeamingSpec `json:"nsxTeamings,omitempty"`

	// NsxtSwitchConfig This specification contains the configurations to be associated with the vSphere Distributed Switch managed by NSX
	NsxtSwitchConfig *NsxtSwitchConfig `json:"nsxtSwitchConfig,omitempty"`

	// Vmnics Vmnics to be attached to the DVS.
	// This property is deprecated in favor of vmnicsToUplinks fields
	// Deprecated:
	Vmnics *[]string `json:"vmnics,omitempty"`

	// VmnicsToUplinks List of vmnic to uplink mapping
	VmnicsToUplinks *[]VmnicToUplink `json:"vmnicsToUplinks,omitempty"`
}

// EdgeCluster EdgeCluster representation
type EdgeCluster struct {
	// Clusters List of clusters associated with the edge cluster
	Clusters *[]ClusterReference `json:"clusters,omitempty"`

	// EdgeNodes List of edge nodes associated with the edge cluster
	EdgeNodes *[]EdgeNodeReference `json:"edgeNodes,omitempty"`

	// Id ID of the egde cluster
	Id *string `json:"id,omitempty"`

	// IsTier0ManagedBySystem Whether or not this edge cluster's tier 0 is managed by system
	IsTier0ManagedBySystem *bool `json:"isTier0ManagedBySystem,omitempty"`

	// Name Name of the edge cluster
	Name *string `json:"name,omitempty"`

	// NsxtCluster Represents an NSX Cluster reference
	NsxtCluster *NsxTClusterReference `json:"nsxtCluster,omitempty"`

	// SkipTepRoutabilityCheck Whether or not host/TEP network checks were done for this edge cluster
	SkipTepRoutabilityCheck *bool `json:"skipTepRoutabilityCheck,omitempty"`

	// Status NSX Edge cluster status
	Status *string `json:"status,omitempty"`
}

// EdgeClusterCreationSpec NSX Edge cluster creation data to be validated
type EdgeClusterCreationSpec struct {
	// Asn ASN to be used for the edge cluster
	Asn *int64 `json:"asn,omitempty"`

	// EdgeAdminPassword Edge Password for admin user
	EdgeAdminPassword string `json:"edgeAdminPassword"`

	// EdgeAuditPassword Edge Password for audit
	EdgeAuditPassword string `json:"edgeAuditPassword"`

	// EdgeClusterName Name for the edge cluster.
	EdgeClusterName string `json:"edgeClusterName"`

	// EdgeClusterProfileSpec This specification contains edge cluster profile configurations
	EdgeClusterProfileSpec NsxTEdgeClusterProfileSpec `json:"edgeClusterProfileSpec"`

	// EdgeClusterProfileType Type of edge cluster profile
	EdgeClusterProfileType string `json:"edgeClusterProfileType"`

	// EdgeClusterType Type of edge cluster
	EdgeClusterType string `json:"edgeClusterType"`

	// EdgeFormFactor Edge Form Factor
	EdgeFormFactor string `json:"edgeFormFactor"`

	// EdgeNodeSpecs Specifications for Edge Node. Number of Edge Nodes cannot exceed 8 if HA mode is ACTIVE-ACTIVE and can not exceed 2 if HA mode is ACTIVE-STANDBY
	EdgeNodeSpecs []NsxTEdgeNodeSpec `json:"edgeNodeSpecs"`

	// EdgeRootPassword Edge Password for root user.
	EdgeRootPassword string `json:"edgeRootPassword"`

	// InternalTransitSubnets Subnet addresses in CIDR notation that are used to assign addresses to logical links connecting service routers and distributed routers
	InternalTransitSubnets *[]string `json:"internalTransitSubnets,omitempty"`

	// Mtu Maximum transmission unit
	Mtu int32 `json:"mtu"`

	// NewIpAddressPoolSpecs Specifications for new NSX IP address pool(s)
	NewIpAddressPoolSpecs *[]IpAddressPoolSpec `json:"newIpAddressPoolSpecs,omitempty"`

	// SkipTepRoutabilityCheck Set to true to bypass normal ICMP-based check of Edge TEP / host TEP routability (default is false, meaning do check)
	SkipTepRoutabilityCheck *bool `json:"skipTepRoutabilityCheck,omitempty"`

	// Tier0Name Name for the Tier-0
	Tier0Name *string `json:"tier0Name,omitempty"`

	// Tier0RoutingType Tier 0 Routing type -eg eBGP, Static
	Tier0RoutingType *string `json:"tier0RoutingType,omitempty"`

	// Tier0ServicesHighAvailability High-availability Mode for Tier-0
	Tier0ServicesHighAvailability *string `json:"tier0ServicesHighAvailability,omitempty"`

	// Tier1Name Name for the Tier-1
	Tier1Name *string `json:"tier1Name,omitempty"`

	// Tier1Unhosted Select whether Tier-1 being created per this spec is hosted on the new Edge cluster or not (default value is false, meaning hosted)
	Tier1Unhosted *bool `json:"tier1Unhosted,omitempty"`

	// TransitSubnets Transit subnet addresses in CIDR notation that are used to assign addresses to logical links connecting Tier-0 and Tier-1s
	TransitSubnets *[]string `json:"transitSubnets,omitempty"`
}

// EdgeClusterExpansionSpec This specification contains the parameters required to expand a NSX edge cluster.
type EdgeClusterExpansionSpec struct {
	// AdditionalTier1Names List of names for the additional Tier-1(s) to be created during expansion
	AdditionalTier1Names *[]string `json:"additionalTier1Names,omitempty"`

	// EdgeNodeAdminPassword Edge Password for admin user
	EdgeNodeAdminPassword string `json:"edgeNodeAdminPassword"`

	// EdgeNodeAuditPassword Edge Password for audit user
	EdgeNodeAuditPassword string `json:"edgeNodeAuditPassword"`

	// EdgeNodeRootPassword Edge Password for root user.
	EdgeNodeRootPassword string `json:"edgeNodeRootPassword"`

	// EdgeNodeSpecs Specifications for Edge Node
	EdgeNodeSpecs []NsxTEdgeNodeSpec `json:"edgeNodeSpecs"`

	// NewIpAddressPoolSpecs Specifications for new NSX IP address pool(s)
	NewIpAddressPoolSpecs *[]IpAddressPoolSpec `json:"newIpAddressPoolSpecs,omitempty"`

	// SkipTepRoutabilityCheck Set to true to bypass normal ICMP-based check of Edge TEP / host TEP routability (default is false, meaning do check)
	SkipTepRoutabilityCheck *bool `json:"skipTepRoutabilityCheck,omitempty"`

	// Tier1Unhosted Select whether all Tier-1(s) being created per this spec are hosted on the Edge cluster or not (default is false, meaning hosted)
	Tier1Unhosted *bool `json:"tier1Unhosted,omitempty"`
}

// EdgeClusterNsxtEntityCriterion Represents a criterion for querying the Edge Cluster
type EdgeClusterNsxtEntityCriterion struct {
	// Arguments Arguments required for a particular criterion
	Arguments *map[string]string `json:"arguments,omitempty"`

	// Description Description of the criterion
	Description *string `json:"description,omitempty"`

	// Name Name of the criterion
	Name *string `json:"name,omitempty"`
}

// EdgeClusterShrinkageSpec This specification contains the parameters required to shrink a NSX edge cluster.
type EdgeClusterShrinkageSpec struct {
	// EdgeNodeIds List of VCF Edge Node ID's to be removed for shrinkage.
	EdgeNodeIds []string `json:"edgeNodeIds"`
}

// EdgeClusterUpdateSpec NSX Edge cluster update specification
type EdgeClusterUpdateSpec struct {
	// EdgeClusterExpansionSpec This specification contains the parameters required to expand a NSX edge cluster.
	EdgeClusterExpansionSpec *EdgeClusterExpansionSpec `json:"edgeClusterExpansionSpec,omitempty"`

	// EdgeClusterShrinkageSpec This specification contains the parameters required to shrink a NSX edge cluster.
	EdgeClusterShrinkageSpec *EdgeClusterShrinkageSpec `json:"edgeClusterShrinkageSpec,omitempty"`

	// Operation Edge cluster operation Type.
	Operation string `json:"operation"`
}

// EdgeNodeReference Represents a reference to the edge node
type EdgeNodeReference struct {
	// HostName Hostname of the edge node
	HostName string `json:"hostName"`

	// Id ID of the edge node
	Id string `json:"id"`
}

// EdgeTepIpAddressPoolSpec This specification indicates which NSX IP pool to use for an Edge node's TEPs
type EdgeTepIpAddressPoolSpec struct {
	// Name NSX IP Pool Name
	Name *string `json:"name,omitempty"`

	// NsxId NSX IP Pool ID
	NsxId *string `json:"nsxId,omitempty"`
}

// Encryption Restore Specification
type Encryption struct {
	// Passphrase Passphrase
	Passphrase string `json:"passphrase"`
}

// Endpoint Represents an Endpoint in a Domain
type Endpoint struct {
	// Type Type of the Endpoint
	Type *string `json:"type,omitempty"`

	// Url Url of the Endpoint
	Url *string `json:"url,omitempty"`
}

// Entitlements Entitlements of the resource
type Entitlements struct {
	// HasNsxEntitlement Flag indicating whether the resource has NSX entitlement or not
	HasNsxEntitlement *bool `json:"hasNsxEntitlement,omitempty"`
}

// EntityRest Entity model representing the physical data output of the assessment workflow.
type EntityRest struct {
	// ChildEntities Child entities of this entity
	ChildEntities *[]EntityRest `json:"childEntities,omitempty"`

	// Classifications Classifications of the entity
	Classifications *[]Classification `json:"classifications,omitempty"`

	// Description Description of the entity
	Description *string `json:"description,omitempty"`

	// Id Id of the entity
	Id *string `json:"id,omitempty"`

	// Name Name of the entity
	Name *string `json:"name,omitempty"`

	// Properties Properties for this entity
	Properties *map[string]map[string]interface{} `json:"properties,omitempty"`

	// SourceAddress The address of the source
	SourceAddress *string `json:"sourceAddress,omitempty"`

	// Type Type of the entity
	Type *string `json:"type,omitempty"`
}

// Error Error response containing a minor error code, a localized error message, a localized remediation message and optionally a reference token to correlate the error with the logs
type Error struct {
	// Arguments The arguments used to localize the message, Can be used by scripts to automate the error processing.
	Arguments *[]string `json:"arguments,omitempty"`

	// Causes The underlying cause exceptions.
	Causes *[]ErrorCause `json:"causes,omitempty"`

	// Context The error context (e.g. the component where it occurred).
	Context *map[string]string `json:"context,omitempty"`

	// ErrorCode The minor error code
	ErrorCode *string `json:"errorCode,omitempty"`

	// ErrorType The error type
	ErrorType *string `json:"errorType,omitempty"`

	// Message The localized error message
	Message *string `json:"message,omitempty"`

	// NestedErrors The nested errors when the error is a composite one
	NestedErrors *[]Error `json:"nestedErrors,omitempty"`

	// ReferenceToken A reference token correlating the error with the relevant detailed error logs. Should be sent to the service provider when reporting issues.
	ReferenceToken *string `json:"referenceToken,omitempty"`

	// RemediationMessage The localized remediation error message
	RemediationMessage *string `json:"remediationMessage,omitempty"`
}

// ErrorCause Describes a single error cause
type ErrorCause struct {
	// Message The message describing the reason for the error
	Message *string `json:"message,omitempty"`

	// Type The type of the error cause
	Type *string `json:"type,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Arguments          *[]string          `json:"arguments,omitempty"`
	Cause              *[]ErrorCause      `json:"cause,omitempty"`
	Context            *map[string]string `json:"context,omitempty"`
	ErrorCode          *string            `json:"errorCode,omitempty"`
	Message            *string            `json:"message,omitempty"`
	NestedErrors       *[]ErrorResponse   `json:"nestedErrors,omitempty"`
	ReferenceToken     *string            `json:"referenceToken,omitempty"`
	RemediationMessage *string            `json:"remediationMessage,omitempty"`
}

// EsaConfig This spec contains cluster vSAN ESA configuration
type EsaConfig struct {
	// Enabled vSAN ESA enablement status.
	Enabled bool `json:"enabled"`

	// VsanMaxConfig This spec contains cluster vSAN MAX configuration
	VsanMaxConfig *VsanMaxConfig `json:"vsanMaxConfig,omitempty"`
}

// EsxUpgradeFailureAction Esx Upgrade failure actions to be taken if host entering maintenance mode failed during esx cluster upgrade
type EsxUpgradeFailureAction struct {
	// Action Action to be taken if entering maintenance mode fails for a host
	Action string `json:"action"`

	// RetryCount Number of times to retry the failed operation. If the action is RETRY, the value should be between 3 and 100. If the action is FAIL, the value should not be set.
	RetryCount int64 `json:"retryCount"`

	// RetryDelay Time to wait before we retry the failed operation in seconds. If action is RETRY, the value should be between 300 and 3600 seconds. If action is FAIL, the value should not be set.
	RetryDelay int64 `json:"retryDelay"`
}

// EsxUpgradeOptionsSpec Options for ESXi upgrade. These are applicable to vSphere Lifecycle Manager Images based upgrade only.
type EsxUpgradeOptionsSpec struct {
	// DisableDpm Flag for disabling DPM on the cluster.
	DisableDpm *bool `json:"disableDpm,omitempty"`

	// DisableHac Flag for disabling HA admission control on the cluster.
	DisableHac *bool `json:"disableHac,omitempty"`

	// EnableQuickPatch Flag for enabling quick patch policy for ESXi upgrade, when applicable, to do live remediation and not require full maintenance mode or reboot. This option is only applicable to vLCM based ESXi upgrade.
	EnableQuickPatch *bool `json:"enableQuickPatch,omitempty"`

	// EnableQuickboot Flag for requesting Quick Boot
	EnableQuickboot *bool `json:"enableQuickboot,omitempty"`

	// EnforceHclValidation Flag for enforcing HCL validation for ESXi upgrade, when applicable, to prevent remediation if hardware compatibility issues are found.
	EnforceHclValidation *bool `json:"enforceHclValidation,omitempty"`

	// EsxUpgradeFailureAction Esx Upgrade failure actions to be taken if host entering maintenance mode failed during esx cluster upgrade
	EsxUpgradeFailureAction *EsxUpgradeFailureAction `json:"esxUpgradeFailureAction,omitempty"`

	// EvacuateOfflineVms Flag for requesting Evacuation of Offline VMs
	EvacuateOfflineVms *bool `json:"evacuateOfflineVms,omitempty"`

	// PreRemediationPowerAction Flag for setting VM power state before entering maintenance mode.
	PreRemediationPowerAction *string `json:"preRemediationPowerAction,omitempty"`
}

// ExpirationDetails Represents expiration details of the credential
type ExpirationDetails struct {
	// ConnectivityStatus Connectivity status
	ConnectivityStatus *string `json:"connectivityStatus,omitempty"`

	// ExpiryDate Expiration date
	ExpiryDate *string `json:"expiryDate,omitempty"`

	// LastCheckedDate Last checked date
	LastCheckedDate *string `json:"lastCheckedDate,omitempty"`

	// Status Expiration status
	Status *string `json:"status,omitempty"`
}

// FcSpec Cluster storage configuration for VMFS on FC
type FcSpec struct {
	// DatastoreName Datastore name used for cluster creation
	DatastoreName string `json:"datastoreName"`
}

// FederatedIdentityProviderInfo The identity management info when the provider is via broker federation
type FederatedIdentityProviderInfo struct {
	// DirectoryList The directory configuration when the provider is via broker federation
	DirectoryList *IdentityProviderDirectory `json:"directoryList,omitempty"`

	// Name The user-friendly name for the Identity Provider
	Name *string `json:"name,omitempty"`

	// OidcInfo Represents Identity management configuration when the provider is based on OIDC
	OidcInfo *OidcInfo `json:"oidcInfo,omitempty"`

	// Source The source of the Identity Provider
	Source *string `json:"source,omitempty"`

	// SyncClientTokenInfo Represents the information about sync client token
	SyncClientTokenInfo *SyncClientTokenInfo `json:"syncClientTokenInfo,omitempty"`

	// SyncClientTokenTTL The lifetime in seconds of the sync client bear token
	SyncClientTokenTTL *int64 `json:"syncClientTokenTTL,omitempty"`
}

// FederatedIdentityProviderSpec The identity management configuration when the provider is via broker federation
type FederatedIdentityProviderSpec struct {
	// Directory The directory configuration when the provider is via broker federation
	Directory *IdentityProviderDirectory `json:"directory,omitempty"`

	// Name The user-friendly name for the Identity Provider
	Name string `json:"name"`

	// OidcSpec Identity management configuration when the Identity Provider is based on oidc
	OidcSpec *OidcSpec `json:"oidcSpec,omitempty"`

	// SyncClientTokenTTL The lifetime in seconds of the sync client bear token, default to 6 months if not specified. This field is deprecated.  It is being made as a query parameter in the sync client token generation API.
	// Deprecated:
	SyncClientTokenTTL *int64 `json:"syncClientTokenTTL,omitempty"`
}

// Fips Represents VCF FIPS mode status (enabled/disabled)
type Fips struct {
	// Enabled VCF FIPS mode status
	Enabled *bool `json:"enabled,omitempty"`
}

// FlexibleProductPatch Model for product async/hot patches with their supported product versions
type FlexibleProductPatch struct {
	// ProductType product type of patch
	ProductType *string `json:"productType,omitempty"`

	// Versions supported versions of patch
	Versions *[]string `json:"versions,omitempty"`
}

// FlexibleProductPatches Model for supported product async/hot patches associated with a VCF release
type FlexibleProductPatches struct {
	// Patches List of available patches on the VCF release
	Patches *[]FlexibleProductPatch `json:"patches,omitempty"`

	// Version Domain VCF release version
	Version *string `json:"version,omitempty"`
}

// FrequencyMetric Represents a single metric representing frequency
type FrequencyMetric struct {
	// Unit Unit of the metric
	Unit *FrequencyMetricUnit `json:"unit,omitempty"`

	// Value Value of the metric
	Value *float64 `json:"value,omitempty"`
}

// FrequencyMetricUnit Unit of the metric
type FrequencyMetricUnit string

// Functionality Defines a functionality model
type Functionality struct {
	// ErrorMessage The localized error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// IsAllowed Flag indicating if a given functionality is allowed/disallowed
	IsAllowed bool `json:"isAllowed"`

	// Type Operation that is represented in machine readable format. The convention is <resource>_<operation>
	Type string `json:"type"`
}

// HardwareSupportInfo Hardware support contains base os, components, hardware support, addOn metadata to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
type HardwareSupportInfo struct {
	// Packages Hardware support packages
	Packages *map[string]HardwareSupportPackageInfo `json:"packages,omitempty"`
}

// HardwareSupportPackage Hardware Support Specification for Firmware Upgrade
type HardwareSupportPackage struct {
	// DisplayName Hardware Support Manager display name
	DisplayName *string `json:"displayName,omitempty"`

	// Name Hardware Support Manager name
	Name string `json:"name"`

	// Pkg Hardware Support Package Specification
	Pkg Package `json:"pkg"`
}

// HardwareSupportPackageInfo Hardware Support Package contains metadata regarding the package, version to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
type HardwareSupportPackageInfo struct {
	// Pkg Hardware support package name
	Pkg *string `json:"pkg,omitempty"`

	// Version Hardware support package version
	Version *string `json:"version,omitempty"`
}

// HardwareSupportPackages Available Hardware Support Manager details
type HardwareSupportPackages struct {
	// DisplayName Hardware Support Manager display name
	DisplayName string `json:"displayName"`

	// Name Hardware Support Manager name
	Name string `json:"name"`

	// Packages Hardware Support Packages
	Packages []Package `json:"packages"`
}

// HardwareSupportSpec Hardware Support Specification for Firmware Upgrade
type HardwareSupportSpec struct {
	// Name Hardware Support Manager name
	Name string `json:"name"`

	// PackageSpec Hardware Support Package Specification
	PackageSpec PackageSpec `json:"packageSpec"`
}

// HciMeshData vSAN remote datastore mount related data for Cluster
type HciMeshData struct {
	// ClientClusters Client Cluster
	ClientClusters *[]string `json:"clientClusters,omitempty"`

	// ComputeOnlyClient Is Cluster Compute only
	ComputeOnlyClient *bool `json:"computeOnlyClient,omitempty"`

	// IsClient Is Cluster Client
	IsClient *bool `json:"isClient,omitempty"`

	// IsHciMeshEnabled vSAN remote datastore mount enabled status
	IsHciMeshEnabled *bool `json:"isHciMeshEnabled,omitempty"`

	// IsServer Is Cluster Server
	IsServer *bool `json:"isServer,omitempty"`

	// Name Cluster name
	Name *string `json:"name,omitempty"`

	// NumberOfClients Client clusters count
	NumberOfClients *int32 `json:"numberOfClients,omitempty"`

	// NumberOfServers Server clusters count
	NumberOfServers *int32 `json:"numberOfServers,omitempty"`

	// PrimaryDataStoreId Primary Datastore Id
	PrimaryDataStoreId *string `json:"primaryDataStoreId,omitempty"`

	// RemoteDatastore Remote Datastore
	RemoteDatastore *string `json:"remoteDatastore,omitempty"`

	// RemoteDatastoreInfos Remote Datastore Infos
	RemoteDatastoreInfos *[]RemoteDatastoreInfo `json:"remoteDatastoreInfos,omitempty"`

	// VsanDataStores vSAN Datastores
	VsanDataStores *[]string `json:"vsanDataStores,omitempty"`
}

// HealthCheckQueryResult HealthCheckQueryResult
type HealthCheckQueryResult struct {
	// Result result
	Result *[]HealthCheckResult `json:"result,omitempty"`

	// ResultId Result id
	ResultId string `json:"resultId"`

	// Status status
	Status string `json:"status"`
}

// HealthCheckResult HealthCheckResult
type HealthCheckResult struct {
	// Description Health check description
	Description string `json:"description"`

	// Id Health Check id
	Id string `json:"id"`

	// Name Health Check name
	Name string `json:"name"`

	// ResourceId ID of the resource, if the ResourceType is CLUSTER, then the resourceId == ClusterId
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceName Name of  resource, if the ResourceType is CLUSTER, then the resourceName == ClusterName
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Type of the health status.
	ResourceType *string `json:"resourceType,omitempty"`

	// Status Type of the health status.
	Status *string `json:"status,omitempty"`

	// Type Type of the health check.
	Type *string `json:"type,omitempty"`
}

// HealthCheckSpec HealthCheck
type HealthCheckSpec struct {
	// Id Health Check id
	Id string `json:"id"`

	// Name Health Check name
	Name string `json:"name"`

	// ResourceName Name of the resource, if the ResourceType is CLUSTER, then the resourceName == ClusterName
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Resource Type
	ResourceType string `json:"resourceType"`

	// Status Health check status
	Status string `json:"status"`
}

// HealthCheckTask HealthCheckTask
type HealthCheckTask struct {
	// Id Health Check task id
	Id string `json:"id"`

	// ResourceStatus Health Check resource status
	ResourceStatus map[string]string `json:"resourceStatus"`

	// Status Health Check task status
	Status string `json:"status"`
}

// HealthChecks Sos Health Checks.
type HealthChecks struct {
	// CertificateHealth Performs Certificate health checks.
	CertificateHealth *bool `json:"certificateHealth,omitempty"`

	// ComputeHealth Performs Compute Health checks.
	ComputeHealth *bool `json:"computeHealth,omitempty"`

	// ConnectivityHealth Performs Connectivity health checks.
	ConnectivityHealth *bool `json:"connectivityHealth,omitempty"`

	// DnsHealth Performs DNS Health checks.
	DnsHealth *bool `json:"dnsHealth,omitempty"`

	// GeneralHealth Performs some generic health checks.
	GeneralHealth *bool `json:"generalHealth,omitempty"`

	// HardwareCompatibilityHealth Performs HardwareCompatibilityHealth Health checks.
	HardwareCompatibilityHealth *bool `json:"hardwareCompatibilityHealth,omitempty"`

	// NtpHealth Performs NTP checks for components.
	NtpHealth *bool `json:"ntpHealth,omitempty"`

	// PasswordHealth Performs Password Expiry checks.
	PasswordHealth *bool `json:"passwordHealth,omitempty"`

	// ServicesHealth Performs checks on Services health.
	ServicesHealth *bool `json:"servicesHealth,omitempty"`

	// StorageHealth Performs Storage Health checks.
	StorageHealth *bool `json:"storageHealth,omitempty"`

	// VersionHealth Perform version checks for VCF components.
	VersionHealth *bool `json:"versionHealth,omitempty"`
}

// HealthSummary defines model for HealthSummary.
type HealthSummary struct {
	// BundleAvailable Indicate if bundle is available in file system.
	BundleAvailable *string `json:"bundleAvailable,omitempty"`

	// BundleName Name of the Support Bundle.
	BundleName *string `json:"bundleName,omitempty"`

	// CompletionTimestamp CompletionTimestamp.
	CompletionTimestamp *string `json:"completionTimestamp,omitempty"`

	// CreationTimestamp CreationTimestamp.
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Description Name of the Operation.
	Description *string `json:"description,omitempty"`

	// Id Id of the Support Bundle task.
	Id *string `json:"id,omitempty"`

	// Status Health summary collection status.
	Status *string `json:"status,omitempty"`
}

// HealthSummaryConfig HealthSummary config
type HealthSummaryConfig struct {
	// Force Run SOS operations, even if there is a Workload running.
	Force *bool `json:"force,omitempty"`

	// SkipKnownHostCheck Skip known_hosts file for HealthSummary.
	SkipKnownHostCheck *bool `json:"skipKnownHostCheck,omitempty"`
}

// HealthSummaryIncludeItems Sos Additional Reports for Health Checks.
type HealthSummaryIncludeItems struct {
	// PrecheckReport Collect VCF LCM Upgrade Pre-check Reports, Default value is False
	PrecheckReport *bool `json:"precheckReport,omitempty"`

	// SummaryReport Collect Vcf Summary Reports
	SummaryReport *bool `json:"summaryReport,omitempty"`
}

// HealthSummaryOption Sos options for support health checks.
type HealthSummaryOption struct {
	// Config HealthSummary config
	Config *HealthSummaryConfig `json:"config,omitempty"`

	// Include Sos Additional Reports for Health Checks.
	Include *HealthSummaryIncludeItems `json:"include,omitempty"`
}

// HealthSummaryScope Domain and cluster under which logs should be collected.
type HealthSummaryScope struct {
	// Domains Domains and Clusters for SOS operation.
	Domains *[]Domains `json:"domains,omitempty"`

	// IncludeAllDomains Include all domains for SOS operation.
	IncludeAllDomains *bool `json:"includeAllDomains,omitempty"`

	// IncludeFreeHosts Include free hosts.
	IncludeFreeHosts *bool `json:"includeFreeHosts,omitempty"`
}

// HealthSummarySpec defines model for HealthSummarySpec.
type HealthSummarySpec struct {
	// HealthChecks Sos Health Checks.
	HealthChecks *HealthChecks `json:"healthChecks,omitempty"`

	// Options Sos options for support health checks.
	Options *HealthSummaryOption `json:"options,omitempty"`

	// Scope Domain and cluster under which logs should be collected.
	Scope *HealthSummaryScope `json:"scope,omitempty"`
}

// HighAvailability This specification contains high availability settings
type HighAvailability struct {
	Enabled bool `json:"enabled"`
}

// History Represents version change history for a resource
type History struct {
	// Versions The list of version change
	Versions *[]Version `json:"versions,omitempty"`
}

// Host Represents an Esxi host in the system
type Host struct {
	// BundleRepoDatastore Bundle repositry datastore for this host
	BundleRepoDatastore *string `json:"bundleRepoDatastore,omitempty"`

	// Cluster Represents a reference to the cluster
	Cluster *ClusterReference `json:"cluster,omitempty"`

	// CompatibleStorageType Information about the host compatible storage type
	CompatibleStorageType *string `json:"compatibleStorageType,omitempty"`

	// ConfigurationStatus Information about the configuration status of the host
	ConfigurationStatus *string `json:"configurationStatus,omitempty"`

	// Cpu Represents information about CPUs on a host
	Cpu *Cpu `json:"cpu,omitempty"`

	// DatastoreType Information about the datastore type of the host
	DatastoreType *string `json:"datastoreType,omitempty"`

	// Domain Represents a domain reference
	Domain *DomainReference `json:"domain,omitempty"`

	// EsxiVersion ESXi software version of the host
	EsxiVersion *string `json:"esxiVersion,omitempty"`

	// Fqdn FQDN of the host
	Fqdn *string `json:"fqdn,omitempty"`

	// HardwareModel Hardware model of the host
	HardwareModel *string `json:"hardwareModel,omitempty"`

	// HardwareVendor Hardware vendor of the host
	HardwareVendor *string `json:"hardwareVendor,omitempty"`

	// HostNetworks Information about Networks on the host
	HostNetworks *[]HostNetwork `json:"hostNetworks,omitempty"`

	// Hybrid Information about the storage type of the host, true if the host is hybrid
	Hybrid *bool `json:"hybrid,omitempty"`

	// Id ID of the host
	Id *string `json:"id,omitempty"`

	// IpAddresses Information about IP addresses assigned to the host
	IpAddresses *[]IpAddress `json:"ipAddresses,omitempty"`

	// IsPrimary Is the host a primary host in VxRail HCI Context
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// IsVsanEsaEligible Is the host vSAN ESA eligible in VxRail HCI Context
	IsVsanEsaEligible *bool `json:"isVsanEsaEligible,omitempty"`

	// Memory Represents information about memory on a host
	Memory *Memory `json:"memory,omitempty"`

	// Networkpool Represents a network pool reference
	Networkpool *NetworkPoolReference `json:"networkpool,omitempty"`

	// Networks Information about Networks on the host This is deprecated
	// Deprecated:
	Networks *[]Network `json:"networks,omitempty"`

	// PhysicalNics Information about physical NICs on the host
	PhysicalNics *[]PhysicalNic `json:"physicalNics,omitempty"`

	// SerialNumber Serial Number of the host
	SerialNumber *string `json:"serialNumber,omitempty"`

	// SoftwareInfo SoftwareSpec contains base os, components, hardware support, addOn metadata to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
	SoftwareInfo *SoftwareInfo `json:"softwareInfo,omitempty"`

	// SshThumbprint SSH Thumbprint of the host
	SshThumbprint *string `json:"sshThumbprint,omitempty"`

	// SslThumbprint SSL Thumbprint of the host
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// Status Status of the host
	Status *string `json:"status,omitempty"`

	// Storage Represents information about storage on a host
	Storage *Storage `json:"storage,omitempty"`

	// Tags Deprecated, this list will always be returned empty
	// Deprecated:
	Tags *[]Tag `json:"tags,omitempty"`
}

// HostCommissionSpec  This specification contains the input to commission a host to VMware Cloud Foundation
type HostCommissionSpec struct {
	// Fqdn FQDN of the host
	Fqdn string `json:"fqdn"`

	// NetworkPoolId ID of the network pool to associate the host with
	NetworkPoolId string `json:"networkPoolId"`

	// NetworkPoolName Name of the network pool to associate the host with
	NetworkPoolName *string `json:"networkPoolName,omitempty"`

	// Password Password of the host
	Password string `json:"password"`

	// SshThumbprint SSH thumbprint of the host
	SshThumbprint *string `json:"sshThumbprint,omitempty"`

	// SslThumbprint SSL thumbprint of the host
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// StorageType Storage Type
	StorageType string `json:"storageType"`

	// Username Username of the host
	Username string `json:"username"`

	// VvolStorageProtocolType vVol Storage Protocol Type
	VvolStorageProtocolType *string `json:"vvolStorageProtocolType,omitempty"`
}

// HostCriterion Represents a criterion for querying the host
type HostCriterion struct {
	// Arguments Arguments required for a particular criterion
	Arguments *map[string]string `json:"arguments,omitempty"`

	// Description Description of the criterion
	Description *string `json:"description,omitempty"`

	// Name Name of the criterion
	Name *string `json:"name,omitempty"`

	// SubCriteria Collection of sub-criterion supported on this criterion
	SubCriteria *[]HostCriterion `json:"subCriteria,omitempty"`
}

// HostDecommissionSpec This specification contains host details required to decommission a host from VMware Cloud Foundation
type HostDecommissionSpec struct {
	// Fqdn FQDN of the host
	Fqdn string `json:"fqdn"`
}

// HostDetail Host Configuration
type HostDetail struct {
	// AzName Availability zone to which the host belongs when the cluster is stretched
	AzName *string `json:"azName,omitempty"`

	// HostName Host name of the vSphere host
	HostName *string `json:"hostName,omitempty"`

	// HostNetworkConfiguration Host Network Configuration.
	HostNetworkConfiguration *HostNetworkConfiguration `json:"hostNetworkConfiguration,omitempty"`

	// Id ID of the host
	Id *string `json:"id,omitempty"`
}

// HostNetwork Represents a network in a Host
type HostNetwork struct {
	// Mtu MTU of the network
	Mtu int32 `json:"mtu"`

	// Type Network Type of the network
	Type string `json:"type"`

	// VlanId VLAN ID associated with the network
	VlanId int32 `json:"vlanId"`
}

// HostNetworkConfiguration Host Network Configuration.
type HostNetworkConfiguration struct {
	// NetworkProfileName The network profile associated with the Host
	NetworkProfileName *string `json:"networkProfileName,omitempty"`

	// VmNics Vmnic-Uplink configuration of the vSphere host
	VmNics *[]HostVmnicUplinkConfiguration `json:"vmNics,omitempty"`
}

// HostNetworkSpec This specification contains network details required when adding a vSphere host to a cluster
type HostNetworkSpec struct {
	// NetworkProfileName Network profile name
	NetworkProfileName *string `json:"networkProfileName,omitempty"`

	// VmNics List of the vSphere host vmNics
	VmNics *[]VmNic `json:"vmNics,omitempty"`
}

// HostPrechecks Represents the status of prechecks done on host
type HostPrechecks struct {
	// Error Error found during prechecks
	Error *string `json:"error,omitempty"`

	// Host Represents an Esxi host in the system
	Host *Host `json:"host,omitempty"`

	// Result Result of the prechecks
	Result *string `json:"result,omitempty"`
}

// HostQueryResponse Represents a host query response
type HostQueryResponse struct {
	// QueryInfo Represents the query info.
	QueryInfo *QueryInfo `json:"queryInfo,omitempty"`

	// Result Represents a page of elements of a single type
	Result *PageHost `json:"result,omitempty"`
}

// HostReference Represents an ESXi host reference
type HostReference struct {
	// AzName Fault domain name of the host
	AzName *string `json:"azName,omitempty"`

	// Fqdn FQDN of the host
	Fqdn *string `json:"fqdn,omitempty"`

	// Id ID of the host
	Id *string `json:"id,omitempty"`

	// IpAddress IP address of the host
	IpAddress *string `json:"ipAddress,omitempty"`

	// VmNics VM NICs of the host
	VmNics *[]VMNicInfo `json:"vmNics,omitempty"`
}

// HostSpec This specification contains information required to add vSphere host to a cluster
type HostSpec struct {
	// AzName Availability Zone Name
	// (This is required while performing a stretched cluster expand operation)
	AzName *string `json:"azName,omitempty"`

	// HostName Host name of the vSphere host
	HostName *string `json:"hostName,omitempty"`

	// HostNetworkSpec This specification contains network details required when adding a vSphere host to a cluster
	HostNetworkSpec *HostNetworkSpec `json:"hostNetworkSpec,omitempty"`

	// Id ID of a vSphere host in the free pool
	Id string `json:"id"`

	// IpAddress IP address of the vSphere host
	IpAddress *string `json:"ipAddress,omitempty"`

	// LicenseKey License key of a vSphere host in the free pool
	// (This is required except in cases where the ESXi host has already been licensed outside of the VMware Cloud Foundation system)
	LicenseKey *string `json:"licenseKey,omitempty"`

	// Password SSH password of the vSphere host
	Password *string `json:"password,omitempty"`

	// SerialNumber Serial Number of the vSphere host
	SerialNumber *string `json:"serialNumber,omitempty"`

	// SshThumbprint SSH thumbprint(fingerprint) of the vSphere host
	// Note:This field will be mandatory in future releases.
	SshThumbprint *string `json:"sshThumbprint,omitempty"`

	// Username Username of the vSphere host
	Username *string `json:"username,omitempty"`
}

// HostVmnicUplinkConfiguration This specification contains vmnic-uplink network configuration of host in a cluster
type HostVmnicUplinkConfiguration struct {
	// Id VmNic ID
	Id *string `json:"id,omitempty"`

	// Uplink Uplink of the VDS associated with the vmnic
	Uplink *string `json:"uplink,omitempty"`

	// VdsName VDS name
	VdsName *string `json:"vdsName,omitempty"`
}

// HostsPrechecksRequest Represents hosts prechecks request
type HostsPrechecksRequest struct {
	// Hosts list of hosts on which prechecks will be done
	Hosts *[]HostCommissionSpec `json:"hosts,omitempty"`
}

// HostsPrechecksResponse Represents hosts prechecks response
type HostsPrechecksResponse struct {
	// ExecutionStatus Overall execution status of hosts prechecks
	ExecutionStatus *string `json:"executionStatus,omitempty"`

	// HostPrechecks precheck done on each host
	HostPrechecks *[]HostPrechecks `json:"hostPrechecks,omitempty"`

	// Id The ID for hosts prechecks
	Id *string `json:"id,omitempty"`

	// Result Result status of the hosts prechecks after it has completed its execution
	Result *string `json:"result,omitempty"`
}

// IdentityProvider Represents Identity Provider and its attributes
type IdentityProvider struct {
	// DomainNames The Domains of the Identity Provider
	DomainNames *[]string `json:"domainNames,omitempty"`

	// FedIdp The identity management info when the provider is via broker federation
	FedIdp *FederatedIdentityProviderInfo `json:"fedIdp,omitempty"`

	// Id ID of the Identity Provider
	Id *string `json:"id,omitempty"`

	// IdentitySources The Identity Sources of the Identity Provider
	IdentitySources *[]VcIdentitySources `json:"identitySources,omitempty"`

	// IdpMessage The message conveyed by VCF for managing the Identity Provider
	IdpMessage *string `json:"idpMessage,omitempty"`

	// Ldap Represents Identity management configuration when the protocol is LDAP
	Ldap *LdapInfo `json:"ldap,omitempty"`

	// Name The user-friendly name for the Identity Provider
	Name *string `json:"name,omitempty"`

	// Oidc Represents Identity management configuration when the provider is based on OIDC
	Oidc *OidcInfo `json:"oidc,omitempty"`

	// Status The status of the Identity Provider (set as ACTIVE for currently enabled Identity Provider)
	Status *string `json:"status,omitempty"`

	// Type The type of the Identity Provider
	Type *string `json:"type,omitempty"`
}

// IdentityProviderDirectory The directory configuration when the provider is via broker federation
type IdentityProviderDirectory struct {
	// DefaultDomain The trusted default domain of the directory
	DefaultDomain *string `json:"defaultDomain,omitempty"`

	// DirectoryId The id of the directory
	DirectoryId *string `json:"directoryId,omitempty"`

	// Domains The set of trusted domains of the directory
	Domains *[]string `json:"domains,omitempty"`

	// FederatedIdpSourceType The type of the Federated IDP
	FederatedIdpSourceType *string `json:"federatedIdpSourceType,omitempty"`

	// Name The user-friendly name for the directory. This must be unique and the allowed symbols are letters in any language, digits (0-9), space, underscore and hyphen
	Name string `json:"name"`
}

// IdentityProviderPrecheckResult Represents Identity Management pre-check result
type IdentityProviderPrecheckResult struct {
	// Details Details about status type and error messages
	Details *[]Details `json:"details,omitempty"`

	// Status One of SUCCESS, WARNING, FAILURE
	Status *string `json:"status,omitempty"`
}

// IdentityProviderSpec Identity Provider Spec
type IdentityProviderSpec struct {
	// CertChain The root certificate chain required to connect to the external server
	CertChain *[]string `json:"certChain,omitempty"`

	// FedIdpSpec The identity management configuration when the provider is via broker federation
	FedIdpSpec *FederatedIdentityProviderSpec `json:"fedIdpSpec,omitempty"`

	// Ldap The LDAP specification when the protocol is LDAP
	Ldap *LdapSpec `json:"ldap,omitempty"`

	// Name The user-friendly name for the Identity Provider
	Name string `json:"name"`

	// Oidc Identity management configuration when the Identity Provider is based on oidc
	Oidc *OidcSpec `json:"oidc,omitempty"`

	// Type The type of Identity Identity Provider
	Type string `json:"type"`
}

// IdentitySourceSpec Identity Source Spec
type IdentitySourceSpec struct {
	// Ldap The LDAP specification when the protocol is LDAP
	Ldap LdapSpec `json:"ldap"`

	// Name The user-friendly name for the identity Source
	Name string `json:"name"`
}

// ImportVdsSpec Import Vds Spec
type ImportVdsSpec struct {
	// ListOfVdsDetails List of details of vSphere Distributed Switches to be imported to the inventory
	ListOfVdsDetails []VdsDetail `json:"listOfVdsDetails"`
}

// InventoryMismatchInfo Represents the inventory mismatch info.
type InventoryMismatchInfo struct {
	// InventoryObjects Inventory object names associated with the mismatch
	InventoryObjects *[]string `json:"inventoryObjects,omitempty"`

	// Type Inventory mismatch type
	Type *string `json:"type,omitempty"`
}

// IpAddress Represents IP address
type IpAddress struct {
	// IpAddress IP address
	IpAddress *string `json:"ipAddress,omitempty"`

	// Type Type of IP addresss
	Type *string `json:"type,omitempty"`
}

// IpAddressPoolRangeSpec This specification contains the parameters required to create an IP address range
type IpAddressPoolRangeSpec struct {
	// End The last IP Address of the IP Address Range
	End string `json:"end"`

	// Start The first IP Address of the IP Address Range
	Start string `json:"start"`
}

// IpAddressPoolSpec This specification contains the parameters required to create or reuse an IP address pool.
type IpAddressPoolSpec struct {
	// Description Description of the IP address pool
	Description *string `json:"description,omitempty"`

	// IgnoreUnavailableNsxtCluster Ignore unavailable NSX cluster(s) during IP pool spec validation
	IgnoreUnavailableNsxtCluster *bool `json:"ignoreUnavailableNsxtCluster,omitempty"`

	// Name Name of the IP address pool
	Name string `json:"name"`

	// Subnets List of IP address pool subnet specification
	Subnets *[]IpAddressPoolSubnetSpec `json:"subnets,omitempty"`
}

// IpAddressPoolSubnetSpec This specification contains the parameters required to create an IP address pool subnet
type IpAddressPoolSubnetSpec struct {
	// Cidr The subnet representation, contains the network address and the prefix length
	Cidr string `json:"cidr"`

	// Gateway The default gateway address of the network
	Gateway string `json:"gateway"`

	// IpAddressPoolRanges List of the IP allocation ranges. Atleast 1 IP address range has to be specified
	IpAddressPoolRanges []IpAddressPoolRangeSpec `json:"ipAddressPoolRanges"`
}

// IpAllocation Defines an IP address with gateway and subnet
type IpAllocation struct {
	// Cidr Classless Inter-Domain Routing (CIDR)
	Cidr *string `json:"cidr,omitempty"`

	// Gateway Gateway
	Gateway *string `json:"gateway,omitempty"`

	// IpAddress IP Address of the ESXi host
	IpAddress string `json:"ipAddress"`

	// Subnet Subnet
	Subnet *string `json:"subnet,omitempty"`
}

// IpPool Represents an IP Pool of a network in a network pool
type IpPool struct {
	// End End IP address of the IP pool
	End string `json:"end"`

	// Start Start IP address of the IP pool
	Start string `json:"start"`
}

// IpRange Spec contains parameters for range of IP addresses
type IpRange struct {
	// EndIpAddress End IP Address
	EndIpAddress string `json:"endIpAddress"`

	// StartIpAddress Start IP Address
	StartIpAddress string `json:"startIpAddress"`
}

// IsolationPrecheckResult Isolation Precheck Results
type IsolationPrecheckResult struct {
	// ExecutionStatus Execution status of the prechecks
	ExecutionStatus string `json:"executionStatus"`

	// Implications Implications of breaking ELM
	Implications *[]string `json:"implications,omitempty"`

	// PrecheckFailures Conditions that will have to be remediated inorder to proceed with isolation operation
	PrecheckFailures *[]string `json:"precheckFailures,omitempty"`

	// PrecheckWarnings Conditions that may have to cause side effects if not remediated during execution of isolation operation
	PrecheckWarnings *[]string `json:"precheckWarnings,omitempty"`
}

// IsolationSpec Domain Isolation Details
type IsolationSpec struct {
	// DomainIdForIsolation Id of the domain that needs to be isolated
	DomainIdForIsolation *string `json:"domainIdForIsolation,omitempty"`

	// SsoDomainSpec Spec for the SSO configuration in a VMware Cloud Foundation Domain
	SsoDomainSpec *SsoDomainSpec `json:"ssoDomainSpec,omitempty"`

	// WorkloadDomainName Name of the domain that needs to be isolated
	WorkloadDomainName *string `json:"workloadDomainName,omitempty"`
}

// LdapInfo Represents Identity management configuration when the protocol is LDAP
type LdapInfo struct {
	// DomainAlias The optional alias to associate the Domain name
	DomainAlias *string `json:"domainAlias,omitempty"`

	// DomainName The name to associate with the created Domain
	DomainName *string `json:"domainName,omitempty"`

	// SourceDetails Details of the Identity Source
	SourceDetails *SourceDetails `json:"sourceDetails,omitempty"`

	// Type The type of the LDAP Server
	Type *string `json:"type,omitempty"`

	// Username User name to connect to LDAP(s) server
	Username *string `json:"username,omitempty"`
}

// LdapSpec The LDAP specification when the protocol is LDAP
type LdapSpec struct {
	// DomainAlias The optional alias to associate the domain name
	DomainAlias *string `json:"domainAlias,omitempty"`

	// DomainName The name to associate with the created domain
	DomainName string `json:"domainName"`

	// Password Password to connect to the ldap(s) server
	Password string `json:"password"`

	// SourceDetails Details of the Identity Source
	SourceDetails *SourceDetails `json:"sourceDetails,omitempty"`

	// Type The type of the LDAP Server
	Type string `json:"type"`

	// Username User name to connect to ldap(s) server
	Username string `json:"username"`
}

// LicenseCheckResource License check resource
type LicenseCheckResource struct {
	// ProductInfo Product Info and License Key Info
	ProductInfo *ProductInfo `json:"productInfo,omitempty"`

	// ResourceInfo Resource info
	ResourceInfo ResourceInfo `json:"resourceInfo"`
}

// LicenseKey Defines a license key and its attributes
type LicenseKey struct {
	// Description Description of the license key given by user
	Description *string `json:"description,omitempty"`

	// Features License key features
	Features *[]string `json:"features,omitempty"`

	// Id The ID of the license key
	Id *string `json:"id,omitempty"`

	// IsUnlimited Indicates if the license key has unlimited usage
	IsUnlimited *bool `json:"isUnlimited,omitempty"`

	// Key The 29 alpha numeric character license key with hyphens
	Key *string `json:"key,omitempty"`

	// LicenseEdition License key edition
	LicenseEdition *string `json:"licenseEdition,omitempty"`

	// LicenseKeyUsage Defines license key usage
	LicenseKeyUsage *LicenseKeyUsage `json:"licenseKeyUsage,omitempty"`

	// LicenseKeyValidity Defines license key validity details
	LicenseKeyValidity *LicenseKeyValidity `json:"licenseKeyValidity,omitempty"`

	// LicenseUnit License capacity unit
	LicenseUnit *string `json:"licenseUnit,omitempty"`

	// MinimumCore The minimum number of core licenses required per CPU, when license unit is cpu core
	MinimumCore *int32 `json:"minimumCore,omitempty"`

	// ProductType The type of the product to which the license key is applicable
	ProductType *string `json:"productType,omitempty"`

	// ProductVersion Product version
	ProductVersion *string `json:"productVersion,omitempty"`
}

// LicenseKeyUpdateSpec Spec for updating a license key
type LicenseKeyUpdateSpec struct {
	// Description String for updating the description of the license key
	Description *string `json:"description,omitempty"`
}

// LicenseKeyUsage Defines license key usage
type LicenseKeyUsage struct {
	// LicenseUnit Units of the license key
	LicenseUnit *string `json:"licenseUnit,omitempty"`

	// Remaining The remaining/free units of the license key
	Remaining *int32 `json:"remaining,omitempty"`

	// Total The total units of the license key
	Total *int32 `json:"total,omitempty"`

	// Used The consumed/used units of the license key
	Used *int32 `json:"used,omitempty"`
}

// LicenseKeyValidity Defines license key validity details
type LicenseKeyValidity struct {
	// ExpiryDate The license key expiry date
	ExpiryDate *string `json:"expiryDate,omitempty"`

	// LicenseKeyStatus The validity status of the license key
	LicenseKeyStatus *string `json:"licenseKeyStatus,omitempty"`
}

// LicensingInfo Licensing information of the resource
type LicensingInfo struct {
	// DaysRemainingToSubscribe Number of days remaining to subscribe
	DaysRemainingToSubscribe *int32 `json:"daysRemainingToSubscribe,omitempty"`

	// Entitlements Entitlements of the resource
	Entitlements *Entitlements `json:"entitlements,omitempty"`

	// IsRegistered Flag indicating the resource is registered for subscription or not
	IsRegistered *bool `json:"isRegistered,omitempty"`

	// IsSubscribed Flag indicating the resource is subscribed or not
	IsSubscribed *bool `json:"isSubscribed,omitempty"`

	// LicensingMode Licensing mode
	LicensingMode *string `json:"licensingMode,omitempty"`

	// ResourceId ID of the resource, need not be set for the resource of the type : SYSTEM
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceType Type of the resource
	ResourceType string `json:"resourceType"`

	// SubscribedState Subscribed state
	SubscribedState *string `json:"subscribedState,omitempty"`

	// SubscriptionStatus Status of the subscription mode
	SubscriptionStatus *string `json:"subscriptionStatus,omitempty"`
}

// LicensingInfoReference Represents a Licensing information
type LicensingInfoReference struct {
	// DaysRemainingToSubscribe Number of days remaining to subscribe
	DaysRemainingToSubscribe *int32 `json:"daysRemainingToSubscribe,omitempty"`

	// IsRegistered Flag indicating the resource is registered for subscription or not
	IsRegistered *bool `json:"isRegistered,omitempty"`

	// IsSubscribed Flag indicating the resource is subscribed or not
	IsSubscribed *bool `json:"isSubscribed,omitempty"`

	// LicensingMode Licensing mode
	LicensingMode *string `json:"licensingMode,omitempty"`

	// SubscriptionStatus Status of the subscription mode
	SubscriptionStatus *string `json:"subscriptionStatus,omitempty"`
}

// LicensingSpec License Information of resources
type LicensingSpec struct {
	// ResourceLicensingInfos List of LicensingInfos of resources
	ResourceLicensingInfos []ResourceLicensingInfo `json:"resourceLicensingInfos"`
}

// LocalAccountPasswordInfo Local user password details
type LocalAccountPasswordInfo struct {
	// NewPassword The new password of the local account
	NewPassword *string `json:"newPassword,omitempty"`

	// OldPassword The old password of the local account
	OldPassword *string `json:"oldPassword,omitempty"`
}

// LocalOsUserAccount Local OS user account details
type LocalOsUserAccount struct {
	// AccountExpiresAt The date and time when the user's account will expire
	AccountExpiresAt *string `json:"accountExpiresAt,omitempty"`

	// LastPasswordChange The date and time when the user last changed their password
	LastPasswordChange *string `json:"lastPasswordChange,omitempty"`

	// MaxDaysBetweenPasswordChange The maximum number of days that a user can keep the same password before being required to change it
	MaxDaysBetweenPasswordChange *int32 `json:"maxDaysBetweenPasswordChange,omitempty"`

	// MinDaysBetweenPasswordChange The minimum number of days that must elapse before a user can change their password again
	MinDaysBetweenPasswordChange *int32 `json:"minDaysBetweenPasswordChange,omitempty"`

	// PasswordExpiresAt The date and time when the user's password will expire
	PasswordExpiresAt *string `json:"passwordExpiresAt,omitempty"`

	// PasswordInactiveAt The date and time when the user's password becomes inactive
	PasswordInactiveAt *string `json:"passwordInactiveAt,omitempty"`

	// Username The username of the local OS account
	Username *string `json:"username,omitempty"`

	// WarnDaysBeforePasswordExpiration The number of days before the password expiration date that the user will be warned
	WarnDaysBeforePasswordExpiration *int32 `json:"warnDaysBeforePasswordExpiration,omitempty"`
}

// LocalUser Represents Local User and its attributes
type LocalUser struct {
	// ApiKey The API key of the user
	ApiKey *string `json:"apiKey,omitempty"`

	// CreationTimestamp The timestamp at which the user was created
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Domain The domain of the user
	Domain *string `json:"domain,omitempty"`

	// Id The ID of the user
	Id *string `json:"id,omitempty"`

	// IsConfigured Flag indicating whether or not local account is configured
	IsConfigured *bool `json:"isConfigured,omitempty"`

	// Name The name of the user
	Name string `json:"name"`

	// Role Represents a role reference
	Role RoleReference `json:"role"`

	// Type The type of the user
	Type string `json:"type"`
}

// LocalizableWarningPack Localization warning pack containing all required data to provide localized warning messages
type LocalizableWarningPack struct {
	// Arguments Arguments used to localize the message
	Arguments *[]string `json:"arguments,omitempty"`

	// DefaultMessage Default warning message in English. Will be used as fallback if a localized message cannot be obtained
	DefaultMessage string `json:"defaultMessage"`

	// LocalBundle Local bundle to be used for localization
	LocalBundle string `json:"localBundle"`

	// ReferenceToken A reference token correlating the warning with the relevant detailed logs. Should be sent to the service provider when reporting issues
	ReferenceToken *string `json:"referenceToken,omitempty"`

	// VipComponent VIP component that contains the message
	VipComponent string `json:"vipComponent"`

	// WarningCode Minor warning code
	WarningCode string `json:"warningCode"`
}

// Logs Logs of different components.
type Logs struct {
	// ApiLogs Collect API Logs.
	ApiLogs *bool `json:"apiLogs,omitempty"`

	// AutomationLogs Collect VMware Aria Automation support logs.
	AutomationLogs *bool `json:"automationLogs,omitempty"`

	// EsxLogs Collect ESX Logs.
	EsxLogs *bool `json:"esxLogs,omitempty"`

	// LifecycleLogs Collect VMware Aria Suite Lifecycle support logs.
	LifecycleLogs *bool `json:"lifecycleLogs,omitempty"`

	// NsxLogs Collect NSX Logs.
	NsxLogs *bool `json:"nsxLogs,omitempty"`

	// OperationsForLogs Collect VMware Aria Operations For Logs support logs.
	OperationsForLogs *bool `json:"operationsForLogs,omitempty"`

	// OperationsLogs Collect VMware Aria Operations support logs.
	OperationsLogs *bool `json:"operationsLogs,omitempty"`

	// SddcManagerLogs Collect SDDC Manager Logs.
	SddcManagerLogs *bool `json:"sddcManagerLogs,omitempty"`

	// SystemDebugLogs Collect SystemDebug Logs.
	SystemDebugLogs *bool `json:"systemDebugLogs,omitempty"`

	// VcLogs Collect vCenter Logs.
	VcLogs *bool `json:"vcLogs,omitempty"`

	// VmScreenshots Collect VMScreenshots.
	VmScreenshots *bool `json:"vmScreenshots,omitempty"`

	// VraLogs [Deprecated] Collect VMware Aria Automation Logs.
	// Deprecated:
	VraLogs *bool `json:"vraLogs,omitempty"`

	// VrliLogs [Deprecated] Collect VMware Aria Operations for Logs Logs.
	// Deprecated:
	VrliLogs *bool `json:"vrliLogs,omitempty"`

	// VropsLogs [Deprecated] Collect VMware Aria Operations Logs.
	// Deprecated:
	VropsLogs *bool `json:"vropsLogs,omitempty"`

	// VrslcmLogs [Deprecated] Collect VMware Aria Suite Lifecycle Logs.
	// Deprecated:
	VrslcmLogs *bool `json:"vrslcmLogs,omitempty"`

	// VxrailManagerLogs Collect VXRailManager Logs.
	VxrailManagerLogs *bool `json:"vxrailManagerLogs,omitempty"`

	// WcpLogs Collect WCP Logs.
	WcpLogs *bool `json:"wcpLogs,omitempty"`
}

// Manifest LCM 2.0 Manifest model that represents the metadata of the VMware Cloud foundation components and releases that Lyfe cycle manager utilises.
type Manifest struct {
	// AsyncPatches Async patches used by Async Patch Tool
	AsyncPatches *map[string][]AsyncPatch `json:"asyncPatches,omitempty"`

	// CreationTime Creation time for the manifest e.g. 2020-06-08T02:20:15.844Z, in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	CreationTime *string `json:"creationTime,omitempty"`

	// PublishedDate Date of publish of the manifest e.g. 2020-06-08T02:20:15.844Z, in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	PublishedDate *string `json:"publishedDate,omitempty"`

	// RecalledBundles Collection of bundles that are recalled and their replacements, if applicable
	RecalledBundles *[]BundleRecall `json:"recalledBundles,omitempty"`

	// Releases Releases of VCF in the ascending order of product version
	Releases *[]Release `json:"releases,omitempty"`

	// SddcManagerReleases Product releases in the ascending order of product version
	SddcManagerReleases *[]SddcManagerRelease `json:"sddcManagerReleases,omitempty"`

	// SequenceNumber Manifest sequence number which signifies an update in manifest
	SequenceNumber *int32 `json:"sequenceNumber,omitempty"`

	// Version Manifest version supported by VCF
	Version *int32 `json:"version,omitempty"`

	// VvsMappings VVS product release Id to VCF version mapping
	VvsMappings *map[string]map[string]VvsVersionAliases `json:"vvsMappings,omitempty"`
}

// Memory Represents information about memory on a host
type Memory struct {
	// TotalCapacityMB Total memory in MB
	TotalCapacityMB *float64 `json:"totalCapacityMB,omitempty"`

	// UsedCapacityMB Used memory in MB
	UsedCapacityMB *float64 `json:"usedCapacityMB,omitempty"`
}

// MemoryInfo Represents a memory metric with used and total for a resource
type MemoryInfo struct {
	// Total Represents a single metric representing digital data
	Total *DataMetric `json:"total,omitempty"`

	// Used Represents a single metric representing digital data
	Used *DataMetric `json:"used,omitempty"`
}

// MessagePack A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
type MessagePack struct {
	// Arguments The arguments used to localize the message. Can be used by scripts to automate the response processing.
	Arguments *[]string `json:"arguments,omitempty"`

	// Bundle The local resource bundle details
	Bundle *string `json:"bundle,omitempty"`

	// Component The component the message belongs to
	Component *string `json:"component,omitempty"`

	// Message The localized message (if not provided by another property)
	Message *string `json:"message,omitempty"`

	// MessageKey The machine-readable key of the message
	MessageKey string `json:"messageKey"`
}

// MicrosoftCertificateAuthoritySpec This specification contains Microsoft CA configuration details
type MicrosoftCertificateAuthoritySpec struct {
	// Secret CA server password
	Secret string `json:"secret"`

	// ServerUrl CA server url
	ServerUrl string `json:"serverUrl"`

	// TemplateName CA server template name
	TemplateName string `json:"templateName"`

	// Username CA server username
	Username string `json:"username"`
}

// NasVolumeSpec NAS configuration for NFS based cluster
type NasVolumeSpec struct {
	// Path Shared directory path used for NFS based cluster creation
	Path string `json:"path"`

	// ReadOnly Readonly is used to identify whether to mount the directory as readOnly or not
	ReadOnly bool `json:"readOnly"`

	// ServerName NFS Server name used for cluster creation
	ServerName []string `json:"serverName"`

	// UserTag User tag used to annotate NFS share
	UserTag *string `json:"userTag,omitempty"`
}

// Network Represents a network in a network pool
type Network struct {
	// FreeIps List of free IPs to use
	FreeIps *[]string `json:"freeIps,omitempty"`

	// Gateway Gateway for the network
	Gateway string `json:"gateway"`

	// Id The ID of the network
	Id *string `json:"id,omitempty"`

	// IpPools List of IP pool ranges to use
	IpPools *[]IpPool `json:"ipPools,omitempty"`

	// Mask Subnet mask for the subnet of the network
	Mask string `json:"mask"`

	// Mtu MTU of the network
	Mtu int32 `json:"mtu"`

	// Subnet Subnet associated with the network
	Subnet string `json:"subnet"`

	// Type Network Type of the network
	Type string `json:"type"`

	// UsedIps List of used IPs
	UsedIps *[]string `json:"usedIps,omitempty"`

	// VlanId VLAN ID associated with the network
	VlanId int32 `json:"vlanId"`
}

// NetworkDetailsSpec This specification contains network parameters required for new virtual machines being added to a workload domain
type NetworkDetailsSpec struct {
	// DnsName DNS name of the virtual machine, e.g., vc-1.domain1.vsphere.local
	DnsName string `json:"dnsName"`

	// Gateway IPv4 gateway the VM can use to connect to the outside world
	Gateway *string `json:"gateway,omitempty"`

	// IpAddress IPv4 address of the virtual machine. Can be omitted if hostname (dnsName) is provded.
	IpAddress *string `json:"ipAddress,omitempty"`

	// SubnetMask Subnet mask
	SubnetMask *string `json:"subnetMask,omitempty"`
}

// NetworkPool Represents a network pool in the system
type NetworkPool struct {
	// Id The ID of the network pool
	Id *string `json:"id,omitempty"`

	// Name User specified name of the network pool
	Name string `json:"name"`

	// Networks Representing the networks associated with the network pool
	Networks []Network `json:"networks"`
}

// NetworkPoolReference Represents a network pool reference
type NetworkPoolReference struct {
	// Id ID of the network pool
	Id string `json:"id"`

	// Name Name of the network pool
	Name *string `json:"name,omitempty"`
}

// NetworkPoolUpdateSpec Network Pool update data
type NetworkPoolUpdateSpec struct {
	// Name Name of the Network Pool
	Name string `json:"name"`
}

// NetworkProfile This specification contains the host switch configurations for the NSX transport node.
type NetworkProfile struct {
	// Description The network profile description
	Description *string `json:"description,omitempty"`

	// IsDefault Designates the network profile as a Global Network Config or Sub Network Config
	IsDefault *bool `json:"isDefault,omitempty"`

	// Name The network profile name
	Name string `json:"name"`

	// NsxtHostSwitchConfigs The list of NSX host switch configurations
	NsxtHostSwitchConfigs []NsxtHostSwitchConfig `json:"nsxtHostSwitchConfigs"`
}

// NetworkProfileConfiguration This configuration contains the host switch configurations for the NSX transport node.
type NetworkProfileConfiguration struct {
	// IsDefault Flag that denotes if the profile is default or not
	IsDefault *bool `json:"isDefault,omitempty"`

	// Name The network profile name
	Name *string `json:"name,omitempty"`

	// NsxtHostSwitchConfigs The list of NSX host switch configurations
	NsxtHostSwitchConfigs *[]NsxtHostSwitchConfiguration `json:"nsxtHostSwitchConfigs,omitempty"`
}

// NetworkSpec This specification contains cluster's network configuration.
type NetworkSpec struct {
	// NetworkProfiles The list of network profiles
	NetworkProfiles *[]NetworkProfile `json:"networkProfiles,omitempty"`

	// NsxClusterSpec This specification contains NSX configuration for cluster
	NsxClusterSpec *NsxClusterSpec `json:"nsxClusterSpec,omitempty"`

	// VdsSpecs Distributed switches to add to the cluster
	VdsSpecs *[]VdsSpec `json:"vdsSpecs,omitempty"`
}

// NfsDatastoreSpec This specification contains cluster storage configuration for NFS
type NfsDatastoreSpec struct {
	// DatastoreName Datastore name used for cluster creation
	DatastoreName string `json:"datastoreName"`

	// NasVolume NAS configuration for NFS based cluster
	NasVolume NasVolumeSpec `json:"nasVolume"`
}

// NiocBandwidthAllocation Network traffic per resource type
type NiocBandwidthAllocation struct {
	// NiocTrafficResourceAllocation Specify network traffic allocation for a resource
	NiocTrafficResourceAllocation *NiocTrafficResourceAllocation `json:"niocTrafficResourceAllocation,omitempty"`

	// Type Host infrastructure traffic type
	Type *string `json:"type,omitempty"`
}

// NiocBandwidthAllocationSpec This specification contains network traffic per resource type
type NiocBandwidthAllocationSpec struct {
	// NiocTrafficResourceAllocation Specify network traffic allocation for a resource
	NiocTrafficResourceAllocation NiocTrafficResourceAllocation `json:"niocTrafficResourceAllocation"`

	// Type DvsHostInfrastructureTrafficResource resource type
	Type string `json:"type"`
}

// NiocSpec Spec contains parameters for Network IO Control
type NiocSpec struct {
	// TrafficType Traffic Type. One among:VSAN, VMOTION, VIRTUALMACHINE, MANAGEMENT, NFS, VDP, HBR, FAULTTOLERANCE, ISCSI
	TrafficType string `json:"trafficType"`

	// Value NIOC Value
	Value string `json:"value"`
}

// NiocTrafficResourceAllocation Specify network traffic allocation for a resource
type NiocTrafficResourceAllocation struct {
	Limit       *int64 `json:"limit,omitempty"`
	Reservation *int64 `json:"reservation,omitempty"`

	// SharesInfo Specify relative allocation between resource consumers
	SharesInfo *SharesInfo `json:"sharesInfo,omitempty"`
}

// NsxALBCluster NSX ALB Cluster
type NsxALBCluster struct {
	// ClusterFqdn NSX Advanced Load Balancer Cluster Virtual fqdn
	ClusterFqdn *string `json:"clusterFqdn,omitempty"`

	// ClusterIpAddress NSX Advanced Load Balancer Cluster Virtual IPv4 address of format 'x.x.x.x'
	ClusterIpAddress *string `json:"clusterIpAddress,omitempty"`

	// ClusterName Name of NSX Advanced Load Balancer Cluster
	ClusterName *string `json:"clusterName,omitempty"`

	// ClusterStatus NSX Advanced Load Balancer Cluster status
	ClusterStatus *string `json:"clusterStatus,omitempty"`

	// DeploymentStatus NSX Advanced Load Balancer Deployment Status
	DeploymentStatus *string `json:"deploymentStatus,omitempty"`

	// Domains Collection of IDs of Workload Domains where NSX Advanced Load Balancer Cluster is deployed
	Domains *[]DomainReference `json:"domains,omitempty"`

	// Id ID of the NSX Advanced Load Balancer Cluster
	Id *string `json:"id,omitempty"`

	// NsxClusters Collection of IDs of the NSX where NSX Advanced Load Balancer Cluster is deployed
	NsxClusters *[]NsxTClusterReference `json:"nsxClusters,omitempty"`

	// Version NSX Advanced Load Balancer Cluster version
	Version *string `json:"version,omitempty"`
}

// NsxAlbControllerClusterSpec NSX Alb cluster creation data
type NsxAlbControllerClusterSpec struct {
	// AdminPassword Admin user password of NSX Advanced Load Balancer Cluster
	AdminPassword *string `json:"adminPassword,omitempty"`

	// BundleId NSX Advanced Load Balancer Bundle ID
	BundleId *string `json:"bundleId,omitempty"`

	// ClusterFqdn NSX Advanced Load Balancer Cluster fully qualified domain name
	ClusterFqdn *string `json:"clusterFqdn,omitempty"`

	// ClusterIpAddress NSX Advanced Load Balancer Cluster Virtual IPv4 address of format 'x.x.x.x'
	ClusterIpAddress *string `json:"clusterIpAddress,omitempty"`

	// ClusterName Name of NSX Advanced Load Balancer Cluster
	ClusterName *string `json:"clusterName,omitempty"`

	// DomainIds IDs of the workload Domains where NSX Advanced Load Balancer Cluster will be deployed
	DomainIds *[]string `json:"domainIds,omitempty"`

	// FormFactor Size of NSX ALB cluster
	FormFactor *string `json:"formFactor,omitempty"`

	// Nodes NSX Advanced Load Balancer Cluster Controller Nodes
	Nodes *[]NsxAlbControllerNodeSpec `json:"nodes,omitempty"`
}

// NsxAlbControllerNodeSpec NSX ALB Node representation
type NsxAlbControllerNodeSpec struct {
	// IpAddress IPv4 address of NSX Advanced Load Balancer Node
	IpAddress *string `json:"ipAddress,omitempty"`
}

// NsxAlbVersionValidationSpec NSX Alb cluster creation data
type NsxAlbVersionValidationSpec struct {
	// BundleId NSX Advanced Load Balancer Bundle ID
	BundleId *string `json:"bundleId,omitempty"`

	// DomainIds IDs of the WorkLoadDomain where NSX Advanced Load Balancer Cluster will be deployed
	DomainIds *[]string `json:"domainIds,omitempty"`
}

// NsxClusterSpec This specification contains NSX configuration for cluster
type NsxClusterSpec struct {
	// NsxTClusterSpec This specification contains NSX configuration for a new cluster.
	NsxTClusterSpec *NsxTClusterSpec `json:"nsxTClusterSpec,omitempty"`
}

// NsxManagerSpec This specification contains the parameters required to install and configure NSX Manager in a workload domain
type NsxManagerSpec struct {
	// Name Name of the NSX Manager virtual machine
	Name *string `json:"name,omitempty"`

	// NetworkDetailsSpec This specification contains network parameters required for new virtual machines being added to a workload domain
	NetworkDetailsSpec NetworkDetailsSpec `json:"networkDetailsSpec"`
}

// NsxStretchClusterSpec This specification contains NSX configuration for Secondary AZ Hosts
type NsxStretchClusterSpec struct {
	// IpAddressPoolsSpec The IP address pool specifications
	IpAddressPoolsSpec *[]IpAddressPoolSpec `json:"ipAddressPoolsSpec,omitempty"`

	// UplinkProfiles The list of uplink profile specifications.
	UplinkProfiles []UplinkProfile `json:"uplinkProfiles"`
}

// NsxTCluster NSX Cluster representation
type NsxTCluster struct {
	// Domains Information about the domains associated with the cluster
	Domains *[]DomainReference `json:"domains,omitempty"`

	// Id ID of the cluster
	Id *string `json:"id,omitempty"`

	// IsShareable Boolean to identify if the NSX cluster can be shared to create a new workload domain
	IsShareable *bool `json:"isShareable,omitempty"`

	// IsShared Boolean to identify if the NSX cluster is shared among workload domains
	IsShared *bool `json:"isShared,omitempty"`

	// IsVlcmCompatible Boolean to identify if the NSX cluster is compatible with vLCM. This should not be used to determineif vLCM Clusters can be created on the domain
	IsVlcmCompatible *bool `json:"isVlcmCompatible,omitempty"`

	// NativeId [Deprecated] Native ID of the NSX cluster
	// Deprecated:
	NativeId *string `json:"nativeId,omitempty"`

	// Nodes Information about the NSX managers associated with the cluster
	Nodes *[]NsxTManager `json:"nodes,omitempty"`

	// Status NSX cluster status. To get NSX cluster status invoke nsxt-clusters query API with criterion NSXT_CLUSTERS_WITH_STATUS
	Status *string `json:"status,omitempty"`

	// Version Version of the NSX managers associated with the cluster
	Version *string `json:"version,omitempty"`

	// Vip VIP (Virtual IP Address) of the cluster
	Vip *string `json:"vip,omitempty"`

	// VipFqdn FQDN for VIP of the cluster
	VipFqdn *string `json:"vipFqdn,omitempty"`
}

// NsxTClusterReference Represents an NSX Cluster reference
type NsxTClusterReference struct {
	// Id ID of the NSX cluster
	Id *string `json:"id,omitempty"`

	// Vip VIP (Virtual IP Address) of the NSX cluster
	Vip *string `json:"vip,omitempty"`

	// VipFqdn FQDN for VIP of the NSX cluster
	VipFqdn *string `json:"vipFqdn,omitempty"`
}

// NsxTClusterSpec This specification contains NSX configuration for a new cluster.
type NsxTClusterSpec struct {
	// GeneveVlanId Vlan id of Geneve. (This field is deprecated, instead please use transportVlan in uplinkProfiles)
	// Deprecated:
	GeneveVlanId *int32 `json:"geneveVlanId,omitempty"`

	// IpAddressPoolSpec This specification contains the parameters required to create or reuse an IP address pool.
	IpAddressPoolSpec *IpAddressPoolSpec `json:"ipAddressPoolSpec,omitempty"`

	// IpAddressPoolsSpec The list of IP address pools specification
	IpAddressPoolsSpec *[]IpAddressPoolSpec `json:"ipAddressPoolsSpec,omitempty"`

	// UplinkProfiles The list of uplink profile specifications.
	UplinkProfiles *[]UplinkProfile `json:"uplinkProfiles,omitempty"`
}

// NsxTCriterion Represents a criterion for querying the NSX cluster
type NsxTCriterion struct {
	// Arguments Arguments required for a particular criterion
	Arguments *map[string]string `json:"arguments,omitempty"`

	// Description Description of the criterion
	Description *string `json:"description,omitempty"`

	// Name Name of the criterion
	Name *string `json:"name,omitempty"`
}

// NsxTEdgeClusterProfileSpec This specification contains edge cluster profile configurations
type NsxTEdgeClusterProfileSpec struct {
	// BfdAllowedHop BFD allowed Hop
	BfdAllowedHop int64 `json:"bfdAllowedHop"`

	// BfdDeclareDeadMultiple BFD Declare Dead Multiple
	BfdDeclareDeadMultiple int64 `json:"bfdDeclareDeadMultiple"`

	// BfdProbeInterval BFD Probe
	BfdProbeInterval int64 `json:"bfdProbeInterval"`

	// EdgeClusterProfileName Name for the edge cluster profile.
	EdgeClusterProfileName string `json:"edgeClusterProfileName"`

	// StandbyRelocationThreshold Standby Relocation Threshold
	StandbyRelocationThreshold int64 `json:"standbyRelocationThreshold"`
}

// NsxTEdgeNodeSpec This specification contains configuration inputs required to deploy and configure an edge node
type NsxTEdgeNodeSpec struct {
	// ClusterId ID of vSphere cluster where the Edge node will be deployed
	ClusterId *string `json:"clusterId,omitempty"`

	// EdgeNodeName Edge Node Name
	EdgeNodeName string `json:"edgeNodeName"`

	// EdgeTep1IP Edge TEP 1 IP
	EdgeTep1IP *string `json:"edgeTep1IP,omitempty"`

	// EdgeTep2IP Edge TEP 2 IP
	EdgeTep2IP *string `json:"edgeTep2IP,omitempty"`

	// EdgeTepGateway Edge TEP Gateway IP
	EdgeTepGateway *string `json:"edgeTepGateway,omitempty"`

	// EdgeTepIpAddressPool This specification indicates which NSX IP pool to use for an Edge node's TEPs
	EdgeTepIpAddressPool *EdgeTepIpAddressPoolSpec `json:"edgeTepIpAddressPool,omitempty"`

	// EdgeTepVlan Edge TEP VLAN
	EdgeTepVlan int32 `json:"edgeTepVlan"`

	// FirstNsxVdsUplink First NSX enabled VDS uplink for the Edge node
	FirstNsxVdsUplink *string `json:"firstNsxVdsUplink,omitempty"`

	// InterRackCluster Is inter-rack cluster(true for L2 non-uniform and L3 : At least one of management, uplink, Edge and host TEP networks is different for hosts of the cluster, false for L2 uniform :   All hosts in cluster have identical management, uplink, Edge and host TEP networks)
	InterRackCluster *bool `json:"interRackCluster,omitempty"`

	// ManagementGateway Management Gateway IP
	ManagementGateway string `json:"managementGateway"`

	// ManagementIP Management Interface IP
	ManagementIP string `json:"managementIP"`

	// SecondNsxVdsUplink Second NSX enabled VDS uplink for the Edge node
	SecondNsxVdsUplink *string `json:"secondNsxVdsUplink,omitempty"`

	// UplinkNetwork Specifications of Tier0 uplinks for the Edge Node. For edge cluster creation uplink network is mandatory otherwise its optional an field
	UplinkNetwork *[]NsxTEdgeUplinkNetwork `json:"uplinkNetwork,omitempty"`

	// VmManagementPortgroupName Management Network Name
	VmManagementPortgroupName *string `json:"vmManagementPortgroupName,omitempty"`

	// VmManagementPortgroupVlan Management Vlan Id
	VmManagementPortgroupVlan *int32 `json:"vmManagementPortgroupVlan,omitempty"`
}

// NsxTEdgeUplinkNetwork This specification contains input  parameters required to configure  uplink network for NSX  edge node VM
type NsxTEdgeUplinkNetwork struct {
	// AsnPeer [Deprecated] ASN of Peer (please use bgpPeers instead)
	// Deprecated:
	AsnPeer *int64 `json:"asnPeer,omitempty"`

	// BgpPeerPassword [Deprecated] BGP Peer Password (please use bgpPeers instead)
	// Deprecated:
	BgpPeerPassword *string `json:"bgpPeerPassword,omitempty"`

	// BgpPeers List of BGP Peer configuration
	BgpPeers *[]BgpPeerSpec `json:"bgpPeers,omitempty"`

	// PeerIP [Deprecated] BGP Peer IP (please use bgpPeers instead)
	// Deprecated:
	PeerIP *string `json:"peerIP,omitempty"`

	// UplinkInterfaceIP Uplink IP
	UplinkInterfaceIP string `json:"uplinkInterfaceIP"`

	// UplinkVlan Uplink Vlan
	UplinkVlan int32 `json:"uplinkVlan"`
}

// NsxTManager NSX Manager representation
type NsxTManager struct {
	// Fqdn FQDN of the manager
	Fqdn *string `json:"fqdn,omitempty"`

	// Id ID of the manager
	Id *string `json:"id,omitempty"`

	// IpAddress IP address of the manager
	IpAddress *string `json:"ipAddress,omitempty"`

	// Name NSX Manager VM name in vCenter
	Name *string `json:"name,omitempty"`
}

// NsxTQueryResponse Represents a NSX cluster query response.
type NsxTQueryResponse struct {
	// QueryInfo Represents the query info.
	QueryInfo *QueryInfo `json:"queryInfo,omitempty"`

	// Result Represents a page of elements of a single type
	Result *PageNsxTCluster `json:"result,omitempty"`
}

// NsxTSpec This specification contains the parameters required to install and configure NSX in a workload domain
type NsxTSpec struct {
	// FormFactor NSX manager form factor
	FormFactor *string `json:"formFactor,omitempty"`

	// IpAddressPoolSpec This specification contains the parameters required to create or reuse an IP address pool.
	IpAddressPoolSpec *IpAddressPoolSpec `json:"ipAddressPoolSpec,omitempty"`

	// LicenseKey NSX license value
	LicenseKey *string `json:"licenseKey,omitempty"`

	// NsxManagerAdminPassword NSX manager admin password (basic auth and SSH)
	NsxManagerAdminPassword *string `json:"nsxManagerAdminPassword,omitempty"`

	// NsxManagerAuditPassword NSX manager Audit password
	NsxManagerAuditPassword *string `json:"nsxManagerAuditPassword,omitempty"`

	// NsxManagerSpecs Specification details of the NSX Manager virtual machine
	NsxManagerSpecs []NsxManagerSpec `json:"nsxManagerSpecs"`

	// Vip Virtual IP address which would act as proxy/alias for NSX Managers. Can be omitted if FQDN is provided.
	Vip *string `json:"vip,omitempty"`

	// VipFqdn FQDN for VIP so that common SSL certificates can be installed across all managers
	VipFqdn string `json:"vipFqdn"`
}

// NsxTransportZone The transport zone associated with the vSphere Distributed Switch used by NSX
type NsxTransportZone struct {
	// Name The name of the transport zone
	Name *string `json:"name,omitempty"`

	// TransportType The type of the transport zone
	TransportType *string `json:"transportType,omitempty"`
}

// NsxtEdgeCluster NSX Edge Cluster Upgrade Resource
type NsxtEdgeCluster struct {
	// Id Edge cluster id
	Id *string `json:"id,omitempty"`

	// Name Edge cluster name
	Name *string `json:"name,omitempty"`

	// ResourceHealth Current resource health status
	ResourceHealth *string `json:"resourceHealth,omitempty"`

	// UpgradeStatus Upgrade status with respect to the bundle
	UpgradeStatus *string `json:"upgradeStatus,omitempty"`

	// Version The current version of the edge cluster.If a partial upgrade is done, this will be the least version among the edges in the edge cluster
	Version *string `json:"version,omitempty"`
}

// NsxtEdgeClusterUpgradeSpec Host transport node cluster upgrade input
type NsxtEdgeClusterUpgradeSpec struct {
	// EdgeClusterId Resource ID of the edge transport node cluster
	EdgeClusterId string `json:"edgeClusterId"`

	// EdgeParallelUpgrade disable/enable parallel upgrade of edges within the cluster
	EdgeParallelUpgrade *bool `json:"edgeParallelUpgrade,omitempty"`
}

// NsxtHostCluster NSX Host Cluster Upgrade Resource
type NsxtHostCluster struct {
	// AvailableHardwareSupportManagers Available Hardware Support Managers for Firmware upgrade
	AvailableHardwareSupportManagers *[]HardwareSupportPackages `json:"availableHardwareSupportManagers,omitempty"`

	// ConfiguredHardwareSupportManagers Configured Hardware Support Managers for Firmware upgrade
	ConfiguredHardwareSupportManagers *[]HardwareSupportPackage `json:"configuredHardwareSupportManagers,omitempty"`

	// DomainId Id of the domain the Host cluster belongs to
	DomainId *string `json:"domainId,omitempty"`

	// Id Host cluster VCF cluster id
	Id *string `json:"id,omitempty"`

	// Name Cluster name
	Name *string `json:"name,omitempty"`

	// PrimaryCluster Flag to determine if primary cluster for vLCM
	PrimaryCluster *bool `json:"primaryCluster,omitempty"`

	// ResourceHealth Current resource health status
	ResourceHealth *string `json:"resourceHealth,omitempty"`

	// TotalUnits Total number of hosts in the Host cluster
	TotalUnits *int32 `json:"totalUnits,omitempty"`

	// UpgradeStatus Upgrade status with respect to the bundle
	UpgradeStatus *string `json:"upgradeStatus,omitempty"`

	// UpgradedUnits Number of hosts which are already upgraded
	UpgradedUnits *int32 `json:"upgradedUnits,omitempty"`

	// VLcmEnabled Flag to determine if vLCM enabled on the cluster
	VLcmEnabled *bool `json:"vLcmEnabled,omitempty"`

	// Version The current version of the host node cluster.If a partial upgrade is done, this will be the least version among the hosts
	Version *string `json:"version,omitempty"`
}

// NsxtHostClusterUpgradeSpec Host trnasport node cluster upgrade input
type NsxtHostClusterUpgradeSpec struct {
	// HostClusterId Resource ID of the host transport node cluster
	HostClusterId string `json:"hostClusterId"`

	// HostParallelUpgrade Flag for disabling/enabling parallel upgrade within the cluster
	HostParallelUpgrade *bool `json:"hostParallelUpgrade,omitempty"`

	// LiveUpgrade Flag for disabling/enabling live upgrade of hosts in the transportnode clusters
	LiveUpgrade *bool `json:"liveUpgrade,omitempty"`
}

// NsxtHostSwitchConfig This specification contains the configurations to be applied on the Host switch.
type NsxtHostSwitchConfig struct {
	// IpAddressPoolName The IP address pool name
	IpAddressPoolName *string `json:"ipAddressPoolName,omitempty"`

	// UplinkProfileName The name of the uplink profile
	UplinkProfileName string `json:"uplinkProfileName"`

	// VdsName The name of the vSphere Distributed Switch
	VdsName string `json:"vdsName"`

	// VdsUplinkToNsxUplink The map of vSphere Distributed Switch uplinks to the NSX switch uplinks.
	VdsUplinkToNsxUplink []UplinkMapping `json:"vdsUplinkToNsxUplink"`
}

// NsxtHostSwitchConfiguration The configurations to be applied on the Host switch.
type NsxtHostSwitchConfiguration struct {
	// IpAddressPoolName The IP address Pool name. For DHCP, this field will be empty
	IpAddressPoolName *string `json:"ipAddressPoolName,omitempty"`

	// UplinkProfileName The name of the uplink profile
	UplinkProfileName *string `json:"uplinkProfileName,omitempty"`

	// VdsName The name of the vSphere Distributed Switch
	VdsName *string `json:"vdsName,omitempty"`

	// VdsUplinkToNsxUplink The map of vSphere Distributed Switch uplinks to the NSX switch uplinks.
	VdsUplinkToNsxUplink *[]VdsUplinkToNsxUplinkConfiguration `json:"vdsUplinkToNsxUplink,omitempty"`
}

// NsxtIpAddressPool NSX IP address pool representation
type NsxtIpAddressPool struct {
	// AvailableIpAddresses The number of IP addresses available in the IP address pool
	AvailableIpAddresses *int32 `json:"availableIpAddresses,omitempty"`

	// BlockSubnets The list of IP address pool block subnets
	BlockSubnets *[]NsxtIpAddressPoolBlockSubnet `json:"blockSubnets,omitempty"`

	// Description Description of the IP address pool
	Description *string `json:"description,omitempty"`

	// Name Name of the IP address pool
	Name *string `json:"name,omitempty"`

	// StaticSubnets The list of IP address pool static subnets
	StaticSubnets *[]NsxtIpAddressPoolStaticSubnet `json:"staticSubnets,omitempty"`

	// TotalIpAddresses The total number of IP addresses in the IP address pool
	TotalIpAddresses *int32 `json:"totalIpAddresses,omitempty"`
}

// NsxtIpAddressPoolBlockSubnet NSX IP address pool block subnet representation
type NsxtIpAddressPoolBlockSubnet struct {
	// Cidr The CIDR of the IP address subnet
	Cidr *string `json:"cidr,omitempty"`

	// GatewayAssigned The boolean representing the state of the gateway assignment
	GatewayAssigned *bool `json:"gatewayAssigned,omitempty"`

	// Size The size of the IP address block
	Size *int32 `json:"size,omitempty"`
}

// NsxtIpAddressPoolRange NSX IP address pool range representation
type NsxtIpAddressPoolRange struct {
	// End The end of the IP address range
	End *string `json:"end,omitempty"`

	// Start The start of the IP address range
	Start *string `json:"start,omitempty"`
}

// NsxtIpAddressPoolStaticSubnet NSX IP address pool static subnet representation
type NsxtIpAddressPoolStaticSubnet struct {
	// Cidr The CIDR of the IP address subnet
	Cidr *string `json:"cidr,omitempty"`

	// Gateway The gateway IP address
	Gateway *string `json:"gateway,omitempty"`

	// IpAddressPoolRanges The list of IP address ranges
	IpAddressPoolRanges *[]NsxtIpAddressPoolRange `json:"ipAddressPoolRanges,omitempty"`
}

// NsxtIpAddressPoolValidationSpec defines model for NsxtIpAddressPoolValidationSpec.
type NsxtIpAddressPoolValidationSpec struct {
	// IpAddressPoolSpec This specification contains the parameters required to create or reuse an IP address pool.
	IpAddressPoolSpec IpAddressPoolSpec `json:"ipAddressPoolSpec"`
	NsxtClusterId     *string           `json:"nsxtClusterId,omitempty"`
}

// NsxtManagerCluster Nsx Manager Cluster Upgrade Resource
type NsxtManagerCluster struct {
	// Id Manager cluster id
	Id *string `json:"id,omitempty"`

	// Name Manager cluster name
	Name *string `json:"name,omitempty"`

	// ResourceHealth Current resource health status
	ResourceHealth *string `json:"resourceHealth,omitempty"`

	// UpgradeStatus Upgrade status with respect to the bundle
	UpgradeStatus *string `json:"upgradeStatus,omitempty"`

	// Version The current version of the manager cluster.If a partial upgrade is done, this will be the least version among the managers in the manager cluster
	Version *string `json:"version,omitempty"`
}

// NsxtManagerSpec Spec contains parameters for NSX manager
type NsxtManagerSpec struct {
	// Hostname NSX Manager hostname
	Hostname *string `json:"hostname,omitempty"`

	// Ip NSX Manager IP Address. Can be omitted if hostname is provided.
	Ip *string `json:"ip,omitempty"`
}

// NsxtOidcSpec Spec for the parameters required to add OpenId connection to NSX
type NsxtOidcSpec struct {
	// EntityInventoryId VCF Inventory identificator of the entity to connect oidc
	EntityInventoryId string `json:"entityInventoryId"`

	// OidcType Type of the oidc entity.
	OidcType NsxtOidcSpecOidcType `json:"oidcType"`
}

// NsxtOidcSpecOidcType Type of the oidc entity.
type NsxtOidcSpecOidcType string

// NsxtResources NSX Upgrade Resources for an NSX instance
type NsxtResources struct {
	// BundleId Bundle id used to compute the upgradability
	BundleId *string `json:"bundleId,omitempty"`

	// DomainId Domain id associated with the NSX cluster
	DomainId *string `json:"domainId,omitempty"`

	// NsxtEdgeClusters List of edge clusters that are candidates for upgrade
	NsxtEdgeClusters *[]NsxtEdgeCluster `json:"nsxtEdgeClusters,omitempty"`

	// NsxtHostClusters List of host clusters that are candidates for upgrade
	NsxtHostClusters *[]NsxtHostCluster `json:"nsxtHostClusters,omitempty"`

	// NsxtManagerCluster Nsx Manager Cluster Upgrade Resource
	NsxtManagerCluster *NsxtManagerCluster `json:"nsxtManagerCluster,omitempty"`

	// NsxtUpgradeCoordinator NSX Upgrade coordinator Upgrade Resource
	NsxtUpgradeCoordinator *NsxtUpgradeCoordinator `json:"nsxtUpgradeCoordinator,omitempty"`
}

// NsxtSwitchConfig This specification contains the configurations to be associated with the vSphere Distributed Switch managed by NSX
type NsxtSwitchConfig struct {
	// HostSwitchOperationalMode Operational mode type of a Host Switch. Applicable only for the VI Workload Domains.
	HostSwitchOperationalMode *string `json:"hostSwitchOperationalMode,omitempty"`

	// TransportZones The list of transport zones to be associated with the vSphere Distributed Switch managed by NSX
	TransportZones []TransportZone `json:"transportZones"`
}

// NsxtSwitchConfiguration The network configurations associated with the vSphere Distributed Switch managed by NSX
type NsxtSwitchConfiguration struct {
	// HostSwitchOperationalMode Operational mode of a Host Switch
	HostSwitchOperationalMode *string `json:"hostSwitchOperationalMode,omitempty"`

	// TransportZones The list of transport zones associated with the vSphere Distributed Switch managed by NSX
	TransportZones *[]NsxTransportZone `json:"transportZones,omitempty"`
}

// NsxtTransportZone Spec contains required parameters for NSX Transport Zone
type NsxtTransportZone struct {
	// NetworkName Transport zone network name
	NetworkName string `json:"networkName"`

	// ZoneName Transport zone name
	ZoneName string `json:"zoneName"`
}

// NsxtTransportZoneInfo NSX transport zone representation.
type NsxtTransportZoneInfo = map[string]interface{}

// NsxtUpgradeCoordinator NSX Upgrade coordinator Upgrade Resource
type NsxtUpgradeCoordinator struct {
	// EnabledOn The IP of the manager on which UC is enabled
	EnabledOn *string `json:"enabledOn,omitempty"`

	// Id Upgrade coordinator id
	Id *string `json:"id,omitempty"`

	// ResourceHealth Current resource health status
	ResourceHealth *string `json:"resourceHealth,omitempty"`

	// UpgradeStatus Upgrade status with respect to the bundle
	UpgradeStatus *string `json:"upgradeStatus,omitempty"`

	// Version The current version of the UC
	Version *string `json:"version,omitempty"`
}

// NsxtUpgradeOptions NSX Upgrade options
type NsxtUpgradeOptions struct {
	// IsEdgeClustersUpgradeParallel Flag for disabling/enabling parallel upgrade of edge transportnode clusters
	IsEdgeClustersUpgradeParallel *bool `json:"isEdgeClustersUpgradeParallel,omitempty"`

	// IsEdgeOnlyUpgrade Flag for performing edge-only upgrade
	IsEdgeOnlyUpgrade *bool `json:"isEdgeOnlyUpgrade,omitempty"`

	// IsHostClustersUpgradeParallel Flag for disabling/enabling parallel upgrade of host transportnode clusters
	IsHostClustersUpgradeParallel *bool `json:"isHostClustersUpgradeParallel,omitempty"`
}

// NsxtUpgradeUserInputSpec NSX Upgrade User Input Specification
type NsxtUpgradeUserInputSpec struct {
	// NsxtEdgeClusterUpgradeSpecs List of edge clusters information if explicit selection is to be made
	NsxtEdgeClusterUpgradeSpecs *[]NsxtEdgeClusterUpgradeSpec `json:"nsxtEdgeClusterUpgradeSpecs,omitempty"`

	// NsxtHostClusterUpgradeSpecs List of host clusters information if explicit selection is to be made
	NsxtHostClusterUpgradeSpecs *[]NsxtHostClusterUpgradeSpec `json:"nsxtHostClusterUpgradeSpecs,omitempty"`

	// NsxtId Identifier of the NSX instance
	NsxtId *string `json:"nsxtId,omitempty"`

	// NsxtUpgradeOptions NSX Upgrade options
	NsxtUpgradeOptions *NsxtUpgradeOptions `json:"nsxtUpgradeOptions,omitempty"`
}

// NtpConfiguration NTP Configuration
type NtpConfiguration struct {
	// NtpServers List of NTP servers
	NtpServers []NtpServer `json:"ntpServers"`
}

// NtpServer NTP server details
type NtpServer struct {
	// IpAddress IP address/FQDN of NTP server
	IpAddress string `json:"ipAddress"`
}

// OidcInfo Represents Identity management configuration when the provider is based on OIDC
type OidcInfo struct {
	// AuthEndpoint Authentication endpoint of the Identity Provider
	AuthEndpoint *string `json:"authEndpoint,omitempty"`

	// AuthMethod Authentication method used by the Identity Provider
	AuthMethod *string `json:"authMethod,omitempty"`

	// ClientId Client identifier to connect to the Identity Provider
	ClientId *string `json:"clientId,omitempty"`

	// DiscoveryEndpoint Endpoint to retrieve the Identity Provider metadata
	DiscoveryEndpoint *string `json:"discoveryEndpoint,omitempty"`

	// Issuer The Identity Provider namespace. It is used to validate the issuer in the acquired OAuth2 token
	Issuer *string `json:"issuer,omitempty"`

	// LogoutEndpoint The endpoint to use for terminating the user's session at the Identity Provider
	LogoutEndpoint *string `json:"logoutEndpoint,omitempty"`

	// PublicKeyUri Endpoint to retrieve the Identity Provider public key for validation
	PublicKeyUri *string `json:"publicKeyUri,omitempty"`

	// TokenEndpoint Token endpoint of the Identity Provider
	TokenEndpoint *string `json:"tokenEndpoint,omitempty"`
}

// OidcSpec Identity management configuration when the Identity Provider is based on oidc
type OidcSpec struct {
	// ClientId Client identifier to connect to the provider
	ClientId string `json:"clientId"`

	// ClientSecret The secret shared between the client and the provider
	ClientSecret string `json:"clientSecret"`

	// DiscoveryEndpoint Endpoint to retrieve the provider metadata
	DiscoveryEndpoint string `json:"discoveryEndpoint"`
}

// OpenSSLCertificateAuthoritySpec This specification contains OpenSSL CA configuration details
type OpenSSLCertificateAuthoritySpec struct {
	// CommonName OpenSSL CA domain name
	CommonName string `json:"commonName"`

	// Country ISO 3166 country code where company is legally registered
	Country string `json:"country"`

	// Locality The city or locality where company is legally registered
	Locality string `json:"locality"`

	// Organization The name under which company is legally registered
	Organization string `json:"organization"`

	// OrganizationUnit Organization with which the certificate is associated
	OrganizationUnit string `json:"organizationUnit"`

	// State The full name of the state where company is legally registered
	State string `json:"state"`
}

// Package Hardware Support Package Specification
type Package struct {
	// Name Package name
	Name string `json:"name"`

	// Version Package version
	Version string `json:"version"`
}

// PackageSpec Hardware Support Package Specification
type PackageSpec struct {
	// Name Package name
	Name string `json:"name"`

	// Version Package version
	Version string `json:"version"`
}

// Page Represents a page of elements of a single type
type Page struct {
	// Elements The list of elements included in this page
	Elements *[]TrustedCertificate `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageCluster Represents a page of elements of a single type
type PageCluster struct {
	// Elements The list of elements included in this page
	Elements *[]Cluster `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageClusterNetworkConfiguration Represents a page of elements of a single type
type PageClusterNetworkConfiguration struct {
	// Elements The list of elements included in this page
	Elements *[]ClusterNetworkConfiguration `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageDatastore Represents a page of elements of a single type
type PageDatastore struct {
	// Elements The list of elements included in this page
	Elements *[]Datastore `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageHost Represents a page of elements of a single type
type PageHost struct {
	// Elements The list of elements included in this page
	Elements *[]Host `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageMetadata Represents pageable elements pagination metadata
type PageMetadata struct {
	// PageNumber Returns the current page number
	PageNumber *int32 `json:"pageNumber,omitempty"`

	// PageSize Returns the number of elements in the current page
	PageSize *int32 `json:"pageSize,omitempty"`

	// TotalElements Returns the total number of elements
	TotalElements *int32 `json:"totalElements,omitempty"`

	// TotalPages Returns the total number of pages
	TotalPages *int32 `json:"totalPages,omitempty"`
}

// PageNsxTCluster Represents a page of elements of a single type
type PageNsxTCluster struct {
	// Elements The list of elements included in this page
	Elements *[]NsxTCluster `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfBundle defines model for PageOfBundle.
type PageOfBundle struct {
	// Elements The list of elements included in this page
	Elements *[]Bundle `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfCertificate defines model for PageOfCertificate.
type PageOfCertificate struct {
	// Elements The list of elements included in this page
	Elements *[]Certificate `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfCertificateAuthority defines model for PageOfCertificateAuthority.
type PageOfCertificateAuthority struct {
	// Elements The list of elements included in this page
	Elements *[]CertificateAuthority `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfCluster defines model for PageOfCluster.
type PageOfCluster struct {
	// Elements The list of elements included in this page
	Elements *[]Cluster `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfClusterCriterion defines model for PageOfClusterCriterion.
type PageOfClusterCriterion struct {
	// Elements The list of elements included in this page
	Elements *[]ClusterCriterion `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfCompatibilityMatrix defines model for PageOfCompatibilityMatrix.
type PageOfCompatibilityMatrix struct {
	// Elements The list of elements included in this page
	Elements *[]CompatibilityMatrix `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfComplianceAudit defines model for PageOfComplianceAudit.
type PageOfComplianceAudit struct {
	// Elements The list of elements included in this page
	Elements *[]ComplianceAudit `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfComplianceAuditItem defines model for PageOfComplianceAuditItem.
type PageOfComplianceAuditItem struct {
	// Elements The list of elements included in this page
	Elements *[]ComplianceAuditItem `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfComplianceConfiguration defines model for PageOfComplianceConfiguration.
type PageOfComplianceConfiguration struct {
	// Elements The list of elements included in this page
	Elements *[]ComplianceConfiguration `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfComplianceStandard defines model for PageOfComplianceStandard.
type PageOfComplianceStandard struct {
	// Elements The list of elements included in this page
	Elements *[]ComplianceStandard `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfConfigDriftSpec defines model for PageOfConfigDriftSpec.
type PageOfConfigDriftSpec struct {
	// Elements The list of elements included in this page
	Elements *[]ConfigDriftSpec `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfCredential defines model for PageOfCredential.
type PageOfCredential struct {
	// Elements The list of elements included in this page
	Elements *[]Credential `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfCredentialsTask defines model for PageOfCredentialsTask.
type PageOfCredentialsTask struct {
	// Elements The list of elements included in this page
	Elements *[]CredentialsTask `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfCsr defines model for PageOfCsr.
type PageOfCsr struct {
	// Elements The list of elements included in this page
	Elements *[]Csr `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfCustomIso defines model for PageOfCustomIso.
type PageOfCustomIso struct {
	// Elements The list of elements included in this page
	Elements *[]CustomIso `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfDatastoreCriterion defines model for PageOfDatastoreCriterion.
type PageOfDatastoreCriterion struct {
	// Elements The list of elements included in this page
	Elements *[]DatastoreCriterion `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfDomain defines model for PageOfDomain.
type PageOfDomain struct {
	// Elements The list of elements included in this page
	Elements *[]Domain `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfDomainFutureRelease defines model for PageOfDomainFutureRelease.
type PageOfDomainFutureRelease struct {
	// Elements The list of elements included in this page
	Elements *[]DomainFutureRelease `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfDomainIntegration defines model for PageOfDomainIntegration.
type PageOfDomainIntegration struct {
	// Elements The list of elements included in this page
	Elements *[]DomainIntegration `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfDomainReleaseView defines model for PageOfDomainReleaseView.
type PageOfDomainReleaseView struct {
	// Elements The list of elements included in this page
	Elements *[]DomainReleaseView `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfEdgeCluster defines model for PageOfEdgeCluster.
type PageOfEdgeCluster struct {
	// Elements The list of elements included in this page
	Elements *[]EdgeCluster `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfEdgeClusterNsxtEntityCriterion defines model for PageOfEdgeClusterNsxtEntityCriterion.
type PageOfEdgeClusterNsxtEntityCriterion struct {
	// Elements The list of elements included in this page
	Elements *[]EdgeClusterNsxtEntityCriterion `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfEndpoint defines model for PageOfEndpoint.
type PageOfEndpoint struct {
	// Elements The list of elements included in this page
	Elements *[]Endpoint `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfHealthSummary defines model for PageOfHealthSummary.
type PageOfHealthSummary struct {
	// Elements The list of elements included in this page
	Elements *[]HealthSummary `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfHost defines model for PageOfHost.
type PageOfHost struct {
	// Elements The list of elements included in this page
	Elements *[]Host `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfHostCriterion defines model for PageOfHostCriterion.
type PageOfHostCriterion struct {
	// Elements The list of elements included in this page
	Elements *[]HostCriterion `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfIdentityProvider defines model for PageOfIdentityProvider.
type PageOfIdentityProvider struct {
	// Elements The list of elements included in this page
	Elements *[]IdentityProvider `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfLicenseKey defines model for PageOfLicenseKey.
type PageOfLicenseKey struct {
	// Elements The list of elements included in this page
	Elements *[]LicenseKey `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfNetwork defines model for PageOfNetwork.
type PageOfNetwork struct {
	// Elements The list of elements included in this page
	Elements *[]Network `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfNetworkPool defines model for PageOfNetworkPool.
type PageOfNetworkPool struct {
	// Elements The list of elements included in this page
	Elements *[]NetworkPool `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfNsxALBCluster defines model for PageOfNsxALBCluster.
type PageOfNsxALBCluster struct {
	// Elements The list of elements included in this page
	Elements *[]NsxALBCluster `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfNsxTCluster defines model for PageOfNsxTCluster.
type PageOfNsxTCluster struct {
	// Elements The list of elements included in this page
	Elements *[]NsxTCluster `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfNsxTCriterion defines model for PageOfNsxTCriterion.
type PageOfNsxTCriterion struct {
	// Elements The list of elements included in this page
	Elements *[]NsxTCriterion `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfNsxtIpAddressPool defines model for PageOfNsxtIpAddressPool.
type PageOfNsxtIpAddressPool struct {
	// Elements The list of elements included in this page
	Elements *[]NsxtIpAddressPool `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfNsxtTransportZoneInfo defines model for PageOfNsxtTransportZoneInfo.
type PageOfNsxtTransportZoneInfo struct {
	// Elements The list of elements included in this page
	Elements *[]NsxtTransportZoneInfo `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfPersonality defines model for PageOfPersonality.
type PageOfPersonality struct {
	// Elements The list of elements included in this page
	Elements *[]Personality `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfPsc defines model for PageOfPsc.
type PageOfPsc struct {
	// Elements The list of elements included in this page
	Elements *[]Psc `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfRelease defines model for PageOfRelease.
type PageOfRelease struct {
	// Elements The list of elements included in this page
	Elements *[]Release `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfResourceFunctionalities defines model for PageOfResourceFunctionalities.
type PageOfResourceFunctionalities struct {
	// Elements The list of elements included in this page
	Elements *[]ResourceFunctionalities `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfResourceWarning defines model for PageOfResourceWarning.
type PageOfResourceWarning struct {
	// Elements The list of elements included in this page
	Elements *[]ResourceWarning `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfRole defines model for PageOfRole.
type PageOfRole struct {
	// Elements The list of elements included in this page
	Elements *[]Role `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfSddcManager defines model for PageOfSddcManager.
type PageOfSddcManager struct {
	// Elements The list of elements included in this page
	Elements *[]SddcManager `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfSddcTask defines model for PageOfSddcTask.
type PageOfSddcTask struct {
	// Elements The list of elements included in this page
	Elements *[]SddcTask `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfSsoDomainEntity defines model for PageOfSsoDomainEntity.
type PageOfSsoDomainEntity struct {
	// Elements The list of elements included in this page
	Elements *[]SsoDomainEntity `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfString defines model for PageOfString.
type PageOfString struct {
	// Elements The list of elements included in this page
	Elements *[]string `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfSupportBundle defines model for PageOfSupportBundle.
type PageOfSupportBundle struct {
	// Elements The list of elements included in this page
	Elements *[]SupportBundle `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfTag defines model for PageOfTag.
type PageOfTag struct {
	// Elements The list of elements included in this page
	Elements *[]Tag `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfTagsForResource defines model for PageOfTagsForResource.
type PageOfTagsForResource struct {
	// Elements The list of elements included in this page
	Elements *[]TagsForResource `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfTask defines model for PageOfTask.
type PageOfTask struct {
	// Elements The list of elements included in this page
	Elements *[]Task `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfTrustedCertificate defines model for PageOfTrustedCertificate.
type PageOfTrustedCertificate struct {
	// Elements The list of elements included in this page
	Elements *[]TrustedCertificate `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfUpgradable defines model for PageOfUpgradable.
type PageOfUpgradable struct {
	// Elements The list of elements included in this page
	Elements *[]Upgradable `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfUpgradablesClusterResource Represents a page of elements of a Upgradables Cluster Resource
type PageOfUpgradablesClusterResource struct {
	// Elements The list of Upgradables Cluster Resource elements included in this page
	Elements *[]UpgradablesClusterResource `json:"elements,omitempty"`
}

// PageOfUpgrade defines model for PageOfUpgrade.
type PageOfUpgrade struct {
	// Elements The list of elements included in this page
	Elements *[]Upgrade `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfUser defines model for PageOfUser.
type PageOfUser struct {
	// Elements The list of elements included in this page
	Elements *[]User `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfValidation defines model for PageOfValidation.
type PageOfValidation struct {
	// Elements The list of elements included in this page
	Elements *[]Validation `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfVasaProvider defines model for PageOfVasaProvider.
type PageOfVasaProvider struct {
	// Elements The list of elements included in this page
	Elements *[]VasaProvider `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfVcenter defines model for PageOfVcenter.
type PageOfVcenter struct {
	// Elements The list of elements included in this page
	Elements *[]Vcenter `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfVcfService defines model for PageOfVcfService.
type PageOfVcfService struct {
	// Elements The list of elements included in this page
	Elements *[]VcfService `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfVersionAliasesForBundleComponentType defines model for PageOfVersionAliasesForBundleComponentType.
type PageOfVersionAliasesForBundleComponentType struct {
	// Elements The list of elements included in this page
	Elements *[]VersionAliasesForBundleComponentType `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfVra defines model for PageOfVra.
type PageOfVra struct {
	// Elements The list of elements included in this page
	Elements *[]Vra `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfVrli defines model for PageOfVrli.
type PageOfVrli struct {
	// Elements The list of elements included in this page
	Elements *[]Vrli `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfVrops defines model for PageOfVrops.
type PageOfVrops struct {
	// Elements The list of elements included in this page
	Elements *[]Vrops `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfVrslcm defines model for PageOfVrslcm.
type PageOfVrslcm struct {
	// Elements The list of elements included in this page
	Elements *[]Vrslcm `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PageOfWsa defines model for PageOfWsa.
type PageOfWsa struct {
	// Elements The list of elements included in this page
	Elements *[]Wsa `json:"elements,omitempty"`

	// PageMetadata Represents pageable elements pagination metadata
	PageMetadata *PageMetadata `json:"pageMetadata,omitempty"`
}

// PartnerExtensionSpec Specification for partner extensions. This specification is used in the Bundle Upload API
type PartnerExtensionSpec struct {
	// PartnerBundleMetadataFilePath Path to the bundle metadata file. The metadata file can have details of multiple bundles
	PartnerBundleMetadataFilePath *string `json:"partnerBundleMetadataFilePath,omitempty"`

	// PartnerBundleVersion Version of partner bundle to be uploaded. Should match one of the bundle versions available in the partner bundle metadata file
	PartnerBundleVersion *string `json:"partnerBundleVersion,omitempty"`
}

// Patch Patch rest model that is located in the Product Version Catalog, these models are consumed by LCM's Flex BOM workflows.
type Patch struct {
	// Artifacts Patch rest model that is located in the Product Version Catalog, these models are consumed by LCM's Flex BOM workflows.
	Artifacts *Artifact `json:"artifacts,omitempty"`

	// ProductVersion Product version of the patch bundle
	ProductVersion *string `json:"productVersion,omitempty"`
}

// PatchBundle Model for patch bundle in a release
type PatchBundle struct {
	// BundleElements Bundle elements of the patch bundle
	BundleElements *[]string `json:"bundleElements,omitempty"`

	// BundleId Bundle ID of the patch bundle
	BundleId *string `json:"bundleId,omitempty"`

	// BundleType Bundle type of the patch bundle
	BundleType *string `json:"bundleType,omitempty"`

	// CumulativeFromVcfVersion Minimum VCF version that this patch bundle can be directly applied on
	CumulativeFromVcfVersion *string `json:"cumulativeFromVcfVersion,omitempty"`
}

// Personality Personality contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
type Personality struct {
	// CreatedBy Personality created by
	CreatedBy *string `json:"createdBy,omitempty"`

	// Description Personality description
	Description *string `json:"description,omitempty"`

	// DisplayName Personality displayName
	DisplayName *string `json:"displayName,omitempty"`

	// ImageChecksum Personality image checksum
	ImageChecksum *string `json:"imageChecksum,omitempty"`

	// ImageSize Personality image size
	ImageSize *string `json:"imageSize,omitempty"`

	// ImportTimestamp Timestamp of Personality import into SDDC Manager
	ImportTimestamp *string `json:"importTimestamp,omitempty"`

	// KbArticles Personality kb articles
	KbArticles *string `json:"kbArticles,omitempty"`

	// PersonalityId Personality id
	PersonalityId *string `json:"personalityId,omitempty"`

	// PersonalityName Personality name
	PersonalityName *string `json:"personalityName,omitempty"`

	// ReleaseDate Personality Release date
	// Deprecated:
	ReleaseDate *string `json:"releaseDate,omitempty"`

	// SoftwareInfo SoftwareSpec contains base os, components, hardware support, addOn metadata to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
	SoftwareInfo SoftwareInfo `json:"softwareInfo"`

	// Tags Personality tags
	Tags *[]string `json:"tags,omitempty"`

	// Version Personality Version
	Version *string `json:"version,omitempty"`

	// VsphereExportedIsoPath Personality depot path
	VsphereExportedIsoPath *string `json:"vsphereExportedIsoPath,omitempty"`

	// VsphereExportedJsonPath Personality depot path
	VsphereExportedJsonPath *string `json:"vsphereExportedJsonPath,omitempty"`

	// VsphereExportedZipPath Personality depot path
	VsphereExportedZipPath *string `json:"vsphereExportedZipPath,omitempty"`
}

// PersonalitySpec Personality Specification for vLCM based upgrade
type PersonalitySpec struct {
	// HardwareSupportSpecs Hardware Support Specifications for Firmware upgrade
	HardwareSupportSpecs *[]HardwareSupportSpec `json:"hardwareSupportSpecs,omitempty"`

	// PersonalityId Personality ID for vLCM based Upgrade
	PersonalityId string `json:"personalityId"`
}

// PersonalityUploadSpec Personality Upload Specification
type PersonalityUploadSpec struct {
	// Name Personality name
	Name *string `json:"name,omitempty"`

	// UploadMode Personality upload mode
	UploadMode string `json:"uploadMode"`

	// UploadSpecRawMode Personality upload specification for uploading the personality from raw files exported from avCenter cluster. This mode of uploading personality is useful when the source vCenter cluster is outside the target VCF deployment.
	UploadSpecRawMode *PersonalityUploadSpecRaw `json:"uploadSpecRawMode,omitempty"`

	// UploadSpecRawWithFileUploadIdMode Personality upload specification for uploading the personality from raw files exported from a vCenter cluster. This mode of uploading personality is useful when the source vCenter cluster is outside the target VCF deployment. User can upload files from a source location to SDDC Manager using v1/personalities/files API, which returns a file upload id. The id is then passed in this spec with Personality Upload Mode RAW_WITH_FILE_UPLOAD_ID.
	UploadSpecRawWithFileUploadIdMode *PersonalityUploadSpecRawWithFileUploadId `json:"uploadSpecRawWithFileUploadIdMode,omitempty"`

	// UploadSpecReferredMode Personality upload specification for uploading the personality from a referred vCentercluster. This mode of uploading personality is useful when the source vCenter cluster is internal to the target VCF deployment.
	UploadSpecReferredMode *PersonalityUploadSpecReferred `json:"uploadSpecReferredMode,omitempty"`
}

// PersonalityUploadSpecRaw Personality upload specification for uploading the personality from raw files exported from avCenter cluster. This mode of uploading personality is useful when the source vCenter cluster is outside the target VCF deployment.
type PersonalityUploadSpecRaw struct {
	// PersonalityISOFilePath Personality ISO File Path
	PersonalityISOFilePath *string `json:"personalityISOFilePath,omitempty"`

	// PersonalityInfoJSONFilePath Personality Info JSON File Path
	PersonalityInfoJSONFilePath string `json:"personalityInfoJSONFilePath"`

	// PersonalityJSONFilePath Personality JSON File Path
	PersonalityJSONFilePath string `json:"personalityJSONFilePath"`

	// PersonalityZIPFilePath Personality Zip File Path
	PersonalityZIPFilePath string `json:"personalityZIPFilePath"`
}

// PersonalityUploadSpecRawWithFileUploadId Personality upload specification for uploading the personality from raw files exported from a vCenter cluster. This mode of uploading personality is useful when the source vCenter cluster is outside the target VCF deployment. User can upload files from a source location to SDDC Manager using v1/personalities/files API, which returns a file upload id. The id is then passed in this spec with Personality Upload Mode RAW_WITH_FILE_UPLOAD_ID.
type PersonalityUploadSpecRawWithFileUploadId struct {
	// FileUploadId Personality file upload id. This id is obtained by calling v1/personalities/files and uploading files into SDDC Manager
	FileUploadId string `json:"fileUploadId"`
}

// PersonalityUploadSpecReferred Personality upload specification for uploading the personality from a referred vCentercluster. This mode of uploading personality is useful when the source vCenter cluster is internal to the target VCF deployment.
type PersonalityUploadSpecReferred struct {
	// ClusterId Source cluster MOID
	ClusterId string `json:"clusterId"`

	// VCenterId Source vCenter UUID from VCF inventory
	VCenterId string `json:"vCenterId"`
}

// PhysicalNic Represents a physical NIC
type PhysicalNic struct {
	// DeviceName Device name of the physical NIC
	DeviceName *string `json:"deviceName,omitempty"`

	// MacAddress Mac address of the physical NIC
	MacAddress *string `json:"macAddress,omitempty"`

	// SmartNicInfo Represents informtion related to smart nic
	SmartNicInfo *SmartNicInfo `json:"smartNicInfo,omitempty"`

	// Speed Speed in bytes of the physical NIC
	Speed *int64 `json:"speed,omitempty"`

	// State State of the physical NIC
	State *string `json:"state,omitempty"`

	// Unit Unit of physical NIC speed
	Unit *PhysicalNicUnit `json:"unit,omitempty"`
}

// PhysicalNicUnit Unit of physical NIC speed
type PhysicalNicUnit string

// Portgroup Portgroup associated with the vSphere Distributed Switch
type Portgroup struct {
	// ActiveUplinks List of active uplinks
	ActiveUplinks *[]string `json:"activeUplinks,omitempty"`

	// Name Port group name
	Name string `json:"name"`

	// PortBindingType Port binding type
	PortBindingType *string `json:"portBindingType,omitempty"`

	// StandbyUplinks List of standby uplinks
	StandbyUplinks *[]string `json:"standbyUplinks,omitempty"`

	// TransportType Port group transport type
	TransportType string `json:"transportType"`

	// VlanId VLAN ID
	VlanId *int32 `json:"vlanId,omitempty"`
}

// PortgroupConfig This specification contains the network configuration in a port group.
type PortgroupConfig struct {
	// ActiveUplinks List of active uplinks associated with port group
	ActiveUplinks *[]string `json:"activeUplinks,omitempty"`

	// Mtu The maximum transmission unit (MTU) used for the uplinks associated with the port group
	Mtu *int32 `json:"mtu,omitempty"`

	// Name Port group name
	Name *string `json:"name,omitempty"`

	// Policy The load balancing policy associated with port group
	Policy *string `json:"policy,omitempty"`

	// StandByUplinks List of standby uplinks associated with port group
	StandByUplinks *[]string `json:"standByUplinks,omitempty"`

	// SupportedTeamingPolicies List of supported teaming policies at port group
	SupportedTeamingPolicies *map[string]string `json:"supportedTeamingPolicies,omitempty"`

	// TransportType Port group transport type
	TransportType *string `json:"transportType,omitempty"`

	// VlanId The vlan id associated with the port group
	VlanId *int32 `json:"vlanId,omitempty"`
}

// PortgroupSpec This specification contains vCenter port group configurations
type PortgroupSpec struct {
	// ActiveUplinks The list of active uplinks associated with portgroup
	ActiveUplinks *[]string `json:"activeUplinks,omitempty"`

	// Name Port group name
	Name string `json:"name"`

	// StandByUplinks The list of standby uplinks associated with portgroup.
	StandByUplinks *[]string `json:"standByUplinks,omitempty"`

	// TeamingPolicy The teaming policy associated with the portgroup.
	TeamingPolicy *string `json:"teamingPolicy,omitempty"`

	// TransportType Port group transport type
	TransportType string `json:"transportType"`
}

// PrecheckSpec Precheck System Spec
type PrecheckSpec struct {
	// BundleId  If specified, indicate the bundle applicability in the result
	BundleId *string `json:"bundleId,omitempty"`

	// Mode  If specified, indicates the mode of the execution. Supported modes are UPGRADE and RECOVERY. UPGRADE is default mode. Specify RECOVERY for the Inventory Consistency Checks
	Mode *string `json:"mode,omitempty"`

	// Resources List of resources for Precheck supported type DOMAIN, CLUSTER
	Resources []Resource `json:"resources"`
}

// ProductInfo Product Info and License Key Info
type ProductInfo struct {
	// ErrorResponse Error response containing a minor error code, a localized error message, a localized remediation message and optionally a reference token to correlate the error with the logs
	ErrorResponse *Error `json:"errorResponse,omitempty"`

	// LicenseKey License key of product
	LicenseKey *string `json:"licenseKey,omitempty"`

	// LicenseKeyExpirationDate License key expiration date
	LicenseKeyExpirationDate *string `json:"licenseKeyExpirationDate,omitempty"`

	// LicenseKeyStatus License key status
	LicenseKeyStatus *string `json:"licenseKeyStatus,omitempty"`

	// LicensingMode Licensing Mode
	LicensingMode *string `json:"licensingMode,omitempty"`

	// Type Product type
	Type *string `json:"type,omitempty"`
}

// ProductVersion Details of the product/component for the release.
type ProductVersion struct {
	// AdditionalMetadata any additional metadata
	AdditionalMetadata *string `json:"additionalMetadata,omitempty"`

	// Name Name of the product. e.g ESX
	Name *string `json:"name,omitempty"`

	// PublicName Public name of the product, e.g VMware ESXi
	PublicName *string `json:"publicName,omitempty"`

	// ReleaseURL URL for the release.
	ReleaseURL *string `json:"releaseURL,omitempty"`

	// Version Version for the product, e.g 6.7.0-11675023
	Version *string `json:"version,omitempty"`
}

// ProductVersionCatalog LCM Product Version Catalog that contains async patches for VMware Cloud foundation components (VC/ESX/NSX) that's used by Life cycle manager.
type ProductVersionCatalog struct {
	// CreationTime Creation time for the Product Version catalog e.g. 2020-06-08T02:20:15.844Z, in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	CreationTime *string `json:"creationTime,omitempty"`

	// Patches Patches used for the product version catalog
	Patches *map[string][]Patch `json:"patches,omitempty"`

	// PublishedTime Time of publish of the Product Version catalog e.g. 2020-06-08T02:20:15.844Z, in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	PublishedTime *string `json:"publishedTime,omitempty"`

	// SequenceNumber Product Version catalog sequence number which signifies an update in the product version catalog
	SequenceNumber *int32 `json:"sequenceNumber,omitempty"`

	// Version Product Version catalog version supported by VCF
	Version *int32 `json:"version,omitempty"`
}

// ProxyConfiguration Proxy Configuration
type ProxyConfiguration struct {
	// Host IP address/FQDN of proxy server
	Host *string `json:"host,omitempty"`

	// IsAuthenticated Is proxy authenticated
	IsAuthenticated *bool `json:"isAuthenticated,omitempty"`

	// IsConfigured Is proxy configured
	IsConfigured *bool `json:"isConfigured,omitempty"`

	// IsEnabled Is proxy enabled
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Password User password to connect, will return null on reading
	Password *string `json:"password,omitempty"`

	// Port Port of proxy server
	Port *int32 `json:"port,omitempty"`

	// TransferProtocol Proxy transfer protocol, default value is HTTP
	TransferProtocol *ProxyConfigurationTransferProtocol `json:"transferProtocol,omitempty"`

	// Username User name to connect
	Username *string `json:"username,omitempty"`
}

// ProxyConfigurationTransferProtocol Proxy transfer protocol, default value is HTTP
type ProxyConfigurationTransferProtocol string

// ProxySpec Spec contains parameters for proxy settings
type ProxySpec struct {
	// Host IP address/FQDN of proxy server
	Host string `json:"host"`

	// Password Proxy server password
	Password *string `json:"password,omitempty"`

	// Port Port of proxy server
	Port int32 `json:"port"`

	// TransferProtocol Proxy transfer protocol, default value is HTTP. One among: HTTP, HTTPS
	TransferProtocol *string `json:"transferProtocol,omitempty"`

	// Username Proxy server username
	Username *string `json:"username,omitempty"`
}

// Psc Psc representation
type Psc struct {
	// Domain Represents a domain reference
	Domain *DomainReference `json:"domain,omitempty"`

	// Fqdn FQDN of the Psc
	Fqdn *string `json:"fqdn,omitempty"`

	// Id ID of the Psc
	Id *string `json:"id,omitempty"`

	// IpAddress IP Address of the Psc
	IpAddress *string `json:"ipAddress,omitempty"`

	// IsReplica Indicates if the Psc is a replica
	IsReplica *bool `json:"isReplica,omitempty"`

	// SsoDomainName SSO Domain name of the Psc
	SsoDomainName *string `json:"ssoDomainName,omitempty"`

	// SsoSubDomainName SSO sub domain name of the Psc
	SsoSubDomainName *string `json:"ssoSubDomainName,omitempty"`
}

// PscSpec Spec contains parameters for deployment/configuration of Platform Services Controller
type PscSpec struct {
	// AdminUserSsoPassword Admin user sso passwordPassword needs to be a strong password with at least one Uppercase alphabet, one lowercase alphabet, one digit and one special character specified in braces [!$%^] and 8-20 characters in length,and 3 maximum identical adjacent characters!. If blank, the SDDC Local Admin Password will be used.
	AdminUserSsoPassword *string `json:"adminUserSsoPassword,omitempty"`

	// PscSsoSpec Spec contains parameters for Platform Services Controller SSO
	PscSsoSpec PscSsoSpec `json:"pscSsoSpec"`
}

// PscSsoSpec Spec contains parameters for Platform Services Controller SSO
type PscSsoSpec struct {
	// SsoDomain PSC SSO Domain
	SsoDomain *string `json:"ssoDomain,omitempty"`
}

// QueryInfo Represents the query info.
type QueryInfo struct {
	Completed *bool `json:"completed,omitempty"`

	// ErrorResponse Error response containing a minor error code, a localized error message, a localized remediation message and optionally a reference token to correlate the error with the logs
	ErrorResponse *Error `json:"errorResponse,omitempty"`
	Failure       *bool  `json:"failure,omitempty"`
	Processing    *bool  `json:"processing,omitempty"`

	// QueryId ID of the query to retrieve
	QueryId *string `json:"queryId,omitempty"`

	// Status Status of the query
	Status *string `json:"status,omitempty"`
}

// ReconciliationForResource Describes Configuration Reconciliation operation(s) for a resource
type ReconciliationForResource struct {
	// ApplyAll All application flag. Indicates if all applicable config drifts must be applied
	ApplyAll bool `json:"applyAll"`

	// ResourceId Target resource ID
	ResourceId string `json:"resourceId"`
}

// RefreshToken This contains refresh token id for the user API access.
type RefreshToken struct {
	// Id Refresh token id that can be used to request new access token
	Id *string `json:"id,omitempty"`
}

// Release Model for releases with their description and product version
type Release struct {
	// Bom Release bill of materials
	Bom *[]ProductVersion `json:"bom,omitempty"`

	// Description Release description with all major features.
	Description *string `json:"description,omitempty"`

	// Eol Release eol information e.g. 2020-06-08T02:20:15.844Z in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	Eol *string `json:"eol,omitempty"`

	// IsApplicable [Deprecated] Whether bundle is applicable or not.
	// Deprecated:
	IsApplicable *bool `json:"isApplicable,omitempty"`

	// MinCompatibleVcfVersion Minimum compatible VCF version, used to represent compatibility of SDDC Manager and VMware BOM components
	MinCompatibleVcfVersion *string `json:"minCompatibleVcfVersion,omitempty"`

	// NotApplicableReason [Deprecated] Incompatibility reason for not applicable.
	// Deprecated:
	NotApplicableReason *string `json:"notApplicableReason,omitempty"`

	// PatchBundles List of patch bundles in this release
	PatchBundles *[]PatchBundle `json:"patchBundles,omitempty"`

	// Product Name of the product e.g. "VCF"
	Product *string `json:"product,omitempty"`

	// ReleaseDate Release date e.g. 2020-06-08T02:20:15.844Z in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	ReleaseDate *string `json:"releaseDate,omitempty"`

	// Sku Release sku specific patch and bill of materials
	Sku *[]SkuBomDetails `json:"sku,omitempty"`

	// Updates Collection of release updates
	Updates *[]ReleaseUpdate `json:"updates,omitempty"`

	// UpgradeOrder Custom upgrade order. Comma separated list of components in upgrade order. Supported components types: NSX_T_MANAGER, VCENTER, ESX_HOST.
	UpgradeOrder *string `json:"upgradeOrder,omitempty"`

	// Version Version of the release
	Version *string `json:"version,omitempty"`
}

// ReleaseUpdate Update to a given release
type ReleaseUpdate struct {
	// BaseProductVersion Base product version for the release
	BaseProductVersion *string `json:"baseProductVersion,omitempty"`

	// Description Description of the release update
	Description *string `json:"description,omitempty"`

	// Id Release version
	Id *string `json:"id,omitempty"`

	// ProductName Product name for which the release update is provided
	ProductName *string `json:"productName,omitempty"`

	// ReleaseDate Release date e.g. 2020-06-08T02:20:15.844Z in yyyy-MM-dd'T'HH:mm:ss[.SSS]XXX ISO 8601 format
	ReleaseDate *string `json:"releaseDate,omitempty"`

	// ReleaseUpdateURL URL to the release update
	ReleaseUpdateURL *string `json:"releaseUpdateURL,omitempty"`
}

// RemoteDatastoreInfo Remote Datastore Info
type RemoteDatastoreInfo struct {
	// RemoteDatastore Remote Datastore
	RemoteDatastore *string `json:"remoteDatastore,omitempty"`

	// ServerCluster Server cluster
	ServerCluster *string `json:"serverCluster,omitempty"`
}

// Resource Represents the resource in the system
type Resource struct {
	// Fqdn Resource FQDN
	Fqdn *string `json:"fqdn,omitempty"`

	// Name Name of the resource
	Name *string `json:"name,omitempty"`

	// ResourceId Resource ID
	ResourceId string `json:"resourceId"`

	// Sans Subject alternative name(s)
	Sans *[]string `json:"sans,omitempty"`

	// Type Resource type
	Type string `json:"type"`
}

// ResourceCertificateSpec This specification contains resource certificate details. Either resourceId or resourceFqdn should be provided. Either certificateChain or both resourceCertificate and caCertificate should be provided.
type ResourceCertificateSpec struct {
	// CaCertificate CA Certificate
	CaCertificate *string `json:"caCertificate,omitempty"`

	// CertificateChain Certificate Chain
	CertificateChain *string `json:"certificateChain,omitempty"`

	// ResourceCertificate Resource Certificate
	ResourceCertificate *string `json:"resourceCertificate,omitempty"`

	// ResourceFqdn Resource FQDN
	ResourceFqdn *string `json:"resourceFqdn,omitempty"`

	// ResourceId Resource ID
	ResourceId *string `json:"resourceId,omitempty"`
}

// ResourceCredentials Represents a resource along with its list of credentials to be changed.
type ResourceCredentials struct {
	// Credentials Credentials of the resource
	Credentials []BaseCredential `json:"credentials"`

	// ResourceId Resource ID
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceName Resource name
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Authenticated Resource Type
	ResourceType string `json:"resourceType"`
}

// ResourceDomainInfo Information about the domain the resource belongs to
type ResourceDomainInfo struct {
	// DomainId Id of the domain
	DomainId *string `json:"domainId,omitempty"`

	// DomainName Name of the domain
	DomainName *string `json:"domainName,omitempty"`

	// DomainType Type of the domain
	DomainType *ResourceDomainInfoDomainType `json:"domainType,omitempty"`
}

// ResourceDomainInfoDomainType Type of the domain
type ResourceDomainInfoDomainType string

// ResourceFunctionalities Defines a resource functionality specification
type ResourceFunctionalities struct {
	// Functionalities List of functionalities associated with the resource
	Functionalities *[]Functionality `json:"functionalities,omitempty"`

	// ResourceId ID of the resource
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceType Type of the resource
	ResourceType string `json:"resourceType"`
}

// ResourceFunctionalitiesCaller Defines a resource functionality caller specification
type ResourceFunctionalitiesCaller struct {
	// OperationId The identifier of the operation associated with the resource functionalities
	OperationId *string `json:"operationId,omitempty"`

	// OperationName The name of the operation associated with the resource functionalities
	OperationName *string `json:"operationName,omitempty"`

	// ResourceFunctionalities List of resource functionalities associated with the caller
	ResourceFunctionalities *[]ResourceFunctionalities `json:"resourceFunctionalities,omitempty"`

	// ServiceId The identifier of the service associated with the resource functionalities
	ServiceId *string `json:"serviceId,omitempty"`
}

// ResourceFunctionalitiesGlobalConfiguration Defines a resource functionality caller specification
type ResourceFunctionalitiesGlobalConfiguration struct {
	// ErrorMessage The localized error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// IsAllowed Global flag representing if all of the VMware Cloud Foundation operations are allowed or not
	IsAllowed *bool `json:"isAllowed,omitempty"`
}

// ResourceFunctionalitiesGlobalConfigurationCaller Defines a resource functionality global caller specification
type ResourceFunctionalitiesGlobalConfigurationCaller struct {
	// IsAllowed Global flag representing if all of the VMware Cloud Foundation operations are allowed or not
	IsAllowed *bool `json:"isAllowed,omitempty"`

	// OperationId The identifier of the operation associated with the resource functionalities
	OperationId *string `json:"operationId,omitempty"`

	// OperationName The name of the operation associated with the resource functionalities
	OperationName *string `json:"operationName,omitempty"`

	// ServiceId The identifier of the service associated with the resource functionalities
	ServiceId *string `json:"serviceId,omitempty"`
}

// ResourceFunctionalitiesGlobalUpdateSpec Resource Functionality Global Caller update specification
type ResourceFunctionalitiesGlobalUpdateSpec struct {
	// IsAllowed Flag indicating if all of the functionalities are allowed
	IsAllowed bool `json:"isAllowed"`

	// OperationId The identifier of the operation associated with the resource functionalities
	OperationId string `json:"operationId"`

	// OperationName The name of the operation associated with the resource functionalities
	OperationName string `json:"operationName"`

	// ServiceId The identifier of the service associated with the resource functionalities
	ServiceId string `json:"serviceId"`
}

// ResourceFunctionalitiesUpdateSpec Resource Functionality Caller update specification
type ResourceFunctionalitiesUpdateSpec struct {
	// OperationId The identifier of the operation associated with the resource functionalities
	OperationId string `json:"operationId"`

	// OperationName The name of the operation associated with the resource functionalities
	OperationName string `json:"operationName"`

	// ResourceFunctionalities List of resource functionalities associated with the caller
	ResourceFunctionalities []ResourceFunctionalities `json:"resourceFunctionalities"`

	// ServiceId The identifier of the service associated with the resource functionalities
	ServiceId string `json:"serviceId"`
}

// ResourceInfo Resource info
type ResourceInfo struct {
	// ClusterId Cluster Id of resourceInfo
	ClusterId *string `json:"clusterId,omitempty"`

	// DomainId Domain Identifier
	DomainId string `json:"domainId"`

	// HostId Host Id of resourceInfo
	HostId *string `json:"hostId,omitempty"`
}

// ResourceLicensingInfo Resource Licensing Info
type ResourceLicensingInfo struct {
	// ProductInfo Product Info and License Key Info
	ProductInfo *ProductInfo `json:"productInfo,omitempty"`

	// ResourceInfo Resource info
	ResourceInfo ResourceInfo `json:"resourceInfo"`
}

// ResourcePoolSpec Spec contains parameters for Resource Pool
type ResourcePoolSpec struct {
	// CpuLimit CPU limit, default -1 (unlimited)
	CpuLimit *int64 `json:"cpuLimit,omitempty"`

	// CpuReservationExpandable Is CPU reservation expandable, default true
	CpuReservationExpandable *bool `json:"cpuReservationExpandable,omitempty"`

	// CpuReservationMhz CPU reservation in Mhz, default 0
	CpuReservationMhz *int64 `json:"cpuReservationMhz,omitempty"`

	// CpuReservationPercentage CPU reservation percentage, from 0 to 100, default 0
	CpuReservationPercentage *int32 `json:"cpuReservationPercentage,omitempty"`

	// CpuSharesLevel CPU shares level, default 'normal'
	CpuSharesLevel *ResourcePoolSpecCpuSharesLevel `json:"cpuSharesLevel,omitempty"`

	// CpuSharesValue CPU shares value, only relevant when shares level is 'custom', default 0
	CpuSharesValue *int32 `json:"cpuSharesValue,omitempty"`

	// MemoryLimit Memory limit, default -1 (unlimited)
	MemoryLimit *int64 `json:"memoryLimit,omitempty"`

	// MemoryReservationExpandable Is Memory reservation expandable, default true
	MemoryReservationExpandable *bool `json:"memoryReservationExpandable,omitempty"`

	// MemoryReservationMb Memory reservation in MB, default 0
	MemoryReservationMb *int64 `json:"memoryReservationMb,omitempty"`

	// MemoryReservationPercentage Memory reservation percentage, from 0 to 100, default 0
	MemoryReservationPercentage *int32 `json:"memoryReservationPercentage,omitempty"`

	// MemorySharesLevel Memory shares level. default 'normal'
	MemorySharesLevel *ResourcePoolSpecMemorySharesLevel `json:"memorySharesLevel,omitempty"`

	// MemorySharesValue Memory shares value, only relevant when shares level is 'custom', default 0
	MemorySharesValue *int32 `json:"memorySharesValue,omitempty"`

	// Name Resource Pool name. It will be auto-generated if blank
	Name *string `json:"name,omitempty"`

	// Type Type of resource pool. One among: management, compute, network
	Type *ResourcePoolSpecType `json:"type,omitempty"`
}

// ResourcePoolSpecCpuSharesLevel CPU shares level, default 'normal'
type ResourcePoolSpecCpuSharesLevel string

// ResourcePoolSpecMemorySharesLevel Memory shares level. default 'normal'
type ResourcePoolSpecMemorySharesLevel string

// ResourcePoolSpecType Type of resource pool. One among: management, compute, network
type ResourcePoolSpecType string

// ResourceUpgradeSpec Resource Upgrade Specification
type ResourceUpgradeSpec struct {
	// CustomIsoSpec Custom ISO Specifications for VUM Clusters Upgrade with Custom ISO
	CustomIsoSpec *CustomISOSpec `json:"customIsoSpec,omitempty"`

	// EnableQuickboot Flag for requesting Quick Boot for ESXi upgrade
	// Deprecated:
	EnableQuickboot *bool `json:"enableQuickboot,omitempty"`

	// EsxUpgradeOptionsSpec Options for ESXi upgrade. These are applicable to vSphere Lifecycle Manager Images based upgrade only.
	EsxUpgradeOptionsSpec *EsxUpgradeOptionsSpec `json:"esxUpgradeOptionsSpec,omitempty"`

	// EvacuateOfflineVms Flag for requesting Evacuation of Offline VMs for ESXi upgrade
	// Deprecated:
	EvacuateOfflineVms *bool `json:"evacuateOfflineVms,omitempty"`

	// PersonalitySpec Personality Specification for vLCM based upgrade
	PersonalitySpec *PersonalitySpec `json:"personalitySpec,omitempty"`

	// ResourceId Resource ID for Upgrade
	ResourceId string `json:"resourceId"`

	// ScheduledTimestamp Upgrade Scheduled Time
	ScheduledTimestamp *string `json:"scheduledTimestamp,omitempty"`

	// ShutdownVms If Resource Type is UNASSIGNED_HOST, set flag for enabling shutting down VM's before Upgrade
	ShutdownVms *bool `json:"shutdownVms,omitempty"`

	// ToVersion If Resource Type is UNASSIGNED_HOST, set the target version for Upgrade
	ToVersion *string `json:"toVersion,omitempty"`

	// UpgradeNow Flag for enabling Upgrade Now. If true, scheduledTimestamp is ignored
	UpgradeNow *bool `json:"upgradeNow,omitempty"`
}

// ResourceWarning Represents a warning associated to a specific resource
type ResourceWarning struct {
	// AssociatedTask Task association for a resource warning. Indicates in which task the resource warning occurred
	AssociatedTask *AssociatedTask `json:"associatedTask,omitempty"`

	// Context Optional additional context information in a key value form
	Context *map[string]string `json:"context,omitempty"`

	// Id ID of the resource warning
	Id *string `json:"id,omitempty"`

	// Message The localized warning message
	Message *string `json:"message,omitempty"`

	// OccurredAtTimestamp Timestamp when the warning occurred
	OccurredAtTimestamp string `json:"occurredAtTimestamp"`

	// ReferenceToken A reference token correlating the warning with the relevant detailed logs. Should be sent to the service provider when reporting issues
	ReferenceToken *string `json:"referenceToken,omitempty"`

	// RemediationMessage The localized remediation warning message
	RemediationMessage *string `json:"remediationMessage,omitempty"`

	// ResourceId ID of the associated resource
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceName Name of the associated resource
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Type of the associated resource
	ResourceType *string `json:"resourceType,omitempty"`

	// Severity Severity of the warning
	Severity *string `json:"severity,omitempty"`

	// WarningCode The warning code
	WarningCode *string `json:"warningCode,omitempty"`

	// WarningType Type of the warning
	WarningType *string `json:"warningType,omitempty"`
}

// ResourceWarningCreationSpec Resource Warning creation specification
type ResourceWarningCreationSpec struct {
	// AssociatedTask Task association for a resource warning. Indicates in which task the resource warning occurred
	AssociatedTask *AssociatedTask `json:"associatedTask,omitempty"`

	// Context Optional additional context information to be associated to the warning
	Context *map[string]string `json:"context,omitempty"`

	// LocalizableWarningPack Localization warning pack containing all required data to provide localized warning messages
	LocalizableWarningPack LocalizableWarningPack `json:"localizableWarningPack"`

	// OccurredAtTimestamp The Unix epoch timestamp of when the warning occurred
	OccurredAtTimestamp int64 `json:"occurredAtTimestamp"`

	// ResourceId ID of the resource to which this warning will be associated
	ResourceId string `json:"resourceId"`

	// ResourceName Name of the resource to which this warning will be associated
	ResourceName string `json:"resourceName"`

	// ResourceType Type of the resource to which this warning will be associated
	ResourceType ResourceWarningCreationSpecResourceType `json:"resourceType"`

	// Severity The severity of the warning
	Severity ResourceWarningCreationSpecSeverity `json:"severity"`

	// WarningType The type of the warning
	WarningType ResourceWarningCreationSpecWarningType `json:"warningType"`
}

// ResourceWarningCreationSpecResourceType Type of the resource to which this warning will be associated
type ResourceWarningCreationSpecResourceType string

// ResourceWarningCreationSpecSeverity The severity of the warning
type ResourceWarningCreationSpecSeverity string

// ResourceWarningCreationSpecWarningType The type of the warning
type ResourceWarningCreationSpecWarningType string

// ResourcesLicenseCheckResult Resource License check result
type ResourcesLicenseCheckResult struct {
	// EndTimestamp Task end timestamp
	EndTimestamp *string `json:"endTimestamp,omitempty"`

	// Id ID of the resources license check task
	Id *string `json:"id,omitempty"`

	// ResourceLicensingInfos List of licensing infos of resources
	ResourceLicensingInfos *[]ResourceLicensingInfo `json:"resourceLicensingInfos,omitempty"`

	// StartTimestamp Task start timestamp
	StartTimestamp *string `json:"startTimestamp,omitempty"`

	// Status Task status
	Status *string `json:"status,omitempty"`
}

// ResourcesLicenseCheckSpec Resources license check spec
type ResourcesLicenseCheckSpec struct {
	// ForAllDomains Value that defines whether to get license check for all domains or not
	ForAllDomains *bool `json:"forAllDomains,omitempty"`

	// LicenseCheckResources A list of resources for which license check needs to be performed
	LicenseCheckResources *[]LicenseCheckResource `json:"licenseCheckResources,omitempty"`
}

// RestoreSpec Restore Specification
type RestoreSpec struct {
	// BackupFile Backup file name
	BackupFile string `json:"backupFile"`

	// Elements List of elements to be restored
	Elements []BackupResource `json:"elements"`

	// Encryption Restore Specification
	Encryption *Encryption `json:"encryption,omitempty"`
}

// Role Represents role and its attributes
type Role struct {
	// Description The description of the role
	Description *string `json:"description,omitempty"`

	// Id The ID of the role
	Id *string `json:"id,omitempty"`

	// Name The name of the role
	Name *string `json:"name,omitempty"`
}

// RoleReference Represents a role reference
type RoleReference struct {
	// Id ID of the role
	Id string `json:"id"`
}

// RootCaCerts Spec contains Root Certificate Authority parameters
type RootCaCerts struct {
	// Alias Certificate alias
	Alias *string `json:"alias,omitempty"`

	// CertChain List of Base64 encoded certificates
	CertChain *[]string `json:"certChain,omitempty"`
}

// SDDCManagerOidcInfo Represents the SDDC Manager's OIDC client information
type SDDCManagerOidcInfo struct {
	// IdpType The type of the current identity provider
	IdpType *string `json:"idpType,omitempty"`

	// OidcAuthorizationEndpoint The SDDC Manager Authorization end point
	OidcAuthorizationEndpoint *string `json:"oidcAuthorizationEndpoint,omitempty"`

	// OidcClientId The SDDC Manager OIDC client id
	OidcClientId *string `json:"oidcClientId,omitempty"`

	// OidcEndSessionEndpoint The SDDC Manager end session end point
	OidcEndSessionEndpoint *string `json:"oidcEndSessionEndpoint,omitempty"`

	// Source The source of the current identity provider
	Source *string `json:"source,omitempty"`
}

// SddcClusterSpec Spec contains parameters for vCenter Cluster
type SddcClusterSpec struct {
	// ClusterEvcMode vCenter Cluster EVC mode
	ClusterEvcMode *string `json:"clusterEvcMode,omitempty"`

	// ClusterImageEnabled Enable vSphere Lifecycle Manager Images for cluster creation
	ClusterImageEnabled *bool `json:"clusterImageEnabled,omitempty"`

	// ClusterName vCenter Cluster Name. It will be auto-generated if blank.
	ClusterName *string `json:"clusterName,omitempty"`

	// HostFailuresToTolerate Host failures to tolerate
	HostFailuresToTolerate *int32 `json:"hostFailuresToTolerate,omitempty"`

	// PersonalityName Cluster Personality Name
	// Deprecated:
	PersonalityName *string `json:"personalityName,omitempty"`

	// ResourcePoolSpecs List of Resource Pool Specification. If blank, no resource pools will be created. However, if you want to create resource pool, Management Resource Pool is required to be present in the list.
	ResourcePoolSpecs *[]ResourcePoolSpec `json:"resourcePoolSpecs,omitempty"`

	// VmFolders Virtual Machine folders map. One among:MANAGEMENT, NETWORKING
	VmFolders *map[string]string `json:"vmFolders,omitempty"`
}

// SddcCredentials Credentials contains the username and password
type SddcCredentials struct {
	// Password Password
	Password string `json:"password"`

	// Username Username
	Username *string `json:"username,omitempty"`
}

// SddcHostSpec Spec contains parameters for Host
type SddcHostSpec struct {
	// Association Datacenter name. Can be added to just one of the host specifications. If not provided, it will be auto-generated.
	Association *string `json:"association,omitempty"`

	// Credentials Credentials contains the username and password
	Credentials *SddcCredentials `json:"credentials,omitempty"`

	// Hostname ESXi Host hostname. This value will be prefixed to the DNS subdomain name and should not include the domain name itself. Must also adhere to RFC 1123 naming conventions
	Hostname string `json:"hostname"`

	// IpAddressPrivate Defines an IP address with gateway and subnet
	IpAddressPrivate *IpAllocation `json:"ipAddressPrivate,omitempty"`

	// SshThumbprint ESXi Host SSH thumbprint (RSA SHA256)
	SshThumbprint *string `json:"sshThumbprint,omitempty"`

	// SslThumbprint ESXi Host SSL thumbprint (SHA256)
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// VSwitch ESXi Host vSwitch name
	// Deprecated:
	VSwitch *string `json:"vSwitch,omitempty"`
}

// SddcHotPatchInfo Sddc Hot patch info rest model that is located in the 2.0 manifest, as part of the async patch catalog.
type SddcHotPatchInfo struct {
	// SddcHotPatchMinTargetVcfVersion Sddc Hot patch min target version
	SddcHotPatchMinTargetVcfVersion *string `json:"sddcHotPatchMinTargetVcfVersion,omitempty"`

	// Version Product version
	Version *string `json:"version,omitempty"`
}

// SddcManager SDDC Manager representation
type SddcManager struct {
	// BasicAuthDetails Basic auth details
	BasicAuthDetails *BasicAuthDetails `json:"basicAuthDetails,omitempty"`

	// Domain Represents a domain reference
	Domain *DomainReference `json:"domain,omitempty"`

	// Fqdn FQDN of the SDDC Manager
	Fqdn *string `json:"fqdn,omitempty"`

	// Id ID of the SDDC Manager
	Id *string `json:"id,omitempty"`

	// IpAddress IP Address of the SDDC Manager
	IpAddress *string `json:"ipAddress,omitempty"`

	// Version Version of the SDDC Manager
	Version *string `json:"version,omitempty"`
}

// SddcManagerInfo SDDC Manager Information
type SddcManagerInfo struct {
	// Fqdn FQDN of the SDDC Manager
	Fqdn *string `json:"fqdn,omitempty"`

	// Id ID of the SDDC Manager
	Id *string `json:"id,omitempty"`

	// IpAddress IP Address of the SDDC Manager
	IpAddress *string `json:"ipAddress,omitempty"`

	// Version Version of the SDDC Manager
	Version *string `json:"version,omitempty"`
}

// SddcManagerRelease Collection of Sddc Manager Releases
type SddcManagerRelease struct {
	// AdditionalMetadata Sddc Manager release additional details
	AdditionalMetadata *string `json:"additionalMetadata,omitempty"`

	// BundleId Bundle ID of the Sddc Manager release
	BundleId *string `json:"bundleId,omitempty"`

	// CumulativeFromVcfVersion Minimum VCF version that this patch bundle can be directly applied on
	CumulativeFromVcfVersion *string `json:"cumulativeFromVcfVersion,omitempty"`

	// Description Sddc Manager release description
	Description *string `json:"description,omitempty"`

	// ReleaseDate Sddc Manager version release date in epoch
	ReleaseDate *int64 `json:"releaseDate,omitempty"`

	// Version Sddc Manager release version
	Version *string `json:"version,omitempty"`
}

// SddcManagerSpec Client input parameters for SDDC Manager Virtual Machine
type SddcManagerSpec struct {
	// Hostname SDDC Manager Hostname.
	Hostname string `json:"hostname"`

	// IpAddress SDDC Manager IP address. Can be omitted if hostname is provided.
	IpAddress *string `json:"ipAddress,omitempty"`

	// LocalUserPassword The local account is a built-in admin account in VCF that can be used in emergency scenarios. The password of this account must be at least 12 characters long. It also must contain at-least 1 uppercase, 1 lowercase, 1 special character specified in braces [!%@$^#?] and 1 digit. In addition, a character cannot be repeated more than 3 times consecutively. This password will be used for other passwords if they have not been passed as input.
	LocalUserPassword *string `json:"localUserPassword,omitempty"`

	// RootUserCredentials Credentials contains the username and password
	RootUserCredentials *SddcCredentials `json:"rootUserCredentials,omitempty"`

	// SecondUserCredentials Credentials contains the username and password
	SecondUserCredentials *SddcCredentials `json:"secondUserCredentials,omitempty"`
}

// SddcNetworkSpec Defines a network spec
type SddcNetworkSpec struct {
	// ActiveUplinks Active Uplinks for teaming policy, specify uplink1 for failover_explicit VSAN Teaming Policy
	ActiveUplinks *[]string `json:"activeUplinks,omitempty"`

	// ExcludeIpAddressRanges This property is deprecated and will be ignored.
	// Deprecated:
	ExcludeIpAddressRanges *[]string `json:"excludeIpAddressRanges,omitempty"`

	// ExcludeIpaddresses This property is deprecated and will be ignored.
	// Deprecated:
	ExcludeIpaddresses *[]string `json:"excludeIpaddresses,omitempty"`

	// Gateway Gateway
	Gateway *string `json:"gateway,omitempty"`

	// IncludeIpAddress IP Addresses to be included
	IncludeIpAddress *[]string `json:"includeIpAddress,omitempty"`

	// IncludeIpAddressRanges IP Address ranges to be included
	IncludeIpAddressRanges *[]IpRange `json:"includeIpAddressRanges,omitempty"`

	// Mtu MTU size
	Mtu *int `json:"mtu,omitempty"`

	// NetworkType Network Type. One among: VSAN, VMOTION, MANAGEMENT, VM_MANAGEMENT or any custom network type
	NetworkType string `json:"networkType"`

	// PortGroupKey Name of the Distributed Portgroup to be created. It will be autogenerated if null
	PortGroupKey *string `json:"portGroupKey,omitempty"`

	// StandbyUplinks Standby Uplinks for teaming policy, specify uplink2 for failover_explicit VSAN Teaming Policy
	StandbyUplinks *[]string `json:"standbyUplinks,omitempty"`

	// Subnet Subnet
	Subnet *string `json:"subnet,omitempty"`

	// SubnetMask Subnet Mask
	SubnetMask *string `json:"subnetMask,omitempty"`

	// TeamingPolicy Teaming Policy for VSAN and VMOTION network types, Default is loadbalance_loadbased. One among:loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, loadbalance_loadbased
	TeamingPolicy *string `json:"teamingPolicy,omitempty"`

	// VlanId VLAN ID
	VlanId int `json:"vlanId"`
}

// SddcNsxtSpec Spec contains parameters for NSX deployment and configurations
type SddcNsxtSpec struct {
	// IpAddressPoolSpec This specification contains the parameters required to create or reuse an IP address pool.
	IpAddressPoolSpec *IpAddressPoolSpec `json:"ipAddressPoolSpec,omitempty"`

	// NsxtAdminPassword NSX admin password. The password must be at least 12 characters long. Must contain at-least 1 uppercase, 1 lowercase, 1 special character and 1 digit. In addition, a character cannot be repeated 3 or more times consectively. If blank, the SDDC Local Admin Password will be used.
	NsxtAdminPassword *string `json:"nsxtAdminPassword,omitempty"`

	// NsxtAuditPassword NSX audit password. The password must be at least 12 characters long. Must contain at-least 1 uppercase, 1 lowercase, 1 special character and 1 digit. In addition, a character cannot be repeated 3 or more times consectively. If blank, the SDDC Local Admin Password will be used.
	NsxtAuditPassword *string `json:"nsxtAuditPassword,omitempty"`

	// NsxtLicense NSX Manager license
	NsxtLicense *string `json:"nsxtLicense,omitempty"`

	// NsxtManagerSize NSX Manager size. One among: medium, large,xlarge. Default value if not provided is medium
	NsxtManagerSize *string `json:"nsxtManagerSize,omitempty"`

	// NsxtManagers NSX Managers
	NsxtManagers []NsxtManagerSpec `json:"nsxtManagers"`

	// OverLayTransportZone Spec contains required parameters for NSX Transport Zone
	// Deprecated:
	OverLayTransportZone *NsxtTransportZone `json:"overLayTransportZone,omitempty"`

	// RootNsxtManagerPassword NSX Manager root password. Password should have 1) At least eight characters, 2) At least one lower-case letter, 3) At least one upper-case letter 4) At least one digit 5) At least one special character, 6) At least five different characters , 7) No dictionary words, 6) No palindromes. If blank, the SDDC Local Admin Password will be used.
	RootNsxtManagerPassword *string `json:"rootNsxtManagerPassword,omitempty"`

	// TransportVlanId Transport VLAN ID. Default '0' if not specified
	TransportVlanId *int32 `json:"transportVlanId,omitempty"`

	// Vip Virtual IP address which would act as proxy/alias for NSX Managers. Can be omitted if VIP hostname is provided.
	Vip *string `json:"vip,omitempty"`

	// VipFqdn Hostname for VIP so that common SSL certificates can be installed across all managers.
	VipFqdn string `json:"vipFqdn"`
}

// SddcSpec SDDC specification
type SddcSpec struct {
	// CeipEnabled Enable VCF Customer Experience Improvement Program
	CeipEnabled *bool `json:"ceipEnabled,omitempty"`

	// ClusterSpec Spec contains parameters for vCenter Cluster
	ClusterSpec *SddcClusterSpec `json:"clusterSpec,omitempty"`

	// DeployWithoutLicenseKeys Flag that indicates if the deployment should happen without license keys.
	DeployWithoutLicenseKeys *bool `json:"deployWithoutLicenseKeys,omitempty"`

	// DnsSpec Spec contains parameters of Domain Name System
	DnsSpec DnsSpec `json:"dnsSpec"`

	// DvSwitchVersion The version of the Distributed vSphere Switches to be used. One among: 7.0.0, 7.0.2, 7.0.3, 8.0.0. If blank, then the latest version will be obtain from vCenter Server
	DvSwitchVersion *string `json:"dvSwitchVersion,omitempty"`

	// DvsSpecs List of vSphere Distributed Switches to be created. For VCF only: if blank, a default single one will be created for all types of traffic connected to vmnic0 and vmnic1
	DvsSpecs *[]DvsSpec `json:"dvsSpecs,omitempty"`

	// EsxLicense License for the ESXi hosts
	EsxLicense *string `json:"esxLicense,omitempty"`

	// ExcludedComponents Components of the workflow to be excluded. NOTE: Leave this empty unless you are fully aware of what you are doing.
	ExcludedComponents *[]string `json:"excludedComponents,omitempty"`

	// FipsEnabled Enable Federal Information Processing Standards
	FipsEnabled *bool `json:"fipsEnabled,omitempty"`

	// HostSpecs List of ESXi to be added to the Management Cluster
	HostSpecs []SddcHostSpec `json:"hostSpecs"`

	// ManagementPoolName Name for the network pool to be created and associated with the Management Cluster
	ManagementPoolName *string `json:"managementPoolName,omitempty"`

	// NetworkSpecs List of Networks which be created and used for Management Cluster
	NetworkSpecs []SddcNetworkSpec `json:"networkSpecs"`

	// NsxtSpec Spec contains parameters for NSX deployment and configurations
	NsxtSpec *SddcNsxtSpec `json:"nsxtSpec,omitempty"`

	// NtpServers List of NTP servers to be used for configuring Management Appliances
	NtpServers []string `json:"ntpServers"`

	// ProxySpec Spec contains parameters for proxy settings
	ProxySpec *ProxySpec `json:"proxySpec,omitempty"`

	// PscSpecs Specification for SSO Configuration in the Management vCenter Server Appliance
	PscSpecs *[]PscSpec `json:"pscSpecs,omitempty"`

	// SddcId Client string that identifies an SDDC by name or instance name. Used for management domain name. Can contain only letters, numbers and the following symbols: '-'
	SddcId string `json:"sddcId"`

	// SddcManagerSpec Client input parameters for SDDC Manager Virtual Machine
	SddcManagerSpec *SddcManagerSpec `json:"sddcManagerSpec,omitempty"`

	// SecuritySpec Spec contains security settings
	SecuritySpec *SecuritySpec `json:"securitySpec,omitempty"`

	// SkipEsxThumbprintValidation Skip ESXi thumbprint validation
	SkipEsxThumbprintValidation *bool `json:"skipEsxThumbprintValidation,omitempty"`

	// SkipGatewayPingValidation Skip networks gateway connectivity validation
	SkipGatewayPingValidation *bool `json:"skipGatewayPingValidation,omitempty"`

	// TaskName Name of the task to execute. This is deprecated. Please use property 'workflowType'
	// Deprecated:
	TaskName *string `json:"taskName,omitempty"`

	// VcenterSpec Spec contains parameters for vCenter
	VcenterSpec SddcVcenterSpec `json:"vcenterSpec"`

	// VsanSpec Spec contains parameters of Virtual SAN
	VsanSpec *VsanSpec `json:"vsanSpec,omitempty"`

	// VxManagerSpec Spec contains parameters for VxRail Manager
	VxManagerSpec *VxManagerSpec `json:"vxManagerSpec,omitempty"`

	// WorkflowType Type of workflow to initiate creation and/or validation of SDDC
	WorkflowType *string `json:"workflowType,omitempty"`
}

// SddcSubTask Represents a SDDC sub-task
type SddcSubTask struct {
	// CreationTimestamp Sub-Task Creation Time
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Description Sub-Task Description
	Description *string `json:"description,omitempty"`

	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// LocalizableDescriptionPack A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
	LocalizableDescriptionPack *MessagePack `json:"localizableDescriptionPack,omitempty"`

	// LocalizableNamePack A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
	LocalizableNamePack *MessagePack `json:"localizableNamePack,omitempty"`

	// Name Sub-Task Name
	Name *string `json:"name,omitempty"`

	// ProcessingStateDescription Processing category description, e.g., VC Deployment, VSAN configuration etc
	ProcessingStateDescription *string `json:"processingStateDescription,omitempty"`

	// ProcessingStateName Processing category name, e.g., VC Deployment, VSAN configuration etc
	ProcessingStateName *string `json:"processingStateName,omitempty"`

	// SddcId SDDC ID
	SddcId *string `json:"sddcId,omitempty"`

	// Status Task Status
	Status *string `json:"status,omitempty"`

	// UpdateTimestamp Last Update Time of Sub-Task
	UpdateTimestamp *string `json:"updateTimestamp,omitempty"`
}

// SddcTask Represents a SDDC task
type SddcTask struct {
	// CreationTimestamp SDDC Task creation timestamp
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Id SDDC ID
	Id *string `json:"id,omitempty"`

	// LocalizableNamePack A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
	LocalizableNamePack *MessagePack `json:"localizableNamePack,omitempty"`

	// Name Task name
	Name *string `json:"name,omitempty"`

	// SddcSubTasks All SDDC Sub-Tasks
	SddcSubTasks *[]SddcSubTask `json:"sddcSubTasks,omitempty"`

	// Status SDDC Task status. One among: IN_PROGRESS, COMPLETED_WITH_SUCCESS, ROLLBACK_SUCCESS, COMPLETED_WITH_FAILURE
	Status *string `json:"status,omitempty"`
}

// SddcVcenterSpec Spec contains parameters for vCenter
type SddcVcenterSpec struct {
	// LicenseFile License File/Key
	LicenseFile *string `json:"licenseFile,omitempty"`

	// RootVcenterPassword vCenter root password. The password must be between 8 characters and 20 characters long. It must also contain at least one uppercase and lowercase letter, one number, and one character from '! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { &Iota; } ~' and all characters must be ASCII. Space is not allowed in password. For VCF only: if blank, the SDDC Local Admin Password will be used.
	RootVcenterPassword string `json:"rootVcenterPassword"`

	// SshThumbprint vCenter Server SSH thumbprint (RSA SHA256). This is only for VCF on VxRail
	SshThumbprint *string `json:"sshThumbprint,omitempty"`

	// SslThumbprint vCenter Server SSL thumbprint (SHA256). This is only for VCF on VxRail
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// StorageSize vCenter Virtual Machine Storage size. One among:lstorage, xlstorage
	StorageSize *string `json:"storageSize,omitempty"`

	// VcenterHostname vCenter hostname address.
	VcenterHostname string `json:"vcenterHostname"`

	// VcenterIp vCenter IP address. Can be omitted if hostname is provided.
	VcenterIp *string `json:"vcenterIp,omitempty"`

	// VmSize vCenter Virtual Machine size. One among:xlarge, large, medium, small, tiny
	VmSize *string `json:"vmSize,omitempty"`
}

// SecuritySpec Spec contains security settings
type SecuritySpec struct {
	// EsxiCertsMode ESXi certificates mode. One among:Custom, VMCA
	EsxiCertsMode *string `json:"esxiCertsMode,omitempty"`

	// RootCaCerts Root Certificate Authority certificate list
	RootCaCerts *[]RootCaCerts `json:"rootCaCerts,omitempty"`
}

// SelectedCheckSetCandidate Selected check-set candidate
type SelectedCheckSetCandidate struct {
	// CheckSetId Id of the selected check-set
	CheckSetId string `json:"checkSetId"`
}

// SharesInfo Specify relative allocation between resource consumers
type SharesInfo struct {
	// Level The allocation level
	Level *string `json:"level,omitempty"`

	// Shares The number of shares allocated
	Shares *int32 `json:"shares,omitempty"`
}

// SkuBomDetails Model for sku with their name, description, patchBundles and bom
type SkuBomDetails struct {
	// Bom Sku specific bill of materials
	Bom *[]ProductVersion `json:"bom,omitempty"`

	// Description Description to be shown in release page
	Description *string `json:"description,omitempty"`

	// Name SKU name
	Name *string `json:"name,omitempty"`

	// SkuSpecificPatchBundles List of patch bundles in this release
	SkuSpecificPatchBundles *[]SkuSpecificPatchBundles `json:"skuSpecificPatchBundles,omitempty"`
}

// SkuSpecificPatchBundles Model for Sku specific patch bundle in a release
type SkuSpecificPatchBundles struct {
	// BundleType Bundle type of the patch bundle
	BundleType *string `json:"bundleType,omitempty"`

	// BundleVersion Bundle Version of the product
	BundleVersion *string `json:"bundleVersion,omitempty"`

	// Version Product version
	Version *string `json:"version,omitempty"`
}

// SmartNicInfo Represents informtion related to smart nic
type SmartNicInfo struct {
	// DpuId Dpu ID corresponding to the SmartNicInfo
	DpuId *string `json:"dpuId,omitempty"`

	// VendorName Vendor Name of the SmartNicInfo
	VendorName *string `json:"vendorName,omitempty"`
}

// SoftwareComponent Software Components which are Upgradable
type SoftwareComponent struct {
	// Id ID of Resource/Software Component
	Id *string `json:"id,omitempty"`

	// Type Type of Resource/Software Component
	Type *string `json:"type,omitempty"`
}

// SoftwareInfo SoftwareSpec contains base os, components, hardware support, addOn metadata to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
type SoftwareInfo struct {
	// AddOn AddOn contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
	AddOn *AddOnInfo `json:"addOn,omitempty"`

	// BaseImage BaseImage contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
	BaseImage *BaseImageInfo `json:"baseImage,omitempty"`

	// Components Personality components
	Components *map[string]ComponentInfo `json:"components,omitempty"`

	// HardwareSupport Hardware support contains base os, components, hardware support, addOn metadata to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
	HardwareSupport *HardwareSupportInfo `json:"hardwareSupport,omitempty"`
}

// SourceDetails Details of the Identity Source
type SourceDetails struct {
	// CertChain SSL certificate chain in base64 encoding. This field can be unset only, if all the active directory server endpoints use the LDAP (not LDAPS) protocol
	CertChain *[]string `json:"certChain,omitempty"`

	// GroupsBaseDn Base distinguished name for groups
	GroupsBaseDn string `json:"groupsBaseDn"`

	// ServerEndpoints Active directory server endpoints. At least one active directory server endpoint must be set
	ServerEndpoints []string `json:"serverEndpoints"`

	// UsersBaseDn Base distinguished name for users
	UsersBaseDn string `json:"usersBaseDn"`
}

// SsoDomainEntity Represents SSO domain entity
type SsoDomainEntity struct {
	// Id The ID of the SSO domain entity
	Id *string `json:"id,omitempty"`

	// Name The name of the SSO domain entity
	Name *string `json:"name,omitempty"`

	// Type The type of the SSO domain entity
	Type *string `json:"type,omitempty"`
}

// SsoDomainSpec Spec for the SSO configuration in a VMware Cloud Foundation Domain
type SsoDomainSpec struct {
	// SsoDomainName SSO domain name to be created
	SsoDomainName *string `json:"ssoDomainName,omitempty"`

	// SsoDomainPassword New SSO domain password
	SsoDomainPassword *string `json:"ssoDomainPassword,omitempty"`
}

// Stage Represents a Stage
type Stage struct {
	CompletionTimestamp string `json:"completionTimestamp"`
	CreationTimestamp   string `json:"creationTimestamp"`

	// Description Stage description
	Description *string `json:"description,omitempty"`

	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// Name Stage name
	Name *string `json:"name,omitempty"`

	// Status Stage status
	Status *string `json:"status,omitempty"`

	// Type Stage type
	Type *string `json:"type,omitempty"`
}

// Storage Represents information about storage on a host
type Storage struct {
	// Disks Information about disks
	Disks *[]Disk `json:"disks,omitempty"`

	// TotalCapacityMB Total storage capacity in MB
	TotalCapacityMB *float64 `json:"totalCapacityMB,omitempty"`

	// UsedCapacityMB Used storage capacity in MB
	UsedCapacityMB *float64 `json:"usedCapacityMB,omitempty"`
}

// StorageContainer Storage container representation
type StorageContainer struct {
	// ClusterId ID of the cluster which is using the storage container
	ClusterId *string `json:"clusterId,omitempty"`

	// Id ID of the storage container
	Id *string `json:"id,omitempty"`

	// Name Name of the storage container
	Name string `json:"name"`

	// ProtocolType Storage protocol type
	ProtocolType string `json:"protocolType"`
}

// StorageContainerUpdateSpec Storage container update data
type StorageContainerUpdateSpec struct {
	// Name Name of the storage container
	Name string `json:"name"`
}

// StorageInfo Represents a storage metric with used and total for a resource
type StorageInfo struct {
	// Total Represents a single metric representing digital data
	Total *DataMetric `json:"total,omitempty"`

	// Used Represents a single metric representing digital data
	Used *DataMetric `json:"used,omitempty"`
}

// StretchClusterNetworkProfile This specification contains the host switch configurations for the NSX transport nodes belonging to Secondary AZ.
type StretchClusterNetworkProfile struct {
	// Description The network profile description
	Description *string `json:"description,omitempty"`

	// Name The network profile name
	Name string `json:"name"`

	// NsxtHostSwitchConfigs The list of NSX host switch configurations
	NsxtHostSwitchConfigs []NsxtHostSwitchConfig `json:"nsxtHostSwitchConfigs"`
}

// SubTask Represents a sub-task
type SubTask struct {
	// CompletionTimestamp Sub-task completion timestamp
	CompletionTimestamp *string `json:"completionTimestamp,omitempty"`

	// CreationTimestamp Sub-task creation timestamp
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Description Sub-task description
	Description *string `json:"description,omitempty"`

	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// Name Sub-task name
	Name *string `json:"name,omitempty"`

	// Resources List of resources associated with sub-task
	Resources *[]Resource `json:"resources,omitempty"`

	// Stages List of stages of the sub-task
	Stages *[]Stage `json:"stages,omitempty"`

	// Status Sub-task status
	Status *string `json:"status,omitempty"`

	// SubTasks List of child subtasks associated with this subtask
	SubTasks *[]SubTask `json:"subTasks,omitempty"`

	// Type Sub-task type
	Type *string `json:"type,omitempty"`
}

// SupportBundle defines model for SupportBundle.
type SupportBundle struct {
	// BundleAvailable Indicate if bundle is available in file system.
	BundleAvailable *string `json:"bundleAvailable,omitempty"`

	// BundleName Name of the Support Bundle.
	BundleName *string `json:"bundleName,omitempty"`

	// CompletionTimestamp CompletionTimestamp.
	CompletionTimestamp *string `json:"completionTimestamp,omitempty"`

	// CreationTimestamp CreationTimestamp.
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Description Name of the Operation.
	Description *string `json:"description,omitempty"`

	// Id Id of the Support Bundle task.
	Id *string `json:"id,omitempty"`

	// Status Support Bundle Status.
	Status *string `json:"status,omitempty"`
}

// SupportBundleConfig SupportBundle config.
type SupportBundleConfig struct {
	// Force Run SOS operations, even if there is a Workload running.
	Force *bool `json:"force,omitempty"`

	// SkipKnownHostCheck Skip known_hosts file for SupportBundle collection.
	SkipKnownHostCheck *bool `json:"skipKnownHostCheck,omitempty"`
}

// SupportBundleIncludeItems Sos Additional Reports for Support Bundle.
type SupportBundleIncludeItems struct {
	// HealthCheck Perform SOS Health checks.
	HealthCheck *bool `json:"healthCheck,omitempty"`

	// SummaryReport Collect Vcf Summary Reports.
	SummaryReport *bool `json:"summaryReport,omitempty"`
}

// SupportBundleOption Sos options for support bundle collection.
type SupportBundleOption struct {
	// Config SupportBundle config.
	Config *SupportBundleConfig `json:"config,omitempty"`

	// Include Sos Additional Reports for Support Bundle.
	Include *SupportBundleIncludeItems `json:"include,omitempty"`
}

// SupportBundleScope Domain and cluster under which logs should be collected.
type SupportBundleScope struct {
	// Domains Domains and Clusters for SOS operation.
	Domains *[]Domains `json:"domains,omitempty"`

	// IncludeFreeHosts Include free hosts.
	IncludeFreeHosts *bool `json:"includeFreeHosts,omitempty"`
}

// SupportBundleSpec defines model for SupportBundleSpec.
type SupportBundleSpec struct {
	// Logs Logs of different components.
	Logs *Logs `json:"logs,omitempty"`

	// Options Sos options for support bundle collection.
	Options *SupportBundleOption `json:"options,omitempty"`

	// Scope Domain and cluster under which logs should be collected.
	Scope *SupportBundleScope `json:"scope,omitempty"`
}

// SyncClientTokenInfo Represents the information about sync client token
type SyncClientTokenInfo struct {
	// ExpireAt The seconds at which the token expires
	ExpireAt *string `json:"expireAt,omitempty"`

	// ExpireIn The seconds in which the token expires. Please start using expireAt field for the same.
	// Deprecated:
	ExpireIn *int64 `json:"expireIn,omitempty"`

	// ScimUrl The WS1B SCIM URL to push users and groups data from external identity provider
	ScimUrl *string `json:"scimUrl,omitempty"`

	// Token The sync client bearer token
	Token *string `json:"token,omitempty"`
}

// System Represents a system
type System struct {
	// Id The identifier of the system
	Id *string `json:"id,omitempty"`

	// MaxAllowedDomainsInSubscription The maximum number of domains allowed in subscription mode
	MaxAllowedDomainsInSubscription *int32 `json:"maxAllowedDomainsInSubscription,omitempty"`
}

// SystemUpdateSpec Contains the parameters required to perform update operation on system
type SystemUpdateSpec struct {
	// MaxAllowedDomainsInSubscription new limit of amount of domains in subscription mode
	MaxAllowedDomainsInSubscription int32 `json:"maxAllowedDomainsInSubscription"`
}

// Tag Represents a tag
type Tag struct {
	// CategoryId ID of the tag category
	CategoryId *string `json:"categoryId,omitempty"`

	// CategoryName Category name of the tag
	CategoryName *string `json:"categoryName,omitempty"`

	// Id ID of the tag
	Id *string `json:"id,omitempty"`

	// Name Name of the tag
	Name *string `json:"name,omitempty"`
}

// TagAssignmentResult Represents a Tag Assignment Result
type TagAssignmentResult struct {
	// DefaultErrorMessages Default Error messages for Assign/Detach Tags operation
	DefaultErrorMessages *[]string `json:"defaultErrorMessages,omitempty"`

	// Success Success value of Assign/Detach Tags operation
	Success *bool `json:"success,omitempty"`
}

// TagManagerModel Represents a Tag Manager Model
type TagManagerModel struct {
	// TagManagerUrl Tag Manager URL value
	TagManagerUrl *string `json:"tagManagerUrl,omitempty"`
}

// TaggedResource Specifies a resource with id and type
type TaggedResource struct {
	// Id ID of the resource
	Id *string `json:"id,omitempty"`

	// Type Type of the resource
	Type *string `json:"type,omitempty"`
}

// TagsForResource Represents a taggable resource with its associations
type TagsForResource struct {
	// Resource Specifies a resource with id and type
	Resource *TaggedResource `json:"resource,omitempty"`

	// Tags List of associated tags
	Tags *[]Tag `json:"tags,omitempty"`
}

// TagsSpec Tags Spec
type TagsSpec struct {
	// TagIds Tag IDs
	TagIds []string `json:"tagIds"`
}

// TargetProductVersion Model for target product versions in domain release view.
type TargetProductVersion struct {
	// ProductType Product Type
	ProductType string `json:"productType"`

	// Version Target upgrade version of the product
	Version string `json:"version"`
}

// Task Represents a task
type Task struct {
	// CompletionTimestamp Task completion timestamp
	CompletionTimestamp *string `json:"completionTimestamp,omitempty"`

	// CreationTimestamp Task creation timestamp
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Errors List of errors in case of a failure
	Errors *[]Error `json:"errors,omitempty"`

	// Id Task ID
	Id *string `json:"id,omitempty"`

	// IsCancellable Represents task can be cancellable or not.
	IsCancellable *bool `json:"isCancellable,omitempty"`

	// IsRetryable Indicates whether a task is eligible for retry or not.
	IsRetryable *bool `json:"isRetryable,omitempty"`

	// LocalizableDescriptionPack A message pack representing a localizable message and suitable for machine processing. Contains a message key unique in the scope of the specified component, as well as the arguments needed to generate the localized message.
	LocalizableDescriptionPack *MessagePack `json:"localizableDescriptionPack,omitempty"`

	// Name Task name
	Name *string `json:"name,omitempty"`

	// ResolutionStatus Resolution state
	ResolutionStatus *string `json:"resolutionStatus,omitempty"`

	// Resources List of resources associated with task
	Resources *[]Resource `json:"resources,omitempty"`

	// Status Task status
	Status *string `json:"status,omitempty"`

	// SubTasks List of sub-tasks of the task
	SubTasks *[]SubTask `json:"subTasks,omitempty"`

	// Type Operation that is represented by the Task in machine readable format.  The value is controlled by the owners/producers of the Task. The convention is <resource>_<operation>
	Type *string `json:"type,omitempty"`
}

// TeamingSpec This specification contains the teaming policies associated with the uplink profile.
type TeamingSpec struct {
	// ActiveUplinks The list of active uplinks
	ActiveUplinks []string `json:"activeUplinks"`

	// Policy The teaming policy associated with the uplink profile
	Policy string `json:"policy"`

	// StandByUplinks The list of stand by uplinks
	StandByUplinks *[]string `json:"standByUplinks,omitempty"`
}

// TemporaryNetwork Temporary Network for vCenter Upgrade
type TemporaryNetwork struct {
	// Gateway Gateway for vCenter Upgrade temporary network
	Gateway string `json:"gateway"`

	// IpAddress IP Address for vCenter Upgrade temporary network
	IpAddress string `json:"ipAddress"`

	// SubnetMask Subnet Mask for vCenter Upgrade temporary network
	SubnetMask string `json:"subnetMask"`
}

// TokenCreationSpec The spec used to sign the token
type TokenCreationSpec struct {
	// ApiKey API Key
	ApiKey *string `json:"apiKey,omitempty"`

	// IdToken Id Token
	IdToken *string `json:"idToken,omitempty"`

	// Password User Password
	Password *string `json:"password,omitempty"`

	// Username Username
	Username *string `json:"username,omitempty"`
}

// TokenPair This contains the access token and the refresh token for the user API access.
type TokenPair struct {
	// AccessToken Bearer token that can be used to make public API calls
	AccessToken *string `json:"accessToken,omitempty"`

	// RefreshToken This contains refresh token id for the user API access.
	RefreshToken *RefreshToken `json:"refreshToken,omitempty"`
}

// TransportZone The transport zone to be associated with the vSphere Distributed Switch managed by NSX
type TransportZone struct {
	// Name The name of the transport zone
	Name *string `json:"name,omitempty"`

	// TransportType The type of the transport zone
	TransportType string `json:"transportType"`
}

// TrustedCertificate The Trusted Certificate details.
type TrustedCertificate struct {
	// Alias Certificate alias
	Alias string `json:"alias"`

	// Certificate Certificate in PEM format
	Certificate string `json:"certificate"`
}

// TrustedCertificateSpec This specification contains certificate & certificate usage
type TrustedCertificateSpec struct {
	// Certificate Certificate in PEM format
	Certificate string `json:"certificate"`

	// CertificateUsageType Certificate usage
	// Deprecated:
	CertificateUsageType *string `json:"certificateUsageType,omitempty"`
}

// UnmanagedResourceCredential Represents credentials of am unmanaged resource (i.e a resource that is not managed by VCF)
type UnmanagedResourceCredential struct {
	// CredentialType Credential type
	CredentialType string `json:"credentialType"`

	// Password Password
	Password *string `json:"password,omitempty"`

	// Username Username
	Username string `json:"username"`
}

// Upgradable Upgradable represents the upgrade capability of resources. It contains the bundle(using what), resource(on which) and its associated resources/software components that can be upgraded.
type Upgradable struct {
	// BundleId Bundle ID
	BundleId *string `json:"bundleId,omitempty"`

	// BundleType Bundle Type
	BundleType *string `json:"bundleType,omitempty"`

	// Errors Upgradable Errors found during computation of upgrade availabiltiy.
	Errors *[]Error `json:"errors,omitempty"`

	// Resource Represents the resource in the system
	Resource *Resource `json:"resource,omitempty"`

	// SoftwareComponents Software Components which are Upgradable
	SoftwareComponents *[]SoftwareComponent `json:"softwareComponents,omitempty"`

	// Status Upgradable Status
	Status *string `json:"status,omitempty"`
}

// UpgradablesClusterResource Upgradables clusters details with hardware support managers
type UpgradablesClusterResource struct {
	// AvailableHardwareSupportManagers Available Hardware Support Managers for Firmware upgrade
	AvailableHardwareSupportManagers *[]HardwareSupportPackages `json:"availableHardwareSupportManagers,omitempty"`

	// ConfiguredHardwareSupportManagers Configured Hardware Support Managers for Firmware upgrade
	ConfiguredHardwareSupportManagers *[]HardwareSupportPackage `json:"configuredHardwareSupportManagers,omitempty"`

	// PrimaryCluster Flag for primary cluster
	PrimaryCluster *bool `json:"primaryCluster,omitempty"`

	// ResourceId Resource Id
	ResourceId string `json:"resourceId"`

	// ResourceType Resource Type
	ResourceType string `json:"resourceType"`

	// SoftwareInfo SoftwareSpec contains base os, components, hardware support, addOn metadata to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
	SoftwareInfo *SoftwareInfo `json:"softwareInfo,omitempty"`

	// VlcmEnabled Flag to determine if vLCM enabled on the cluster
	VlcmEnabled *bool `json:"vlcmEnabled,omitempty"`
}

// Upgrade Upgrade object which contain details regarding the upgrade
type Upgrade struct {
	// Bundle Bundle contains bits to install/update the appropriate Cloud Foundation software components in your management domain or workload domain.
	Bundle *Bundle `json:"bundle,omitempty"`

	// BundleId Bundle ID for Upgrade
	BundleId string `json:"bundleId"`

	// EndTime End time of the upgrade
	EndTime *int64 `json:"endTime,omitempty"`

	// Id ID for Upgrade
	Id string `json:"id"`

	// NsxtUpgradeUserInputSpec NSX Upgrade User Input Specification
	NsxtUpgradeUserInputSpec *NsxtUpgradeUserInputSpec `json:"nsxtUpgradeUserInputSpec,omitempty"`

	// ParallelUpgrade Boolean to represent components will be upgraded in parallel on not
	ParallelUpgrade *bool `json:"parallelUpgrade,omitempty"`

	// ResourceType Resource Type for Upgrade
	ResourceType string `json:"resourceType"`

	// ResourceUpgradeSpecs Resource Upgrade Specifications
	ResourceUpgradeSpecs []ResourceUpgradeSpec `json:"resourceUpgradeSpecs"`

	// Status Overall upgrade status
	Status string `json:"status"`

	// TaskId Task ID associated with upgrade
	TaskId string `json:"taskId"`
}

// UpgradeCommitSpec Upgrade Commit/Reschedule Specification
type UpgradeCommitSpec struct {
	// MarkForCancellation Flag for marking an upgrade for cancellation.  If set to true, other fields in the request will be ignored
	MarkForCancellation *bool `json:"markForCancellation,omitempty"`

	// ScheduledTimestamp Upgrade Scheduled Time
	ScheduledTimestamp *string `json:"scheduledTimestamp,omitempty"`

	// UpgradeNow Flag for enabling Upgrade Now. If true, scheduledTimestamp is ignored
	UpgradeNow *bool `json:"upgradeNow,omitempty"`
}

// UpgradeSpec Upgrade Specification
type UpgradeSpec struct {
	// BundleId Bundle ID for Upgrade
	BundleId string `json:"bundleId"`

	// DraftMode Boolean to represent upgrade will be created in DRAFT mode. This allows to run prechecks before user confirm/commit the upgrade.
	DraftMode *bool `json:"draftMode,omitempty"`

	// NsxtUpgradeUserInputSpecs Resource Upgrade Specifications for NSX upgrade
	NsxtUpgradeUserInputSpecs *[]NsxtUpgradeUserInputSpec `json:"nsxtUpgradeUserInputSpecs,omitempty"`

	// ParallelUpgrade Boolean to represent components will be upgraded in parallel on not
	ParallelUpgrade *bool `json:"parallelUpgrade,omitempty"`

	// ResourceType Resource Type for Upgrade
	ResourceType string `json:"resourceType"`

	// ResourceUpgradeSpecs Resource Upgrade Specifications
	ResourceUpgradeSpecs []ResourceUpgradeSpec `json:"resourceUpgradeSpecs"`

	// VcenterUpgradeUserInputSpecs User Input for vCenter upgrade
	VcenterUpgradeUserInputSpecs *[]VcenterUpgradeUserInputSpec `json:"vcenterUpgradeUserInputSpecs,omitempty"`
}

// UpgradeStatus Represents upgrade status of a domain
type UpgradeStatus struct {
	// CompletedResources Number of completed resources
	CompletedResources *int32 `json:"completedResources,omitempty"`

	// Status Upgrade status
	Status *string `json:"status,omitempty"`

	// TotalResources Total number of resources
	TotalResources *int32 `json:"totalResources,omitempty"`
}

// UplinkMapping The map of vSphere Distributed Switch uplinks to the NSX switch uplinks.
type UplinkMapping struct {
	// NsxUplinkName The uplink name of the NSX switch
	NsxUplinkName string `json:"nsxUplinkName"`

	// VdsUplinkName The uplink name of the vSphere Distributed Switch
	VdsUplinkName string `json:"vdsUplinkName"`
}

// UplinkProfile This specification contains the policies for the links from hypervisor hosts to NSX logical switch.
type UplinkProfile struct {
	// Name The uplink profile name
	Name string `json:"name"`

	// SupportedTeamingPolicies List of supported teaming policies in NSX
	SupportedTeamingPolicies *map[string]string `json:"supportedTeamingPolicies,omitempty"`

	// Teamings The teaming policies to be associated with the uplink profile
	Teamings []TeamingSpec `json:"teamings"`

	// TransportVlan The VLAN used for tagging overlay traffic of the associated Host Switch
	TransportVlan *int32 `json:"transportVlan,omitempty"`
}

// User Represents user and its attributes
type User struct {
	// ApiKey The API key of the user
	ApiKey *string `json:"apiKey,omitempty"`

	// CreationTimestamp The timestamp at which the user was created
	CreationTimestamp *string `json:"creationTimestamp,omitempty"`

	// Domain The domain of the user
	Domain *string `json:"domain,omitempty"`

	// Id The ID of the user
	Id *string `json:"id,omitempty"`

	// Name The name of the user
	Name string `json:"name"`

	// Role Represents a role reference
	Role RoleReference `json:"role"`

	// Type The type of the user
	Type string `json:"type"`
}

// VMNicInfo VMNics attached to an ESXi host reference
type VMNicInfo struct {
	// IsActive Status of VMNic if active or inactive
	IsActive *bool `json:"isActive,omitempty"`

	// IsAutoNegotiateSupported Status of VMNic if auto negotiate is supported or not
	IsAutoNegotiateSupported *bool `json:"isAutoNegotiateSupported,omitempty"`

	// IsInUse Status of VMNic if in use or available
	IsInUse *bool `json:"isInUse,omitempty"`

	// LinkSpeedMB VMNic link speed in MB
	LinkSpeedMB *int32 `json:"linkSpeedMB,omitempty"`

	// Name Name of the VMNic
	Name *string `json:"name,omitempty"`
}

// VSANNetworkSpec Contains the vSAN Network details
type VSANNetworkSpec struct {
	// VsanCidr vSAN subnet cidr of the ESXi host
	VsanCidr string `json:"vsanCidr"`

	// VsanGatewayIP vSAN Gateway IP of the ESXi host
	VsanGatewayIP string `json:"vsanGatewayIP"`
}

// Validation Represents a validation with a list of one or more validation checks that are performed as part of the validation
type Validation struct {
	AdditionalProperties *map[string]string `json:"additionalProperties,omitempty"`

	// Description Description of the validation
	Description *string `json:"description,omitempty"`

	// ExecutionStatus Execution status of the validation. One among: IN_PROGRESS, FAILED, COMPLETED, UNKNOWN, SKIPPED, CANCELLED, CANCELLATION_IN_PROGRESS
	ExecutionStatus *string `json:"executionStatus,omitempty"`

	// Id ID of the validation
	Id *string `json:"id,omitempty"`

	// ResultStatus Result status of the validation after it has completed its execution. One among: SUCCEEDED, FAILED, FAILED_WITH_WARNINGS, UNKNOWN, CANCELLATION_IN_PROGRESS
	ResultStatus *string `json:"resultStatus,omitempty"`

	// ValidationChecks List of one or more validation checks that are performed as part of the validation
	ValidationChecks *[]ValidationCheck `json:"validationChecks,omitempty"`
}

// ValidationCheck Represents a validation check
type ValidationCheck struct {
	// Description Description of the validation check
	Description *string `json:"description,omitempty"`

	// ErrorResponse Error response containing a minor error code, a localized error message, a localized remediation message and optionally a reference token to correlate the error with the logs
	ErrorResponse *Error `json:"errorResponse,omitempty"`

	// ResultStatus Result status of the validation check after it has completed its execution
	ResultStatus string `json:"resultStatus"`

	// Severity Severity of the validation check
	Severity *string `json:"severity,omitempty"`
}

// VasaProvider VASA Provider representation
type VasaProvider struct {
	// Id ID of the VASA Provider
	Id *string `json:"id,omitempty"`

	// Name Name of the VASA Provider
	Name string `json:"name"`

	// StorageContainers List of storage containers associated with the VASA Provider
	StorageContainers []StorageContainer `json:"storageContainers"`

	// Url URL of the VASA Provider
	Url string `json:"url"`

	// Users List of users associated with the VASA Provider
	Users []VasaUser `json:"users"`
}

// VasaProviderSpec This specification contains cluster storage configuration for vVol
type VasaProviderSpec struct {
	// StorageContainerId UUID of the VASA storage container
	StorageContainerId string `json:"storageContainerId"`

	// StorageProtocolType Type of the VASA storage protocol
	StorageProtocolType string `json:"storageProtocolType"`

	// UserId UUID of the VASA storage user
	UserId string `json:"userId"`

	// VasaProviderId UUID of the VASA storage provider
	VasaProviderId string `json:"vasaProviderId"`
}

// VasaProviderUpdateSpec VASA Provider update data
type VasaProviderUpdateSpec struct {
	// Name Name of the VASA Provider
	Name *string `json:"name,omitempty"`

	// Url URL of the VASA Provider
	Url *string `json:"url,omitempty"`
}

// VasaUser VASA User representation
type VasaUser struct {
	// Id ID of the VASA User
	Id *string `json:"id,omitempty"`

	// Password Password
	Password string `json:"password"`

	// Username VASA User name
	Username string `json:"username"`
}

// VasaUserUpdateSpec User update data
type VasaUserUpdateSpec struct {
	// Password Password
	Password *string `json:"password,omitempty"`

	// Username VASA User name
	Username *string `json:"username,omitempty"`
}

// VcIdentitySources Represents embedded Identity Sources and its attributes.
type VcIdentitySources struct {
	// DomainNames The Domains of the Identity Source
	DomainNames *[]string `json:"domainNames,omitempty"`

	// Ldap Represents Identity management configuration when the protocol is LDAP
	Ldap *LdapInfo `json:"ldap,omitempty"`

	// Name Name of the Identity Source.
	Name *string `json:"name,omitempty"`

	// Type Type of the Identity Source.
	Type *string `json:"type,omitempty"`
}

// Vcenter vCenter representation
type Vcenter struct {
	// Domain Represents a domain reference
	Domain *DomainReference `json:"domain,omitempty"`

	// Fqdn FQDN of the vCenter
	Fqdn *string `json:"fqdn,omitempty"`

	// Id ID of the vCenter
	Id *string `json:"id,omitempty"`

	// IpAddress IP address of the vCenter
	IpAddress *string `json:"ipAddress,omitempty"`

	// Version Version of the vCenter
	Version *string `json:"version,omitempty"`
}

// VcenterReference Represents a vCenter reference
type VcenterReference struct {
	// Fqdn FQDN of the vCenter
	Fqdn *string `json:"fqdn,omitempty"`

	// Id ID of the vCenter
	Id string `json:"id"`

	// VcInstanceId vCenter instance ID
	VcInstanceId *string `json:"vcInstanceId,omitempty"`
}

// VcenterSpec This specification contains the installation and configuration of vCenter in a workload domain
type VcenterSpec struct {
	// DatacenterName vCenter datacenter name
	DatacenterName *string `json:"datacenterName,omitempty"`

	// Name Name of the vCenter virtual machine
	Name *string `json:"name,omitempty"`

	// NetworkDetailsSpec This specification contains network parameters required for new virtual machines being added to a workload domain
	NetworkDetailsSpec NetworkDetailsSpec `json:"networkDetailsSpec"`

	// RootPassword vCenter root shell password
	RootPassword *string `json:"rootPassword,omitempty"`

	// StorageSize VCenter storage size
	StorageSize *string `json:"storageSize,omitempty"`

	// VmSize VCenter VM size
	VmSize *string `json:"vmSize,omitempty"`
}

// VcenterUpgradeUserInputSpec vCenter Upgrade User Input Specification
type VcenterUpgradeUserInputSpec struct {
	// TemporaryNetwork Temporary Network for vCenter Upgrade
	TemporaryNetwork TemporaryNetwork `json:"temporaryNetwork"`
}

// VcfService VCF service representation
type VcfService struct {
	// Id ID of the service
	Id *string `json:"id,omitempty"`

	// Name Name of the service
	Name *string `json:"name,omitempty"`

	// Status Status of the service
	Status *string `json:"status,omitempty"`

	// Version Version of the service
	Version *string `json:"version,omitempty"`
}

// Vds vSphere distributed switch
type Vds struct {
	// Id vSphere Distributed Switch id
	Id *string `json:"id,omitempty"`

	// IsUsedByNsxt Boolean to identify if the vSphere distributed switch is used by NSX. This property is deprecated in favor of nsxtSwitchConfig field
	IsUsedByNsxt *bool `json:"isUsedByNsxt,omitempty"`

	// Mtu Maximum Transmission Unit
	Mtu *int32 `json:"mtu,omitempty"`

	// Name vSphere Distributed Switch name
	Name string `json:"name"`

	// NiocBandwidthAllocations List of Network I/O Control Bandwidth Allocations for System Traffic
	// Based on shares, reservation, and limit, you can configure Network I/O Control to allocate certain amount of
	// bandwidth for traffic generated by vSphere Fault Tolerance, iSCSI storage, vSphere vMotion, and so on.
	// You can use Network I/O Control on a distributed switch to configure bandwidth allocation for the traffic
	// that is related to the main system features in vSphere
	NiocBandwidthAllocations *[]NiocBandwidthAllocation `json:"niocBandwidthAllocations,omitempty"`

	// NsxtSwitchConfig The network configurations associated with the vSphere Distributed Switch managed by NSX
	NsxtSwitchConfig *NsxtSwitchConfiguration `json:"nsxtSwitchConfig,omitempty"`

	// PortGroups List of portgroups associated with the vSphere Distributed Switch
	PortGroups *[]Portgroup `json:"portGroups,omitempty"`

	// Version vSphere Distributed Switch version
	Version *string `json:"version,omitempty"`
}

// VdsConfiguration The vSphere Distributed Switch network configuration
type VdsConfiguration struct {
	// InventoryMismatchInfo Inventory mismatch levels
	InventoryMismatchInfo *[]InventoryMismatchInfo `json:"inventoryMismatchInfo,omitempty"`

	// Mtu The maximum transmission unit (MTU) configured for the uplinks
	Mtu *int32 `json:"mtu,omitempty"`

	// Name vSphere Distributed Switch name
	Name *string `json:"name,omitempty"`

	// NsxtSwitchConfig This specification contains the configurations to be associated with the vSphere Distributed Switch managed by NSX
	NsxtSwitchConfig *NsxtSwitchConfig `json:"nsxtSwitchConfig,omitempty"`

	// PortGroups List of portgroup configuration associated with the vSphere Distributed Switch
	PortGroups *[]PortgroupConfig `json:"portGroups,omitempty"`

	// Uplinks Uplinks used by vSphere Distributed Switch
	Uplinks *[]string `json:"uplinks,omitempty"`
}

// VdsDetail This specification contains the details of vSphere Distributed Switch to be imported to the inventory
type VdsDetail struct {
	// VdsName vSphere Distributed Switch name
	VdsName string `json:"vdsName"`
}

// VdsSpec This specification contains vSphere distributed switch configurations
type VdsSpec struct {
	// IsUsedByNsxt Boolean to identify if the vSphere distributed switch is used by NSX. This property is deprecated in favor of nsxtSwitchConfig field
	// Deprecated:
	IsUsedByNsxt *bool `json:"isUsedByNsxt,omitempty"`

	// Mtu The maximum transmission unit (MTU) configured for the uplinks
	Mtu *int32 `json:"mtu,omitempty"`

	// Name vSphere Distributed Switch name
	Name string `json:"name"`

	// NiocBandwidthAllocationSpecs List of Network I/O Control Bandwidth Allocations for System Traffic
	//  Based on shares, reservation, and limit, you can configure Network I/O Control to allocate certain amount of
	// bandwidth for traffic generated by vSphere Fault Tolerance, iSCSI storage, vSphere vMotion, and so on.
	// You can use Network I/O Control on a distributed switch to configure bandwidth allocation for the traffic
	// that is related to the main system features in vSphere
	NiocBandwidthAllocationSpecs *[]NiocBandwidthAllocationSpec `json:"niocBandwidthAllocationSpecs,omitempty"`

	// NsxtSwitchConfig This specification contains the configurations to be associated with the vSphere Distributed Switch managed by NSX
	NsxtSwitchConfig *NsxtSwitchConfig `json:"nsxtSwitchConfig,omitempty"`

	// PortGroupSpecs List of portgroups to be associated with the vSphere Distributed Switch
	PortGroupSpecs *[]PortgroupSpec `json:"portGroupSpecs,omitempty"`
}

// VdsUplinkToNsxUplinkConfiguration The map of vSphere Distributed Switch uplinks to the NSX switch uplinks.
type VdsUplinkToNsxUplinkConfiguration struct {
	// NsxUplinkName The uplink name of the NSX switch
	NsxUplinkName *string `json:"nsxUplinkName,omitempty"`

	// VdsUplinkName The uplink name of the vSphere Distributed Switch
	VdsUplinkName *string `json:"vdsUplinkName,omitempty"`
}

// Version ESX Quick Patch compatible source image version details
type Version struct {
	// DisplayVersion Source Image display version
	DisplayVersion *string `json:"displayVersion,omitempty"`

	// Version Source Image full version
	Version *string `json:"version,omitempty"`
}

// VersionAliasesForBundleComponentType Version Alias representation
type VersionAliasesForBundleComponentType struct {
	// BundleComponentType Bundle Component Type
	BundleComponentType *string `json:"bundleComponentType,omitempty"`

	// VersionAliases Version Aliases
	VersionAliases *[]BaseAlias `json:"versionAliases,omitempty"`
}

// VersionAliasesForBundleComponentTypeSpec Version Alias Configuration Specification
type VersionAliasesForBundleComponentTypeSpec struct {
	// ForceUpdate Flag for force update version alias configuration.
	ForceUpdate *bool `json:"forceUpdate,omitempty"`

	// TargetVcfVersion If this field is set, LCM will calculate and update version aliases based on current deployment VCF version and the provided target VCF version
	TargetVcfVersion *string `json:"targetVcfVersion,omitempty"`

	// VersionAliasesForBundleComponentTypes List of version aliases for bundle component types.
	VersionAliasesForBundleComponentTypes *[]VersionAliasesForBundleComponentType `json:"versionAliasesForBundleComponentTypes,omitempty"`
}

// VersionApplicability Represents the version applicability of a Configuration Drift for a product
type VersionApplicability struct {
	// MaxVersion The maximum version for current product to apply current Configuration Drift
	MaxVersion *string `json:"maxVersion,omitempty"`

	// MinVersion The minimum version for current product to apply current Configuration Drift
	MinVersion *string `json:"minVersion,omitempty"`

	// ProductType Product type
	ProductType *string `json:"productType,omitempty"`
}

// VmNic This specification contains vmnic configurations for vSphere host
type VmNic struct {
	// Id VmNic ID of vSphere host to be associated with VDS, once added to cluster
	Id string `json:"id"`

	// MoveToNvds This flag determines if the vmnic must be on N-VDS. Set this to true for a vmnic that will be moved to N-VDS
	MoveToNvds *bool `json:"moveToNvds,omitempty"`

	// Uplink Uplink to be associated with vmnic
	Uplink *string `json:"uplink,omitempty"`

	// VdsName VDS name to associate with vSphere host. VDS name must match the cluster's VDS name
	VdsName string `json:"vdsName"`
}

// VmfsDatastoreSpec Cluster storage configuration for VMFS
type VmfsDatastoreSpec struct {
	// FcSpec Cluster storage configuration for VMFS on FC
	FcSpec *[]FcSpec `json:"fcSpec,omitempty"`
}

// VmnicToUplink This specification contains vmnic to uplink configurations for vSphere host.
type VmnicToUplink struct {
	// Id VmNic ID of vSphere host to be associated with VDS, once added to cluster
	Id string `json:"id"`

	// Uplink The uplink name of the vSphere Distributed Switch to be associated
	Uplink string `json:"uplink"`
}

// Vra Spec contains parameters of a VMware Aria Automation instance
type Vra struct {
	// Id The ID of the VMware Aria Automation instance
	Id *string `json:"id,omitempty"`

	// LoadBalancerFqdn The Fully Qualified Domain Name of the VMware Aria Automation load balancer
	LoadBalancerFqdn *string `json:"loadBalancerFqdn,omitempty"`

	// LoadBalancerIpAddress The IP address of the VMware Aria Automation load balancer
	LoadBalancerIpAddress *string `json:"loadBalancerIpAddress,omitempty"`

	// Nodes The nodes of the VMware Aria Automation instance
	Nodes *[]VrealizeProductNode `json:"nodes,omitempty"`

	// Status The status of the VMware Aria Automation instance
	Status *string `json:"status,omitempty"`

	// Version The version of the VMware Aria Automation instance
	Version *string `json:"version,omitempty"`
}

// VrealizeProductNode Spec contains information for a VMware Aria product node
type VrealizeProductNode struct {
	// Fqdn The Fully Qualified Domain Name for the VMware Aria node (virtual appliance)
	Fqdn string `json:"fqdn"`

	// Id The ID of the node
	Id *string `json:"id,omitempty"`

	// IpAddress IP Address of VMware Aria product appliance
	IpAddress *string `json:"ipAddress,omitempty"`

	// Type The type of the VMware Aria product node
	Type *VrealizeProductNodeType `json:"type,omitempty"`
}

// VrealizeProductNodeType The type of the VMware Aria product node
type VrealizeProductNodeType string

// Vrli Spec contains parameters of a VMware Aria Operations for Logs instance
type Vrli struct {
	// Id The ID of the VMware Aria Operations for Logs instance
	Id *string `json:"id,omitempty"`

	// LoadBalancerFqdn The Fully Qualified Domain Name of the VMware Aria Operations for Logs load balancer
	LoadBalancerFqdn *string `json:"loadBalancerFqdn,omitempty"`

	// LoadBalancerIpAddress The IP address of the VMware Aria Operations for Logs load balancer
	LoadBalancerIpAddress *string `json:"loadBalancerIpAddress,omitempty"`

	// Nodes The nodes of the VMware Aria Operations for Logs instance
	Nodes *[]VrealizeProductNode `json:"nodes,omitempty"`

	// Status The status of the VMware Aria Operations for Logs instance
	Status *string `json:"status,omitempty"`

	// Version The version of the VMware Aria Operations for Logs instance
	Version *string `json:"version,omitempty"`
}

// Vrops This specification contains information related to the existing VMware Aria Operations instance deployment
type Vrops struct {
	// Id The ID of the VMware Aria Operations instance
	Id *string `json:"id,omitempty"`

	// LoadBalancerFqdn Fully Qualified Domain Name for the VMware Aria Operations load balancer
	LoadBalancerFqdn *string `json:"loadBalancerFqdn,omitempty"`

	// LoadBalancerIp IP for the VMware Aria Operations load balancer
	LoadBalancerIp *string `json:"loadBalancerIp,omitempty"`

	// Nodes The nodes of the VMware Aria Operations instance
	Nodes *[]VropsNode `json:"nodes,omitempty"`

	// Status The state of the current product instance
	Status *string `json:"status,omitempty"`

	// Version The version of the VMware Aria Operations instance
	Version *string `json:"version,omitempty"`
}

// VropsNode Spec contains information for a VMware Aria product node
type VropsNode struct {
	// Fqdn The Fully Qualified Domain Name for the VMware Aria node (virtual appliance)
	Fqdn string `json:"fqdn"`

	// Id The ID of the node
	Id *string `json:"id,omitempty"`

	// IpAddress IP Address of VMware Aria product appliance
	IpAddress *string `json:"ipAddress,omitempty"`

	// Password The password for a root user of VMware Aria appliance
	Password *string `json:"password,omitempty"`

	// Status The status of the VMware Aria product node
	Status *string `json:"status,omitempty"`

	// Type The type of the VMware Aria product node
	Type *VropsNodeType `json:"type,omitempty"`

	// Username The username for a root user of VMware Aria appliance
	Username *string `json:"username,omitempty"`
}

// VropsNodeType The type of the VMware Aria product node
type VropsNodeType string

// Vrslcm This specification contains information related to the existing VMware Aria Suite Lifecycle instance deployment
type Vrslcm struct {
	// Fqdn Fully Qualified Domain Name
	Fqdn *string `json:"fqdn,omitempty"`

	// Id The ID of the VMware Aria Suite Lifecycle Manager instance
	Id *string `json:"id,omitempty"`

	// IpAddress IP Address of VMware Aria Suite Lifecycle Manager appliance
	IpAddress *string `json:"ipAddress,omitempty"`

	// Status The state of the current product instance
	Status *string `json:"status,omitempty"`

	// Version Version of the product that is currently running on the environment
	Version *string `json:"version,omitempty"`
}

// VrslcmDeploymentSpec VMware Aria Suite Lifecycle Deployment Specification
type VrslcmDeploymentSpec struct {
	// ApiPassword The password for an admin API/UI user of VMware Aria Suite Lifecycle
	ApiPassword string `json:"apiPassword"`

	// Fqdn Fully Qualified Domain Name
	Fqdn string `json:"fqdn"`

	// NsxtStandaloneTier1Ip The IP to use for deploying a new standalone Tier-1 router in NSX. This router will be used subsequently for VMware Aria load balancers.
	NsxtStandaloneTier1Ip string `json:"nsxtStandaloneTier1Ip"`

	// SshPassword The password for a root user of VMware Aria Suite Lifecycle appliance
	SshPassword string `json:"sshPassword"`
}

// VrslcmOperationStatus This specification contains information about the current status of certain (i.e. rollback, deployment) operation for VMware Aria Suite Lifecycle
type VrslcmOperationStatus struct {
	// ErrorCode Code used to describe if operation is not available (in error state)
	ErrorCode *string `json:"errorCode,omitempty"`

	// Message Message representing the outcome of the last VMware Aria Suite Lifecycle operation
	Message *string `json:"message,omitempty"`

	// Name Unique name identifier of the supported VMware Aria Suite Lifecycle operation
	Name *string `json:"name,omitempty"`

	// OperationState The status of the operation for VMware Aria Suite Lifecycle in SDDC Manager
	OperationState *string `json:"operationState,omitempty"`
}

// VrslcmStatus This specification contains information about the current status of VMware Aria Suite Lifecycle deployment
type VrslcmStatus struct {
	// Operations A list that represent the states of the executable operations in SDDC Manager (i.e. 'deploy' and 'rollback').
	Operations *[]VrslcmOperationStatus `json:"operations,omitempty"`

	// State The overall status of the VMware Aria Suite Lifecycle deployment
	State *string `json:"state,omitempty"`
}

// VsanDatastoreSpec This specification contains cluster storage configuration for vSAN
type VsanDatastoreSpec struct {
	// DatastoreName Datastore name used for cluster creation
	DatastoreName string `json:"datastoreName"`

	// DedupAndCompressionEnabled Enable vSAN deduplication and compression. This features is only available for clusters in which the hosts are all-flash
	DedupAndCompressionEnabled *bool `json:"dedupAndCompressionEnabled,omitempty"`

	// EsaConfig This spec contains cluster vSAN ESA configuration
	EsaConfig *EsaConfig `json:"esaConfig,omitempty"`

	// FailuresToTolerate Number of vSphere host failures to tolerate in the vSAN cluster. This field is required for vSAN OSA configuration.
	FailuresToTolerate *int32 `json:"failuresToTolerate,omitempty"`

	// LicenseKey License key for the vSAN data store to be applied in vCenter
	LicenseKey *string `json:"licenseKey,omitempty"`
}

// VsanEsaConfig This spec contains cluster vSAN ESA configuration
type VsanEsaConfig struct {
	// Enabled Whether the vSAN ESA is enabled.
	Enabled *bool `json:"enabled,omitempty"`
}

// VsanHclAttributes Represents attributes of vSAN HCL data
type VsanHclAttributes struct {
	// IsErrorThresholdExceeded True if age of vSAN HCL data on SDDC Manager is older than threshold set for error level
	IsErrorThresholdExceeded *bool `json:"isErrorThresholdExceeded,omitempty"`

	// IsLocalDataMissing True if vSAN HCL data is missing on SDDC Manager
	IsLocalDataMissing *bool `json:"isLocalDataMissing,omitempty"`

	// IsNewDataAvailable True if timestamp of vSAN HCL data on SDDC Manager is older than timestamp fetched via periodic polling
	IsNewDataAvailable *bool `json:"isNewDataAvailable,omitempty"`

	// IsWarningThresholdExceeded True if age of vSAN HCL data on SDDC Manager is older than threshold set for warning level
	IsWarningThresholdExceeded *bool `json:"isWarningThresholdExceeded,omitempty"`

	// LastError Details of last error in case of failure in updating vSAN HCL data on SDDC Manager
	LastError *string `json:"lastError,omitempty"`

	// LocalDataTime Last update time of vSAN HCL data in SDDC Manager
	LocalDataTime *string `json:"localDataTime,omitempty"`

	// LocalDataTimestamp Timestamp of vSAN HCL data (in seconds) saved on SDDC Manager
	LocalDataTimestamp *int64 `json:"localDataTimestamp,omitempty"`

	// RemoteDataTimestamp Timestamp of vSAN HCL data (in seconds) from remote vSAN HCL service as determined by periodic polling
	RemoteDataTimestamp *int64 `json:"remoteDataTimestamp,omitempty"`
}

// VsanHclConfiguration vSAN HCL configuration
type VsanHclConfiguration struct {
	// AutoDownloadEnabled Flag to indicate if auto download of vSAN HCL data is enabled or disabled
	AutoDownloadEnabled bool `json:"autoDownloadEnabled"`

	// OutOfDateErrorThreshold Duration after which vSAN HCL data will be flagged as out of date with severity as error
	OutOfDateErrorThreshold int32 `json:"outOfDateErrorThreshold"`

	// OutOfDateWarningThreshold Duration after which vSAN HCL data will be flagged as out of date with severity as warning
	OutOfDateWarningThreshold int32 `json:"outOfDateWarningThreshold"`

	// PollingEnabled Flag to indicate if polling for vSAN HCL data is enabled or disabled
	PollingEnabled bool `json:"pollingEnabled"`

	// PollingInterval Interval in minutes at which availability of new vSAN HCL data will be checked
	PollingInterval int64 `json:"pollingInterval"`
}

// VsanMaxConfig This spec contains cluster vSAN MAX configuration
type VsanMaxConfig struct {
	// EnableVsanMax Field to enable Vsan Max on the Cluster
	EnableVsanMax *bool `json:"enableVsanMax,omitempty"`
}

// VsanRemoteDatastoreClusterSpec vSAN remote datastore configuration for the cluster
type VsanRemoteDatastoreClusterSpec struct {
	// VsanRemoteDatastoreSpec List of Remote vSAN datastore configuration for vSAN compute client cluster
	VsanRemoteDatastoreSpec *[]VsanRemoteDatastoreSpec `json:"vsanRemoteDatastoreSpec,omitempty"`
}

// VsanRemoteDatastoreSpec This specification contains cluster storage configuration for vSAN
type VsanRemoteDatastoreSpec struct {
	// DatastoreUuid vSAN Remote Datastore UUID
	DatastoreUuid string `json:"datastoreUuid"`
}

// VsanSpec Spec contains parameters of Virtual SAN
type VsanSpec struct {
	// DatastoreName Datastore Name. It will be auto-generated if blank
	DatastoreName *string `json:"datastoreName,omitempty"`

	// EsaConfig This spec contains cluster vSAN ESA configuration
	EsaConfig *VsanEsaConfig `json:"esaConfig,omitempty"`

	// HclFile HCL File
	HclFile *string `json:"hclFile,omitempty"`

	// LicenseFile License File
	LicenseFile *string `json:"licenseFile,omitempty"`

	// VsanDedup VSAN feature Deduplication and Compression flag, one flag for both features
	VsanDedup *bool `json:"vsanDedup,omitempty"`
}

// VvolDatastoreSpec This specification contains cluster storage configuration for vVol
type VvolDatastoreSpec struct {
	// Name Name of the datastore
	Name string `json:"name"`

	// VasaProviderSpec This specification contains cluster storage configuration for vVol
	VasaProviderSpec VasaProviderSpec `json:"vasaProviderSpec"`
}

// VvsVersionAliases Vvs Mapping rest model that is located in the 2.0 manifest, these models are consumed by AP tool to determine the release Id to vcf version mapping in VVS compatibility data.
type VvsVersionAliases struct {
	// Aliases Product version aliases
	Aliases *[]string `json:"aliases,omitempty"`

	// Version Product version
	Version *string `json:"version,omitempty"`
}

// VxManagerSpec Spec contains parameters for VxRail Manager
type VxManagerSpec struct {
	// DefaultAdminUserCredentials Credentials contains the username and password
	DefaultAdminUserCredentials SddcCredentials `json:"defaultAdminUserCredentials"`

	// DefaultRootUserCredentials Credentials contains the username and password
	DefaultRootUserCredentials SddcCredentials `json:"defaultRootUserCredentials"`

	// SshThumbprint VxRail Manager SSH thumbprint (RSA SHA256)
	SshThumbprint *string `json:"sshThumbprint,omitempty"`

	// SslThumbprint VxRail Manager SSL thumbprint (SHA256)
	SslThumbprint *string `json:"sslThumbprint,omitempty"`

	// VxManagerHostName VxRail Manager Appliance hostname
	VxManagerHostName string `json:"vxManagerHostName"`
}

// VxRailArrayAssociationContext Contains the mapping between custom attributes and the supported attributes on the array item object.
type VxRailArrayAssociationContext struct {
	// ArrayAttributeIdsKeyValue Key, Value map that holds the simple attributes on the array item that are currently supported.
	ArrayAttributeIdsKeyValue *map[string]string `json:"arrayAttributeIdsKeyValue,omitempty"`

	// Parent Contains the mapping between custom attributes and the supported attributes on the array item object.
	Parent *VxRailArrayAssociationContext `json:"parent,omitempty"`
}

// VxRailContext Contains VxRail Specific properties
type VxRailContext struct {
	// AttributeName Attribute name
	AttributeName *string `json:"attributeName,omitempty"`

	// Datatype Datatype of attribute value
	Datatype *VxRailContextDatatype `json:"datatype,omitempty"`

	// Value Attribute value
	Value *string `json:"value,omitempty"`
}

// VxRailContextDatatype Datatype of attribute value
type VxRailContextDatatype string

// VxRailCustomArrayContext Contains the details of simple/complex custom attribute on an array item object.
type VxRailCustomArrayContext struct {
	// ArrayAssociationContext Contains the mapping between custom attributes and the supported attributes on the array item object.
	ArrayAssociationContext *VxRailArrayAssociationContext `json:"arrayAssociationContext,omitempty"`

	// SimpleAttributes Collection of simple attributes that contains name, value and type for each attribute.
	SimpleAttributes *[]VxRailContext `json:"simpleAttributes,omitempty"`
}

// VxRailDetails Contains the VxRail Manager details
type VxRailDetails struct {
	// AdminCredentials Represents credentials of am unmanaged resource (i.e a resource that is not managed by VCF)
	AdminCredentials *UnmanagedResourceCredential `json:"adminCredentials,omitempty"`

	// ArrayContextWithKeyValuePair Map of Context class with list of key and value pairs for array objects
	ArrayContextWithKeyValuePair *map[string][]VxRailCustomArrayContext `json:"arrayContextWithKeyValuePair,omitempty"`

	// ContextWithKeyValuePair Map of Context class with list of key and value pairs
	ContextWithKeyValuePair *map[string][]VxRailContext `json:"contextWithKeyValuePair,omitempty"`

	// DnsName DNS Name/Hostname of the VxRail Manager
	DnsName *string `json:"dnsName,omitempty"`

	// IpAddress IP Address of the VxRail Manager
	IpAddress *string `json:"ipAddress,omitempty"`

	// Networks Network details of the VxRail Manager
	Networks []Network `json:"networks"`

	// NicProfile Nic Profile Type
	NicProfile *string `json:"nicProfile,omitempty"`

	// RootCredentials Represents credentials of am unmanaged resource (i.e a resource that is not managed by VCF)
	RootCredentials *UnmanagedResourceCredential `json:"rootCredentials,omitempty"`

	// SshThumbprint SSH thumbprint of the VxRail Manager
	SshThumbprint *string `json:"sshThumbprint,omitempty"`

	// SslThumbprint SSL thumbprint of the VxRail Manager
	SslThumbprint *string `json:"sslThumbprint,omitempty"`
}

// WitnessSpec Spec contains the Witness host parameters that are part of each stretched cluster
type WitnessSpec struct {
	// Fqdn Management ip of the witness host
	Fqdn string `json:"fqdn"`

	// VsanCidr vSAN subnet cidr of the witness host
	VsanCidr string `json:"vsanCidr"`

	// VsanIp vSAN IP of the witness host
	VsanIp string `json:"vsanIp"`
}

// Wsa Spec contains parameters of a VMware Aria Automation instance
type Wsa struct {
	// Id The ID of the Workspace ONE Access instance
	Id *string `json:"id,omitempty"`

	// LoadBalancerFqdn The Fully Qualified Domain Name of the Workspace ONE Access load balancer
	LoadBalancerFqdn *string `json:"loadBalancerFqdn,omitempty"`

	// LoadBalancerIpAddress The IP address of the Workspace ONE Access load balancer
	LoadBalancerIpAddress *string `json:"loadBalancerIpAddress,omitempty"`

	// Nodes The nodes of the Workspace ONE Access instance
	Nodes *[]VrealizeProductNode `json:"nodes,omitempty"`

	// Status The status of the Workspace ONE Access instance
	Status *string `json:"status,omitempty"`

	// Version The version of the Workspace ONE Access instance
	Version *string `json:"version,omitempty"`
}

// Details Represents Identity Management pre-check details and user messages
type Details struct {
	// Message User messages for WARNING and FAILURE
	Message *string `json:"message,omitempty"`

	// Type Precheck response type
	Type *string `json:"type,omitempty"`
}

// GetAvnsParams defines parameters for GetAvns.
type GetAvnsParams struct {
	// RegionType Pass an optional AVN region type matching either Region-A or X-Region
	RegionType *string `form:"regionType,omitempty" json:"regionType,omitempty"`
}

// GetBundlesParams defines parameters for GetBundles.
type GetBundlesParams struct {
	// ProductType The type of the product
	ProductType *string `form:"productType,omitempty" json:"productType,omitempty"`

	// IsCompliant Is compliant with the current VCF version
	IsCompliant *bool `form:"isCompliant,omitempty" json:"isCompliant,omitempty"`

	// BundleType The type of the bundle
	BundleType *string `form:"bundleType,omitempty" json:"bundleType,omitempty"`
}

// GetBundlesForSkipUpgradeParams defines parameters for GetBundlesForSkipUpgrade.
type GetBundlesForSkipUpgradeParams struct {
	// TargetVersion [Deprecated] Target domain VCF version
	TargetVersion *string `form:"targetVersion,omitempty" json:"targetVersion,omitempty"`
}

// GetClustersParams defines parameters for GetClusters.
type GetClustersParams struct {
	// IsStretched Is cluster vSAN stretched
	IsStretched *bool `form:"isStretched,omitempty" json:"isStretched,omitempty"`

	// IsImageBased Is cluster managed using vSphere lifecycle Manager Images
	IsImageBased *bool `form:"isImageBased,omitempty" json:"isImageBased,omitempty"`

	// DomainId ID of the Domain
	DomainId *string `form:"domainId,omitempty" json:"domainId,omitempty"`
}

// ValidateClusterCreationSpecParams defines parameters for ValidateClusterCreationSpec.
type ValidateClusterCreationSpecParams struct {
	// HostsOnly Validate hosts only
	HostsOnly *bool `form:"hostsOnly,omitempty" json:"hostsOnly,omitempty"`

	// SkipHostSwitchValidation Skips host switch validation when hostOnly=true
	SkipHostSwitchValidation *bool `form:"skipHostSwitchValidation,omitempty" json:"skipHostSwitchValidation,omitempty"`
}

// DeleteClusterParams defines parameters for DeleteCluster.
type DeleteClusterParams struct {
	// Force Force deletion of the cluster. Please note when passed true, deletion will ignore vCenter Server connection issues and could possible leave cluster related resources in the vCenter Server if a connection cannot be established.
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// ValidateClusterUpdateSpecParams defines parameters for ValidateClusterUpdateSpec.
type ValidateClusterUpdateSpecParams struct {
	// UseAsyncValidation Cluster validations to be run async
	UseAsyncValidation *bool `form:"useAsyncValidation,omitempty" json:"useAsyncValidation,omitempty"`
}

// GetClusterUpdateValidationParams defines parameters for GetClusterUpdateValidation.
type GetClusterUpdateValidationParams struct {
	// UseAsyncValidation Cluster validation result for async validations
	UseAsyncValidation *bool `form:"useAsyncValidation,omitempty" json:"useAsyncValidation,omitempty"`
}

// UpdateCompatibilityMatrixMultipartBody defines parameters for UpdateCompatibilityMatrix.
type UpdateCompatibilityMatrixMultipartBody struct {
	// CompatibilityMatrixContent Compatibility Matrix Content in JSON File format
	CompatibilityMatrixContent openapi_types.File `json:"compatibilityMatrixContent"`
}

// UpdateCompatibilityMatrixParams defines parameters for UpdateCompatibilityMatrix.
type UpdateCompatibilityMatrixParams struct {
	// CompatibilityMatrixSource Compatibility Matrix Source (VMWARE_COMPAT, VXRAIL_COMPAT)
	CompatibilityMatrixSource string `form:"compatibilityMatrixSource" json:"compatibilityMatrixSource"`
}

// GetComplianceConfigurationsParams defines parameters for GetComplianceConfigurations.
type GetComplianceConfigurationsParams struct {
	// StandardType The standard type
	StandardType *string `form:"standardType,omitempty" json:"standardType,omitempty"`

	// StandardVersion The standard version, use in combination with standardType
	StandardVersion *string `form:"standardVersion,omitempty" json:"standardVersion,omitempty"`

	// ResourceType The resource type One among: SDDC_MANAGER
	ResourceType *string `form:"resourceType,omitempty" json:"resourceType,omitempty"`

	// ResourceVersion The resource version, use in combination with resourceType)
	ResourceVersion *string `form:"resourceVersion,omitempty" json:"resourceVersion,omitempty"`
}

// GetConfigsParams defines parameters for GetConfigs.
type GetConfigsParams struct {
	// ResourceId Resource Id
	ResourceId *string `form:"resourceId,omitempty" json:"resourceId,omitempty"`

	// ResourceType Resource Type
	ResourceType *string `form:"resourceType,omitempty" json:"resourceType,omitempty"`

	// ConfigId Config Id
	ConfigId *string `form:"configId,omitempty" json:"configId,omitempty"`

	// DriftType Drift Type
	DriftType *string `form:"driftType,omitempty" json:"driftType,omitempty"`

	// Size Size of the page to retrieve. Default page size is 10. Optional
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Page Page number to retrieve. Default page 0 will retrieve all elements. Optional
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// GetCredentialsParams defines parameters for GetCredentials.
type GetCredentialsParams struct {
	// ResourceName The name of the resource
	ResourceName *string `form:"resourceName,omitempty" json:"resourceName,omitempty"`

	// ResourceIp The IP address of the resource
	ResourceIp *string `form:"resourceIp,omitempty" json:"resourceIp,omitempty"`

	// ResourceType The type of the resource. One among: ESXI, VCENTER, PSC, NSX_MANAGER, NSX_CONTROLLER, NSX_EDGE, NSXT_MANAGER, NSXT_EDGE, VRLI, VROPS, VRA, WSA, VRSLCM, VXRAIL_MANAGER, NSX_ALB, BACKUP
	ResourceType *string `form:"resourceType,omitempty" json:"resourceType,omitempty"`

	// DomainName The name of the domain to which the resource belongs to (may be null in case there is no associated domain)
	DomainName *string `form:"domainName,omitempty" json:"domainName,omitempty"`

	// PageNumber The page number (must be a positive number), starts with 0
	PageNumber *string `form:"pageNumber,omitempty" json:"pageNumber,omitempty"`

	// PageSize The page size (must be a positive number, 0 as page size returns all records in one page
	PageSize *string `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// AccountType Type of the account that needs to be fetched by filtering
	AccountType *string `form:"accountType,omitempty" json:"accountType,omitempty"`
}

// GetCredentialsTasksParams defines parameters for GetCredentialsTasks.
type GetCredentialsTasksParams struct {
	// Limit The number of elements to be returned in the result
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetCustomIsosParams defines parameters for GetCustomIsos.
type GetCustomIsosParams struct {
	// Name The name of the Custom ISO
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Vendor The vendor name of the Custom ISO
	Vendor *string `form:"vendor,omitempty" json:"vendor,omitempty"`

	// DomainId The domain resource ID
	DomainId *string `form:"domainId,omitempty" json:"domainId,omitempty"`

	// TargetVersion The ESXi target version
	TargetVersion *string `form:"targetVersion,omitempty" json:"targetVersion,omitempty"`
}

// UploadCustomIsoMultipartBody defines parameters for UploadCustomIso.
type UploadCustomIsoMultipartBody struct {
	File openapi_types.File `json:"file"`
}

// UploadCustomIsoParams defines parameters for UploadCustomIso.
type UploadCustomIsoParams struct {
	Name string `form:"name" json:"name"`
}

// GetDomainsParams defines parameters for GetDomains.
type GetDomainsParams struct {
	// Type The type of the domain
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// ValidateDomainCreationSpecParams defines parameters for ValidateDomainCreationSpec.
type ValidateDomainCreationSpecParams struct {
	// HostsOnly Validate hosts only
	HostsOnly *bool `form:"hostsOnly,omitempty" json:"hostsOnly,omitempty"`

	// SkipHostSwitchValidation Skips host switch validation when hostOnly=true
	SkipHostSwitchValidation *bool `form:"skipHostSwitchValidation,omitempty" json:"skipHostSwitchValidation,omitempty"`
}

// GetVsanHealthCheckByDomainParams defines parameters for GetVsanHealthCheckByDomain.
type GetVsanHealthCheckByDomainParams struct {
	// Status Status of health check to filter by
	Status *string `form:"status,omitempty" json:"status,omitempty"`
}

// UpdateVsanHealthCheckByDomainJSONBody defines parameters for UpdateVsanHealthCheckByDomain.
type UpdateVsanHealthCheckByDomainJSONBody = []HealthCheckSpec

// UploadCertificatesMultipartBody defines parameters for UploadCertificates.
type UploadCertificatesMultipartBody struct {
	File openapi_types.File `json:"file"`
}

// ReplaceResourceCertificatesJSONBody defines parameters for ReplaceResourceCertificates.
type ReplaceResourceCertificatesJSONBody = []ResourceCertificateSpec

// ValidateResourceCertificatesJSONBody defines parameters for ValidateResourceCertificates.
type ValidateResourceCertificatesJSONBody = []ResourceCertificateSpec

// GetEdgeClustersParams defines parameters for GetEdgeClusters.
type GetEdgeClustersParams struct {
	// ClusterId Pass an optional vSphere Cluster ID to fetch edge clusters associated with the vSphere Cluster
	ClusterId *string `form:"clusterId,omitempty" json:"clusterId,omitempty"`
}

// DecommissionHostsJSONBody defines parameters for DecommissionHosts.
type DecommissionHostsJSONBody = []HostDecommissionSpec

// GetHostsParams defines parameters for GetHosts.
type GetHostsParams struct {
	// Status Status of the Host.One among: ASSIGNED, UNASSIGNED_USEABLE, UNASSIGNED_UNUSEABLE
	Status *string `form:"status,omitempty" json:"status,omitempty"`

	// DomainId ID of the Domain
	DomainId *string `form:"domainId,omitempty" json:"domainId,omitempty"`

	// ClusterId ID of the Cluster
	ClusterId *string `form:"clusterId,omitempty" json:"clusterId,omitempty"`

	// NetworkpoolId ID of the Network pool
	NetworkpoolId *string `form:"networkpoolId,omitempty" json:"networkpoolId,omitempty"`

	// StorageType Type of the Storage.VMFS_FC
	StorageType *string `form:"storageType,omitempty" json:"storageType,omitempty"`

	// DatastoreName Name of the datastore
	DatastoreName *string `form:"datastoreName,omitempty" json:"datastoreName,omitempty"`
}

// CommissionHostsJSONBody defines parameters for CommissionHosts.
type CommissionHostsJSONBody = []HostCommissionSpec

// PostHostsPrechecks1MultipartBody defines parameters for PostHostsPrechecks1.
type PostHostsPrechecks1MultipartBody struct {
	SpecFile *openapi_types.File `json:"specFile,omitempty"`
}

// ValidateHostCommissionSpecJSONBody defines parameters for ValidateHostCommissionSpec.
type ValidateHostCommissionSpecJSONBody = []HostCommissionSpec

// ValidateCommissionHostsJSONBody defines parameters for ValidateCommissionHosts.
type ValidateCommissionHostsJSONBody = []HostCommissionSpec

// GetIdentityPrecheckResultParams defines parameters for GetIdentityPrecheckResult.
type GetIdentityPrecheckResultParams struct {
	// Type IDP type for which Precheck needs to be run
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// GenerateSyncClientTokenParams defines parameters for GenerateSyncClientToken.
type GenerateSyncClientTokenParams struct {
	// SyncClientTokenTTL TTL of the sync client token
	SyncClientTokenTTL *int64 `form:"syncClientTokenTTL,omitempty" json:"syncClientTokenTTL,omitempty"`
}

// GetLicenseKeysParams defines parameters for GetLicenseKeys.
type GetLicenseKeysParams struct {
	// ProductType Type of a Product
	ProductType *[]string `form:"productType,omitempty" json:"productType,omitempty"`

	// LicenseKeyStatus Status of a License Key
	LicenseKeyStatus *[]string `form:"licenseKeyStatus,omitempty" json:"licenseKeyStatus,omitempty"`

	// LicenseUnit Unit of a license
	LicenseUnit *[]string `form:"licenseUnit,omitempty" json:"licenseUnit,omitempty"`

	// ProductVersion Product Version, gets the license keys matching the major version of the product version
	ProductVersion *string `form:"productVersion,omitempty" json:"productVersion,omitempty"`
}

// GetLicenseInformationParams defines parameters for GetLicenseInformation.
type GetLicenseInformationParams struct {
	// ResourceType Resource type
	ResourceType *string `form:"resourceType,omitempty" json:"resourceType,omitempty"`

	// ResourceIds Resource IDs
	ResourceIds *[]string `form:"resourceIds,omitempty" json:"resourceIds,omitempty"`
}

// DeleteNetworkPoolParams defines parameters for DeleteNetworkPool.
type DeleteNetworkPoolParams struct {
	// Force Force removal of Network Pool
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetALBClustersParams defines parameters for GetALBClusters.
type GetALBClustersParams struct {
	// DomainId Domain Id
	DomainId *string `form:"domainId,omitempty" json:"domainId,omitempty"`
}

// ValidateALBClusterCreationSpecParams defines parameters for ValidateALBClusterCreationSpec.
type ValidateALBClusterCreationSpecParams struct {
	// SkipCompatibilityCheck Pass an optional Skip compatibility checks
	SkipCompatibilityCheck *bool `form:"skipCompatibilityCheck,omitempty" json:"skipCompatibilityCheck,omitempty"`
}

// DeleteALBClusterParams defines parameters for DeleteALBCluster.
type DeleteALBClusterParams struct {
	// ForceDelete Force Delete ALB Cluster
	ForceDelete *bool `form:"forceDelete,omitempty" json:"forceDelete,omitempty"`
}

// GetNsxClustersParams defines parameters for GetNsxClusters.
type GetNsxClustersParams struct {
	// IsShareable filter NSX clusters which can be shared for domain creation
	IsShareable *bool `form:"isShareable,omitempty" json:"isShareable,omitempty"`
}

// DeletePersonalityParams defines parameters for DeletePersonality.
type DeletePersonalityParams struct {
	// PersonalityId The personality id
	PersonalityId *string `form:"personalityId,omitempty" json:"personalityId,omitempty"`

	// PersonalityName The personality name
	PersonalityName *string `form:"personalityName,omitempty" json:"personalityName,omitempty"`
}

// GetPersonalitiesParams defines parameters for GetPersonalities.
type GetPersonalitiesParams struct {
	// BaseOSVersion The base OS version
	BaseOSVersion *string `form:"baseOSVersion,omitempty" json:"baseOSVersion,omitempty"`

	// AddOnName The add on name
	AddOnName *string `form:"addOnName,omitempty" json:"addOnName,omitempty"`

	// AddOnVendorName The add on vendor name
	AddOnVendorName *string `form:"addOnVendorName,omitempty" json:"addOnVendorName,omitempty"`

	// ComponentName The component name
	ComponentName *string `form:"componentName,omitempty" json:"componentName,omitempty"`

	// ComponentVendorName The component vendor name
	ComponentVendorName *string `form:"componentVendorName,omitempty" json:"componentVendorName,omitempty"`
	PersonalityName     *string `form:"personalityName,omitempty" json:"personalityName,omitempty"`
}

// UploadPersonalityFilesMultipartBody defines parameters for UploadPersonalityFiles.
type UploadPersonalityFilesMultipartBody struct {
	Files []openapi_types.File `json:"files"`
}

// GetReleasesParams defines parameters for GetReleases.
type GetReleasesParams struct {
	// DomainId Domain ID to get current release of the domain
	DomainId *string `form:"domainId,omitempty" json:"domainId,omitempty"`

	// VersionEq Release version to get its release
	VersionEq *string `form:"versionEq,omitempty" json:"versionEq,omitempty"`

	// VxRailVersionEq Release VxRail version to get its release
	VxRailVersionEq *string `form:"vxRailVersionEq,omitempty" json:"vxRailVersionEq,omitempty"`

	// VersionGt Release version to get its future releases
	VersionGt *string `form:"versionGt,omitempty" json:"versionGt,omitempty"`

	// VxRailVersionGt Release vxrail version to get its future releases
	VxRailVersionGt *string `form:"vxRailVersionGt,omitempty" json:"vxRailVersionGt,omitempty"`

	// ApplicableForVersion Release version to get applicable releases
	ApplicableForVersion *string `form:"applicableForVersion,omitempty" json:"applicableForVersion,omitempty"`

	// ApplicableForVxRailVersion Release VxRail version to get applicable releases
	ApplicableForVxRailVersion *string `form:"applicableForVxRailVersion,omitempty" json:"applicableForVxRailVersion,omitempty"`

	// GetFutureReleases [Deprecated] Get all future releases for a given domain
	GetFutureReleases *bool `form:"getFutureReleases,omitempty" json:"getFutureReleases,omitempty"`
}

// GetCustomPatchesParams defines parameters for GetCustomPatches.
type GetCustomPatchesParams struct {
	// VcfRelease VCF release
	VcfRelease *string `form:"vcfRelease,omitempty" json:"vcfRelease,omitempty"`

	// VxrailReleaseVersion Vxrail release version
	VxrailReleaseVersion *string `form:"vxrailReleaseVersion,omitempty" json:"vxrailReleaseVersion,omitempty"`

	// ProductType Product Type
	ProductType *string `form:"productType,omitempty" json:"productType,omitempty"`
}

// GetResourceFunctionalitiesParams defines parameters for GetResourceFunctionalities.
type GetResourceFunctionalitiesParams struct {
	// ResourceType Resource type
	ResourceType *string `form:"resourceType,omitempty" json:"resourceType,omitempty"`

	// FunctionalityType Functionality type
	FunctionalityType *string `form:"functionalityType,omitempty" json:"functionalityType,omitempty"`

	// ResourceIds Resource IDs
	ResourceIds *[]string `form:"resourceIds,omitempty" json:"resourceIds,omitempty"`

	// IsAllowed Allowed or disallowed resource functionalities
	IsAllowed *bool `form:"isAllowed,omitempty" json:"isAllowed,omitempty"`

	// ParentResourceType Parent resource type
	ParentResourceType *string `form:"parentResourceType,omitempty" json:"parentResourceType,omitempty"`
}

// GetResourceWarningsParams defines parameters for GetResourceWarnings.
type GetResourceWarningsParams struct {
	// ResourceType Resource type
	ResourceType *string `form:"resourceType,omitempty" json:"resourceType,omitempty"`

	// ResourceIds Resource IDs
	ResourceIds *[]string `form:"resourceIds,omitempty" json:"resourceIds,omitempty"`

	// ResourceNames Resource Names
	ResourceNames *[]string `form:"resourceNames,omitempty" json:"resourceNames,omitempty"`
}

// GetSddcManagerUpgradablesParams defines parameters for GetSddcManagerUpgradables.
type GetSddcManagerUpgradablesParams struct {
	ApplicabilityStatus *GetSddcManagerUpgradablesParamsApplicabilityStatus `form:"applicabilityStatus,omitempty" json:"applicabilityStatus,omitempty"`
	Version             *string                                             `form:"version,omitempty" json:"version,omitempty"`
}

// GetSddcManagerUpgradablesParamsApplicabilityStatus defines parameters for GetSddcManagerUpgradables.
type GetSddcManagerUpgradablesParamsApplicabilityStatus string

// ValidateBringupSpecParams defines parameters for ValidateBringupSpec.
type ValidateBringupSpecParams struct {
	Redo *bool `form:"redo,omitempty" json:"redo,omitempty"`

	// Name Validation name
	// Deprecated: ESXI_VERSION_VALIDATION
	Name *ValidateBringupSpecParamsName `form:"name,omitempty" json:"name,omitempty"`
}

// ValidateBringupSpecParamsName defines parameters for ValidateBringupSpec.
type ValidateBringupSpecParamsName string

// ExportBringupValidationReportParams defines parameters for ExportBringupValidationReport.
type ExportBringupValidationReportParams struct {
	// StartTime Start time of validation to be put in the report
	StartTime *string `form:"startTime,omitempty" json:"startTime,omitempty"`

	// CurClientTime Current client local time of the the report generation
	CurClientTime *string `form:"curClientTime,omitempty" json:"curClientTime,omitempty"`
}

// ExportBringupDetailReportParams defines parameters for ExportBringupDetailReport.
type ExportBringupDetailReportParams struct {
	// Format One among: PDF, CSV
	Format *ExportBringupDetailReportParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// ExportBringupDetailReportParamsFormat defines parameters for ExportBringupDetailReport.
type ExportBringupDetailReportParamsFormat string

// GetSSODomainEntitiesParams defines parameters for GetSSODomainEntities.
type GetSSODomainEntitiesParams struct {
	// EntityName Search Criteria for the users and groups
	EntityName *string `form:"entityName,omitempty" json:"entityName,omitempty"`
}

// GetBackupLocationParams defines parameters for GetBackupLocation.
type GetBackupLocationParams struct {
	// ServerIP Backup server IP
	ServerIP string `form:"serverIP" json:"serverIP"`

	// Port Backup server port
	Port string `form:"port" json:"port"`
}

// GetLastAssessmentRunInfoParams defines parameters for GetLastAssessmentRunInfo.
type GetLastAssessmentRunInfoParams struct {
	// DomainId Id of the domain to filter tasks for, accepts multiple values as comma separated
	DomainId *string `form:"domainId,omitempty" json:"domainId,omitempty"`
}

// GetValidationsOfDNSConfigurationParams defines parameters for GetValidationsOfDNSConfiguration.
type GetValidationsOfDNSConfigurationParams struct {
	// ExecutionStatus executionStatus
	ExecutionStatus *string `form:"executionStatus,omitempty" json:"executionStatus,omitempty"`
}

// GetValidationsOfNtpConfigurationParams defines parameters for GetValidationsOfNtpConfiguration.
type GetValidationsOfNtpConfigurationParams struct {
	// ExecutionStatus executionStatus
	ExecutionStatus *string `form:"executionStatus,omitempty" json:"executionStatus,omitempty"`
}

// StartBringupSpecConversionMultipartBody defines parameters for StartBringupSpecConversion.
type StartBringupSpecConversionMultipartBody struct {
	// SpecFile SDDC specification file which is either a JSON or xls file
	SpecFile openapi_types.File `json:"specFile"`
}

// StartBringupSpecConversionParams defines parameters for StartBringupSpecConversion.
type StartBringupSpecConversionParams struct {
	// Design Supported bringup designs - EMS, VXRAIL
	Design *StartBringupSpecConversionParamsDesign `form:"design,omitempty" json:"design,omitempty"`
}

// StartBringupSpecConversionParamsDesign defines parameters for StartBringupSpecConversion.
type StartBringupSpecConversionParamsDesign string

// DeleteDepotSettingsParams defines parameters for DeleteDepotSettings.
type DeleteDepotSettingsParams struct {
	// DepotType Depot type
	DepotType *string `form:"depotType,omitempty" json:"depotType,omitempty"`
}

// DeleteAliasVersionsBySoftwareTypeAndBaseVersionJSONBody defines parameters for DeleteAliasVersionsBySoftwareTypeAndBaseVersion.
type DeleteAliasVersionsBySoftwareTypeAndBaseVersionJSONBody = []string

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	// Limit The number of elements to be returned in the result
	Limit        *int32  `form:"limit,omitempty" json:"limit,omitempty"`
	TaskStatus   *string `form:"taskStatus,omitempty" json:"taskStatus,omitempty"`
	TaskType     *string `form:"taskType,omitempty" json:"taskType,omitempty"`
	ResourceId   *string `form:"resourceId,omitempty" json:"resourceId,omitempty"`
	ResourceType *string `form:"resourceType,omitempty" json:"resourceType,omitempty"`

	// CompletedAfter A time based filter to get tasks which are completed after the given timestamp. A task is completed if its status is 'Successful' or 'Failed'. Time is in milliseconds.
	CompletedAfter *int64 `form:"completedAfter,omitempty" json:"completedAfter,omitempty"`

	// PageNumber Page number.
	PageNumber *int32 `form:"pageNumber,omitempty" json:"pageNumber,omitempty"`

	// PageSize Size of the page you want to retrieve. Max page size allowed is 100.
	PageSize       *int32  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	OrderDirection *string `form:"orderDirection,omitempty" json:"orderDirection,omitempty"`
	OrderBy        *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// TaskName Search filter when task name contains text.
	TaskName *string `form:"taskName,omitempty" json:"taskName,omitempty"`
}

// RefreshAccessTokenJSONBody defines parameters for RefreshAccessToken.
type RefreshAccessTokenJSONBody = string

// InvalidateRefreshTokenJSONBody defines parameters for InvalidateRefreshToken.
type InvalidateRefreshTokenJSONBody = string

// GetUpgradablesByDomainParams defines parameters for GetUpgradablesByDomain.
type GetUpgradablesByDomainParams struct {
	// TargetVersion Target Version to get Upgradables for a given Target Release
	TargetVersion *string `form:"targetVersion,omitempty" json:"targetVersion,omitempty"`
}

// GetNsxUpgradeResourcesParams defines parameters for GetNsxUpgradeResources.
type GetNsxUpgradeResourcesParams struct {
	// BundleId bundle Id of the upgrade bundle applicable on the domain
	BundleId *string `form:"bundleId,omitempty" json:"bundleId,omitempty"`
}

// GetUpgradesParams defines parameters for GetUpgrades.
type GetUpgradesParams struct {
	// Status Status of the upgrades you want to retrieve
	Status *string `form:"status,omitempty" json:"status,omitempty"`

	// BundleId Bundle Id for the upgrade
	BundleId *string `form:"bundleId,omitempty" json:"bundleId,omitempty"`

	// BundleType Bundle type of the upgrades you want to retrieve
	BundleType *string `form:"bundleType,omitempty" json:"bundleType,omitempty"`
}

// AddUsersJSONBody defines parameters for AddUsers.
type AddUsersJSONBody = []User

// GetVasaProviderStorageContainersParams defines parameters for GetVasaProviderStorageContainers.
type GetVasaProviderStorageContainersParams struct {
	// ProtocolType Pass an optional Storage Protocol type
	ProtocolType *string `form:"protocolType,omitempty" json:"protocolType,omitempty"`
}

// AddVasaProviderStorageContainerJSONBody defines parameters for AddVasaProviderStorageContainer.
type AddVasaProviderStorageContainerJSONBody = []StorageContainer

// AddVasaProviderUserJSONBody defines parameters for AddVasaProviderUser.
type AddVasaProviderUserJSONBody = []VasaUser

// GetVcentersParams defines parameters for GetVcenters.
type GetVcentersParams struct {
	// DomainId ID of the domain
	DomainId *string `form:"domainId,omitempty" json:"domainId,omitempty"`
}

// CreateAvnsJSONRequestBody defines body for CreateAvns for application/json ContentType.
type CreateAvnsJSONRequestBody = AvnsCreationSpec

// ValidateAvnSpecJSONRequestBody defines body for ValidateAvnSpec for application/json ContentType.
type ValidateAvnSpecJSONRequestBody = AvnsCreationSpec

// StartBackupJSONRequestBody defines body for StartBackup for application/json ContentType.
type StartBackupJSONRequestBody = BackupSpec

// UploadBundleJSONRequestBody defines body for UploadBundle for application/json ContentType.
type UploadBundleJSONRequestBody = BundleUploadSpec

// UpdateBundleCompatibilitySetsJSONRequestBody defines body for UpdateBundleCompatibilitySets for application/json ContentType.
type UpdateBundleCompatibilitySetsJSONRequestBody = BundleUpdateSpec

// StartBundleDownloadByIDJSONRequestBody defines body for StartBundleDownloadByID for application/json ContentType.
type StartBundleDownloadByIDJSONRequestBody = BundleUpdateSpec

// ConfigureCertificateAuthorityJSONRequestBody defines body for ConfigureCertificateAuthority for application/json ContentType.
type ConfigureCertificateAuthorityJSONRequestBody = CertificateAuthorityCreationSpec

// CreateCertificateAuthorityJSONRequestBody defines body for CreateCertificateAuthority for application/json ContentType.
type CreateCertificateAuthorityJSONRequestBody = CertificateAuthorityCreationSpec

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody = ClusterCreationSpec

// ValidateClusterCreationSpecJSONRequestBody defines body for ValidateClusterCreationSpec for application/json ContentType.
type ValidateClusterCreationSpecJSONRequestBody = ClusterCreationSpec

// ValidateVsanRemoteDatastoreSpecJSONRequestBody defines body for ValidateVsanRemoteDatastoreSpec for application/json ContentType.
type ValidateVsanRemoteDatastoreSpecJSONRequestBody = DatastoreMountSpec

// ValidateVsanRemoteDatastoreMountSpecJSONRequestBody defines body for ValidateVsanRemoteDatastoreMountSpec for application/json ContentType.
type ValidateVsanRemoteDatastoreMountSpecJSONRequestBody = DatastoreMountSpec

// ImportVdsToInventoryJSONRequestBody defines body for ImportVdsToInventory for application/json ContentType.
type ImportVdsToInventoryJSONRequestBody = ImportVdsSpec

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody = ClusterUpdateSpec

// AddDatastoreToClusterJSONRequestBody defines body for AddDatastoreToCluster for application/json ContentType.
type AddDatastoreToClusterJSONRequestBody = DatastoreMountSpec

// PostDatastoreQuery1JSONRequestBody defines body for PostDatastoreQuery1 for application/json ContentType.
type PostDatastoreQuery1JSONRequestBody = DatastoreCriterion

// PostHostQueryJSONRequestBody defines body for PostHostQuery for application/json ContentType.
type PostHostQueryJSONRequestBody = HostCriterion

// GetClusterNetworkConfigurationJSONRequestBody defines body for GetClusterNetworkConfiguration for application/json ContentType.
type GetClusterNetworkConfigurationJSONRequestBody = ClusterNetworkConfigurationCriterion

// RemoveTagsFromClusterJSONRequestBody defines body for RemoveTagsFromCluster for application/json ContentType.
type RemoveTagsFromClusterJSONRequestBody = TagsSpec

// AssignTagsToClusterJSONRequestBody defines body for AssignTagsToCluster for application/json ContentType.
type AssignTagsToClusterJSONRequestBody = TagsSpec

// ValidateClusterUpdateSpecJSONRequestBody defines body for ValidateClusterUpdateSpec for application/json ContentType.
type ValidateClusterUpdateSpecJSONRequestBody = ClusterUpdateSpec

// UpdateCompatibilityMatrixMultipartRequestBody defines body for UpdateCompatibilityMatrix for multipart/form-data ContentType.
type UpdateCompatibilityMatrixMultipartRequestBody UpdateCompatibilityMatrixMultipartBody

// ReconcileConfigsJSONRequestBody defines body for ReconcileConfigs for application/json ContentType.
type ReconcileConfigsJSONRequestBody = ConfigDriftApplySpec

// UpdateOrRotatePasswordsJSONRequestBody defines body for UpdateOrRotatePasswords for application/json ContentType.
type UpdateOrRotatePasswordsJSONRequestBody = CredentialsUpdateSpec

// GetPasswordExpirationJSONRequestBody defines body for GetPasswordExpiration for application/json ContentType.
type GetPasswordExpirationJSONRequestBody = CredentialsExpirationSpec

// RetryCredentialsTaskJSONRequestBody defines body for RetryCredentialsTask for application/json ContentType.
type RetryCredentialsTaskJSONRequestBody = CredentialsUpdateSpec

// UploadCustomIsoMultipartRequestBody defines body for UploadCustomIso for multipart/form-data ContentType.
type UploadCustomIsoMultipartRequestBody UploadCustomIsoMultipartBody

// RenameCustomIsoByIdJSONRequestBody defines body for RenameCustomIsoById for application/json ContentType.
type RenameCustomIsoByIdJSONRequestBody = CustomIsoRenameSpec

// CreateDomainJSONRequestBody defines body for CreateDomain for application/json ContentType.
type CreateDomainJSONRequestBody = DomainCreationSpec

// ValidateDomainCreationSpecJSONRequestBody defines body for ValidateDomainCreationSpec for application/json ContentType.
type ValidateDomainCreationSpecJSONRequestBody = DomainCreationSpec

// PostClustersQueryJSONRequestBody defines body for PostClustersQuery for application/json ContentType.
type PostClustersQueryJSONRequestBody = ClusterCriterion

// PostClusterQueryJSONRequestBody defines body for PostClusterQuery for application/json ContentType.
type PostClusterQueryJSONRequestBody = ClusterCriterion

// PostDatastoreQueryJSONRequestBody defines body for PostDatastoreQuery for application/json ContentType.
type PostDatastoreQueryJSONRequestBody = DatastoreCriterion

// UpdateVsanHealthCheckByDomainJSONRequestBody defines body for UpdateVsanHealthCheckByDomain for application/json ContentType.
type UpdateVsanHealthCheckByDomainJSONRequestBody = UpdateVsanHealthCheckByDomainJSONBody

// PerformDomainIsolationPrecheckJSONRequestBody defines body for PerformDomainIsolationPrecheck for application/json ContentType.
type PerformDomainIsolationPrecheckJSONRequestBody = IsolationSpec

// UpdateDomainJSONRequestBody defines body for UpdateDomain for application/json ContentType.
type UpdateDomainJSONRequestBody = DomainUpdateSpec

// ReplaceCertificatesJSONRequestBody defines body for ReplaceCertificates for application/json ContentType.
type ReplaceCertificatesJSONRequestBody = CertificateOperationSpec

// GenerateCertificatesJSONRequestBody defines body for GenerateCertificates for application/json ContentType.
type GenerateCertificatesJSONRequestBody = CertificatesGenerationSpec

// UploadCertificatesMultipartRequestBody defines body for UploadCertificates for multipart/form-data ContentType.
type UploadCertificatesMultipartRequestBody UploadCertificatesMultipartBody

// ComplianceAuditJSONRequestBody defines body for ComplianceAudit for application/json ContentType.
type ComplianceAuditJSONRequestBody = ComplianceAuditSpec

// GeneratesCSRsJSONRequestBody defines body for GeneratesCSRs for application/json ContentType.
type GeneratesCSRsJSONRequestBody = CsrsGenerationSpec

// ReplaceResourceCertificatesJSONRequestBody defines body for ReplaceResourceCertificates for application/json ContentType.
type ReplaceResourceCertificatesJSONRequestBody = ReplaceResourceCertificatesJSONBody

// ValidateResourceCertificatesJSONRequestBody defines body for ValidateResourceCertificates for application/json ContentType.
type ValidateResourceCertificatesJSONRequestBody = ValidateResourceCertificatesJSONBody

// RemoveTagsFromDomainJSONRequestBody defines body for RemoveTagsFromDomain for application/json ContentType.
type RemoveTagsFromDomainJSONRequestBody = TagsSpec

// AssignTagsToDomainJSONRequestBody defines body for AssignTagsToDomain for application/json ContentType.
type AssignTagsToDomainJSONRequestBody = TagsSpec

// ValidateDomainUpdateSpecJSONRequestBody defines body for ValidateDomainUpdateSpec for application/json ContentType.
type ValidateDomainUpdateSpecJSONRequestBody = DomainUpdateSpec

// CreateEdgeClusterJSONRequestBody defines body for CreateEdgeCluster for application/json ContentType.
type CreateEdgeClusterJSONRequestBody = EdgeClusterCreationSpec

// ValidateEdgeClusterCreationSpecJSONRequestBody defines body for ValidateEdgeClusterCreationSpec for application/json ContentType.
type ValidateEdgeClusterCreationSpecJSONRequestBody = EdgeClusterCreationSpec

// UpdateEdgeClusterJSONRequestBody defines body for UpdateEdgeCluster for application/json ContentType.
type UpdateEdgeClusterJSONRequestBody = EdgeClusterUpdateSpec

// ValidateEdgeClusterUpdateSpecJSONRequestBody defines body for ValidateEdgeClusterUpdateSpec for application/json ContentType.
type ValidateEdgeClusterUpdateSpecJSONRequestBody = EdgeClusterUpdateSpec

// DecommissionHostsJSONRequestBody defines body for DecommissionHosts for application/json ContentType.
type DecommissionHostsJSONRequestBody = DecommissionHostsJSONBody

// CommissionHostsJSONRequestBody defines body for CommissionHosts for application/json ContentType.
type CommissionHostsJSONRequestBody = CommissionHostsJSONBody

// PostHostsPrechecks1JSONRequestBody defines body for PostHostsPrechecks1 for application/json ContentType.
type PostHostsPrechecks1JSONRequestBody = HostsPrechecksRequest

// PostHostsPrechecks1MultipartRequestBody defines body for PostHostsPrechecks1 for multipart/form-data ContentType.
type PostHostsPrechecks1MultipartRequestBody PostHostsPrechecks1MultipartBody

// PostQueryJSONRequestBody defines body for PostQuery for application/json ContentType.
type PostQueryJSONRequestBody = HostCriterion

// ValidateHostCommissionSpecJSONRequestBody defines body for ValidateHostCommissionSpec for application/json ContentType.
type ValidateHostCommissionSpecJSONRequestBody = ValidateHostCommissionSpecJSONBody

// ValidateCommissionHostsJSONRequestBody defines body for ValidateCommissionHosts for application/json ContentType.
type ValidateCommissionHostsJSONRequestBody = ValidateCommissionHostsJSONBody

// RemoveTagsFromHostJSONRequestBody defines body for RemoveTagsFromHost for application/json ContentType.
type RemoveTagsFromHostJSONRequestBody = TagsSpec

// AssignTagsToHostJSONRequestBody defines body for AssignTagsToHost for application/json ContentType.
type AssignTagsToHostJSONRequestBody = TagsSpec

// AddExternalIdentityProviderJSONRequestBody defines body for AddExternalIdentityProvider for application/json ContentType.
type AddExternalIdentityProviderJSONRequestBody = IdentityProviderSpec

// UpdateExternalIdentityProviderJSONRequestBody defines body for UpdateExternalIdentityProvider for application/json ContentType.
type UpdateExternalIdentityProviderJSONRequestBody = IdentityProviderSpec

// AddEmbeddedIdentitySourceJSONRequestBody defines body for AddEmbeddedIdentitySource for application/json ContentType.
type AddEmbeddedIdentitySourceJSONRequestBody = IdentitySourceSpec

// UpdateEmbeddedIdentitySourceJSONRequestBody defines body for UpdateEmbeddedIdentitySource for application/json ContentType.
type UpdateEmbeddedIdentitySourceJSONRequestBody = IdentitySourceSpec

// AddLicenseKeyJSONRequestBody defines body for AddLicenseKey for application/json ContentType.
type AddLicenseKeyJSONRequestBody = LicenseKey

// UpdateLicenseKeyJSONRequestBody defines body for UpdateLicenseKey for application/json ContentType.
type UpdateLicenseKeyJSONRequestBody = LicenseKeyUpdateSpec

// SaveManifestJSONRequestBody defines body for SaveManifest for application/json ContentType.
type SaveManifestJSONRequestBody = Manifest

// CreateNetworkPoolJSONRequestBody defines body for CreateNetworkPool for application/json ContentType.
type CreateNetworkPoolJSONRequestBody = NetworkPool

// UpdateNetworkPoolJSONRequestBody defines body for UpdateNetworkPool for application/json ContentType.
type UpdateNetworkPoolJSONRequestBody = NetworkPoolUpdateSpec

// DeleteIpPoolFromNetworkOfNetworkPoolJSONRequestBody defines body for DeleteIpPoolFromNetworkOfNetworkPool for application/json ContentType.
type DeleteIpPoolFromNetworkOfNetworkPoolJSONRequestBody = IpPool

// AddIpPoolToNetworkOfNetworkPoolJSONRequestBody defines body for AddIpPoolToNetworkOfNetworkPool for application/json ContentType.
type AddIpPoolToNetworkOfNetworkPoolJSONRequestBody = IpPool

// ValidateALBClusterCreationSpecJSONRequestBody defines body for ValidateALBClusterCreationSpec for application/json ContentType.
type ValidateALBClusterCreationSpecJSONRequestBody = NsxAlbControllerClusterSpec

// ValidateNsxALBCompatibilityJSONRequestBody defines body for ValidateNsxALBCompatibility for application/json ContentType.
type ValidateNsxALBCompatibilityJSONRequestBody = NsxAlbVersionValidationSpec

// ValidateIpPoolJSONRequestBody defines body for ValidateIpPool for application/json ContentType.
type ValidateIpPoolJSONRequestBody = NsxtIpAddressPoolValidationSpec

// ConnectOpenIdJSONRequestBody defines body for ConnectOpenId for application/json ContentType.
type ConnectOpenIdJSONRequestBody = NsxtOidcSpec

// StartNsxCriteriaQueryJSONRequestBody defines body for StartNsxCriteriaQuery for application/json ContentType.
type StartNsxCriteriaQueryJSONRequestBody = NsxTCriterion

// UploadPersonalityJSONRequestBody defines body for UploadPersonality for application/json ContentType.
type UploadPersonalityJSONRequestBody = PersonalityUploadSpec

// UploadPersonalityFilesMultipartRequestBody defines body for UploadPersonalityFiles for multipart/form-data ContentType.
type UploadPersonalityFilesMultipartRequestBody UploadPersonalityFilesMultipartBody

// RenamePersonalityByIdJSONRequestBody defines body for RenamePersonalityById for application/json ContentType.
type RenamePersonalityByIdJSONRequestBody = Personality

// UploadProductVersionCatalogJSONRequestBody defines body for UploadProductVersionCatalog for application/json ContentType.
type UploadProductVersionCatalogJSONRequestBody = ProductVersionCatalog

// UpdateReleaseByDomainIDJSONRequestBody defines body for UpdateReleaseByDomainID for application/json ContentType.
type UpdateReleaseByDomainIDJSONRequestBody = DomainRelease

// ValidateReleaseByDomainIDJSONRequestBody defines body for ValidateReleaseByDomainID for application/json ContentType.
type ValidateReleaseByDomainIDJSONRequestBody = DomainRelease

// UpdateResourcesFunctionalitiesJSONRequestBody defines body for UpdateResourcesFunctionalities for application/json ContentType.
type UpdateResourcesFunctionalitiesJSONRequestBody = ResourceFunctionalitiesUpdateSpec

// UpdateResourcesFunctionalities1JSONRequestBody defines body for UpdateResourcesFunctionalities1 for application/json ContentType.
type UpdateResourcesFunctionalities1JSONRequestBody = ResourceFunctionalitiesGlobalUpdateSpec

// CreateResourceWarningJSONRequestBody defines body for CreateResourceWarning for application/json ContentType.
type CreateResourceWarningJSONRequestBody = ResourceWarningCreationSpec

// StartLicenseCheckByResourceJSONRequestBody defines body for StartLicenseCheckByResource for application/json ContentType.
type StartLicenseCheckByResourceJSONRequestBody = ResourcesLicenseCheckSpec

// SetLicenseKeyForResourceJSONRequestBody defines body for SetLicenseKeyForResource for application/json ContentType.
type SetLicenseKeyForResourceJSONRequestBody = LicensingSpec

// StartRestoreJSONRequestBody defines body for StartRestore for application/json ContentType.
type StartRestoreJSONRequestBody = RestoreSpec

// AddTrustedCertificateJSONRequestBody defines body for AddTrustedCertificate for application/json ContentType.
type AddTrustedCertificateJSONRequestBody = TrustedCertificateSpec

// StartBringupJSONRequestBody defines body for StartBringup for application/json ContentType.
type StartBringupJSONRequestBody = SddcSpec

// ValidateBringupSpecJSONRequestBody defines body for ValidateBringupSpec for application/json ContentType.
type ValidateBringupSpecJSONRequestBody = SddcSpec

// RetrySddcJSONRequestBody defines body for RetrySddc for application/json ContentType.
type RetrySddcJSONRequestBody = SddcSpec

// UpdateSystemConfigurationJSONRequestBody defines body for UpdateSystemConfiguration for application/json ContentType.
type UpdateSystemConfigurationJSONRequestBody = SystemUpdateSpec

// UpdateBackupConfigurationJSONRequestBody defines body for UpdateBackupConfiguration for application/json ContentType.
type UpdateBackupConfigurationJSONRequestBody = BackupConfigurationSpec

// SetBackupConfigurationJSONRequestBody defines body for SetBackupConfiguration for application/json ContentType.
type SetBackupConfigurationJSONRequestBody = BackupConfigurationSpec

// ValidateBackupConfigurationsOperationsJSONRequestBody defines body for ValidateBackupConfigurationsOperations for application/json ContentType.
type ValidateBackupConfigurationsOperationsJSONRequestBody = BackupConfigurationSpec

// SetCeipStatusJSONRequestBody defines body for SetCeipStatus for application/json ContentType.
type SetCeipStatusJSONRequestBody = CeipUpdateSpec

// TriggerCheckRunJSONRequestBody defines body for TriggerCheckRun for application/json ContentType.
type TriggerCheckRunJSONRequestBody = CheckSetRunInput

// QueryCheckSetsJSONRequestBody defines body for QueryCheckSets for application/json ContentType.
type QueryCheckSetsJSONRequestBody = CheckSetQueryInput

// TriggerPartialRetryOfCheckRunJSONRequestBody defines body for TriggerPartialRetryOfCheckRun for application/json ContentType.
type TriggerPartialRetryOfCheckRunJSONRequestBody = AssessmentPartialRetryInput

// ConfigureDnsJSONRequestBody defines body for ConfigureDns for application/json ContentType.
type ConfigureDnsJSONRequestBody = DnsConfiguration

// ValidateDnsConfigurationJSONRequestBody defines body for ValidateDnsConfiguration for application/json ContentType.
type ValidateDnsConfigurationJSONRequestBody = DnsConfiguration

// StartHealthCheckJSONRequestBody defines body for StartHealthCheck for application/json ContentType.
type StartHealthCheckJSONRequestBody = HealthSummarySpec

// ConfigureNtpJSONRequestBody defines body for ConfigureNtp for application/json ContentType.
type ConfigureNtpJSONRequestBody = NtpConfiguration

// ValidateNtpConfigurationJSONRequestBody defines body for ValidateNtpConfiguration for application/json ContentType.
type ValidateNtpConfigurationJSONRequestBody = NtpConfiguration

// StartPrecheckJSONRequestBody defines body for StartPrecheck for application/json ContentType.
type StartPrecheckJSONRequestBody = PrecheckSpec

// UpdateProxyConfigurationJSONRequestBody defines body for UpdateProxyConfiguration for application/json ContentType.
type UpdateProxyConfigurationJSONRequestBody = ProxyConfiguration

// StartBringupSpecConversionMultipartRequestBody defines body for StartBringupSpecConversion for multipart/form-data ContentType.
type StartBringupSpecConversionMultipartRequestBody StartBringupSpecConversionMultipartBody

// UpdateDepotSettingsJSONRequestBody defines body for UpdateDepotSettings for application/json ContentType.
type UpdateDepotSettingsJSONRequestBody = DepotSettings

// UpdateVersionAliasConfigurationsJSONRequestBody defines body for UpdateVersionAliasConfigurations for application/json ContentType.
type UpdateVersionAliasConfigurationsJSONRequestBody = VersionAliasesForBundleComponentTypeSpec

// DeleteAliasVersionsBySoftwareTypeAndBaseVersionJSONRequestBody defines body for DeleteAliasVersionsBySoftwareTypeAndBaseVersion for application/json ContentType.
type DeleteAliasVersionsBySoftwareTypeAndBaseVersionJSONRequestBody = DeleteAliasVersionsBySoftwareTypeAndBaseVersionJSONBody

// UpdateVersionAliasConfigurationJSONRequestBody defines body for UpdateVersionAliasConfiguration for application/json ContentType.
type UpdateVersionAliasConfigurationJSONRequestBody = AliasSpec

// StartSupportBundleJSONRequestBody defines body for StartSupportBundle for application/json ContentType.
type StartSupportBundleJSONRequestBody = SupportBundleSpec

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody = TokenCreationSpec

// RefreshAccessTokenJSONRequestBody defines body for RefreshAccessToken for application/json ContentType.
type RefreshAccessTokenJSONRequestBody = RefreshAccessTokenJSONBody

// InvalidateRefreshTokenJSONRequestBody defines body for InvalidateRefreshToken for application/json ContentType.
type InvalidateRefreshTokenJSONRequestBody = InvalidateRefreshTokenJSONBody

// PerformUpgradeJSONRequestBody defines body for PerformUpgrade for application/json ContentType.
type PerformUpgradeJSONRequestBody = UpgradeSpec

// UpdateUpgradeScheduleJSONRequestBody defines body for UpdateUpgradeSchedule for application/json ContentType.
type UpdateUpgradeScheduleJSONRequestBody = UpgradeCommitSpec

// AddUsersJSONRequestBody defines body for AddUsers for application/json ContentType.
type AddUsersJSONRequestBody = AddUsersJSONBody

// UpdateLocalUserPasswordJSONRequestBody defines body for UpdateLocalUserPassword for application/json ContentType.
type UpdateLocalUserPasswordJSONRequestBody = LocalAccountPasswordInfo

// AddVasaProviderJSONRequestBody defines body for AddVasaProvider for application/json ContentType.
type AddVasaProviderJSONRequestBody = VasaProvider

// ValidateVasaProviderSpecJSONRequestBody defines body for ValidateVasaProviderSpec for application/json ContentType.
type ValidateVasaProviderSpecJSONRequestBody = VasaProvider

// UpdateVasaProviderJSONRequestBody defines body for UpdateVasaProvider for application/json ContentType.
type UpdateVasaProviderJSONRequestBody = VasaProviderUpdateSpec

// AddVasaProviderStorageContainerJSONRequestBody defines body for AddVasaProviderStorageContainer for application/json ContentType.
type AddVasaProviderStorageContainerJSONRequestBody = AddVasaProviderStorageContainerJSONBody

// UpdateVasaProviderStorageContainerJSONRequestBody defines body for UpdateVasaProviderStorageContainer for application/json ContentType.
type UpdateVasaProviderStorageContainerJSONRequestBody = StorageContainerUpdateSpec

// AddVasaProviderUserJSONRequestBody defines body for AddVasaProviderUser for application/json ContentType.
type AddVasaProviderUserJSONRequestBody = AddVasaProviderUserJSONBody

// UpdateVasaProviderUserJSONRequestBody defines body for UpdateVasaProviderUser for application/json ContentType.
type UpdateVasaProviderUserJSONRequestBody = VasaUserUpdateSpec

// ConnectVrliWithDomainJSONRequestBody defines body for ConnectVrliWithDomain for application/json ContentType.
type ConnectVrliWithDomainJSONRequestBody = DomainIntegration

// ConnectVropsWithDomainJSONRequestBody defines body for ConnectVropsWithDomain for application/json ContentType.
type ConnectVropsWithDomainJSONRequestBody = DomainIntegration

// UpdateVrslcmVersionInInventoryJSONRequestBody defines body for UpdateVrslcmVersionInInventory for application/json ContentType.
type UpdateVrslcmVersionInInventoryJSONRequestBody = Vrslcm

// DeployVrslcmJSONRequestBody defines body for DeployVrslcm for application/json ContentType.
type DeployVrslcmJSONRequestBody = VrslcmDeploymentSpec

// ValidateVrslcmJSONRequestBody defines body for ValidateVrslcm for application/json ContentType.
type ValidateVrslcmJSONRequestBody = VrslcmDeploymentSpec

// UpdateVrslcmVersionByIdInInventoryJSONRequestBody defines body for UpdateVrslcmVersionByIdInInventory for application/json ContentType.
type UpdateVrslcmVersionByIdInInventoryJSONRequestBody = Vrslcm

// UpdateVsanHclConfigurationJSONRequestBody defines body for UpdateVsanHclConfiguration for application/json ContentType.
type UpdateVsanHclConfigurationJSONRequestBody = VsanHclConfiguration

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAvns request
	GetAvns(ctx context.Context, params *GetAvnsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAvnsWithBody request with any body
	CreateAvnsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAvns(ctx context.Context, body CreateAvnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateAvnSpecWithBody request with any body
	ValidateAvnSpecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateAvnSpec(ctx context.Context, body ValidateAvnSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartBackupWithBody request with any body
	StartBackupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartBackup(ctx context.Context, body StartBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBundles request
	GetBundles(ctx context.Context, params *GetBundlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadBundleWithBody request with any body
	UploadBundleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadBundle(ctx context.Context, body UploadBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBundleCompatibilitySetsWithBody request with any body
	UpdateBundleCompatibilitySetsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBundleCompatibilitySets(ctx context.Context, body UpdateBundleCompatibilitySetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBundlesForSkipUpgrade request
	GetBundlesForSkipUpgrade(ctx context.Context, id string, params *GetBundlesForSkipUpgradeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBundle request
	DeleteBundle(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBundle request
	GetBundle(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartBundleDownloadByIDWithBody request with any body
	StartBundleDownloadByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartBundleDownloadByID(ctx context.Context, id string, body StartBundleDownloadByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertificateAuthorities request
	GetCertificateAuthorities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigureCertificateAuthorityWithBody request with any body
	ConfigureCertificateAuthorityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfigureCertificateAuthority(ctx context.Context, body ConfigureCertificateAuthorityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCertificateAuthorityWithBody request with any body
	CreateCertificateAuthorityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCertificateAuthority(ctx context.Context, body CreateCertificateAuthorityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveCertificateAuthority request
	RemoveCertificateAuthority(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertificateAuthorityById request
	GetCertificateAuthorityById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusters request
	GetClusters(ctx context.Context, params *GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterWithBody request with any body
	CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagsAssignedToClusters request
	GetTagsAssignedToClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateClusterCreationSpecWithBody request with any body
	ValidateClusterCreationSpecWithBody(ctx context.Context, params *ValidateClusterCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateClusterCreationSpec(ctx context.Context, params *ValidateClusterCreationSpecParams, body ValidateClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterCreateValidation request
	GetClusterCreateValidation(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatastoreQueryResponse1 request
	GetDatastoreQueryResponse1(ctx context.Context, clusterId string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateVsanRemoteDatastoreSpecWithBody request with any body
	ValidateVsanRemoteDatastoreSpecWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateVsanRemoteDatastoreSpec(ctx context.Context, clusterId string, body ValidateVsanRemoteDatastoreSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateVsanRemoteDatastoreMountSpecWithBody request with any body
	ValidateVsanRemoteDatastoreMountSpecWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateVsanRemoteDatastoreMountSpec(ctx context.Context, clusterId string, body ValidateVsanRemoteDatastoreMountSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostQueryResponse1 request
	GetHostQueryResponse1(ctx context.Context, clusterId string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVdses request
	GetVdses(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportVdsToInventoryWithBody request with any body
	ImportVdsToInventoryWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportVdsToInventory(ctx context.Context, clusterId string, body ImportVdsToInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, id string, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterWithBody request with any body
	UpdateClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterDatastores request
	GetClusterDatastores(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDatastoreToClusterWithBody request with any body
	AddDatastoreToClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDatastoreToCluster(ctx context.Context, id string, body AddDatastoreToClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatastoresCriteria1 request
	GetDatastoresCriteria1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatastoreCriterion1 request
	GetDatastoreCriterion1(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDatastoreQuery1WithBody request with any body
	PostDatastoreQuery1WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDatastoreQuery1(ctx context.Context, id string, body PostDatastoreQuery1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveDatastoreFromCluster request
	RemoveDatastoreFromCluster(ctx context.Context, id string, datastoreId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostCriteria request
	GetHostCriteria(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostCriterion request
	GetHostCriterion(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostHostQueryWithBody request with any body
	PostHostQueryWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostHostQuery(ctx context.Context, id string, body PostHostQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterNetworkConfigurationCriteria request
	GetClusterNetworkConfigurationCriteria(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterNetworkConfigurationWithBody request with any body
	GetClusterNetworkConfigurationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetClusterNetworkConfiguration(ctx context.Context, id string, body GetClusterNetworkConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterNetworkConfigurationQueryResponse request
	GetClusterNetworkConfigurationQueryResponse(ctx context.Context, id string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTagsFromClusterWithBody request with any body
	RemoveTagsFromClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveTagsFromCluster(ctx context.Context, id string, body RemoveTagsFromClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagsAssignedToCluster request
	GetTagsAssignedToCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignTagsToClusterWithBody request with any body
	AssignTagsToClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignTagsToCluster(ctx context.Context, id string, body AssignTagsToClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagAssignableForCluster request
	GetTagAssignableForCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterTagManagerUrl request
	GetClusterTagManagerUrl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateClusterUpdateSpecWithBody request with any body
	ValidateClusterUpdateSpecWithBody(ctx context.Context, id string, params *ValidateClusterUpdateSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateClusterUpdateSpec(ctx context.Context, id string, params *ValidateClusterUpdateSpecParams, body ValidateClusterUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterUpdateValidation request
	GetClusterUpdateValidation(ctx context.Context, id openapi_types.UUID, validationId openapi_types.UUID, params *GetClusterUpdateValidationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompatibilityMatrices request
	GetCompatibilityMatrices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCompatibilityMatrixWithBody request with any body
	UpdateCompatibilityMatrixWithBody(ctx context.Context, params *UpdateCompatibilityMatrixParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompatibilityMatrix request
	GetCompatibilityMatrix(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompatibilityMatrixContent request
	GetCompatibilityMatrixContent(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompatibilityMatrixMetadata request
	GetCompatibilityMatrixMetadata(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplianceAuditHistory request
	GetComplianceAuditHistory(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplianceAudit request
	GetComplianceAudit(ctx context.Context, complianceAuditId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplianceAuditItems request
	GetComplianceAuditItems(ctx context.Context, complianceAuditId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplianceConfigurations request
	GetComplianceConfigurations(ctx context.Context, params *GetComplianceConfigurationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplianceStandards request
	GetComplianceStandards(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReconcileConfigsWithBody request with any body
	ReconcileConfigsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReconcileConfigs(ctx context.Context, body ReconcileConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReconciliationTask request
	GetReconciliationTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigs request
	GetConfigs(ctx context.Context, params *GetConfigsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredentials request
	GetCredentials(ctx context.Context, params *GetCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrRotatePasswordsWithBody request with any body
	UpdateOrRotatePasswordsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrRotatePasswords(ctx context.Context, body UpdateOrRotatePasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPasswordExpirationWithBody request with any body
	GetPasswordExpirationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPasswordExpiration(ctx context.Context, body GetPasswordExpirationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPasswordExpirationByTaskID request
	GetPasswordExpirationByTaskID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredentialsTasks request
	GetCredentialsTasks(ctx context.Context, params *GetCredentialsTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelCredentialsTask request
	CancelCredentialsTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredentialsTask request
	GetCredentialsTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryCredentialsTaskWithBody request with any body
	RetryCredentialsTaskWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RetryCredentialsTask(ctx context.Context, id string, body RetryCredentialsTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredentialTaskByResourceID request
	GetCredentialTaskByResourceID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredentialsSubTask request
	GetCredentialsSubTask(ctx context.Context, id string, subtaskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredential request
	GetCredential(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomIsos request
	GetCustomIsos(ctx context.Context, params *GetCustomIsosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadCustomIsoWithBody request with any body
	UploadCustomIsoWithBody(ctx context.Context, params *UploadCustomIsoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomIsoById request
	DeleteCustomIsoById(ctx context.Context, customIsoId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomIsoById request
	GetCustomIsoById(ctx context.Context, customIsoId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenameCustomIsoByIdWithBody request with any body
	RenameCustomIsoByIdWithBody(ctx context.Context, customIsoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RenameCustomIsoById(ctx context.Context, customIsoId string, body RenameCustomIsoByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomains request
	GetDomains(ctx context.Context, params *GetDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDomainWithBody request with any body
	CreateDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDomain(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagsAssignedToDomains request
	GetTagsAssignedToDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateDomainCreationSpecWithBody request with any body
	ValidateDomainCreationSpecWithBody(ctx context.Context, params *ValidateDomainCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateDomainCreationSpec(ctx context.Context, params *ValidateDomainCreationSpecParams, body ValidateDomainCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DomainCreateValidation request
	DomainCreateValidation(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterCriteria request
	GetClusterCriteria(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterCriterion request
	GetClusterCriterion(ctx context.Context, domainId string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClustersQueryWithBody request with any body
	PostClustersQueryWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClustersQuery(ctx context.Context, domainId string, body PostClustersQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClustersQueryResponse request
	GetClustersQueryResponse(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClusterQueryWithBody request with any body
	PostClusterQueryWithBody(ctx context.Context, domainId string, clusterName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClusterQuery(ctx context.Context, domainId string, clusterName string, body PostClusterQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterQueryResponse request
	GetClusterQueryResponse(ctx context.Context, domainId string, clusterName string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatastoresCriteria request
	GetDatastoresCriteria(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatastoreCriterion request
	GetDatastoreCriterion(ctx context.Context, domainId string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDatastoreQueryWithBody request with any body
	PostDatastoreQueryWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDatastoreQuery(ctx context.Context, domainId string, body PostDatastoreQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatastoreQueryResponse request
	GetDatastoreQueryResponse(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVsanHealthCheckByDomain request
	GetVsanHealthCheckByDomain(ctx context.Context, domainId string, params *GetVsanHealthCheckByDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVsanHealthCheckByDomainWithBody request with any body
	UpdateVsanHealthCheckByDomainWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVsanHealthCheckByDomain(ctx context.Context, domainId string, body UpdateVsanHealthCheckByDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVsanHealthCheckByQueryID request
	GetVsanHealthCheckByQueryID(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVsanHealthCheckByTaskID request
	GetVsanHealthCheckByTaskID(ctx context.Context, domainId string, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PerformDomainIsolationPrecheckWithBody request with any body
	PerformDomainIsolationPrecheckWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PerformDomainIsolationPrecheck(ctx context.Context, domainId string, body PerformDomainIsolationPrecheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainIsolationPrecheckStatus request
	GetDomainIsolationPrecheckStatus(ctx context.Context, domainId string, precheckId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDomain request
	DeleteDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomain request
	GetDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDomainWithBody request with any body
	UpdateDomainWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDomain(ctx context.Context, id string, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainCertificates request
	GetDomainCertificates(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceCertificatesWithBody request with any body
	ReplaceCertificatesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceCertificates(ctx context.Context, id string, body ReplaceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateCertificatesWithBody request with any body
	GenerateCertificatesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateCertificates(ctx context.Context, id string, body GenerateCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadCertificatesWithBody request with any body
	UploadCertificatesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplianceAuditHistoryForADomain request
	GetComplianceAuditHistoryForADomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ComplianceAuditWithBody request with any body
	ComplianceAuditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ComplianceAudit(ctx context.Context, id string, body ComplianceAuditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplianceAuditTask request
	GetComplianceAuditTask(ctx context.Context, id string, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryComplianceAuditTask request
	RetryComplianceAuditTask(ctx context.Context, id string, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplianceAuditForADomain request
	GetComplianceAuditForADomain(ctx context.Context, id string, complianceAuditId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplianceAuditItemsForADomain request
	GetComplianceAuditItemsForADomain(ctx context.Context, id string, complianceAuditId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCSRs request
	GetCSRs(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeneratesCSRsWithBody request with any body
	GeneratesCSRsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GeneratesCSRs(ctx context.Context, id string, body GeneratesCSRsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadCSR request
	DownloadCSR(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEndpoints request
	GetDomainEndpoints(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertificatesByDomain request
	GetCertificatesByDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceResourceCertificatesWithBody request with any body
	ReplaceResourceCertificatesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceResourceCertificates(ctx context.Context, id string, body ReplaceResourceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateResourceCertificatesWithBody request with any body
	ValidateResourceCertificatesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateResourceCertificates(ctx context.Context, id string, body ValidateResourceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceCertificatesValidationByID request
	GetResourceCertificatesValidationByID(ctx context.Context, id string, validationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTagsFromDomainWithBody request with any body
	RemoveTagsFromDomainWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveTagsFromDomain(ctx context.Context, id string, body RemoveTagsFromDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagsAssignedToDomain request
	GetTagsAssignedToDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignTagsToDomainWithBody request with any body
	AssignTagsToDomainWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignTagsToDomain(ctx context.Context, id string, body AssignTagsToDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssignableTagsForDomain request
	GetAssignableTagsForDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainTagManagerUrl request
	GetDomainTagManagerUrl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateDomainUpdateSpecWithBody request with any body
	ValidateDomainUpdateSpecWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateDomainUpdateSpec(ctx context.Context, id string, body ValidateDomainUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainUpdateValidation request
	GetDomainUpdateValidation(ctx context.Context, id openapi_types.UUID, validationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeClusters request
	GetEdgeClusters(ctx context.Context, params *GetEdgeClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEdgeClusterWithBody request with any body
	CreateEdgeClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEdgeCluster(ctx context.Context, body CreateEdgeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateEdgeClusterCreationSpecWithBody request with any body
	ValidateEdgeClusterCreationSpecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateEdgeClusterCreationSpec(ctx context.Context, body ValidateEdgeClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeClusterValidationByID request
	GetEdgeClusterValidationByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeClusterQueryCriteria request
	GetEdgeClusterQueryCriteria(ctx context.Context, edgeClusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeCluster request
	GetEdgeCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEdgeClusterWithBody request with any body
	UpdateEdgeClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEdgeCluster(ctx context.Context, id string, body UpdateEdgeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateEdgeClusterUpdateSpecWithBody request with any body
	ValidateEdgeClusterUpdateSpecWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateEdgeClusterUpdateSpec(ctx context.Context, id string, body ValidateEdgeClusterUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DecommissionHostsWithBody request with any body
	DecommissionHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DecommissionHosts(ctx context.Context, body DecommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHosts request
	GetHosts(ctx context.Context, params *GetHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommissionHostsWithBody request with any body
	CommissionHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommissionHosts(ctx context.Context, body CommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCriteria request
	GetCriteria(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCriterion request
	GetCriterion(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostHostsPrechecks1WithBody request with any body
	PostHostsPrechecks1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostHostsPrechecks1(ctx context.Context, body PostHostsPrechecks1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostsPrechecksResponse request
	GetHostsPrechecksResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostQueryWithBody request with any body
	PostQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostQuery(ctx context.Context, body PostQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostQueryResponse request
	GetHostQueryResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagsAssignedToHosts request
	GetTagsAssignedToHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateHostCommissionSpecWithBody request with any body
	ValidateHostCommissionSpecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateHostCommissionSpec(ctx context.Context, body ValidateHostCommissionSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateCommissionHostsWithBody request with any body
	ValidateCommissionHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateCommissionHosts(ctx context.Context, body ValidateCommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostCommissionValidationByID request
	GetHostCommissionValidationByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHost request
	GetHost(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTagsFromHostWithBody request with any body
	RemoveTagsFromHostWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveTagsFromHost(ctx context.Context, id string, body RemoveTagsFromHostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagsAssignedToHost request
	GetTagsAssignedToHost(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignTagsToHostWithBody request with any body
	AssignTagsToHostWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignTagsToHost(ctx context.Context, id string, body AssignTagsToHostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssignableTagForHost request
	GetAssignableTagForHost(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostTagManagerUrl request
	GetHostTagManagerUrl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIdentityPrecheckResult request
	GetIdentityPrecheckResult(ctx context.Context, params *GetIdentityPrecheckResultParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSddcWs1bOidcInfo request
	GetSddcWs1bOidcInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIdentityProviders request
	GetIdentityProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddExternalIdentityProviderWithBody request with any body
	AddExternalIdentityProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddExternalIdentityProvider(ctx context.Context, body AddExternalIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExternalIdentityProvider request
	DeleteExternalIdentityProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIdentityProviderById request
	GetIdentityProviderById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateExternalIdentityProviderWithBody request with any body
	UpdateExternalIdentityProviderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateExternalIdentityProvider(ctx context.Context, id string, body UpdateExternalIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddEmbeddedIdentitySourceWithBody request with any body
	AddEmbeddedIdentitySourceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddEmbeddedIdentitySource(ctx context.Context, id string, body AddEmbeddedIdentitySourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIdentitySource request
	DeleteIdentitySource(ctx context.Context, id string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEmbeddedIdentitySourceWithBody request with any body
	UpdateEmbeddedIdentitySourceWithBody(ctx context.Context, id string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEmbeddedIdentitySource(ctx context.Context, id string, domainName string, body UpdateEmbeddedIdentitySourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateSyncClientToken request
	GenerateSyncClientToken(ctx context.Context, id string, params *GenerateSyncClientTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicenseKeys request
	GetLicenseKeys(ctx context.Context, params *GetLicenseKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddLicenseKeyWithBody request with any body
	AddLicenseKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddLicenseKey(ctx context.Context, body AddLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicenseProductTypes request
	GetLicenseProductTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveLicenseKey request
	RemoveLicenseKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicenseKey request
	GetLicenseKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLicenseKeyWithBody request with any body
	UpdateLicenseKeyWithBody(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLicenseKey(ctx context.Context, key string, body UpdateLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicenseInformation request
	GetLicenseInformation(ctx context.Context, params *GetLicenseInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainLicensingInfo request
	GetDomainLicensingInfo(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemLicensingInfo request
	GetSystemLicensingInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetManifest request
	GetManifest(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveManifestWithBody request with any body
	SaveManifestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveManifest(ctx context.Context, body SaveManifestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkPool request
	GetNetworkPool(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNetworkPoolWithBody request with any body
	CreateNetworkPoolWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNetworkPool(ctx context.Context, body CreateNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNetworkPool request
	DeleteNetworkPool(ctx context.Context, id string, params *DeleteNetworkPoolParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkPoolByID request
	GetNetworkPoolByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNetworkPoolWithBody request with any body
	UpdateNetworkPoolWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNetworkPool(ctx context.Context, id string, body UpdateNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworksOfNetworkPool request
	GetNetworksOfNetworkPool(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkOfNetworkPool request
	GetNetworkOfNetworkPool(ctx context.Context, id string, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIpPoolFromNetworkOfNetworkPoolWithBody request with any body
	DeleteIpPoolFromNetworkOfNetworkPoolWithBody(ctx context.Context, id string, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteIpPoolFromNetworkOfNetworkPool(ctx context.Context, id string, networkId string, body DeleteIpPoolFromNetworkOfNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddIpPoolToNetworkOfNetworkPoolWithBody request with any body
	AddIpPoolToNetworkOfNetworkPoolWithBody(ctx context.Context, id string, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddIpPoolToNetworkOfNetworkPool(ctx context.Context, id string, networkId string, body AddIpPoolToNetworkOfNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetALBClusters request
	GetALBClusters(ctx context.Context, params *GetALBClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetALBClustersFormFactors request
	GetALBClustersFormFactors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateALBClusterCreationSpecWithBody request with any body
	ValidateALBClusterCreationSpecWithBody(ctx context.Context, params *ValidateALBClusterCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateALBClusterCreationSpec(ctx context.Context, params *ValidateALBClusterCreationSpecParams, body ValidateALBClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateNsxALBCompatibilityWithBody request with any body
	ValidateNsxALBCompatibilityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateNsxALBCompatibility(ctx context.Context, body ValidateNsxALBCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteALBCluster request
	DeleteALBCluster(ctx context.Context, id string, params *DeleteALBClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetALBCluster request
	GetALBCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNsxClusters request
	GetNsxClusters(ctx context.Context, params *GetNsxClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNsxCriteria request
	GetNsxCriteria(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNsxCriterion request
	GetNsxCriterion(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateIpPoolWithBody request with any body
	ValidateIpPoolWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateIpPool(ctx context.Context, body ValidateIpPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetValidationResult request
	GetValidationResult(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectOpenIdWithBody request with any body
	ConnectOpenIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectOpenId(ctx context.Context, body ConnectOpenIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartNsxCriteriaQueryWithBody request with any body
	StartNsxCriteriaQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartNsxCriteriaQuery(ctx context.Context, body StartNsxCriteriaQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNsxClusterQueryResponse request
	GetNsxClusterQueryResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNsxCluster request
	GetNsxCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNsxIpAddressPools request
	GetNsxIpAddressPools(ctx context.Context, nsxtClusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNsxIpAddressPool request
	GetNsxIpAddressPool(ctx context.Context, nsxtClusterId string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNsxTransportZones request
	GetNsxTransportZones(ctx context.Context, nsxtClusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersonality request
	DeletePersonality(ctx context.Context, params *DeletePersonalityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonalities request
	GetPersonalities(ctx context.Context, params *GetPersonalitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadPersonalityWithBody request with any body
	UploadPersonalityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadPersonality(ctx context.Context, body UploadPersonalityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadPersonalityFilesWithBody request with any body
	UploadPersonalityFilesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonality request
	GetPersonality(ctx context.Context, personalityId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenamePersonalityByIdWithBody request with any body
	RenamePersonalityByIdWithBody(ctx context.Context, personalityId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RenamePersonalityById(ctx context.Context, personalityId string, body RenamePersonalityByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductVersionCatalog request
	GetProductVersionCatalog(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadProductVersionCatalogWithBody request with any body
	UploadProductVersionCatalogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadProductVersionCatalog(ctx context.Context, body UploadProductVersionCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPscs request
	GetPscs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPsc request
	GetPsc(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleases request
	GetReleases(ctx context.Context, params *GetReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleaseByDomains request
	GetReleaseByDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainReleaseViewValidation request
	GetDomainReleaseViewValidation(ctx context.Context, validationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReleaseByDomainID request
	DeleteReleaseByDomainID(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleaseByDomain request
	GetReleaseByDomain(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateReleaseByDomainIDWithBody request with any body
	UpdateReleaseByDomainIDWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateReleaseByDomainID(ctx context.Context, domainId string, body UpdateReleaseByDomainIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomPatches request
	GetCustomPatches(ctx context.Context, domainId string, params *GetCustomPatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFutureReleases request
	GetFutureReleases(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateReleaseByDomainIDWithBody request with any body
	ValidateReleaseByDomainIDWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateReleaseByDomainID(ctx context.Context, domainId string, body ValidateReleaseByDomainIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemRelease request
	GetSystemRelease(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceFunctionalities request
	GetResourceFunctionalities(ctx context.Context, params *GetResourceFunctionalitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResourcesFunctionalitiesWithBody request with any body
	UpdateResourcesFunctionalitiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResourcesFunctionalities(ctx context.Context, body UpdateResourcesFunctionalitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcesFunctionalitiesAllowedGlobal request
	GetResourcesFunctionalitiesAllowedGlobal(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResourcesFunctionalities1WithBody request with any body
	UpdateResourcesFunctionalities1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResourcesFunctionalities1(ctx context.Context, body UpdateResourcesFunctionalities1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceWarnings request
	GetResourceWarnings(ctx context.Context, params *GetResourceWarningsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResourceWarningWithBody request with any body
	CreateResourceWarningWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResourceWarning(ctx context.Context, body CreateResourceWarningJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceWarning request
	GetResourceWarning(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartLicenseCheckByResourceWithBody request with any body
	StartLicenseCheckByResourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartLicenseCheckByResource(ctx context.Context, body StartLicenseCheckByResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicenseCheckResultByID request
	GetLicenseCheckResultByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetLicenseKeyForResourceWithBody request with any body
	SetLicenseKeyForResourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetLicenseKeyForResource(ctx context.Context, body SetLicenseKeyForResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartRestoreWithBody request with any body
	StartRestoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartRestore(ctx context.Context, body StartRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRestoreTask request
	GetRestoreTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoles request
	GetRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocalOsUserAccounts request
	GetLocalOsUserAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTrustedCertificates request
	GetTrustedCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTrustedCertificateWithBody request with any body
	AddTrustedCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTrustedCertificate(ctx context.Context, body AddTrustedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTrustedCertificate request
	DeleteTrustedCertificate(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSddcManagerUpgradables request
	GetSddcManagerUpgradables(ctx context.Context, params *GetSddcManagerUpgradablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSddcManagers request
	GetSddcManagers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSddcManager request
	GetSddcManager(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSddcManagerHistory request
	GetSddcManagerHistory(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBringupTasks request
	GetBringupTasks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartBringupWithBody request with any body
	StartBringupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartBringup(ctx context.Context, body StartBringupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBringupAppInfo request
	GetBringupAppInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBringupValidations request
	GetBringupValidations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateBringupSpecWithBody request with any body
	ValidateBringupSpecWithBody(ctx context.Context, params *ValidateBringupSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateBringupSpec(ctx context.Context, params *ValidateBringupSpecParams, body ValidateBringupSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBringupValidation request
	GetBringupValidation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryBringupValidation request
	RetryBringupValidation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportBringupValidationReport request
	ExportBringupValidationReport(ctx context.Context, validationId string, params *ExportBringupValidationReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBringupTaskByID request
	GetBringupTaskByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrySddcWithBody request with any body
	RetrySddcWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RetrySddc(ctx context.Context, id string, body RetrySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportBringupDetailReport request
	ExportBringupDetailReport(ctx context.Context, id string, params *ExportBringupDetailReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSddcManagerInfo request
	GetSddcManagerInfo(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSSODomains request
	GetSSODomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSSODomainEntities request
	GetSSODomainEntities(ctx context.Context, ssoDomain string, params *GetSSODomainEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemConfiguration request
	GetSystemConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSystemConfigurationWithBody request with any body
	UpdateSystemConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSystemConfiguration(ctx context.Context, body UpdateSystemConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackupConfiguration request
	GetBackupConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBackupConfigurationWithBody request with any body
	UpdateBackupConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBackupConfiguration(ctx context.Context, body UpdateBackupConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBackupConfigurationWithBody request with any body
	SetBackupConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetBackupConfiguration(ctx context.Context, body SetBackupConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackupLocation request
	GetBackupLocation(ctx context.Context, params *GetBackupLocationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateBackupConfigurationsOperationsWithBody request with any body
	ValidateBackupConfigurationsOperationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateBackupConfigurationsOperations(ctx context.Context, body ValidateBackupConfigurationsOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCeipStatus request
	GetCeipStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCeipStatusWithBody request with any body
	SetCeipStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetCeipStatus(ctx context.Context, body SetCeipStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLastAssessmentRunInfo request
	GetLastAssessmentRunInfo(ctx context.Context, params *GetLastAssessmentRunInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerCheckRunWithBody request with any body
	TriggerCheckRunWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TriggerCheckRun(ctx context.Context, body TriggerCheckRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryCheckSetsWithBody request with any body
	QueryCheckSetsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryCheckSets(ctx context.Context, body QueryCheckSetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResult request
	GetResult(ctx context.Context, runId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerPartialRetryOfCheckRunWithBody request with any body
	TriggerPartialRetryOfCheckRunWithBody(ctx context.Context, runId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TriggerPartialRetryOfCheckRun(ctx context.Context, runId openapi_types.UUID, body TriggerPartialRetryOfCheckRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDnsConfiguration request
	GetDnsConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigureDnsWithBody request with any body
	ConfigureDnsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfigureDns(ctx context.Context, body ConfigureDnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetValidationsOfDNSConfiguration request
	GetValidationsOfDNSConfiguration(ctx context.Context, params *GetValidationsOfDNSConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateDnsConfigurationWithBody request with any body
	ValidateDnsConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateDnsConfiguration(ctx context.Context, body ValidateDnsConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetValidationOfDnsConfiguration request
	GetValidationOfDnsConfiguration(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealthCheckTask request
	GetHealthCheckTask(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartHealthCheckWithBody request with any body
	StartHealthCheckWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartHealthCheck(ctx context.Context, body StartHealthCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealthCheckStatus request
	GetHealthCheckStatus(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportHealthCheckByID request
	ExportHealthCheckByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNtpConfiguration request
	GetNtpConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigureNtpWithBody request with any body
	ConfigureNtpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfigureNtp(ctx context.Context, body ConfigureNtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetValidationsOfNtpConfiguration request
	GetValidationsOfNtpConfiguration(ctx context.Context, params *GetValidationsOfNtpConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateNtpConfigurationWithBody request with any body
	ValidateNtpConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateNtpConfiguration(ctx context.Context, body ValidateNtpConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetValidationOfNtpConfiguration request
	GetValidationOfNtpConfiguration(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartPrecheckWithBody request with any body
	StartPrecheckWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartPrecheck(ctx context.Context, body StartPrecheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrecheckTask request
	GetPrecheckTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProxyConfiguration request
	GetProxyConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProxyConfigurationWithBody request with any body
	UpdateProxyConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProxyConfiguration(ctx context.Context, body UpdateProxyConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartBringupSpecConversionWithBody request with any body
	StartBringupSpecConversionWithBody(ctx context.Context, params *StartBringupSpecConversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFIPSConfiguration request
	GetFIPSConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDepotSettings request
	DeleteDepotSettings(ctx context.Context, params *DeleteDepotSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDepotSettings request
	GetDepotSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDepotSettingsWithBody request with any body
	UpdateDepotSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDepotSettings(ctx context.Context, body UpdateDepotSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionAliasConfiguration request
	GetVersionAliasConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVersionAliasConfigurationsWithBody request with any body
	UpdateVersionAliasConfigurationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVersionAliasConfigurations(ctx context.Context, body UpdateVersionAliasConfigurationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVersionAliasBySoftwareType request
	DeleteVersionAliasBySoftwareType(ctx context.Context, bundleComponentType string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAliasVersionsBySoftwareTypeAndBaseVersionWithBody request with any body
	DeleteAliasVersionsBySoftwareTypeAndBaseVersionWithBody(ctx context.Context, bundleComponentType string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteAliasVersionsBySoftwareTypeAndBaseVersion(ctx context.Context, bundleComponentType string, version string, body DeleteAliasVersionsBySoftwareTypeAndBaseVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVersionAliasConfigurationWithBody request with any body
	UpdateVersionAliasConfigurationWithBody(ctx context.Context, bundleComponentType string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVersionAliasConfiguration(ctx context.Context, bundleComponentType string, version string, body UpdateVersionAliasConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSupportBundleTask request
	GetSupportBundleTask(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartSupportBundleWithBody request with any body
	StartSupportBundleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartSupportBundle(ctx context.Context, body StartSupportBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSupportBundleStatus request
	GetSupportBundleStatus(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportSupportBundleByID request
	ExportSupportBundleByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpgradables request
	GetUpgradables(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTasks request
	GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelTask request
	CancelTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTask request
	GetTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryTask request
	RetryTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshAccessTokenWithBody request with any body
	RefreshAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshAccessToken(ctx context.Context, body RefreshAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InvalidateRefreshTokenWithBody request with any body
	InvalidateRefreshTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InvalidateRefreshToken(ctx context.Context, body InvalidateRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpgradablesByDomain request
	GetUpgradablesByDomain(ctx context.Context, domainId string, params *GetUpgradablesByDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpgradablesClusters request
	GetUpgradablesClusters(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNsxUpgradeResources request
	GetNsxUpgradeResources(ctx context.Context, domainId string, params *GetNsxUpgradeResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpgrades request
	GetUpgrades(ctx context.Context, params *GetUpgradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PerformUpgradeWithBody request with any body
	PerformUpgradeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PerformUpgrade(ctx context.Context, body PerformUpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpgradeById request
	GetUpgradeById(ctx context.Context, upgradeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUpgradeScheduleWithBody request with any body
	UpdateUpgradeScheduleWithBody(ctx context.Context, upgradeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUpgradeSchedule(ctx context.Context, upgradeId string, body UpdateUpgradeScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartUpgradePrecheck request
	StartUpgradePrecheck(ctx context.Context, upgradeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpgradePrecheckByID request
	GetUpgradePrecheckByID(ctx context.Context, upgradeId string, precheckId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUsersWithBody request with any body
	AddUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUsers(ctx context.Context, body AddUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableLocalAccount request
	DisableLocalAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocalAccount request
	GetLocalAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLocalUserPasswordWithBody request with any body
	UpdateLocalUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLocalUserPassword(ctx context.Context, body UpdateLocalUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUiUsers request
	GetUiUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUser request
	RemoveUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVasaProviders request
	GetVasaProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddVasaProviderWithBody request with any body
	AddVasaProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVasaProvider(ctx context.Context, body AddVasaProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateVasaProviderSpecWithBody request with any body
	ValidateVasaProviderSpecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateVasaProviderSpec(ctx context.Context, body ValidateVasaProviderSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVasaProviderValidation request
	GetVasaProviderValidation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveVasaProvider request
	RemoveVasaProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVasaProvider request
	GetVasaProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVasaProviderWithBody request with any body
	UpdateVasaProviderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVasaProvider(ctx context.Context, id string, body UpdateVasaProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVasaProviderStorageContainers request
	GetVasaProviderStorageContainers(ctx context.Context, id string, params *GetVasaProviderStorageContainersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddVasaProviderStorageContainerWithBody request with any body
	AddVasaProviderStorageContainerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVasaProviderStorageContainer(ctx context.Context, id string, body AddVasaProviderStorageContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveVasaProviderStorageContainer request
	RemoveVasaProviderStorageContainer(ctx context.Context, id string, storageContainerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVasaProviderStorageContainerWithBody request with any body
	UpdateVasaProviderStorageContainerWithBody(ctx context.Context, id string, storageContainerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVasaProviderStorageContainer(ctx context.Context, id string, storageContainerId string, body UpdateVasaProviderStorageContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVasaProviderUser request
	GetVasaProviderUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddVasaProviderUserWithBody request with any body
	AddVasaProviderUserWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVasaProviderUser(ctx context.Context, id string, body AddVasaProviderUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVasaProviderUserWithBody request with any body
	UpdateVasaProviderUserWithBody(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVasaProviderUser(ctx context.Context, id string, userId string, body UpdateVasaProviderUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVcenters request
	GetVcenters(ctx context.Context, params *GetVcentersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVcenter request
	GetVcenter(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVcfServices request
	GetVcfServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVcfService request
	GetVcfService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVras request
	GetVras(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVrliIntegratedDomains request
	GetVrliIntegratedDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectVrliWithDomainWithBody request with any body
	ConnectVrliWithDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectVrliWithDomain(ctx context.Context, body ConnectVrliWithDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVrlis request
	GetVrlis(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVropsIntegratedDomains request
	GetVropsIntegratedDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectVropsWithDomainWithBody request with any body
	ConnectVropsWithDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectVropsWithDomain(ctx context.Context, body ConnectVropsWithDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVropses request
	GetVropses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RollbackVrslcm request
	RollbackVrslcm(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVrslcm request
	GetVrslcm(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVrslcmVersionInInventoryWithBody request with any body
	UpdateVrslcmVersionInInventoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVrslcmVersionInInventory(ctx context.Context, body UpdateVrslcmVersionInInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVrslcmStatus request
	GetVrslcmStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVrslcms request
	GetVrslcms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeployVrslcmWithBody request with any body
	DeployVrslcmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeployVrslcm(ctx context.Context, body DeployVrslcmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateVrslcmWithBody request with any body
	ValidateVrslcmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateVrslcm(ctx context.Context, body ValidateVrslcmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVrslcmValidation request
	GetVrslcmValidation(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVrslcmVersionByIdInInventoryWithBody request with any body
	UpdateVrslcmVersionByIdInInventoryWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVrslcmVersionByIdInInventory(ctx context.Context, id string, body UpdateVrslcmVersionByIdInInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadVsanHcl request
	DownloadVsanHcl(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVsanHclAttributes request
	GetVsanHclAttributes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVsanHclConfiguration request
	GetVsanHclConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVsanHclConfigurationWithBody request with any body
	UpdateVsanHclConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVsanHclConfiguration(ctx context.Context, body UpdateVsanHclConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWsas request
	GetWsas(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAvns(ctx context.Context, params *GetAvnsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvnsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAvnsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAvnsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAvns(ctx context.Context, body CreateAvnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAvnsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateAvnSpecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateAvnSpecRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateAvnSpec(ctx context.Context, body ValidateAvnSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateAvnSpecRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBackupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBackupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBackup(ctx context.Context, body StartBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBackupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBundles(ctx context.Context, params *GetBundlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBundlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadBundleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadBundleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadBundle(ctx context.Context, body UploadBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadBundleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBundleCompatibilitySetsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBundleCompatibilitySetsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBundleCompatibilitySets(ctx context.Context, body UpdateBundleCompatibilitySetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBundleCompatibilitySetsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBundlesForSkipUpgrade(ctx context.Context, id string, params *GetBundlesForSkipUpgradeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBundlesForSkipUpgradeRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBundle(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBundleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBundle(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBundleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBundleDownloadByIDWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBundleDownloadByIDRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBundleDownloadByID(ctx context.Context, id string, body StartBundleDownloadByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBundleDownloadByIDRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertificateAuthorities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertificateAuthoritiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureCertificateAuthorityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureCertificateAuthorityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureCertificateAuthority(ctx context.Context, body ConfigureCertificateAuthorityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureCertificateAuthorityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCertificateAuthorityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCertificateAuthorityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCertificateAuthority(ctx context.Context, body CreateCertificateAuthorityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCertificateAuthorityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveCertificateAuthority(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveCertificateAuthorityRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertificateAuthorityById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertificateAuthorityByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusters(ctx context.Context, params *GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagsAssignedToClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsAssignedToClustersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateClusterCreationSpecWithBody(ctx context.Context, params *ValidateClusterCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateClusterCreationSpecRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateClusterCreationSpec(ctx context.Context, params *ValidateClusterCreationSpecParams, body ValidateClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateClusterCreationSpecRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterCreateValidation(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterCreateValidationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatastoreQueryResponse1(ctx context.Context, clusterId string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatastoreQueryResponse1Request(c.Server, clusterId, queryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateVsanRemoteDatastoreSpecWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateVsanRemoteDatastoreSpecRequestWithBody(c.Server, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateVsanRemoteDatastoreSpec(ctx context.Context, clusterId string, body ValidateVsanRemoteDatastoreSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateVsanRemoteDatastoreSpecRequest(c.Server, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateVsanRemoteDatastoreMountSpecWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateVsanRemoteDatastoreMountSpecRequestWithBody(c.Server, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateVsanRemoteDatastoreMountSpec(ctx context.Context, clusterId string, body ValidateVsanRemoteDatastoreMountSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateVsanRemoteDatastoreMountSpecRequest(c.Server, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostQueryResponse1(ctx context.Context, clusterId string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostQueryResponse1Request(c.Server, clusterId, queryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVdses(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVdsesRequest(c.Server, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportVdsToInventoryWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportVdsToInventoryRequestWithBody(c.Server, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportVdsToInventory(ctx context.Context, clusterId string, body ImportVdsToInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportVdsToInventoryRequest(c.Server, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, id string, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCluster(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterDatastores(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterDatastoresRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDatastoreToClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDatastoreToClusterRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDatastoreToCluster(ctx context.Context, id string, body AddDatastoreToClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDatastoreToClusterRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatastoresCriteria1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatastoresCriteria1Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatastoreCriterion1(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatastoreCriterion1Request(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDatastoreQuery1WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDatastoreQuery1RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDatastoreQuery1(ctx context.Context, id string, body PostDatastoreQuery1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDatastoreQuery1Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveDatastoreFromCluster(ctx context.Context, id string, datastoreId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveDatastoreFromClusterRequest(c.Server, id, datastoreId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostCriteria(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostCriteriaRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostCriterion(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostCriterionRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHostQueryWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHostQueryRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHostQuery(ctx context.Context, id string, body PostHostQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHostQueryRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterNetworkConfigurationCriteria(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterNetworkConfigurationCriteriaRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterNetworkConfigurationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterNetworkConfigurationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterNetworkConfiguration(ctx context.Context, id string, body GetClusterNetworkConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterNetworkConfigurationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterNetworkConfigurationQueryResponse(ctx context.Context, id string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterNetworkConfigurationQueryResponseRequest(c.Server, id, queryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTagsFromClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTagsFromClusterRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTagsFromCluster(ctx context.Context, id string, body RemoveTagsFromClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTagsFromClusterRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagsAssignedToCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsAssignedToClusterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignTagsToClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignTagsToClusterRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignTagsToCluster(ctx context.Context, id string, body AssignTagsToClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignTagsToClusterRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagAssignableForCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagAssignableForClusterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterTagManagerUrl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterTagManagerUrlRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateClusterUpdateSpecWithBody(ctx context.Context, id string, params *ValidateClusterUpdateSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateClusterUpdateSpecRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateClusterUpdateSpec(ctx context.Context, id string, params *ValidateClusterUpdateSpecParams, body ValidateClusterUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateClusterUpdateSpecRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterUpdateValidation(ctx context.Context, id openapi_types.UUID, validationId openapi_types.UUID, params *GetClusterUpdateValidationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterUpdateValidationRequest(c.Server, id, validationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompatibilityMatrices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompatibilityMatricesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCompatibilityMatrixWithBody(ctx context.Context, params *UpdateCompatibilityMatrixParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCompatibilityMatrixRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompatibilityMatrix(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompatibilityMatrixRequest(c.Server, compatibilityMatrixSource)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompatibilityMatrixContent(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompatibilityMatrixContentRequest(c.Server, compatibilityMatrixSource)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompatibilityMatrixMetadata(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompatibilityMatrixMetadataRequest(c.Server, compatibilityMatrixSource)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplianceAuditHistory(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplianceAuditHistoryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplianceAudit(ctx context.Context, complianceAuditId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplianceAuditRequest(c.Server, complianceAuditId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplianceAuditItems(ctx context.Context, complianceAuditId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplianceAuditItemsRequest(c.Server, complianceAuditId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplianceConfigurations(ctx context.Context, params *GetComplianceConfigurationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplianceConfigurationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplianceStandards(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplianceStandardsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReconcileConfigsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReconcileConfigsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReconcileConfigs(ctx context.Context, body ReconcileConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReconcileConfigsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReconciliationTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReconciliationTaskRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigs(ctx context.Context, params *GetConfigsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredentials(ctx context.Context, params *GetCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrRotatePasswordsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrRotatePasswordsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrRotatePasswords(ctx context.Context, body UpdateOrRotatePasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrRotatePasswordsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPasswordExpirationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPasswordExpirationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPasswordExpiration(ctx context.Context, body GetPasswordExpirationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPasswordExpirationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPasswordExpirationByTaskID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPasswordExpirationByTaskIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredentialsTasks(ctx context.Context, params *GetCredentialsTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialsTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelCredentialsTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelCredentialsTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredentialsTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialsTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryCredentialsTaskWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryCredentialsTaskRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryCredentialsTask(ctx context.Context, id string, body RetryCredentialsTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryCredentialsTaskRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredentialTaskByResourceID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialTaskByResourceIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredentialsSubTask(ctx context.Context, id string, subtaskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialsSubTaskRequest(c.Server, id, subtaskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredential(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomIsos(ctx context.Context, params *GetCustomIsosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomIsosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadCustomIsoWithBody(ctx context.Context, params *UploadCustomIsoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadCustomIsoRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomIsoById(ctx context.Context, customIsoId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomIsoByIdRequest(c.Server, customIsoId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomIsoById(ctx context.Context, customIsoId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomIsoByIdRequest(c.Server, customIsoId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameCustomIsoByIdWithBody(ctx context.Context, customIsoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameCustomIsoByIdRequestWithBody(c.Server, customIsoId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameCustomIsoById(ctx context.Context, customIsoId string, body RenameCustomIsoByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameCustomIsoByIdRequest(c.Server, customIsoId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomains(ctx context.Context, params *GetDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomain(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagsAssignedToDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsAssignedToDomainsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateDomainCreationSpecWithBody(ctx context.Context, params *ValidateDomainCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateDomainCreationSpecRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateDomainCreationSpec(ctx context.Context, params *ValidateDomainCreationSpecParams, body ValidateDomainCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateDomainCreationSpecRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DomainCreateValidation(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDomainCreateValidationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterCriteria(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterCriteriaRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterCriterion(ctx context.Context, domainId string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterCriterionRequest(c.Server, domainId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClustersQueryWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClustersQueryRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClustersQuery(ctx context.Context, domainId string, body PostClustersQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClustersQueryRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClustersQueryResponse(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClustersQueryResponseRequest(c.Server, domainId, queryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClusterQueryWithBody(ctx context.Context, domainId string, clusterName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClusterQueryRequestWithBody(c.Server, domainId, clusterName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClusterQuery(ctx context.Context, domainId string, clusterName string, body PostClusterQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClusterQueryRequest(c.Server, domainId, clusterName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterQueryResponse(ctx context.Context, domainId string, clusterName string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterQueryResponseRequest(c.Server, domainId, clusterName, queryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatastoresCriteria(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatastoresCriteriaRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatastoreCriterion(ctx context.Context, domainId string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatastoreCriterionRequest(c.Server, domainId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDatastoreQueryWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDatastoreQueryRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDatastoreQuery(ctx context.Context, domainId string, body PostDatastoreQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDatastoreQueryRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatastoreQueryResponse(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatastoreQueryResponseRequest(c.Server, domainId, queryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVsanHealthCheckByDomain(ctx context.Context, domainId string, params *GetVsanHealthCheckByDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVsanHealthCheckByDomainRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVsanHealthCheckByDomainWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVsanHealthCheckByDomainRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVsanHealthCheckByDomain(ctx context.Context, domainId string, body UpdateVsanHealthCheckByDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVsanHealthCheckByDomainRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVsanHealthCheckByQueryID(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVsanHealthCheckByQueryIDRequest(c.Server, domainId, queryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVsanHealthCheckByTaskID(ctx context.Context, domainId string, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVsanHealthCheckByTaskIDRequest(c.Server, domainId, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PerformDomainIsolationPrecheckWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPerformDomainIsolationPrecheckRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PerformDomainIsolationPrecheck(ctx context.Context, domainId string, body PerformDomainIsolationPrecheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPerformDomainIsolationPrecheckRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainIsolationPrecheckStatus(ctx context.Context, domainId string, precheckId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainIsolationPrecheckStatusRequest(c.Server, domainId, precheckId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDomainRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomainWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomain(ctx context.Context, id string, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainCertificates(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainCertificatesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCertificatesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCertificatesRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCertificates(ctx context.Context, id string, body ReplaceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCertificatesRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateCertificatesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateCertificatesRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateCertificates(ctx context.Context, id string, body GenerateCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateCertificatesRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadCertificatesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadCertificatesRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplianceAuditHistoryForADomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplianceAuditHistoryForADomainRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ComplianceAuditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewComplianceAuditRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ComplianceAudit(ctx context.Context, id string, body ComplianceAuditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewComplianceAuditRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplianceAuditTask(ctx context.Context, id string, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplianceAuditTaskRequest(c.Server, id, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryComplianceAuditTask(ctx context.Context, id string, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryComplianceAuditTaskRequest(c.Server, id, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplianceAuditForADomain(ctx context.Context, id string, complianceAuditId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplianceAuditForADomainRequest(c.Server, id, complianceAuditId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplianceAuditItemsForADomain(ctx context.Context, id string, complianceAuditId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplianceAuditItemsForADomainRequest(c.Server, id, complianceAuditId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCSRs(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCSRsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneratesCSRsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneratesCSRsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GeneratesCSRs(ctx context.Context, id string, body GeneratesCSRsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeneratesCSRsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadCSR(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadCSRRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEndpoints(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEndpointsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertificatesByDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertificatesByDomainRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceResourceCertificatesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceResourceCertificatesRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceResourceCertificates(ctx context.Context, id string, body ReplaceResourceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceResourceCertificatesRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateResourceCertificatesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateResourceCertificatesRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateResourceCertificates(ctx context.Context, id string, body ValidateResourceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateResourceCertificatesRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceCertificatesValidationByID(ctx context.Context, id string, validationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceCertificatesValidationByIDRequest(c.Server, id, validationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTagsFromDomainWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTagsFromDomainRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTagsFromDomain(ctx context.Context, id string, body RemoveTagsFromDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTagsFromDomainRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagsAssignedToDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsAssignedToDomainRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignTagsToDomainWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignTagsToDomainRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignTagsToDomain(ctx context.Context, id string, body AssignTagsToDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignTagsToDomainRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssignableTagsForDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssignableTagsForDomainRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainTagManagerUrl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainTagManagerUrlRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateDomainUpdateSpecWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateDomainUpdateSpecRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateDomainUpdateSpec(ctx context.Context, id string, body ValidateDomainUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateDomainUpdateSpecRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainUpdateValidation(ctx context.Context, id openapi_types.UUID, validationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainUpdateValidationRequest(c.Server, id, validationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeClusters(ctx context.Context, params *GetEdgeClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEdgeClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEdgeClusterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEdgeCluster(ctx context.Context, body CreateEdgeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEdgeClusterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateEdgeClusterCreationSpecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateEdgeClusterCreationSpecRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateEdgeClusterCreationSpec(ctx context.Context, body ValidateEdgeClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateEdgeClusterCreationSpecRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeClusterValidationByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeClusterValidationByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeClusterQueryCriteria(ctx context.Context, edgeClusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeClusterQueryCriteriaRequest(c.Server, edgeClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeClusterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEdgeClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEdgeClusterRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEdgeCluster(ctx context.Context, id string, body UpdateEdgeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEdgeClusterRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateEdgeClusterUpdateSpecWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateEdgeClusterUpdateSpecRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateEdgeClusterUpdateSpec(ctx context.Context, id string, body ValidateEdgeClusterUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateEdgeClusterUpdateSpecRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DecommissionHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDecommissionHostsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DecommissionHosts(ctx context.Context, body DecommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDecommissionHostsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHosts(ctx context.Context, params *GetHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommissionHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommissionHostsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommissionHosts(ctx context.Context, body CommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommissionHostsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCriteria(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCriteriaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCriterion(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCriterionRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHostsPrechecks1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHostsPrechecks1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHostsPrechecks1(ctx context.Context, body PostHostsPrechecks1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHostsPrechecks1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostsPrechecksResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostsPrechecksResponseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostQuery(ctx context.Context, body PostQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostQueryResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostQueryResponseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagsAssignedToHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsAssignedToHostsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateHostCommissionSpecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateHostCommissionSpecRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateHostCommissionSpec(ctx context.Context, body ValidateHostCommissionSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateHostCommissionSpecRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateCommissionHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateCommissionHostsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateCommissionHosts(ctx context.Context, body ValidateCommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateCommissionHostsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostCommissionValidationByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostCommissionValidationByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHost(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTagsFromHostWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTagsFromHostRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTagsFromHost(ctx context.Context, id string, body RemoveTagsFromHostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTagsFromHostRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagsAssignedToHost(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsAssignedToHostRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignTagsToHostWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignTagsToHostRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignTagsToHost(ctx context.Context, id string, body AssignTagsToHostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignTagsToHostRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssignableTagForHost(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssignableTagForHostRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostTagManagerUrl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostTagManagerUrlRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIdentityPrecheckResult(ctx context.Context, params *GetIdentityPrecheckResultParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIdentityPrecheckResultRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSddcWs1bOidcInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSddcWs1bOidcInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIdentityProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIdentityProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddExternalIdentityProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddExternalIdentityProviderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddExternalIdentityProvider(ctx context.Context, body AddExternalIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddExternalIdentityProviderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExternalIdentityProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExternalIdentityProviderRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIdentityProviderById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIdentityProviderByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExternalIdentityProviderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExternalIdentityProviderRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExternalIdentityProvider(ctx context.Context, id string, body UpdateExternalIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExternalIdentityProviderRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddEmbeddedIdentitySourceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddEmbeddedIdentitySourceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddEmbeddedIdentitySource(ctx context.Context, id string, body AddEmbeddedIdentitySourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddEmbeddedIdentitySourceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIdentitySource(ctx context.Context, id string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIdentitySourceRequest(c.Server, id, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmbeddedIdentitySourceWithBody(ctx context.Context, id string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmbeddedIdentitySourceRequestWithBody(c.Server, id, domainName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmbeddedIdentitySource(ctx context.Context, id string, domainName string, body UpdateEmbeddedIdentitySourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmbeddedIdentitySourceRequest(c.Server, id, domainName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateSyncClientToken(ctx context.Context, id string, params *GenerateSyncClientTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateSyncClientTokenRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicenseKeys(ctx context.Context, params *GetLicenseKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLicenseKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLicenseKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLicenseKey(ctx context.Context, body AddLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLicenseKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicenseProductTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseProductTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveLicenseKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveLicenseKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicenseKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLicenseKeyWithBody(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLicenseKeyRequestWithBody(c.Server, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLicenseKey(ctx context.Context, key string, body UpdateLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLicenseKeyRequest(c.Server, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicenseInformation(ctx context.Context, params *GetLicenseInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseInformationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainLicensingInfo(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainLicensingInfoRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemLicensingInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemLicensingInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetManifest(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetManifestRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveManifestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveManifestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveManifest(ctx context.Context, body SaveManifestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveManifestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkPool(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkPoolRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetworkPoolWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetworkPoolRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetworkPool(ctx context.Context, body CreateNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetworkPoolRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNetworkPool(ctx context.Context, id string, params *DeleteNetworkPoolParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNetworkPoolRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkPoolByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkPoolByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNetworkPoolWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNetworkPoolRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNetworkPool(ctx context.Context, id string, body UpdateNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNetworkPoolRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworksOfNetworkPool(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworksOfNetworkPoolRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkOfNetworkPool(ctx context.Context, id string, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkOfNetworkPoolRequest(c.Server, id, networkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIpPoolFromNetworkOfNetworkPoolWithBody(ctx context.Context, id string, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIpPoolFromNetworkOfNetworkPoolRequestWithBody(c.Server, id, networkId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIpPoolFromNetworkOfNetworkPool(ctx context.Context, id string, networkId string, body DeleteIpPoolFromNetworkOfNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIpPoolFromNetworkOfNetworkPoolRequest(c.Server, id, networkId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddIpPoolToNetworkOfNetworkPoolWithBody(ctx context.Context, id string, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddIpPoolToNetworkOfNetworkPoolRequestWithBody(c.Server, id, networkId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddIpPoolToNetworkOfNetworkPool(ctx context.Context, id string, networkId string, body AddIpPoolToNetworkOfNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddIpPoolToNetworkOfNetworkPoolRequest(c.Server, id, networkId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetALBClusters(ctx context.Context, params *GetALBClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetALBClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetALBClustersFormFactors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetALBClustersFormFactorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateALBClusterCreationSpecWithBody(ctx context.Context, params *ValidateALBClusterCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateALBClusterCreationSpecRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateALBClusterCreationSpec(ctx context.Context, params *ValidateALBClusterCreationSpecParams, body ValidateALBClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateALBClusterCreationSpecRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateNsxALBCompatibilityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateNsxALBCompatibilityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateNsxALBCompatibility(ctx context.Context, body ValidateNsxALBCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateNsxALBCompatibilityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteALBCluster(ctx context.Context, id string, params *DeleteALBClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteALBClusterRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetALBCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetALBClusterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNsxClusters(ctx context.Context, params *GetNsxClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNsxClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNsxCriteria(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNsxCriteriaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNsxCriterion(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNsxCriterionRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateIpPoolWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateIpPoolRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateIpPool(ctx context.Context, body ValidateIpPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateIpPoolRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetValidationResult(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetValidationResultRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectOpenIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectOpenIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectOpenId(ctx context.Context, body ConnectOpenIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectOpenIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartNsxCriteriaQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartNsxCriteriaQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartNsxCriteriaQuery(ctx context.Context, body StartNsxCriteriaQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartNsxCriteriaQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNsxClusterQueryResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNsxClusterQueryResponseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNsxCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNsxClusterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNsxIpAddressPools(ctx context.Context, nsxtClusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNsxIpAddressPoolsRequest(c.Server, nsxtClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNsxIpAddressPool(ctx context.Context, nsxtClusterId string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNsxIpAddressPoolRequest(c.Server, nsxtClusterId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNsxTransportZones(ctx context.Context, nsxtClusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNsxTransportZonesRequest(c.Server, nsxtClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersonality(ctx context.Context, params *DeletePersonalityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersonalityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonalities(ctx context.Context, params *GetPersonalitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonalitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPersonalityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPersonalityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPersonality(ctx context.Context, body UploadPersonalityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPersonalityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPersonalityFilesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPersonalityFilesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonality(ctx context.Context, personalityId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonalityRequest(c.Server, personalityId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenamePersonalityByIdWithBody(ctx context.Context, personalityId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenamePersonalityByIdRequestWithBody(c.Server, personalityId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenamePersonalityById(ctx context.Context, personalityId string, body RenamePersonalityByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenamePersonalityByIdRequest(c.Server, personalityId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductVersionCatalog(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductVersionCatalogRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadProductVersionCatalogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadProductVersionCatalogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadProductVersionCatalog(ctx context.Context, body UploadProductVersionCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadProductVersionCatalogRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPscs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPscsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPsc(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPscRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleases(ctx context.Context, params *GetReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleaseByDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleaseByDomainsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainReleaseViewValidation(ctx context.Context, validationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainReleaseViewValidationRequest(c.Server, validationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReleaseByDomainID(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReleaseByDomainIDRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleaseByDomain(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleaseByDomainRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateReleaseByDomainIDWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReleaseByDomainIDRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateReleaseByDomainID(ctx context.Context, domainId string, body UpdateReleaseByDomainIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReleaseByDomainIDRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomPatches(ctx context.Context, domainId string, params *GetCustomPatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomPatchesRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFutureReleases(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFutureReleasesRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateReleaseByDomainIDWithBody(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateReleaseByDomainIDRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateReleaseByDomainID(ctx context.Context, domainId string, body ValidateReleaseByDomainIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateReleaseByDomainIDRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemRelease(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemReleaseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceFunctionalities(ctx context.Context, params *GetResourceFunctionalitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceFunctionalitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourcesFunctionalitiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourcesFunctionalitiesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourcesFunctionalities(ctx context.Context, body UpdateResourcesFunctionalitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourcesFunctionalitiesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcesFunctionalitiesAllowedGlobal(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcesFunctionalitiesAllowedGlobalRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourcesFunctionalities1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourcesFunctionalities1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourcesFunctionalities1(ctx context.Context, body UpdateResourcesFunctionalities1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourcesFunctionalities1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceWarnings(ctx context.Context, params *GetResourceWarningsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceWarningsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceWarningWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceWarningRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceWarning(ctx context.Context, body CreateResourceWarningJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceWarningRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceWarning(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceWarningRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartLicenseCheckByResourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartLicenseCheckByResourceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartLicenseCheckByResource(ctx context.Context, body StartLicenseCheckByResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartLicenseCheckByResourceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicenseCheckResultByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseCheckResultByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetLicenseKeyForResourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetLicenseKeyForResourceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetLicenseKeyForResource(ctx context.Context, body SetLicenseKeyForResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetLicenseKeyForResourceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartRestoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartRestoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartRestore(ctx context.Context, body StartRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartRestoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRestoreTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRestoreTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocalOsUserAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocalOsUserAccountsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrustedCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTrustedCertificatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTrustedCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTrustedCertificateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTrustedCertificate(ctx context.Context, body AddTrustedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTrustedCertificateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTrustedCertificate(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTrustedCertificateRequest(c.Server, alias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSddcManagerUpgradables(ctx context.Context, params *GetSddcManagerUpgradablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSddcManagerUpgradablesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSddcManagers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSddcManagersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSddcManager(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSddcManagerRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSddcManagerHistory(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSddcManagerHistoryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBringupTasks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBringupTasksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBringupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBringupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBringup(ctx context.Context, body StartBringupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBringupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBringupAppInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBringupAppInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBringupValidations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBringupValidationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateBringupSpecWithBody(ctx context.Context, params *ValidateBringupSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateBringupSpecRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateBringupSpec(ctx context.Context, params *ValidateBringupSpecParams, body ValidateBringupSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateBringupSpecRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBringupValidation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBringupValidationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryBringupValidation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryBringupValidationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportBringupValidationReport(ctx context.Context, validationId string, params *ExportBringupValidationReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportBringupValidationReportRequest(c.Server, validationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBringupTaskByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBringupTaskByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrySddcWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrySddcRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrySddc(ctx context.Context, id string, body RetrySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrySddcRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportBringupDetailReport(ctx context.Context, id string, params *ExportBringupDetailReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportBringupDetailReportRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSddcManagerInfo(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSddcManagerInfoRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSSODomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSSODomainsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSSODomainEntities(ctx context.Context, ssoDomain string, params *GetSSODomainEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSSODomainEntitiesRequest(c.Server, ssoDomain, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSystemConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSystemConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSystemConfiguration(ctx context.Context, body UpdateSystemConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSystemConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBackupConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBackupConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBackupConfiguration(ctx context.Context, body UpdateBackupConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBackupConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBackupConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBackupConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBackupConfiguration(ctx context.Context, body SetBackupConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBackupConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupLocation(ctx context.Context, params *GetBackupLocationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupLocationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateBackupConfigurationsOperationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateBackupConfigurationsOperationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateBackupConfigurationsOperations(ctx context.Context, body ValidateBackupConfigurationsOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateBackupConfigurationsOperationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCeipStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCeipStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCeipStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCeipStatusRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCeipStatus(ctx context.Context, body SetCeipStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCeipStatusRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLastAssessmentRunInfo(ctx context.Context, params *GetLastAssessmentRunInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLastAssessmentRunInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerCheckRunWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerCheckRunRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerCheckRun(ctx context.Context, body TriggerCheckRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerCheckRunRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryCheckSetsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryCheckSetsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryCheckSets(ctx context.Context, body QueryCheckSetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryCheckSetsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResult(ctx context.Context, runId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResultRequest(c.Server, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerPartialRetryOfCheckRunWithBody(ctx context.Context, runId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerPartialRetryOfCheckRunRequestWithBody(c.Server, runId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerPartialRetryOfCheckRun(ctx context.Context, runId openapi_types.UUID, body TriggerPartialRetryOfCheckRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerPartialRetryOfCheckRunRequest(c.Server, runId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDnsConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDnsConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureDnsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureDnsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureDns(ctx context.Context, body ConfigureDnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureDnsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetValidationsOfDNSConfiguration(ctx context.Context, params *GetValidationsOfDNSConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetValidationsOfDNSConfigurationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateDnsConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateDnsConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateDnsConfiguration(ctx context.Context, body ValidateDnsConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateDnsConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetValidationOfDnsConfiguration(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetValidationOfDnsConfigurationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealthCheckTask(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthCheckTaskRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartHealthCheckWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartHealthCheckRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartHealthCheck(ctx context.Context, body StartHealthCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartHealthCheckRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealthCheckStatus(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthCheckStatusRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportHealthCheckByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportHealthCheckByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNtpConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNtpConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureNtpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureNtpRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureNtp(ctx context.Context, body ConfigureNtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureNtpRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetValidationsOfNtpConfiguration(ctx context.Context, params *GetValidationsOfNtpConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetValidationsOfNtpConfigurationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateNtpConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateNtpConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateNtpConfiguration(ctx context.Context, body ValidateNtpConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateNtpConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetValidationOfNtpConfiguration(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetValidationOfNtpConfigurationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartPrecheckWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartPrecheckRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartPrecheck(ctx context.Context, body StartPrecheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartPrecheckRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrecheckTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrecheckTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProxyConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProxyConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProxyConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProxyConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProxyConfiguration(ctx context.Context, body UpdateProxyConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProxyConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBringupSpecConversionWithBody(ctx context.Context, params *StartBringupSpecConversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBringupSpecConversionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFIPSConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFIPSConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDepotSettings(ctx context.Context, params *DeleteDepotSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDepotSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDepotSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDepotSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDepotSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDepotSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDepotSettings(ctx context.Context, body UpdateDepotSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDepotSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionAliasConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionAliasConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVersionAliasConfigurationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVersionAliasConfigurationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVersionAliasConfigurations(ctx context.Context, body UpdateVersionAliasConfigurationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVersionAliasConfigurationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVersionAliasBySoftwareType(ctx context.Context, bundleComponentType string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVersionAliasBySoftwareTypeRequest(c.Server, bundleComponentType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAliasVersionsBySoftwareTypeAndBaseVersionWithBody(ctx context.Context, bundleComponentType string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAliasVersionsBySoftwareTypeAndBaseVersionRequestWithBody(c.Server, bundleComponentType, version, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAliasVersionsBySoftwareTypeAndBaseVersion(ctx context.Context, bundleComponentType string, version string, body DeleteAliasVersionsBySoftwareTypeAndBaseVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAliasVersionsBySoftwareTypeAndBaseVersionRequest(c.Server, bundleComponentType, version, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVersionAliasConfigurationWithBody(ctx context.Context, bundleComponentType string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVersionAliasConfigurationRequestWithBody(c.Server, bundleComponentType, version, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVersionAliasConfiguration(ctx context.Context, bundleComponentType string, version string, body UpdateVersionAliasConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVersionAliasConfigurationRequest(c.Server, bundleComponentType, version, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSupportBundleTask(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSupportBundleTaskRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartSupportBundleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartSupportBundleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartSupportBundle(ctx context.Context, body StartSupportBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartSupportBundleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSupportBundleStatus(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSupportBundleStatusRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportSupportBundleByID(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSupportBundleByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpgradables(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUpgradablesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryTask(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshAccessToken(ctx context.Context, body RefreshAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshAccessTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvalidateRefreshTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvalidateRefreshTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvalidateRefreshToken(ctx context.Context, body InvalidateRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvalidateRefreshTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpgradablesByDomain(ctx context.Context, domainId string, params *GetUpgradablesByDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUpgradablesByDomainRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpgradablesClusters(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUpgradablesClustersRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNsxUpgradeResources(ctx context.Context, domainId string, params *GetNsxUpgradeResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNsxUpgradeResourcesRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpgrades(ctx context.Context, params *GetUpgradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUpgradesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PerformUpgradeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPerformUpgradeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PerformUpgrade(ctx context.Context, body PerformUpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPerformUpgradeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpgradeById(ctx context.Context, upgradeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUpgradeByIdRequest(c.Server, upgradeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUpgradeScheduleWithBody(ctx context.Context, upgradeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUpgradeScheduleRequestWithBody(c.Server, upgradeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUpgradeSchedule(ctx context.Context, upgradeId string, body UpdateUpgradeScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUpgradeScheduleRequest(c.Server, upgradeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartUpgradePrecheck(ctx context.Context, upgradeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartUpgradePrecheckRequest(c.Server, upgradeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpgradePrecheckByID(ctx context.Context, upgradeId string, precheckId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUpgradePrecheckByIDRequest(c.Server, upgradeId, precheckId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUsers(ctx context.Context, body AddUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableLocalAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableLocalAccountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocalAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocalAccountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLocalUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLocalUserPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLocalUserPassword(ctx context.Context, body UpdateLocalUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLocalUserPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUiUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUiUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVasaProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVasaProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVasaProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVasaProviderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVasaProvider(ctx context.Context, body AddVasaProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVasaProviderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateVasaProviderSpecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateVasaProviderSpecRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateVasaProviderSpec(ctx context.Context, body ValidateVasaProviderSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateVasaProviderSpecRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVasaProviderValidation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVasaProviderValidationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveVasaProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveVasaProviderRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVasaProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVasaProviderRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVasaProviderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVasaProviderRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVasaProvider(ctx context.Context, id string, body UpdateVasaProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVasaProviderRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVasaProviderStorageContainers(ctx context.Context, id string, params *GetVasaProviderStorageContainersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVasaProviderStorageContainersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVasaProviderStorageContainerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVasaProviderStorageContainerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVasaProviderStorageContainer(ctx context.Context, id string, body AddVasaProviderStorageContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVasaProviderStorageContainerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveVasaProviderStorageContainer(ctx context.Context, id string, storageContainerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveVasaProviderStorageContainerRequest(c.Server, id, storageContainerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVasaProviderStorageContainerWithBody(ctx context.Context, id string, storageContainerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVasaProviderStorageContainerRequestWithBody(c.Server, id, storageContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVasaProviderStorageContainer(ctx context.Context, id string, storageContainerId string, body UpdateVasaProviderStorageContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVasaProviderStorageContainerRequest(c.Server, id, storageContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVasaProviderUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVasaProviderUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVasaProviderUserWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVasaProviderUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVasaProviderUser(ctx context.Context, id string, body AddVasaProviderUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVasaProviderUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVasaProviderUserWithBody(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVasaProviderUserRequestWithBody(c.Server, id, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVasaProviderUser(ctx context.Context, id string, userId string, body UpdateVasaProviderUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVasaProviderUserRequest(c.Server, id, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVcenters(ctx context.Context, params *GetVcentersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVcentersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVcenter(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVcenterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVcfServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVcfServicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVcfService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVcfServiceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVras(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVrasRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVrliIntegratedDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVrliIntegratedDomainsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectVrliWithDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectVrliWithDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectVrliWithDomain(ctx context.Context, body ConnectVrliWithDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectVrliWithDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVrlis(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVrlisRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVropsIntegratedDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVropsIntegratedDomainsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectVropsWithDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectVropsWithDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectVropsWithDomain(ctx context.Context, body ConnectVropsWithDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectVropsWithDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVropses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVropsesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RollbackVrslcm(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRollbackVrslcmRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVrslcm(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVrslcmRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVrslcmVersionInInventoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVrslcmVersionInInventoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVrslcmVersionInInventory(ctx context.Context, body UpdateVrslcmVersionInInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVrslcmVersionInInventoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVrslcmStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVrslcmStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVrslcms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVrslcmsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeployVrslcmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeployVrslcmRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeployVrslcm(ctx context.Context, body DeployVrslcmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeployVrslcmRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateVrslcmWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateVrslcmRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateVrslcm(ctx context.Context, body ValidateVrslcmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateVrslcmRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVrslcmValidation(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVrslcmValidationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVrslcmVersionByIdInInventoryWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVrslcmVersionByIdInInventoryRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVrslcmVersionByIdInInventory(ctx context.Context, id string, body UpdateVrslcmVersionByIdInInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVrslcmVersionByIdInInventoryRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadVsanHcl(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadVsanHclRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVsanHclAttributes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVsanHclAttributesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVsanHclConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVsanHclConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVsanHclConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVsanHclConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVsanHclConfiguration(ctx context.Context, body UpdateVsanHclConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVsanHclConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWsas(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWsasRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAvnsRequest generates requests for GetAvns
func NewGetAvnsRequest(server string, params *GetAvnsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/avns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RegionType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "regionType", runtime.ParamLocationQuery, *params.RegionType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAvnsRequest calls the generic CreateAvns builder with application/json body
func NewCreateAvnsRequest(server string, body CreateAvnsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAvnsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAvnsRequestWithBody generates requests for CreateAvns with any type of body
func NewCreateAvnsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/avns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateAvnSpecRequest calls the generic ValidateAvnSpec builder with application/json body
func NewValidateAvnSpecRequest(server string, body ValidateAvnSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateAvnSpecRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateAvnSpecRequestWithBody generates requests for ValidateAvnSpec with any type of body
func NewValidateAvnSpecRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/avns/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartBackupRequest calls the generic StartBackup builder with application/json body
func NewStartBackupRequest(server string, body StartBackupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartBackupRequestWithBody(server, "application/json", bodyReader)
}

// NewStartBackupRequestWithBody generates requests for StartBackup with any type of body
func NewStartBackupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/backups/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBundlesRequest generates requests for GetBundles
func NewGetBundlesRequest(server string, params *GetBundlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProductType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productType", runtime.ParamLocationQuery, *params.ProductType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsCompliant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isCompliant", runtime.ParamLocationQuery, *params.IsCompliant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BundleType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundleType", runtime.ParamLocationQuery, *params.BundleType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadBundleRequest calls the generic UploadBundle builder with application/json body
func NewUploadBundleRequest(server string, body UploadBundleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadBundleRequestWithBody(server, "application/json", bodyReader)
}

// NewUploadBundleRequestWithBody generates requests for UploadBundle with any type of body
func NewUploadBundleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateBundleCompatibilitySetsRequest calls the generic UpdateBundleCompatibilitySets builder with application/json body
func NewUpdateBundleCompatibilitySetsRequest(server string, body UpdateBundleCompatibilitySetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBundleCompatibilitySetsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateBundleCompatibilitySetsRequestWithBody generates requests for UpdateBundleCompatibilitySets with any type of body
func NewUpdateBundleCompatibilitySetsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBundlesForSkipUpgradeRequest generates requests for GetBundlesForSkipUpgrade
func NewGetBundlesForSkipUpgradeRequest(server string, id string, params *GetBundlesForSkipUpgradeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TargetVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "targetVersion", runtime.ParamLocationQuery, *params.TargetVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBundleRequest generates requests for DeleteBundle
func NewDeleteBundleRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBundleRequest generates requests for GetBundle
func NewGetBundleRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartBundleDownloadByIDRequest calls the generic StartBundleDownloadByID builder with application/json body
func NewStartBundleDownloadByIDRequest(server string, id string, body StartBundleDownloadByIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartBundleDownloadByIDRequestWithBody(server, id, "application/json", bodyReader)
}

// NewStartBundleDownloadByIDRequestWithBody generates requests for StartBundleDownloadByID with any type of body
func NewStartBundleDownloadByIDRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bundles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCertificateAuthoritiesRequest generates requests for GetCertificateAuthorities
func NewGetCertificateAuthoritiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certificate-authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigureCertificateAuthorityRequest calls the generic ConfigureCertificateAuthority builder with application/json body
func NewConfigureCertificateAuthorityRequest(server string, body ConfigureCertificateAuthorityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfigureCertificateAuthorityRequestWithBody(server, "application/json", bodyReader)
}

// NewConfigureCertificateAuthorityRequestWithBody generates requests for ConfigureCertificateAuthority with any type of body
func NewConfigureCertificateAuthorityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certificate-authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCertificateAuthorityRequest calls the generic CreateCertificateAuthority builder with application/json body
func NewCreateCertificateAuthorityRequest(server string, body CreateCertificateAuthorityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCertificateAuthorityRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCertificateAuthorityRequestWithBody generates requests for CreateCertificateAuthority with any type of body
func NewCreateCertificateAuthorityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certificate-authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveCertificateAuthorityRequest generates requests for RemoveCertificateAuthority
func NewRemoveCertificateAuthorityRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certificate-authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCertificateAuthorityByIdRequest generates requests for GetCertificateAuthorityById
func NewGetCertificateAuthorityByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certificate-authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClustersRequest generates requests for GetClusters
func NewGetClustersRequest(server string, params *GetClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsStretched != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isStretched", runtime.ParamLocationQuery, *params.IsStretched); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsImageBased != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isImageBased", runtime.ParamLocationQuery, *params.IsImageBased); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainId", runtime.ParamLocationQuery, *params.DomainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagsAssignedToClustersRequest generates requests for GetTagsAssignedToClusters
func NewGetTagsAssignedToClustersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateClusterCreationSpecRequest calls the generic ValidateClusterCreationSpec builder with application/json body
func NewValidateClusterCreationSpecRequest(server string, params *ValidateClusterCreationSpecParams, body ValidateClusterCreationSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateClusterCreationSpecRequestWithBody(server, params, "application/json", bodyReader)
}

// NewValidateClusterCreationSpecRequestWithBody generates requests for ValidateClusterCreationSpec with any type of body
func NewValidateClusterCreationSpecRequestWithBody(server string, params *ValidateClusterCreationSpecParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.HostsOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostsOnly", runtime.ParamLocationQuery, *params.HostsOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipHostSwitchValidation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipHostSwitchValidation", runtime.ParamLocationQuery, *params.SkipHostSwitchValidation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterCreateValidationRequest generates requests for GetClusterCreateValidation
func NewGetClusterCreateValidationRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatastoreQueryResponse1Request generates requests for GetDatastoreQueryResponse1
func NewGetDatastoreQueryResponse1Request(server string, clusterId string, queryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "queryId", runtime.ParamLocationPath, queryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/datastores/queries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateVsanRemoteDatastoreSpecRequest calls the generic ValidateVsanRemoteDatastoreSpec builder with application/json body
func NewValidateVsanRemoteDatastoreSpecRequest(server string, clusterId string, body ValidateVsanRemoteDatastoreSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateVsanRemoteDatastoreSpecRequestWithBody(server, clusterId, "application/json", bodyReader)
}

// NewValidateVsanRemoteDatastoreSpecRequestWithBody generates requests for ValidateVsanRemoteDatastoreSpec with any type of body
func NewValidateVsanRemoteDatastoreSpecRequestWithBody(server string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/datastores/validation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateVsanRemoteDatastoreMountSpecRequest calls the generic ValidateVsanRemoteDatastoreMountSpec builder with application/json body
func NewValidateVsanRemoteDatastoreMountSpecRequest(server string, clusterId string, body ValidateVsanRemoteDatastoreMountSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateVsanRemoteDatastoreMountSpecRequestWithBody(server, clusterId, "application/json", bodyReader)
}

// NewValidateVsanRemoteDatastoreMountSpecRequestWithBody generates requests for ValidateVsanRemoteDatastoreMountSpec with any type of body
func NewValidateVsanRemoteDatastoreMountSpecRequestWithBody(server string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/datastores/validations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHostQueryResponse1Request generates requests for GetHostQueryResponse1
func NewGetHostQueryResponse1Request(server string, clusterId string, queryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "queryId", runtime.ParamLocationPath, queryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/hosts/queries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVdsesRequest generates requests for GetVdses
func NewGetVdsesRequest(server string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/vdses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportVdsToInventoryRequest calls the generic ImportVdsToInventory builder with application/json body
func NewImportVdsToInventoryRequest(server string, clusterId string, body ImportVdsToInventoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportVdsToInventoryRequestWithBody(server, clusterId, "application/json", bodyReader)
}

// NewImportVdsToInventoryRequestWithBody generates requests for ImportVdsToInventory with any type of body
func NewImportVdsToInventoryRequestWithBody(server string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/vdses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, id string, params *DeleteClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, id string, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterDatastoresRequest generates requests for GetClusterDatastores
func NewGetClusterDatastoresRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/datastores", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddDatastoreToClusterRequest calls the generic AddDatastoreToCluster builder with application/json body
func NewAddDatastoreToClusterRequest(server string, id string, body AddDatastoreToClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDatastoreToClusterRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddDatastoreToClusterRequestWithBody generates requests for AddDatastoreToCluster with any type of body
func NewAddDatastoreToClusterRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/datastores", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDatastoresCriteria1Request generates requests for GetDatastoresCriteria1
func NewGetDatastoresCriteria1Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/datastores/criteria", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatastoreCriterion1Request generates requests for GetDatastoreCriterion1
func NewGetDatastoreCriterion1Request(server string, id string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/datastores/criteria/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDatastoreQuery1Request calls the generic PostDatastoreQuery1 builder with application/json body
func NewPostDatastoreQuery1Request(server string, id string, body PostDatastoreQuery1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDatastoreQuery1RequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostDatastoreQuery1RequestWithBody generates requests for PostDatastoreQuery1 with any type of body
func NewPostDatastoreQuery1RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/datastores/queries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveDatastoreFromClusterRequest generates requests for RemoveDatastoreFromCluster
func NewRemoveDatastoreFromClusterRequest(server string, id string, datastoreId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "datastoreId", runtime.ParamLocationPath, datastoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/datastores/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostCriteriaRequest generates requests for GetHostCriteria
func NewGetHostCriteriaRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/hosts/criteria", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostCriterionRequest generates requests for GetHostCriterion
func NewGetHostCriterionRequest(server string, id string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/hosts/criteria/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostHostQueryRequest calls the generic PostHostQuery builder with application/json body
func NewPostHostQueryRequest(server string, id string, body PostHostQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostHostQueryRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostHostQueryRequestWithBody generates requests for PostHostQuery with any type of body
func NewPostHostQueryRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/hosts/queries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterNetworkConfigurationCriteriaRequest generates requests for GetClusterNetworkConfigurationCriteria
func NewGetClusterNetworkConfigurationCriteriaRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/network/criteria", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterNetworkConfigurationRequest calls the generic GetClusterNetworkConfiguration builder with application/json body
func NewGetClusterNetworkConfigurationRequest(server string, id string, body GetClusterNetworkConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetClusterNetworkConfigurationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewGetClusterNetworkConfigurationRequestWithBody generates requests for GetClusterNetworkConfiguration with any type of body
func NewGetClusterNetworkConfigurationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/network/queries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterNetworkConfigurationQueryResponseRequest generates requests for GetClusterNetworkConfigurationQueryResponse
func NewGetClusterNetworkConfigurationQueryResponseRequest(server string, id string, queryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "queryId", runtime.ParamLocationPath, queryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/network/queries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveTagsFromClusterRequest calls the generic RemoveTagsFromCluster builder with application/json body
func NewRemoveTagsFromClusterRequest(server string, id string, body RemoveTagsFromClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveTagsFromClusterRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRemoveTagsFromClusterRequestWithBody generates requests for RemoveTagsFromCluster with any type of body
func NewRemoveTagsFromClusterRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagsAssignedToClusterRequest generates requests for GetTagsAssignedToCluster
func NewGetTagsAssignedToClusterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignTagsToClusterRequest calls the generic AssignTagsToCluster builder with application/json body
func NewAssignTagsToClusterRequest(server string, id string, body AssignTagsToClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignTagsToClusterRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAssignTagsToClusterRequestWithBody generates requests for AssignTagsToCluster with any type of body
func NewAssignTagsToClusterRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagAssignableForClusterRequest generates requests for GetTagAssignableForCluster
func NewGetTagAssignableForClusterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/tags/assignable-tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterTagManagerUrlRequest generates requests for GetClusterTagManagerUrl
func NewGetClusterTagManagerUrlRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/tags/tag-manager", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateClusterUpdateSpecRequest calls the generic ValidateClusterUpdateSpec builder with application/json body
func NewValidateClusterUpdateSpecRequest(server string, id string, params *ValidateClusterUpdateSpecParams, body ValidateClusterUpdateSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateClusterUpdateSpecRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewValidateClusterUpdateSpecRequestWithBody generates requests for ValidateClusterUpdateSpec with any type of body
func NewValidateClusterUpdateSpecRequestWithBody(server string, id string, params *ValidateClusterUpdateSpecParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/validations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UseAsyncValidation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useAsyncValidation", runtime.ParamLocationQuery, *params.UseAsyncValidation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterUpdateValidationRequest generates requests for GetClusterUpdateValidation
func NewGetClusterUpdateValidationRequest(server string, id openapi_types.UUID, validationId openapi_types.UUID, params *GetClusterUpdateValidationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "validationId", runtime.ParamLocationPath, validationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clusters/%s/validations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UseAsyncValidation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useAsyncValidation", runtime.ParamLocationQuery, *params.UseAsyncValidation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompatibilityMatricesRequest generates requests for GetCompatibilityMatrices
func NewGetCompatibilityMatricesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/compatibility-matrices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCompatibilityMatrixRequestWithBody generates requests for UpdateCompatibilityMatrix with any type of body
func NewUpdateCompatibilityMatrixRequestWithBody(server string, params *UpdateCompatibilityMatrixParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/compatibility-matrices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "compatibilityMatrixSource", runtime.ParamLocationQuery, params.CompatibilityMatrixSource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCompatibilityMatrixRequest generates requests for GetCompatibilityMatrix
func NewGetCompatibilityMatrixRequest(server string, compatibilityMatrixSource string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "compatibilityMatrixSource", runtime.ParamLocationPath, compatibilityMatrixSource)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/compatibility-matrices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompatibilityMatrixContentRequest generates requests for GetCompatibilityMatrixContent
func NewGetCompatibilityMatrixContentRequest(server string, compatibilityMatrixSource string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "compatibilityMatrixSource", runtime.ParamLocationPath, compatibilityMatrixSource)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/compatibility-matrices/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompatibilityMatrixMetadataRequest generates requests for GetCompatibilityMatrixMetadata
func NewGetCompatibilityMatrixMetadataRequest(server string, compatibilityMatrixSource string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "compatibilityMatrixSource", runtime.ParamLocationPath, compatibilityMatrixSource)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/compatibility-matrices/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComplianceAuditHistoryRequest generates requests for GetComplianceAuditHistory
func NewGetComplianceAuditHistoryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/compliance-audits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComplianceAuditRequest generates requests for GetComplianceAudit
func NewGetComplianceAuditRequest(server string, complianceAuditId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "complianceAuditId", runtime.ParamLocationPath, complianceAuditId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/compliance-audits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComplianceAuditItemsRequest generates requests for GetComplianceAuditItems
func NewGetComplianceAuditItemsRequest(server string, complianceAuditId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "complianceAuditId", runtime.ParamLocationPath, complianceAuditId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/compliance-audits/%s/compliance-audit-items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComplianceConfigurationsRequest generates requests for GetComplianceConfigurations
func NewGetComplianceConfigurationsRequest(server string, params *GetComplianceConfigurationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/compliance-configurations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StandardType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "standardType", runtime.ParamLocationQuery, *params.StandardType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StandardVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "standardVersion", runtime.ParamLocationQuery, *params.StandardVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceType", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceVersion", runtime.ParamLocationQuery, *params.ResourceVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComplianceStandardsRequest generates requests for GetComplianceStandards
func NewGetComplianceStandardsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/compliance-standards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReconcileConfigsRequest calls the generic ReconcileConfigs builder with application/json body
func NewReconcileConfigsRequest(server string, body ReconcileConfigsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReconcileConfigsRequestWithBody(server, "application/json", bodyReader)
}

// NewReconcileConfigsRequestWithBody generates requests for ReconcileConfigs with any type of body
func NewReconcileConfigsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/config-drift-reconciliations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReconciliationTaskRequest generates requests for GetReconciliationTask
func NewGetReconciliationTaskRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/config-drift-reconciliations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigsRequest generates requests for GetConfigs
func NewGetConfigsRequest(server string, params *GetConfigsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/config-drifts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceId", runtime.ParamLocationQuery, *params.ResourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceType", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConfigId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configId", runtime.ParamLocationQuery, *params.ConfigId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DriftType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "driftType", runtime.ParamLocationQuery, *params.DriftType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCredentialsRequest generates requests for GetCredentials
func NewGetCredentialsRequest(server string, params *GetCredentialsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResourceName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceName", runtime.ParamLocationQuery, *params.ResourceName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceIp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceIp", runtime.ParamLocationQuery, *params.ResourceIp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceType", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainName", runtime.ParamLocationQuery, *params.DomainName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageNumber", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountType", runtime.ParamLocationQuery, *params.AccountType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrRotatePasswordsRequest calls the generic UpdateOrRotatePasswords builder with application/json body
func NewUpdateOrRotatePasswordsRequest(server string, body UpdateOrRotatePasswordsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrRotatePasswordsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateOrRotatePasswordsRequestWithBody generates requests for UpdateOrRotatePasswords with any type of body
func NewUpdateOrRotatePasswordsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPasswordExpirationRequest calls the generic GetPasswordExpiration builder with application/json body
func NewGetPasswordExpirationRequest(server string, body GetPasswordExpirationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPasswordExpirationRequestWithBody(server, "application/json", bodyReader)
}

// NewGetPasswordExpirationRequestWithBody generates requests for GetPasswordExpiration with any type of body
func NewGetPasswordExpirationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/credentials/expirations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPasswordExpirationByTaskIDRequest generates requests for GetPasswordExpirationByTaskID
func NewGetPasswordExpirationByTaskIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/credentials/expirations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCredentialsTasksRequest generates requests for GetCredentialsTasks
func NewGetCredentialsTasksRequest(server string, params *GetCredentialsTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/credentials/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelCredentialsTaskRequest generates requests for CancelCredentialsTask
func NewCancelCredentialsTaskRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/credentials/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCredentialsTaskRequest generates requests for GetCredentialsTask
func NewGetCredentialsTaskRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/credentials/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetryCredentialsTaskRequest calls the generic RetryCredentialsTask builder with application/json body
func NewRetryCredentialsTaskRequest(server string, id string, body RetryCredentialsTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRetryCredentialsTaskRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRetryCredentialsTaskRequestWithBody generates requests for RetryCredentialsTask with any type of body
func NewRetryCredentialsTaskRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/credentials/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCredentialTaskByResourceIDRequest generates requests for GetCredentialTaskByResourceID
func NewGetCredentialTaskByResourceIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/credentials/tasks/%s/resource-credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCredentialsSubTaskRequest generates requests for GetCredentialsSubTask
func NewGetCredentialsSubTaskRequest(server string, id string, subtaskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subtaskId", runtime.ParamLocationPath, subtaskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/credentials/tasks/%s/subtasks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCredentialRequest generates requests for GetCredential
func NewGetCredentialRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/credentials/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomIsosRequest generates requests for GetCustomIsos
func NewGetCustomIsosRequest(server string, params *GetCustomIsosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/custom-isos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Vendor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vendor", runtime.ParamLocationQuery, *params.Vendor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainId", runtime.ParamLocationQuery, *params.DomainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "targetVersion", runtime.ParamLocationQuery, *params.TargetVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadCustomIsoRequestWithBody generates requests for UploadCustomIso with any type of body
func NewUploadCustomIsoRequestWithBody(server string, params *UploadCustomIsoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/custom-isos/file")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomIsoByIdRequest generates requests for DeleteCustomIsoById
func NewDeleteCustomIsoByIdRequest(server string, customIsoId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom_iso_id", runtime.ParamLocationPath, customIsoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/custom-isos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomIsoByIdRequest generates requests for GetCustomIsoById
func NewGetCustomIsoByIdRequest(server string, customIsoId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom_iso_id", runtime.ParamLocationPath, customIsoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/custom-isos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRenameCustomIsoByIdRequest calls the generic RenameCustomIsoById builder with application/json body
func NewRenameCustomIsoByIdRequest(server string, customIsoId string, body RenameCustomIsoByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRenameCustomIsoByIdRequestWithBody(server, customIsoId, "application/json", bodyReader)
}

// NewRenameCustomIsoByIdRequestWithBody generates requests for RenameCustomIsoById with any type of body
func NewRenameCustomIsoByIdRequestWithBody(server string, customIsoId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom_iso_id", runtime.ParamLocationPath, customIsoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/custom-isos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDomainsRequest generates requests for GetDomains
func NewGetDomainsRequest(server string, params *GetDomainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDomainRequest calls the generic CreateDomain builder with application/json body
func NewCreateDomainRequest(server string, body CreateDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDomainRequestWithBody generates requests for CreateDomain with any type of body
func NewCreateDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagsAssignedToDomainsRequest generates requests for GetTagsAssignedToDomains
func NewGetTagsAssignedToDomainsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateDomainCreationSpecRequest calls the generic ValidateDomainCreationSpec builder with application/json body
func NewValidateDomainCreationSpecRequest(server string, params *ValidateDomainCreationSpecParams, body ValidateDomainCreationSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateDomainCreationSpecRequestWithBody(server, params, "application/json", bodyReader)
}

// NewValidateDomainCreationSpecRequestWithBody generates requests for ValidateDomainCreationSpec with any type of body
func NewValidateDomainCreationSpecRequestWithBody(server string, params *ValidateDomainCreationSpecParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.HostsOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostsOnly", runtime.ParamLocationQuery, *params.HostsOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipHostSwitchValidation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipHostSwitchValidation", runtime.ParamLocationQuery, *params.SkipHostSwitchValidation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDomainCreateValidationRequest generates requests for DomainCreateValidation
func NewDomainCreateValidationRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterCriteriaRequest generates requests for GetClusterCriteria
func NewGetClusterCriteriaRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/clusters/criteria", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterCriterionRequest generates requests for GetClusterCriterion
func NewGetClusterCriterionRequest(server string, domainId string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/clusters/criteria/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClustersQueryRequest calls the generic PostClustersQuery builder with application/json body
func NewPostClustersQueryRequest(server string, domainId string, body PostClustersQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClustersQueryRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPostClustersQueryRequestWithBody generates requests for PostClustersQuery with any type of body
func NewPostClustersQueryRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/clusters/queries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClustersQueryResponseRequest generates requests for GetClustersQueryResponse
func NewGetClustersQueryResponseRequest(server string, domainId string, queryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "queryId", runtime.ParamLocationPath, queryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/clusters/queries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClusterQueryRequest calls the generic PostClusterQuery builder with application/json body
func NewPostClusterQueryRequest(server string, domainId string, clusterName string, body PostClusterQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClusterQueryRequestWithBody(server, domainId, clusterName, "application/json", bodyReader)
}

// NewPostClusterQueryRequestWithBody generates requests for PostClusterQuery with any type of body
func NewPostClusterQueryRequestWithBody(server string, domainId string, clusterName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterName", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/clusters/%s/queries", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterQueryResponseRequest generates requests for GetClusterQueryResponse
func NewGetClusterQueryResponseRequest(server string, domainId string, clusterName string, queryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterName", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "queryId", runtime.ParamLocationPath, queryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/clusters/%s/queries/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatastoresCriteriaRequest generates requests for GetDatastoresCriteria
func NewGetDatastoresCriteriaRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/datastores/criteria", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatastoreCriterionRequest generates requests for GetDatastoreCriterion
func NewGetDatastoreCriterionRequest(server string, domainId string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/datastores/criteria/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDatastoreQueryRequest calls the generic PostDatastoreQuery builder with application/json body
func NewPostDatastoreQueryRequest(server string, domainId string, body PostDatastoreQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDatastoreQueryRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPostDatastoreQueryRequestWithBody generates requests for PostDatastoreQuery with any type of body
func NewPostDatastoreQueryRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/datastores/queries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDatastoreQueryResponseRequest generates requests for GetDatastoreQueryResponse
func NewGetDatastoreQueryResponseRequest(server string, domainId string, queryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "queryId", runtime.ParamLocationPath, queryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/datastores/queries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVsanHealthCheckByDomainRequest generates requests for GetVsanHealthCheckByDomain
func NewGetVsanHealthCheckByDomainRequest(server string, domainId string, params *GetVsanHealthCheckByDomainParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/health-checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVsanHealthCheckByDomainRequest calls the generic UpdateVsanHealthCheckByDomain builder with application/json body
func NewUpdateVsanHealthCheckByDomainRequest(server string, domainId string, body UpdateVsanHealthCheckByDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVsanHealthCheckByDomainRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewUpdateVsanHealthCheckByDomainRequestWithBody generates requests for UpdateVsanHealthCheckByDomain with any type of body
func NewUpdateVsanHealthCheckByDomainRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/health-checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVsanHealthCheckByQueryIDRequest generates requests for GetVsanHealthCheckByQueryID
func NewGetVsanHealthCheckByQueryIDRequest(server string, domainId string, queryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "queryId", runtime.ParamLocationPath, queryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/health-checks/queries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVsanHealthCheckByTaskIDRequest generates requests for GetVsanHealthCheckByTaskID
func NewGetVsanHealthCheckByTaskIDRequest(server string, domainId string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/health-checks/tasks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPerformDomainIsolationPrecheckRequest calls the generic PerformDomainIsolationPrecheck builder with application/json body
func NewPerformDomainIsolationPrecheckRequest(server string, domainId string, body PerformDomainIsolationPrecheckJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPerformDomainIsolationPrecheckRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewPerformDomainIsolationPrecheckRequestWithBody generates requests for PerformDomainIsolationPrecheck with any type of body
func NewPerformDomainIsolationPrecheckRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/isolation-prechecks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDomainIsolationPrecheckStatusRequest generates requests for GetDomainIsolationPrecheckStatus
func NewGetDomainIsolationPrecheckStatusRequest(server string, domainId string, precheckId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "precheckId", runtime.ParamLocationPath, precheckId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/isolation-prechecks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDomainRequest generates requests for DeleteDomain
func NewDeleteDomainRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDomainRequest generates requests for GetDomain
func NewGetDomainRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDomainRequest calls the generic UpdateDomain builder with application/json body
func NewUpdateDomainRequest(server string, id string, body UpdateDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDomainRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateDomainRequestWithBody generates requests for UpdateDomain with any type of body
func NewUpdateDomainRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDomainCertificatesRequest generates requests for GetDomainCertificates
func NewGetDomainCertificatesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/certificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceCertificatesRequest calls the generic ReplaceCertificates builder with application/json body
func NewReplaceCertificatesRequest(server string, id string, body ReplaceCertificatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceCertificatesRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReplaceCertificatesRequestWithBody generates requests for ReplaceCertificates with any type of body
func NewReplaceCertificatesRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/certificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateCertificatesRequest calls the generic GenerateCertificates builder with application/json body
func NewGenerateCertificatesRequest(server string, id string, body GenerateCertificatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateCertificatesRequestWithBody(server, id, "application/json", bodyReader)
}

// NewGenerateCertificatesRequestWithBody generates requests for GenerateCertificates with any type of body
func NewGenerateCertificatesRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/certificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadCertificatesRequestWithBody generates requests for UploadCertificates with any type of body
func NewUploadCertificatesRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/certificates/uploads", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetComplianceAuditHistoryForADomainRequest generates requests for GetComplianceAuditHistoryForADomain
func NewGetComplianceAuditHistoryForADomainRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/compliance-audits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewComplianceAuditRequest calls the generic ComplianceAudit builder with application/json body
func NewComplianceAuditRequest(server string, id string, body ComplianceAuditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewComplianceAuditRequestWithBody(server, id, "application/json", bodyReader)
}

// NewComplianceAuditRequestWithBody generates requests for ComplianceAudit with any type of body
func NewComplianceAuditRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/compliance-audits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetComplianceAuditTaskRequest generates requests for GetComplianceAuditTask
func NewGetComplianceAuditTaskRequest(server string, id string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/compliance-audits/tasks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetryComplianceAuditTaskRequest generates requests for RetryComplianceAuditTask
func NewRetryComplianceAuditTaskRequest(server string, id string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/compliance-audits/tasks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComplianceAuditForADomainRequest generates requests for GetComplianceAuditForADomain
func NewGetComplianceAuditForADomainRequest(server string, id string, complianceAuditId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "complianceAuditId", runtime.ParamLocationPath, complianceAuditId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/compliance-audits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComplianceAuditItemsForADomainRequest generates requests for GetComplianceAuditItemsForADomain
func NewGetComplianceAuditItemsForADomainRequest(server string, id string, complianceAuditId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "complianceAuditId", runtime.ParamLocationPath, complianceAuditId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/compliance-audits/%s/compliance-audit-items", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCSRsRequest generates requests for GetCSRs
func NewGetCSRsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/csrs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneratesCSRsRequest calls the generic GeneratesCSRs builder with application/json body
func NewGeneratesCSRsRequest(server string, id string, body GeneratesCSRsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGeneratesCSRsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewGeneratesCSRsRequestWithBody generates requests for GeneratesCSRs with any type of body
func NewGeneratesCSRsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/csrs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadCSRRequest generates requests for DownloadCSR
func NewDownloadCSRRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/csrs/downloads", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDomainEndpointsRequest generates requests for GetDomainEndpoints
func NewGetDomainEndpointsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCertificatesByDomainRequest generates requests for GetCertificatesByDomain
func NewGetCertificatesByDomainRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/resource-certificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceResourceCertificatesRequest calls the generic ReplaceResourceCertificates builder with application/json body
func NewReplaceResourceCertificatesRequest(server string, id string, body ReplaceResourceCertificatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceResourceCertificatesRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReplaceResourceCertificatesRequestWithBody generates requests for ReplaceResourceCertificates with any type of body
func NewReplaceResourceCertificatesRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/resource-certificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateResourceCertificatesRequest calls the generic ValidateResourceCertificates builder with application/json body
func NewValidateResourceCertificatesRequest(server string, id string, body ValidateResourceCertificatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateResourceCertificatesRequestWithBody(server, id, "application/json", bodyReader)
}

// NewValidateResourceCertificatesRequestWithBody generates requests for ValidateResourceCertificates with any type of body
func NewValidateResourceCertificatesRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/resource-certificates/validations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResourceCertificatesValidationByIDRequest generates requests for GetResourceCertificatesValidationByID
func NewGetResourceCertificatesValidationByIDRequest(server string, id string, validationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "validationId", runtime.ParamLocationPath, validationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/resource-certificates/validations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveTagsFromDomainRequest calls the generic RemoveTagsFromDomain builder with application/json body
func NewRemoveTagsFromDomainRequest(server string, id string, body RemoveTagsFromDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveTagsFromDomainRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRemoveTagsFromDomainRequestWithBody generates requests for RemoveTagsFromDomain with any type of body
func NewRemoveTagsFromDomainRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagsAssignedToDomainRequest generates requests for GetTagsAssignedToDomain
func NewGetTagsAssignedToDomainRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignTagsToDomainRequest calls the generic AssignTagsToDomain builder with application/json body
func NewAssignTagsToDomainRequest(server string, id string, body AssignTagsToDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignTagsToDomainRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAssignTagsToDomainRequestWithBody generates requests for AssignTagsToDomain with any type of body
func NewAssignTagsToDomainRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAssignableTagsForDomainRequest generates requests for GetAssignableTagsForDomain
func NewGetAssignableTagsForDomainRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/tags/assignable-tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDomainTagManagerUrlRequest generates requests for GetDomainTagManagerUrl
func NewGetDomainTagManagerUrlRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/tags/tag-manager", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateDomainUpdateSpecRequest calls the generic ValidateDomainUpdateSpec builder with application/json body
func NewValidateDomainUpdateSpecRequest(server string, id string, body ValidateDomainUpdateSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateDomainUpdateSpecRequestWithBody(server, id, "application/json", bodyReader)
}

// NewValidateDomainUpdateSpecRequestWithBody generates requests for ValidateDomainUpdateSpec with any type of body
func NewValidateDomainUpdateSpecRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/validations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDomainUpdateValidationRequest generates requests for GetDomainUpdateValidation
func NewGetDomainUpdateValidationRequest(server string, id openapi_types.UUID, validationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "validationId", runtime.ParamLocationPath, validationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/validations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeClustersRequest generates requests for GetEdgeClusters
func NewGetEdgeClustersRequest(server string, params *GetEdgeClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/edge-clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClusterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clusterId", runtime.ParamLocationQuery, *params.ClusterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEdgeClusterRequest calls the generic CreateEdgeCluster builder with application/json body
func NewCreateEdgeClusterRequest(server string, body CreateEdgeClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEdgeClusterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEdgeClusterRequestWithBody generates requests for CreateEdgeCluster with any type of body
func NewCreateEdgeClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/edge-clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateEdgeClusterCreationSpecRequest calls the generic ValidateEdgeClusterCreationSpec builder with application/json body
func NewValidateEdgeClusterCreationSpecRequest(server string, body ValidateEdgeClusterCreationSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateEdgeClusterCreationSpecRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateEdgeClusterCreationSpecRequestWithBody generates requests for ValidateEdgeClusterCreationSpec with any type of body
func NewValidateEdgeClusterCreationSpecRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/edge-clusters/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEdgeClusterValidationByIDRequest generates requests for GetEdgeClusterValidationByID
func NewGetEdgeClusterValidationByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/edge-clusters/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeClusterQueryCriteriaRequest generates requests for GetEdgeClusterQueryCriteria
func NewGetEdgeClusterQueryCriteriaRequest(server string, edgeClusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "edgeClusterId", runtime.ParamLocationPath, edgeClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/edge-clusters/%s/criteria", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeClusterRequest generates requests for GetEdgeCluster
func NewGetEdgeClusterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/edge-clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEdgeClusterRequest calls the generic UpdateEdgeCluster builder with application/json body
func NewUpdateEdgeClusterRequest(server string, id string, body UpdateEdgeClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEdgeClusterRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateEdgeClusterRequestWithBody generates requests for UpdateEdgeCluster with any type of body
func NewUpdateEdgeClusterRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/edge-clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateEdgeClusterUpdateSpecRequest calls the generic ValidateEdgeClusterUpdateSpec builder with application/json body
func NewValidateEdgeClusterUpdateSpecRequest(server string, id string, body ValidateEdgeClusterUpdateSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateEdgeClusterUpdateSpecRequestWithBody(server, id, "application/json", bodyReader)
}

// NewValidateEdgeClusterUpdateSpecRequestWithBody generates requests for ValidateEdgeClusterUpdateSpec with any type of body
func NewValidateEdgeClusterUpdateSpecRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/edge-clusters/%s/validations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDecommissionHostsRequest calls the generic DecommissionHosts builder with application/json body
func NewDecommissionHostsRequest(server string, body DecommissionHostsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDecommissionHostsRequestWithBody(server, "application/json", bodyReader)
}

// NewDecommissionHostsRequestWithBody generates requests for DecommissionHosts with any type of body
func NewDecommissionHostsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHostsRequest generates requests for GetHosts
func NewGetHostsRequest(server string, params *GetHostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainId", runtime.ParamLocationQuery, *params.DomainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClusterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clusterId", runtime.ParamLocationQuery, *params.ClusterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NetworkpoolId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "networkpoolId", runtime.ParamLocationQuery, *params.NetworkpoolId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StorageType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageType", runtime.ParamLocationQuery, *params.StorageType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DatastoreName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "datastoreName", runtime.ParamLocationQuery, *params.DatastoreName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommissionHostsRequest calls the generic CommissionHosts builder with application/json body
func NewCommissionHostsRequest(server string, body CommissionHostsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommissionHostsRequestWithBody(server, "application/json", bodyReader)
}

// NewCommissionHostsRequestWithBody generates requests for CommissionHosts with any type of body
func NewCommissionHostsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCriteriaRequest generates requests for GetCriteria
func NewGetCriteriaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/criteria")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCriterionRequest generates requests for GetCriterion
func NewGetCriterionRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/criteria/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostHostsPrechecks1Request calls the generic PostHostsPrechecks1 builder with application/json body
func NewPostHostsPrechecks1Request(server string, body PostHostsPrechecks1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostHostsPrechecks1RequestWithBody(server, "application/json", bodyReader)
}

// NewPostHostsPrechecks1RequestWithBody generates requests for PostHostsPrechecks1 with any type of body
func NewPostHostsPrechecks1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/prechecks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHostsPrechecksResponseRequest generates requests for GetHostsPrechecksResponse
func NewGetHostsPrechecksResponseRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/prechecks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostQueryRequest calls the generic PostQuery builder with application/json body
func NewPostQueryRequest(server string, body PostQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewPostQueryRequestWithBody generates requests for PostQuery with any type of body
func NewPostQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHostQueryResponseRequest generates requests for GetHostQueryResponse
func NewGetHostQueryResponseRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagsAssignedToHostsRequest generates requests for GetTagsAssignedToHosts
func NewGetTagsAssignedToHostsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateHostCommissionSpecRequest calls the generic ValidateHostCommissionSpec builder with application/json body
func NewValidateHostCommissionSpecRequest(server string, body ValidateHostCommissionSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateHostCommissionSpecRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateHostCommissionSpecRequestWithBody generates requests for ValidateHostCommissionSpec with any type of body
func NewValidateHostCommissionSpecRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateCommissionHostsRequest calls the generic ValidateCommissionHosts builder with application/json body
func NewValidateCommissionHostsRequest(server string, body ValidateCommissionHostsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateCommissionHostsRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateCommissionHostsRequestWithBody generates requests for ValidateCommissionHosts with any type of body
func NewValidateCommissionHostsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/validations/commissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHostCommissionValidationByIDRequest generates requests for GetHostCommissionValidationByID
func NewGetHostCommissionValidationByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostRequest generates requests for GetHost
func NewGetHostRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveTagsFromHostRequest calls the generic RemoveTagsFromHost builder with application/json body
func NewRemoveTagsFromHostRequest(server string, id string, body RemoveTagsFromHostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveTagsFromHostRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRemoveTagsFromHostRequestWithBody generates requests for RemoveTagsFromHost with any type of body
func NewRemoveTagsFromHostRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagsAssignedToHostRequest generates requests for GetTagsAssignedToHost
func NewGetTagsAssignedToHostRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignTagsToHostRequest calls the generic AssignTagsToHost builder with application/json body
func NewAssignTagsToHostRequest(server string, id string, body AssignTagsToHostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignTagsToHostRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAssignTagsToHostRequestWithBody generates requests for AssignTagsToHost with any type of body
func NewAssignTagsToHostRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAssignableTagForHostRequest generates requests for GetAssignableTagForHost
func NewGetAssignableTagForHostRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/%s/tags/assignable-tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostTagManagerUrlRequest generates requests for GetHostTagManagerUrl
func NewGetHostTagManagerUrlRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/%s/tags/tag-manager", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIdentityPrecheckResultRequest generates requests for GetIdentityPrecheckResult
func NewGetIdentityPrecheckResultRequest(server string, params *GetIdentityPrecheckResultParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-broker/prechecks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSddcWs1bOidcInfoRequest generates requests for GetSddcWs1bOidcInfo
func NewGetSddcWs1bOidcInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-broker/sddc-manager-oidc")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIdentityProvidersRequest generates requests for GetIdentityProviders
func NewGetIdentityProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddExternalIdentityProviderRequest calls the generic AddExternalIdentityProvider builder with application/json body
func NewAddExternalIdentityProviderRequest(server string, body AddExternalIdentityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddExternalIdentityProviderRequestWithBody(server, "application/json", bodyReader)
}

// NewAddExternalIdentityProviderRequestWithBody generates requests for AddExternalIdentityProvider with any type of body
func NewAddExternalIdentityProviderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteExternalIdentityProviderRequest generates requests for DeleteExternalIdentityProvider
func NewDeleteExternalIdentityProviderRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIdentityProviderByIdRequest generates requests for GetIdentityProviderById
func NewGetIdentityProviderByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateExternalIdentityProviderRequest calls the generic UpdateExternalIdentityProvider builder with application/json body
func NewUpdateExternalIdentityProviderRequest(server string, id string, body UpdateExternalIdentityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateExternalIdentityProviderRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateExternalIdentityProviderRequestWithBody generates requests for UpdateExternalIdentityProvider with any type of body
func NewUpdateExternalIdentityProviderRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddEmbeddedIdentitySourceRequest calls the generic AddEmbeddedIdentitySource builder with application/json body
func NewAddEmbeddedIdentitySourceRequest(server string, id string, body AddEmbeddedIdentitySourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddEmbeddedIdentitySourceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddEmbeddedIdentitySourceRequestWithBody generates requests for AddEmbeddedIdentitySource with any type of body
func NewAddEmbeddedIdentitySourceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-providers/%s/identity-sources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIdentitySourceRequest generates requests for DeleteIdentitySource
func NewDeleteIdentitySourceRequest(server string, id string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-providers/%s/identity-sources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEmbeddedIdentitySourceRequest calls the generic UpdateEmbeddedIdentitySource builder with application/json body
func NewUpdateEmbeddedIdentitySourceRequest(server string, id string, domainName string, body UpdateEmbeddedIdentitySourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEmbeddedIdentitySourceRequestWithBody(server, id, domainName, "application/json", bodyReader)
}

// NewUpdateEmbeddedIdentitySourceRequestWithBody generates requests for UpdateEmbeddedIdentitySource with any type of body
func NewUpdateEmbeddedIdentitySourceRequestWithBody(server string, id string, domainName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-providers/%s/identity-sources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateSyncClientTokenRequest generates requests for GenerateSyncClientToken
func NewGenerateSyncClientTokenRequest(server string, id string, params *GenerateSyncClientTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-providers/%s/sync-client", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SyncClientTokenTTL != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "syncClientTokenTTL", runtime.ParamLocationQuery, *params.SyncClientTokenTTL); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLicenseKeysRequest generates requests for GetLicenseKeys
func NewGetLicenseKeysRequest(server string, params *GetLicenseKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/license-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProductType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productType", runtime.ParamLocationQuery, *params.ProductType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LicenseKeyStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "licenseKeyStatus", runtime.ParamLocationQuery, *params.LicenseKeyStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LicenseUnit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "licenseUnit", runtime.ParamLocationQuery, *params.LicenseUnit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productVersion", runtime.ParamLocationQuery, *params.ProductVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddLicenseKeyRequest calls the generic AddLicenseKey builder with application/json body
func NewAddLicenseKeyRequest(server string, body AddLicenseKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddLicenseKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewAddLicenseKeyRequestWithBody generates requests for AddLicenseKey with any type of body
func NewAddLicenseKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/license-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLicenseProductTypesRequest generates requests for GetLicenseProductTypes
func NewGetLicenseProductTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/license-keys/product-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveLicenseKeyRequest generates requests for RemoveLicenseKey
func NewRemoveLicenseKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/license-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLicenseKeyRequest generates requests for GetLicenseKey
func NewGetLicenseKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/license-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLicenseKeyRequest calls the generic UpdateLicenseKey builder with application/json body
func NewUpdateLicenseKeyRequest(server string, key string, body UpdateLicenseKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLicenseKeyRequestWithBody(server, key, "application/json", bodyReader)
}

// NewUpdateLicenseKeyRequestWithBody generates requests for UpdateLicenseKey with any type of body
func NewUpdateLicenseKeyRequestWithBody(server string, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/license-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLicenseInformationRequest generates requests for GetLicenseInformation
func NewGetLicenseInformationRequest(server string, params *GetLicenseInformationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/licensing-info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceType", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceIds", runtime.ParamLocationQuery, *params.ResourceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDomainLicensingInfoRequest generates requests for GetDomainLicensingInfo
func NewGetDomainLicensingInfoRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/licensing-info/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemLicensingInfoRequest generates requests for GetSystemLicensingInfo
func NewGetSystemLicensingInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/licensing-info/system")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetManifestRequest generates requests for GetManifest
func NewGetManifestRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/manifests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveManifestRequest calls the generic SaveManifest builder with application/json body
func NewSaveManifestRequest(server string, body SaveManifestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveManifestRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveManifestRequestWithBody generates requests for SaveManifest with any type of body
func NewSaveManifestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/manifests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNetworkPoolRequest generates requests for GetNetworkPool
func NewGetNetworkPoolRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/network-pools")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNetworkPoolRequest calls the generic CreateNetworkPool builder with application/json body
func NewCreateNetworkPoolRequest(server string, body CreateNetworkPoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNetworkPoolRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNetworkPoolRequestWithBody generates requests for CreateNetworkPool with any type of body
func NewCreateNetworkPoolRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/network-pools")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNetworkPoolRequest generates requests for DeleteNetworkPool
func NewDeleteNetworkPoolRequest(server string, id string, params *DeleteNetworkPoolParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/network-pools/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkPoolByIDRequest generates requests for GetNetworkPoolByID
func NewGetNetworkPoolByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/network-pools/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNetworkPoolRequest calls the generic UpdateNetworkPool builder with application/json body
func NewUpdateNetworkPoolRequest(server string, id string, body UpdateNetworkPoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNetworkPoolRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateNetworkPoolRequestWithBody generates requests for UpdateNetworkPool with any type of body
func NewUpdateNetworkPoolRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/network-pools/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNetworksOfNetworkPoolRequest generates requests for GetNetworksOfNetworkPool
func NewGetNetworksOfNetworkPoolRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/network-pools/%s/networks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkOfNetworkPoolRequest generates requests for GetNetworkOfNetworkPool
func NewGetNetworkOfNetworkPoolRequest(server string, id string, networkId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "networkId", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/network-pools/%s/networks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteIpPoolFromNetworkOfNetworkPoolRequest calls the generic DeleteIpPoolFromNetworkOfNetworkPool builder with application/json body
func NewDeleteIpPoolFromNetworkOfNetworkPoolRequest(server string, id string, networkId string, body DeleteIpPoolFromNetworkOfNetworkPoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteIpPoolFromNetworkOfNetworkPoolRequestWithBody(server, id, networkId, "application/json", bodyReader)
}

// NewDeleteIpPoolFromNetworkOfNetworkPoolRequestWithBody generates requests for DeleteIpPoolFromNetworkOfNetworkPool with any type of body
func NewDeleteIpPoolFromNetworkOfNetworkPoolRequestWithBody(server string, id string, networkId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "networkId", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/network-pools/%s/networks/%s/ip-pools", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddIpPoolToNetworkOfNetworkPoolRequest calls the generic AddIpPoolToNetworkOfNetworkPool builder with application/json body
func NewAddIpPoolToNetworkOfNetworkPoolRequest(server string, id string, networkId string, body AddIpPoolToNetworkOfNetworkPoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddIpPoolToNetworkOfNetworkPoolRequestWithBody(server, id, networkId, "application/json", bodyReader)
}

// NewAddIpPoolToNetworkOfNetworkPoolRequestWithBody generates requests for AddIpPoolToNetworkOfNetworkPool with any type of body
func NewAddIpPoolToNetworkOfNetworkPoolRequestWithBody(server string, id string, networkId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "networkId", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/network-pools/%s/networks/%s/ip-pools", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetALBClustersRequest generates requests for GetALBClusters
func NewGetALBClustersRequest(server string, params *GetALBClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsx-alb-clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DomainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainId", runtime.ParamLocationQuery, *params.DomainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetALBClustersFormFactorsRequest generates requests for GetALBClustersFormFactors
func NewGetALBClustersFormFactorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsx-alb-clusters/form-factors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateALBClusterCreationSpecRequest calls the generic ValidateALBClusterCreationSpec builder with application/json body
func NewValidateALBClusterCreationSpecRequest(server string, params *ValidateALBClusterCreationSpecParams, body ValidateALBClusterCreationSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateALBClusterCreationSpecRequestWithBody(server, params, "application/json", bodyReader)
}

// NewValidateALBClusterCreationSpecRequestWithBody generates requests for ValidateALBClusterCreationSpec with any type of body
func NewValidateALBClusterCreationSpecRequestWithBody(server string, params *ValidateALBClusterCreationSpecParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsx-alb-clusters/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipCompatibilityCheck != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipCompatibilityCheck", runtime.ParamLocationQuery, *params.SkipCompatibilityCheck); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateNsxALBCompatibilityRequest calls the generic ValidateNsxALBCompatibility builder with application/json body
func NewValidateNsxALBCompatibilityRequest(server string, body ValidateNsxALBCompatibilityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateNsxALBCompatibilityRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateNsxALBCompatibilityRequestWithBody generates requests for ValidateNsxALBCompatibility with any type of body
func NewValidateNsxALBCompatibilityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsx-alb-clusters/validations/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteALBClusterRequest generates requests for DeleteALBCluster
func NewDeleteALBClusterRequest(server string, id string, params *DeleteALBClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsx-alb-clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "forceDelete", runtime.ParamLocationQuery, *params.ForceDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetALBClusterRequest generates requests for GetALBCluster
func NewGetALBClusterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsx-alb-clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNsxClustersRequest generates requests for GetNsxClusters
func NewGetNsxClustersRequest(server string, params *GetNsxClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsShareable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isShareable", runtime.ParamLocationQuery, *params.IsShareable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNsxCriteriaRequest generates requests for GetNsxCriteria
func NewGetNsxCriteriaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters/criteria")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNsxCriterionRequest generates requests for GetNsxCriterion
func NewGetNsxCriterionRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters/criteria/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateIpPoolRequest calls the generic ValidateIpPool builder with application/json body
func NewValidateIpPoolRequest(server string, body ValidateIpPoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateIpPoolRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateIpPoolRequestWithBody generates requests for ValidateIpPool with any type of body
func NewValidateIpPoolRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters/ip-address-pools/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetValidationResultRequest generates requests for GetValidationResult
func NewGetValidationResultRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters/ip-address-pools/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectOpenIdRequest calls the generic ConnectOpenId builder with application/json body
func NewConnectOpenIdRequest(server string, body ConnectOpenIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectOpenIdRequestWithBody(server, "application/json", bodyReader)
}

// NewConnectOpenIdRequestWithBody generates requests for ConnectOpenId with any type of body
func NewConnectOpenIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters/oidcs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartNsxCriteriaQueryRequest calls the generic StartNsxCriteriaQuery builder with application/json body
func NewStartNsxCriteriaQueryRequest(server string, body StartNsxCriteriaQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartNsxCriteriaQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewStartNsxCriteriaQueryRequestWithBody generates requests for StartNsxCriteriaQuery with any type of body
func NewStartNsxCriteriaQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters/queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNsxClusterQueryResponseRequest generates requests for GetNsxClusterQueryResponse
func NewGetNsxClusterQueryResponseRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters/queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNsxClusterRequest generates requests for GetNsxCluster
func NewGetNsxClusterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNsxIpAddressPoolsRequest generates requests for GetNsxIpAddressPools
func NewGetNsxIpAddressPoolsRequest(server string, nsxtClusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "nsxt-cluster-id", runtime.ParamLocationPath, nsxtClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters/%s/ip-address-pools", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNsxIpAddressPoolRequest generates requests for GetNsxIpAddressPool
func NewGetNsxIpAddressPoolRequest(server string, nsxtClusterId string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "nsxt-cluster-id", runtime.ParamLocationPath, nsxtClusterId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters/%s/ip-address-pools/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNsxTransportZonesRequest generates requests for GetNsxTransportZones
func NewGetNsxTransportZonesRequest(server string, nsxtClusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "nsxt-cluster-id", runtime.ParamLocationPath, nsxtClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/nsxt-clusters/%s/transport-zones", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePersonalityRequest generates requests for DeletePersonality
func NewDeletePersonalityRequest(server string, params *DeletePersonalityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/personalities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PersonalityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personalityId", runtime.ParamLocationQuery, *params.PersonalityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonalityName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personalityName", runtime.ParamLocationQuery, *params.PersonalityName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonalitiesRequest generates requests for GetPersonalities
func NewGetPersonalitiesRequest(server string, params *GetPersonalitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/personalities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BaseOSVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "baseOSVersion", runtime.ParamLocationQuery, *params.BaseOSVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddOnName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addOnName", runtime.ParamLocationQuery, *params.AddOnName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddOnVendorName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addOnVendorName", runtime.ParamLocationQuery, *params.AddOnVendorName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ComponentName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "componentName", runtime.ParamLocationQuery, *params.ComponentName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ComponentVendorName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "componentVendorName", runtime.ParamLocationQuery, *params.ComponentVendorName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonalityName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personalityName", runtime.ParamLocationQuery, *params.PersonalityName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadPersonalityRequest calls the generic UploadPersonality builder with application/json body
func NewUploadPersonalityRequest(server string, body UploadPersonalityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadPersonalityRequestWithBody(server, "application/json", bodyReader)
}

// NewUploadPersonalityRequestWithBody generates requests for UploadPersonality with any type of body
func NewUploadPersonalityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/personalities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadPersonalityFilesRequestWithBody generates requests for UploadPersonalityFiles with any type of body
func NewUploadPersonalityFilesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/personalities/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersonalityRequest generates requests for GetPersonality
func NewGetPersonalityRequest(server string, personalityId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "personalityId", runtime.ParamLocationPath, personalityId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/personalities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRenamePersonalityByIdRequest calls the generic RenamePersonalityById builder with application/json body
func NewRenamePersonalityByIdRequest(server string, personalityId string, body RenamePersonalityByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRenamePersonalityByIdRequestWithBody(server, personalityId, "application/json", bodyReader)
}

// NewRenamePersonalityByIdRequestWithBody generates requests for RenamePersonalityById with any type of body
func NewRenamePersonalityByIdRequestWithBody(server string, personalityId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "personalityId", runtime.ParamLocationPath, personalityId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/personalities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductVersionCatalogRequest generates requests for GetProductVersionCatalog
func NewGetProductVersionCatalogRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/product-version-catalog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadProductVersionCatalogRequest calls the generic UploadProductVersionCatalog builder with application/json body
func NewUploadProductVersionCatalogRequest(server string, body UploadProductVersionCatalogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadProductVersionCatalogRequestWithBody(server, "application/json", bodyReader)
}

// NewUploadProductVersionCatalogRequestWithBody generates requests for UploadProductVersionCatalog with any type of body
func NewUploadProductVersionCatalogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/product-version-catalog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPscsRequest generates requests for GetPscs
func NewGetPscsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pscs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPscRequest generates requests for GetPsc
func NewGetPscRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pscs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReleasesRequest generates requests for GetReleases
func NewGetReleasesRequest(server string, params *GetReleasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DomainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainId", runtime.ParamLocationQuery, *params.DomainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VersionEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "versionEq", runtime.ParamLocationQuery, *params.VersionEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VxRailVersionEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vxRailVersionEq", runtime.ParamLocationQuery, *params.VxRailVersionEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VersionGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "versionGt", runtime.ParamLocationQuery, *params.VersionGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VxRailVersionGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vxRailVersionGt", runtime.ParamLocationQuery, *params.VxRailVersionGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ApplicableForVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applicableForVersion", runtime.ParamLocationQuery, *params.ApplicableForVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ApplicableForVxRailVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applicableForVxRailVersion", runtime.ParamLocationQuery, *params.ApplicableForVxRailVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetFutureReleases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getFutureReleases", runtime.ParamLocationQuery, *params.GetFutureReleases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReleaseByDomainsRequest generates requests for GetReleaseByDomains
func NewGetReleaseByDomainsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDomainReleaseViewValidationRequest generates requests for GetDomainReleaseViewValidation
func NewGetDomainReleaseViewValidationRequest(server string, validationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "validationId", runtime.ParamLocationPath, validationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/domains/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteReleaseByDomainIDRequest generates requests for DeleteReleaseByDomainID
func NewDeleteReleaseByDomainIDRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReleaseByDomainRequest generates requests for GetReleaseByDomain
func NewGetReleaseByDomainRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateReleaseByDomainIDRequest calls the generic UpdateReleaseByDomainID builder with application/json body
func NewUpdateReleaseByDomainIDRequest(server string, domainId string, body UpdateReleaseByDomainIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateReleaseByDomainIDRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewUpdateReleaseByDomainIDRequestWithBody generates requests for UpdateReleaseByDomainID with any type of body
func NewUpdateReleaseByDomainIDRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomPatchesRequest generates requests for GetCustomPatches
func NewGetCustomPatchesRequest(server string, domainId string, params *GetCustomPatchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/domains/%s/custom-patches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.VcfRelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vcfRelease", runtime.ParamLocationQuery, *params.VcfRelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VxrailReleaseVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vxrailReleaseVersion", runtime.ParamLocationQuery, *params.VxrailReleaseVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productType", runtime.ParamLocationQuery, *params.ProductType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFutureReleasesRequest generates requests for GetFutureReleases
func NewGetFutureReleasesRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/domains/%s/future-releases", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateReleaseByDomainIDRequest calls the generic ValidateReleaseByDomainID builder with application/json body
func NewValidateReleaseByDomainIDRequest(server string, domainId string, body ValidateReleaseByDomainIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateReleaseByDomainIDRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewValidateReleaseByDomainIDRequestWithBody generates requests for ValidateReleaseByDomainID with any type of body
func NewValidateReleaseByDomainIDRequestWithBody(server string, domainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/domains/%s/validations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemReleaseRequest generates requests for GetSystemRelease
func NewGetSystemReleaseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/releases/system")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceFunctionalitiesRequest generates requests for GetResourceFunctionalities
func NewGetResourceFunctionalitiesRequest(server string, params *GetResourceFunctionalitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/resource-functionalities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceType", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FunctionalityType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "functionalityType", runtime.ParamLocationQuery, *params.FunctionalityType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceIds", runtime.ParamLocationQuery, *params.ResourceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsAllowed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isAllowed", runtime.ParamLocationQuery, *params.IsAllowed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentResourceType", runtime.ParamLocationQuery, *params.ParentResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateResourcesFunctionalitiesRequest calls the generic UpdateResourcesFunctionalities builder with application/json body
func NewUpdateResourcesFunctionalitiesRequest(server string, body UpdateResourcesFunctionalitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourcesFunctionalitiesRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateResourcesFunctionalitiesRequestWithBody generates requests for UpdateResourcesFunctionalities with any type of body
func NewUpdateResourcesFunctionalitiesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/resource-functionalities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResourcesFunctionalitiesAllowedGlobalRequest generates requests for GetResourcesFunctionalitiesAllowedGlobal
func NewGetResourcesFunctionalitiesAllowedGlobalRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/resource-functionalities/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateResourcesFunctionalities1Request calls the generic UpdateResourcesFunctionalities1 builder with application/json body
func NewUpdateResourcesFunctionalities1Request(server string, body UpdateResourcesFunctionalities1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourcesFunctionalities1RequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateResourcesFunctionalities1RequestWithBody generates requests for UpdateResourcesFunctionalities1 with any type of body
func NewUpdateResourcesFunctionalities1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/resource-functionalities/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResourceWarningsRequest generates requests for GetResourceWarnings
func NewGetResourceWarningsRequest(server string, params *GetResourceWarningsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/resource-warnings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceType", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceIds", runtime.ParamLocationQuery, *params.ResourceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceNames", runtime.ParamLocationQuery, *params.ResourceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateResourceWarningRequest calls the generic CreateResourceWarning builder with application/json body
func NewCreateResourceWarningRequest(server string, body CreateResourceWarningJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResourceWarningRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateResourceWarningRequestWithBody generates requests for CreateResourceWarning with any type of body
func NewCreateResourceWarningRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/resource-warnings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResourceWarningRequest generates requests for GetResourceWarning
func NewGetResourceWarningRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/resource-warnings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartLicenseCheckByResourceRequest calls the generic StartLicenseCheckByResource builder with application/json body
func NewStartLicenseCheckByResourceRequest(server string, body StartLicenseCheckByResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartLicenseCheckByResourceRequestWithBody(server, "application/json", bodyReader)
}

// NewStartLicenseCheckByResourceRequestWithBody generates requests for StartLicenseCheckByResource with any type of body
func NewStartLicenseCheckByResourceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/resources/license-checks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLicenseCheckResultByIDRequest generates requests for GetLicenseCheckResultByID
func NewGetLicenseCheckResultByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/resources/license-checks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetLicenseKeyForResourceRequest calls the generic SetLicenseKeyForResource builder with application/json body
func NewSetLicenseKeyForResourceRequest(server string, body SetLicenseKeyForResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetLicenseKeyForResourceRequestWithBody(server, "application/json", bodyReader)
}

// NewSetLicenseKeyForResourceRequestWithBody generates requests for SetLicenseKeyForResource with any type of body
func NewSetLicenseKeyForResourceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/resources/licensing-infos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartRestoreRequest calls the generic StartRestore builder with application/json body
func NewStartRestoreRequest(server string, body StartRestoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartRestoreRequestWithBody(server, "application/json", bodyReader)
}

// NewStartRestoreRequestWithBody generates requests for StartRestore with any type of body
func NewStartRestoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/restores/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRestoreTaskRequest generates requests for GetRestoreTask
func NewGetRestoreTaskRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/restores/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRolesRequest generates requests for GetRoles
func NewGetRolesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocalOsUserAccountsRequest generates requests for GetLocalOsUserAccounts
func NewGetLocalOsUserAccountsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddc-manager/local-os-user-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTrustedCertificatesRequest generates requests for GetTrustedCertificates
func NewGetTrustedCertificatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddc-manager/trusted-certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTrustedCertificateRequest calls the generic AddTrustedCertificate builder with application/json body
func NewAddTrustedCertificateRequest(server string, body AddTrustedCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTrustedCertificateRequestWithBody(server, "application/json", bodyReader)
}

// NewAddTrustedCertificateRequestWithBody generates requests for AddTrustedCertificate with any type of body
func NewAddTrustedCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddc-manager/trusted-certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTrustedCertificateRequest generates requests for DeleteTrustedCertificate
func NewDeleteTrustedCertificateRequest(server string, alias string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddc-manager/trusted-certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSddcManagerUpgradablesRequest generates requests for GetSddcManagerUpgradables
func NewGetSddcManagerUpgradablesRequest(server string, params *GetSddcManagerUpgradablesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddc-manager/upgradables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ApplicabilityStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applicabilityStatus", runtime.ParamLocationQuery, *params.ApplicabilityStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSddcManagersRequest generates requests for GetSddcManagers
func NewGetSddcManagersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddc-managers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSddcManagerRequest generates requests for GetSddcManager
func NewGetSddcManagerRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddc-managers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSddcManagerHistoryRequest generates requests for GetSddcManagerHistory
func NewGetSddcManagerHistoryRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddc-managers/%s/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBringupTasksRequest generates requests for GetBringupTasks
func NewGetBringupTasksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartBringupRequest calls the generic StartBringup builder with application/json body
func NewStartBringupRequest(server string, body StartBringupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartBringupRequestWithBody(server, "application/json", bodyReader)
}

// NewStartBringupRequestWithBody generates requests for StartBringup with any type of body
func NewStartBringupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBringupAppInfoRequest generates requests for GetBringupAppInfo
func NewGetBringupAppInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/about")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBringupValidationsRequest generates requests for GetBringupValidations
func NewGetBringupValidationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateBringupSpecRequest calls the generic ValidateBringupSpec builder with application/json body
func NewValidateBringupSpecRequest(server string, params *ValidateBringupSpecParams, body ValidateBringupSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateBringupSpecRequestWithBody(server, params, "application/json", bodyReader)
}

// NewValidateBringupSpecRequestWithBody generates requests for ValidateBringupSpec with any type of body
func NewValidateBringupSpecRequestWithBody(server string, params *ValidateBringupSpecParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Redo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redo", runtime.ParamLocationQuery, *params.Redo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBringupValidationRequest generates requests for GetBringupValidation
func NewGetBringupValidationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetryBringupValidationRequest generates requests for RetryBringupValidation
func NewRetryBringupValidationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportBringupValidationReportRequest generates requests for ExportBringupValidationReport
func NewExportBringupValidationReportRequest(server string, validationId string, params *ExportBringupValidationReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "validationId", runtime.ParamLocationPath, validationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/validations/%s/report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurClientTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "curClientTime", runtime.ParamLocationQuery, *params.CurClientTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBringupTaskByIDRequest generates requests for GetBringupTaskByID
func NewGetBringupTaskByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrySddcRequest calls the generic RetrySddc builder with application/json body
func NewRetrySddcRequest(server string, id string, body RetrySddcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRetrySddcRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRetrySddcRequestWithBody generates requests for RetrySddc with any type of body
func NewRetrySddcRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExportBringupDetailReportRequest generates requests for ExportBringupDetailReport
func NewExportBringupDetailReportRequest(server string, id string, params *ExportBringupDetailReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/%s/detail-report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSddcManagerInfoRequest generates requests for GetSddcManagerInfo
func NewGetSddcManagerInfoRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sddcs/%s/sddc-manager", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSSODomainsRequest generates requests for GetSSODomains
func NewGetSSODomainsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sso-domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSSODomainEntitiesRequest generates requests for GetSSODomainEntities
func NewGetSSODomainEntitiesRequest(server string, ssoDomain string, params *GetSSODomainEntitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sso-domain", runtime.ParamLocationPath, ssoDomain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sso-domains/%s/entities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EntityName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityName", runtime.ParamLocationQuery, *params.EntityName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemConfigurationRequest generates requests for GetSystemConfiguration
func NewGetSystemConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSystemConfigurationRequest calls the generic UpdateSystemConfiguration builder with application/json body
func NewUpdateSystemConfigurationRequest(server string, body UpdateSystemConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSystemConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateSystemConfigurationRequestWithBody generates requests for UpdateSystemConfiguration with any type of body
func NewUpdateSystemConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBackupConfigurationRequest generates requests for GetBackupConfiguration
func NewGetBackupConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/backup-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBackupConfigurationRequest calls the generic UpdateBackupConfiguration builder with application/json body
func NewUpdateBackupConfigurationRequest(server string, body UpdateBackupConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBackupConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateBackupConfigurationRequestWithBody generates requests for UpdateBackupConfiguration with any type of body
func NewUpdateBackupConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/backup-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetBackupConfigurationRequest calls the generic SetBackupConfiguration builder with application/json body
func NewSetBackupConfigurationRequest(server string, body SetBackupConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetBackupConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewSetBackupConfigurationRequestWithBody generates requests for SetBackupConfiguration with any type of body
func NewSetBackupConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/backup-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBackupLocationRequest generates requests for GetBackupLocation
func NewGetBackupLocationRequest(server string, params *GetBackupLocationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/backup-configuration/backup-locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serverIP", runtime.ParamLocationQuery, params.ServerIP); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "port", runtime.ParamLocationQuery, params.Port); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateBackupConfigurationsOperationsRequest calls the generic ValidateBackupConfigurationsOperations builder with application/json body
func NewValidateBackupConfigurationsOperationsRequest(server string, body ValidateBackupConfigurationsOperationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateBackupConfigurationsOperationsRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateBackupConfigurationsOperationsRequestWithBody generates requests for ValidateBackupConfigurationsOperations with any type of body
func NewValidateBackupConfigurationsOperationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/backup-configuration/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCeipStatusRequest generates requests for GetCeipStatus
func NewGetCeipStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/ceip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetCeipStatusRequest calls the generic SetCeipStatus builder with application/json body
func NewSetCeipStatusRequest(server string, body SetCeipStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetCeipStatusRequestWithBody(server, "application/json", bodyReader)
}

// NewSetCeipStatusRequestWithBody generates requests for SetCeipStatus with any type of body
func NewSetCeipStatusRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/ceip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLastAssessmentRunInfoRequest generates requests for GetLastAssessmentRunInfo
func NewGetLastAssessmentRunInfoRequest(server string, params *GetLastAssessmentRunInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/check-sets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DomainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainId", runtime.ParamLocationQuery, *params.DomainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerCheckRunRequest calls the generic TriggerCheckRun builder with application/json body
func NewTriggerCheckRunRequest(server string, body TriggerCheckRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTriggerCheckRunRequestWithBody(server, "application/json", bodyReader)
}

// NewTriggerCheckRunRequestWithBody generates requests for TriggerCheckRun with any type of body
func NewTriggerCheckRunRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/check-sets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryCheckSetsRequest calls the generic QueryCheckSets builder with application/json body
func NewQueryCheckSetsRequest(server string, body QueryCheckSetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryCheckSetsRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryCheckSetsRequestWithBody generates requests for QueryCheckSets with any type of body
func NewQueryCheckSetsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/check-sets/queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResultRequest generates requests for GetResult
func NewGetResultRequest(server string, runId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "runId", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/check-sets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerPartialRetryOfCheckRunRequest calls the generic TriggerPartialRetryOfCheckRun builder with application/json body
func NewTriggerPartialRetryOfCheckRunRequest(server string, runId openapi_types.UUID, body TriggerPartialRetryOfCheckRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTriggerPartialRetryOfCheckRunRequestWithBody(server, runId, "application/json", bodyReader)
}

// NewTriggerPartialRetryOfCheckRunRequestWithBody generates requests for TriggerPartialRetryOfCheckRun with any type of body
func NewTriggerPartialRetryOfCheckRunRequestWithBody(server string, runId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "runId", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/check-sets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDnsConfigurationRequest generates requests for GetDnsConfiguration
func NewGetDnsConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/dns-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigureDnsRequest calls the generic ConfigureDns builder with application/json body
func NewConfigureDnsRequest(server string, body ConfigureDnsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfigureDnsRequestWithBody(server, "application/json", bodyReader)
}

// NewConfigureDnsRequestWithBody generates requests for ConfigureDns with any type of body
func NewConfigureDnsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/dns-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetValidationsOfDNSConfigurationRequest generates requests for GetValidationsOfDNSConfiguration
func NewGetValidationsOfDNSConfigurationRequest(server string, params *GetValidationsOfDNSConfigurationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/dns-configuration/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExecutionStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "executionStatus", runtime.ParamLocationQuery, *params.ExecutionStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateDnsConfigurationRequest calls the generic ValidateDnsConfiguration builder with application/json body
func NewValidateDnsConfigurationRequest(server string, body ValidateDnsConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateDnsConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateDnsConfigurationRequestWithBody generates requests for ValidateDnsConfiguration with any type of body
func NewValidateDnsConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/dns-configuration/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetValidationOfDnsConfigurationRequest generates requests for GetValidationOfDnsConfiguration
func NewGetValidationOfDnsConfigurationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/dns-configuration/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHealthCheckTaskRequest generates requests for GetHealthCheckTask
func NewGetHealthCheckTaskRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/health-summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartHealthCheckRequest calls the generic StartHealthCheck builder with application/json body
func NewStartHealthCheckRequest(server string, body StartHealthCheckJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartHealthCheckRequestWithBody(server, "application/json", bodyReader)
}

// NewStartHealthCheckRequestWithBody generates requests for StartHealthCheck with any type of body
func NewStartHealthCheckRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/health-summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHealthCheckStatusRequest generates requests for GetHealthCheckStatus
func NewGetHealthCheckStatusRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/health-summary/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportHealthCheckByIDRequest generates requests for ExportHealthCheckByID
func NewExportHealthCheckByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/health-summary/%s/data", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNtpConfigurationRequest generates requests for GetNtpConfiguration
func NewGetNtpConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/ntp-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigureNtpRequest calls the generic ConfigureNtp builder with application/json body
func NewConfigureNtpRequest(server string, body ConfigureNtpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfigureNtpRequestWithBody(server, "application/json", bodyReader)
}

// NewConfigureNtpRequestWithBody generates requests for ConfigureNtp with any type of body
func NewConfigureNtpRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/ntp-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetValidationsOfNtpConfigurationRequest generates requests for GetValidationsOfNtpConfiguration
func NewGetValidationsOfNtpConfigurationRequest(server string, params *GetValidationsOfNtpConfigurationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/ntp-configuration/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExecutionStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "executionStatus", runtime.ParamLocationQuery, *params.ExecutionStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateNtpConfigurationRequest calls the generic ValidateNtpConfiguration builder with application/json body
func NewValidateNtpConfigurationRequest(server string, body ValidateNtpConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateNtpConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateNtpConfigurationRequestWithBody generates requests for ValidateNtpConfiguration with any type of body
func NewValidateNtpConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/ntp-configuration/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetValidationOfNtpConfigurationRequest generates requests for GetValidationOfNtpConfiguration
func NewGetValidationOfNtpConfigurationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/ntp-configuration/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartPrecheckRequest calls the generic StartPrecheck builder with application/json body
func NewStartPrecheckRequest(server string, body StartPrecheckJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartPrecheckRequestWithBody(server, "application/json", bodyReader)
}

// NewStartPrecheckRequestWithBody generates requests for StartPrecheck with any type of body
func NewStartPrecheckRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/prechecks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPrecheckTaskRequest generates requests for GetPrecheckTask
func NewGetPrecheckTaskRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/prechecks/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProxyConfigurationRequest generates requests for GetProxyConfiguration
func NewGetProxyConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/proxy-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProxyConfigurationRequest calls the generic UpdateProxyConfiguration builder with application/json body
func NewUpdateProxyConfigurationRequest(server string, body UpdateProxyConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProxyConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateProxyConfigurationRequestWithBody generates requests for UpdateProxyConfiguration with any type of body
func NewUpdateProxyConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/proxy-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartBringupSpecConversionRequestWithBody generates requests for StartBringupSpecConversion with any type of body
func NewStartBringupSpecConversionRequestWithBody(server string, params *StartBringupSpecConversionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/sddc-spec-converter")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Design != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "design", runtime.ParamLocationQuery, *params.Design); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFIPSConfigurationRequest generates requests for GetFIPSConfiguration
func NewGetFIPSConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/security/fips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDepotSettingsRequest generates requests for DeleteDepotSettings
func NewDeleteDepotSettingsRequest(server string, params *DeleteDepotSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/depot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DepotType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depotType", runtime.ParamLocationQuery, *params.DepotType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDepotSettingsRequest generates requests for GetDepotSettings
func NewGetDepotSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/depot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDepotSettingsRequest calls the generic UpdateDepotSettings builder with application/json body
func NewUpdateDepotSettingsRequest(server string, body UpdateDepotSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDepotSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateDepotSettingsRequestWithBody generates requests for UpdateDepotSettings with any type of body
func NewUpdateDepotSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/depot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVersionAliasConfigurationRequest generates requests for GetVersionAliasConfiguration
func NewGetVersionAliasConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/version-aliases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVersionAliasConfigurationsRequest calls the generic UpdateVersionAliasConfigurations builder with application/json body
func NewUpdateVersionAliasConfigurationsRequest(server string, body UpdateVersionAliasConfigurationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVersionAliasConfigurationsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateVersionAliasConfigurationsRequestWithBody generates requests for UpdateVersionAliasConfigurations with any type of body
func NewUpdateVersionAliasConfigurationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/version-aliases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVersionAliasBySoftwareTypeRequest generates requests for DeleteVersionAliasBySoftwareType
func NewDeleteVersionAliasBySoftwareTypeRequest(server string, bundleComponentType string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bundleComponentType", runtime.ParamLocationPath, bundleComponentType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/version-aliases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAliasVersionsBySoftwareTypeAndBaseVersionRequest calls the generic DeleteAliasVersionsBySoftwareTypeAndBaseVersion builder with application/json body
func NewDeleteAliasVersionsBySoftwareTypeAndBaseVersionRequest(server string, bundleComponentType string, version string, body DeleteAliasVersionsBySoftwareTypeAndBaseVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteAliasVersionsBySoftwareTypeAndBaseVersionRequestWithBody(server, bundleComponentType, version, "application/json", bodyReader)
}

// NewDeleteAliasVersionsBySoftwareTypeAndBaseVersionRequestWithBody generates requests for DeleteAliasVersionsBySoftwareTypeAndBaseVersion with any type of body
func NewDeleteAliasVersionsBySoftwareTypeAndBaseVersionRequestWithBody(server string, bundleComponentType string, version string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bundleComponentType", runtime.ParamLocationPath, bundleComponentType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/version-aliases/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateVersionAliasConfigurationRequest calls the generic UpdateVersionAliasConfiguration builder with application/json body
func NewUpdateVersionAliasConfigurationRequest(server string, bundleComponentType string, version string, body UpdateVersionAliasConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVersionAliasConfigurationRequestWithBody(server, bundleComponentType, version, "application/json", bodyReader)
}

// NewUpdateVersionAliasConfigurationRequestWithBody generates requests for UpdateVersionAliasConfiguration with any type of body
func NewUpdateVersionAliasConfigurationRequestWithBody(server string, bundleComponentType string, version string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bundleComponentType", runtime.ParamLocationPath, bundleComponentType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/settings/version-aliases/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSupportBundleTaskRequest generates requests for GetSupportBundleTask
func NewGetSupportBundleTaskRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/support-bundles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartSupportBundleRequest calls the generic StartSupportBundle builder with application/json body
func NewStartSupportBundleRequest(server string, body StartSupportBundleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartSupportBundleRequestWithBody(server, "application/json", bodyReader)
}

// NewStartSupportBundleRequestWithBody generates requests for StartSupportBundle with any type of body
func NewStartSupportBundleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/support-bundles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSupportBundleStatusRequest generates requests for GetSupportBundleStatus
func NewGetSupportBundleStatusRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/support-bundles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportSupportBundleByIDRequest generates requests for ExportSupportBundleByID
func NewExportSupportBundleByIDRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/support-bundles/%s/data", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUpgradablesRequest generates requests for GetUpgradables
func NewGetUpgradablesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/system/upgradables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTasksRequest generates requests for GetTasks
func NewGetTasksRequest(server string, params *GetTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaskStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taskStatus", runtime.ParamLocationQuery, *params.TaskStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaskType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taskType", runtime.ParamLocationQuery, *params.TaskType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceId", runtime.ParamLocationQuery, *params.ResourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceType", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completedAfter", runtime.ParamLocationQuery, *params.CompletedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageNumber", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderDirection", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaskName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taskName", runtime.ParamLocationQuery, *params.TaskName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelTaskRequest generates requests for CancelTask
func NewCancelTaskRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaskRequest generates requests for GetTask
func NewGetTaskRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetryTaskRequest generates requests for RetryTask
func NewRetryTaskRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshAccessTokenRequest calls the generic RefreshAccessToken builder with application/json body
func NewRefreshAccessTokenRequest(server string, body RefreshAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefreshAccessTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewRefreshAccessTokenRequestWithBody generates requests for RefreshAccessToken with any type of body
func NewRefreshAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tokens/access-token/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInvalidateRefreshTokenRequest calls the generic InvalidateRefreshToken builder with application/json body
func NewInvalidateRefreshTokenRequest(server string, body InvalidateRefreshTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInvalidateRefreshTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewInvalidateRefreshTokenRequestWithBody generates requests for InvalidateRefreshToken with any type of body
func NewInvalidateRefreshTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tokens/refresh-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUpgradablesByDomainRequest generates requests for GetUpgradablesByDomain
func NewGetUpgradablesByDomainRequest(server string, domainId string, params *GetUpgradablesByDomainParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/upgradables/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TargetVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "targetVersion", runtime.ParamLocationQuery, *params.TargetVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUpgradablesClustersRequest generates requests for GetUpgradablesClusters
func NewGetUpgradablesClustersRequest(server string, domainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/upgradables/domains/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNsxUpgradeResourcesRequest generates requests for GetNsxUpgradeResources
func NewGetNsxUpgradeResourcesRequest(server string, domainId string, params *GetNsxUpgradeResourcesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/upgradables/domains/%s/nsxt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BundleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundleId", runtime.ParamLocationQuery, *params.BundleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUpgradesRequest generates requests for GetUpgrades
func NewGetUpgradesRequest(server string, params *GetUpgradesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/upgrades")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BundleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundleId", runtime.ParamLocationQuery, *params.BundleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BundleType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundleType", runtime.ParamLocationQuery, *params.BundleType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPerformUpgradeRequest calls the generic PerformUpgrade builder with application/json body
func NewPerformUpgradeRequest(server string, body PerformUpgradeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPerformUpgradeRequestWithBody(server, "application/json", bodyReader)
}

// NewPerformUpgradeRequestWithBody generates requests for PerformUpgrade with any type of body
func NewPerformUpgradeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/upgrades")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUpgradeByIdRequest generates requests for GetUpgradeById
func NewGetUpgradeByIdRequest(server string, upgradeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upgradeId", runtime.ParamLocationPath, upgradeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/upgrades/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUpgradeScheduleRequest calls the generic UpdateUpgradeSchedule builder with application/json body
func NewUpdateUpgradeScheduleRequest(server string, upgradeId string, body UpdateUpgradeScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUpgradeScheduleRequestWithBody(server, upgradeId, "application/json", bodyReader)
}

// NewUpdateUpgradeScheduleRequestWithBody generates requests for UpdateUpgradeSchedule with any type of body
func NewUpdateUpgradeScheduleRequestWithBody(server string, upgradeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upgradeId", runtime.ParamLocationPath, upgradeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/upgrades/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartUpgradePrecheckRequest generates requests for StartUpgradePrecheck
func NewStartUpgradePrecheckRequest(server string, upgradeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upgradeId", runtime.ParamLocationPath, upgradeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/upgrades/%s/prechecks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUpgradePrecheckByIDRequest generates requests for GetUpgradePrecheckByID
func NewGetUpgradePrecheckByIDRequest(server string, upgradeId string, precheckId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upgradeId", runtime.ParamLocationPath, upgradeId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "precheckId", runtime.ParamLocationPath, precheckId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/upgrades/%s/prechecks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUsersRequest calls the generic AddUsers builder with application/json body
func NewAddUsersRequest(server string, body AddUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewAddUsersRequestWithBody generates requests for AddUsers with any type of body
func NewAddUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisableLocalAccountRequest generates requests for DisableLocalAccount
func NewDisableLocalAccountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/local/admin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocalAccountRequest generates requests for GetLocalAccount
func NewGetLocalAccountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/local/admin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLocalUserPasswordRequest calls the generic UpdateLocalUserPassword builder with application/json body
func NewUpdateLocalUserPasswordRequest(server string, body UpdateLocalUserPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLocalUserPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateLocalUserPasswordRequestWithBody generates requests for UpdateLocalUserPassword with any type of body
func NewUpdateLocalUserPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/local/admin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUiUsersRequest generates requests for GetUiUsers
func NewGetUiUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/ui")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveUserRequest generates requests for RemoveUser
func NewRemoveUserRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVasaProvidersRequest generates requests for GetVasaProviders
func NewGetVasaProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddVasaProviderRequest calls the generic AddVasaProvider builder with application/json body
func NewAddVasaProviderRequest(server string, body AddVasaProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVasaProviderRequestWithBody(server, "application/json", bodyReader)
}

// NewAddVasaProviderRequestWithBody generates requests for AddVasaProvider with any type of body
func NewAddVasaProviderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateVasaProviderSpecRequest calls the generic ValidateVasaProviderSpec builder with application/json body
func NewValidateVasaProviderSpecRequest(server string, body ValidateVasaProviderSpecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateVasaProviderSpecRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateVasaProviderSpecRequestWithBody generates requests for ValidateVasaProviderSpec with any type of body
func NewValidateVasaProviderSpecRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVasaProviderValidationRequest generates requests for GetVasaProviderValidation
func NewGetVasaProviderValidationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveVasaProviderRequest generates requests for RemoveVasaProvider
func NewRemoveVasaProviderRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVasaProviderRequest generates requests for GetVasaProvider
func NewGetVasaProviderRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVasaProviderRequest calls the generic UpdateVasaProvider builder with application/json body
func NewUpdateVasaProviderRequest(server string, id string, body UpdateVasaProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVasaProviderRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateVasaProviderRequestWithBody generates requests for UpdateVasaProvider with any type of body
func NewUpdateVasaProviderRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVasaProviderStorageContainersRequest generates requests for GetVasaProviderStorageContainers
func NewGetVasaProviderStorageContainersRequest(server string, id string, params *GetVasaProviderStorageContainersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/%s/storage-containers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProtocolType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "protocolType", runtime.ParamLocationQuery, *params.ProtocolType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddVasaProviderStorageContainerRequest calls the generic AddVasaProviderStorageContainer builder with application/json body
func NewAddVasaProviderStorageContainerRequest(server string, id string, body AddVasaProviderStorageContainerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVasaProviderStorageContainerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddVasaProviderStorageContainerRequestWithBody generates requests for AddVasaProviderStorageContainer with any type of body
func NewAddVasaProviderStorageContainerRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/%s/storage-containers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveVasaProviderStorageContainerRequest generates requests for RemoveVasaProviderStorageContainer
func NewRemoveVasaProviderStorageContainerRequest(server string, id string, storageContainerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "storageContainerId", runtime.ParamLocationPath, storageContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/%s/storage-containers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVasaProviderStorageContainerRequest calls the generic UpdateVasaProviderStorageContainer builder with application/json body
func NewUpdateVasaProviderStorageContainerRequest(server string, id string, storageContainerId string, body UpdateVasaProviderStorageContainerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVasaProviderStorageContainerRequestWithBody(server, id, storageContainerId, "application/json", bodyReader)
}

// NewUpdateVasaProviderStorageContainerRequestWithBody generates requests for UpdateVasaProviderStorageContainer with any type of body
func NewUpdateVasaProviderStorageContainerRequestWithBody(server string, id string, storageContainerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "storageContainerId", runtime.ParamLocationPath, storageContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/%s/storage-containers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVasaProviderUserRequest generates requests for GetVasaProviderUser
func NewGetVasaProviderUserRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddVasaProviderUserRequest calls the generic AddVasaProviderUser builder with application/json body
func NewAddVasaProviderUserRequest(server string, id string, body AddVasaProviderUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVasaProviderUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddVasaProviderUserRequestWithBody generates requests for AddVasaProviderUser with any type of body
func NewAddVasaProviderUserRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateVasaProviderUserRequest calls the generic UpdateVasaProviderUser builder with application/json body
func NewUpdateVasaProviderUserRequest(server string, id string, userId string, body UpdateVasaProviderUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVasaProviderUserRequestWithBody(server, id, userId, "application/json", bodyReader)
}

// NewUpdateVasaProviderUserRequestWithBody generates requests for UpdateVasaProviderUser with any type of body
func NewUpdateVasaProviderUserRequestWithBody(server string, id string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vasa-providers/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVcentersRequest generates requests for GetVcenters
func NewGetVcentersRequest(server string, params *GetVcentersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vcenters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DomainId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainId", runtime.ParamLocationQuery, *params.DomainId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVcenterRequest generates requests for GetVcenter
func NewGetVcenterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vcenters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVcfServicesRequest generates requests for GetVcfServices
func NewGetVcfServicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vcf-services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVcfServiceRequest generates requests for GetVcfService
func NewGetVcfServiceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vcf-services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVrasRequest generates requests for GetVras
func NewGetVrasRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vras")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVrliIntegratedDomainsRequest generates requests for GetVrliIntegratedDomains
func NewGetVrliIntegratedDomainsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrli/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectVrliWithDomainRequest calls the generic ConnectVrliWithDomain builder with application/json body
func NewConnectVrliWithDomainRequest(server string, body ConnectVrliWithDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectVrliWithDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewConnectVrliWithDomainRequestWithBody generates requests for ConnectVrliWithDomain with any type of body
func NewConnectVrliWithDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrli/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVrlisRequest generates requests for GetVrlis
func NewGetVrlisRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrlis")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVropsIntegratedDomainsRequest generates requests for GetVropsIntegratedDomains
func NewGetVropsIntegratedDomainsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrops/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectVropsWithDomainRequest calls the generic ConnectVropsWithDomain builder with application/json body
func NewConnectVropsWithDomainRequest(server string, body ConnectVropsWithDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectVropsWithDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewConnectVropsWithDomainRequestWithBody generates requests for ConnectVropsWithDomain with any type of body
func NewConnectVropsWithDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrops/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVropsesRequest generates requests for GetVropses
func NewGetVropsesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vropses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRollbackVrslcmRequest generates requests for RollbackVrslcm
func NewRollbackVrslcmRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrslcm")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVrslcmRequest generates requests for GetVrslcm
func NewGetVrslcmRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrslcm")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVrslcmVersionInInventoryRequest calls the generic UpdateVrslcmVersionInInventory builder with application/json body
func NewUpdateVrslcmVersionInInventoryRequest(server string, body UpdateVrslcmVersionInInventoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVrslcmVersionInInventoryRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateVrslcmVersionInInventoryRequestWithBody generates requests for UpdateVrslcmVersionInInventory with any type of body
func NewUpdateVrslcmVersionInInventoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrslcm")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVrslcmStatusRequest generates requests for GetVrslcmStatus
func NewGetVrslcmStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrslcm/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVrslcmsRequest generates requests for GetVrslcms
func NewGetVrslcmsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrslcms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeployVrslcmRequest calls the generic DeployVrslcm builder with application/json body
func NewDeployVrslcmRequest(server string, body DeployVrslcmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeployVrslcmRequestWithBody(server, "application/json", bodyReader)
}

// NewDeployVrslcmRequestWithBody generates requests for DeployVrslcm with any type of body
func NewDeployVrslcmRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrslcms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateVrslcmRequest calls the generic ValidateVrslcm builder with application/json body
func NewValidateVrslcmRequest(server string, body ValidateVrslcmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateVrslcmRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateVrslcmRequestWithBody generates requests for ValidateVrslcm with any type of body
func NewValidateVrslcmRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrslcms/validations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVrslcmValidationRequest generates requests for GetVrslcmValidation
func NewGetVrslcmValidationRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrslcms/validations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVrslcmVersionByIdInInventoryRequest calls the generic UpdateVrslcmVersionByIdInInventory builder with application/json body
func NewUpdateVrslcmVersionByIdInInventoryRequest(server string, id string, body UpdateVrslcmVersionByIdInInventoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVrslcmVersionByIdInInventoryRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateVrslcmVersionByIdInInventoryRequestWithBody generates requests for UpdateVrslcmVersionByIdInInventory with any type of body
func NewUpdateVrslcmVersionByIdInInventoryRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vrslcms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadVsanHclRequest generates requests for DownloadVsanHcl
func NewDownloadVsanHclRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vsan-hcl")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVsanHclAttributesRequest generates requests for GetVsanHclAttributes
func NewGetVsanHclAttributesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vsan-hcl/attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVsanHclConfigurationRequest generates requests for GetVsanHclConfiguration
func NewGetVsanHclConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vsan-hcl/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVsanHclConfigurationRequest calls the generic UpdateVsanHclConfiguration builder with application/json body
func NewUpdateVsanHclConfigurationRequest(server string, body UpdateVsanHclConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVsanHclConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateVsanHclConfigurationRequestWithBody generates requests for UpdateVsanHclConfiguration with any type of body
func NewUpdateVsanHclConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vsan-hcl/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWsasRequest generates requests for GetWsas
func NewGetWsasRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wsas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAvnsWithResponse request
	GetAvnsWithResponse(ctx context.Context, params *GetAvnsParams, reqEditors ...RequestEditorFn) (*GetAvnsResponse, error)

	// CreateAvnsWithBodyWithResponse request with any body
	CreateAvnsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAvnsResponse, error)

	CreateAvnsWithResponse(ctx context.Context, body CreateAvnsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAvnsResponse, error)

	// ValidateAvnSpecWithBodyWithResponse request with any body
	ValidateAvnSpecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateAvnSpecResponse, error)

	ValidateAvnSpecWithResponse(ctx context.Context, body ValidateAvnSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateAvnSpecResponse, error)

	// StartBackupWithBodyWithResponse request with any body
	StartBackupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBackupResponse, error)

	StartBackupWithResponse(ctx context.Context, body StartBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*StartBackupResponse, error)

	// GetBundlesWithResponse request
	GetBundlesWithResponse(ctx context.Context, params *GetBundlesParams, reqEditors ...RequestEditorFn) (*GetBundlesResponse, error)

	// UploadBundleWithBodyWithResponse request with any body
	UploadBundleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadBundleResponse, error)

	UploadBundleWithResponse(ctx context.Context, body UploadBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadBundleResponse, error)

	// UpdateBundleCompatibilitySetsWithBodyWithResponse request with any body
	UpdateBundleCompatibilitySetsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBundleCompatibilitySetsResponse, error)

	UpdateBundleCompatibilitySetsWithResponse(ctx context.Context, body UpdateBundleCompatibilitySetsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBundleCompatibilitySetsResponse, error)

	// GetBundlesForSkipUpgradeWithResponse request
	GetBundlesForSkipUpgradeWithResponse(ctx context.Context, id string, params *GetBundlesForSkipUpgradeParams, reqEditors ...RequestEditorFn) (*GetBundlesForSkipUpgradeResponse, error)

	// DeleteBundleWithResponse request
	DeleteBundleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBundleResponse, error)

	// GetBundleWithResponse request
	GetBundleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBundleResponse, error)

	// StartBundleDownloadByIDWithBodyWithResponse request with any body
	StartBundleDownloadByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBundleDownloadByIDResponse, error)

	StartBundleDownloadByIDWithResponse(ctx context.Context, id string, body StartBundleDownloadByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*StartBundleDownloadByIDResponse, error)

	// GetCertificateAuthoritiesWithResponse request
	GetCertificateAuthoritiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCertificateAuthoritiesResponse, error)

	// ConfigureCertificateAuthorityWithBodyWithResponse request with any body
	ConfigureCertificateAuthorityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureCertificateAuthorityResponse, error)

	ConfigureCertificateAuthorityWithResponse(ctx context.Context, body ConfigureCertificateAuthorityJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureCertificateAuthorityResponse, error)

	// CreateCertificateAuthorityWithBodyWithResponse request with any body
	CreateCertificateAuthorityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCertificateAuthorityResponse, error)

	CreateCertificateAuthorityWithResponse(ctx context.Context, body CreateCertificateAuthorityJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCertificateAuthorityResponse, error)

	// RemoveCertificateAuthorityWithResponse request
	RemoveCertificateAuthorityWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RemoveCertificateAuthorityResponse, error)

	// GetCertificateAuthorityByIdWithResponse request
	GetCertificateAuthorityByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCertificateAuthorityByIdResponse, error)

	// GetClustersWithResponse request
	GetClustersWithResponse(ctx context.Context, params *GetClustersParams, reqEditors ...RequestEditorFn) (*GetClustersResponse, error)

	// CreateClusterWithBodyWithResponse request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// GetTagsAssignedToClustersWithResponse request
	GetTagsAssignedToClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsAssignedToClustersResponse, error)

	// ValidateClusterCreationSpecWithBodyWithResponse request with any body
	ValidateClusterCreationSpecWithBodyWithResponse(ctx context.Context, params *ValidateClusterCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateClusterCreationSpecResponse, error)

	ValidateClusterCreationSpecWithResponse(ctx context.Context, params *ValidateClusterCreationSpecParams, body ValidateClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateClusterCreationSpecResponse, error)

	// GetClusterCreateValidationWithResponse request
	GetClusterCreateValidationWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetClusterCreateValidationResponse, error)

	// GetDatastoreQueryResponse1WithResponse request
	GetDatastoreQueryResponse1WithResponse(ctx context.Context, clusterId string, queryId string, reqEditors ...RequestEditorFn) (*GetDatastoreQueryResponse1Response, error)

	// ValidateVsanRemoteDatastoreSpecWithBodyWithResponse request with any body
	ValidateVsanRemoteDatastoreSpecWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateVsanRemoteDatastoreSpecResponse, error)

	ValidateVsanRemoteDatastoreSpecWithResponse(ctx context.Context, clusterId string, body ValidateVsanRemoteDatastoreSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateVsanRemoteDatastoreSpecResponse, error)

	// ValidateVsanRemoteDatastoreMountSpecWithBodyWithResponse request with any body
	ValidateVsanRemoteDatastoreMountSpecWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateVsanRemoteDatastoreMountSpecResponse, error)

	ValidateVsanRemoteDatastoreMountSpecWithResponse(ctx context.Context, clusterId string, body ValidateVsanRemoteDatastoreMountSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateVsanRemoteDatastoreMountSpecResponse, error)

	// GetHostQueryResponse1WithResponse request
	GetHostQueryResponse1WithResponse(ctx context.Context, clusterId string, queryId string, reqEditors ...RequestEditorFn) (*GetHostQueryResponse1Response, error)

	// GetVdsesWithResponse request
	GetVdsesWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*GetVdsesResponse, error)

	// ImportVdsToInventoryWithBodyWithResponse request with any body
	ImportVdsToInventoryWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportVdsToInventoryResponse, error)

	ImportVdsToInventoryWithResponse(ctx context.Context, clusterId string, body ImportVdsToInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportVdsToInventoryResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, id string, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateClusterWithBodyWithResponse request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// GetClusterDatastoresWithResponse request
	GetClusterDatastoresWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterDatastoresResponse, error)

	// AddDatastoreToClusterWithBodyWithResponse request with any body
	AddDatastoreToClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDatastoreToClusterResponse, error)

	AddDatastoreToClusterWithResponse(ctx context.Context, id string, body AddDatastoreToClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDatastoreToClusterResponse, error)

	// GetDatastoresCriteria1WithResponse request
	GetDatastoresCriteria1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDatastoresCriteria1Response, error)

	// GetDatastoreCriterion1WithResponse request
	GetDatastoreCriterion1WithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*GetDatastoreCriterion1Response, error)

	// PostDatastoreQuery1WithBodyWithResponse request with any body
	PostDatastoreQuery1WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDatastoreQuery1Response, error)

	PostDatastoreQuery1WithResponse(ctx context.Context, id string, body PostDatastoreQuery1JSONRequestBody, reqEditors ...RequestEditorFn) (*PostDatastoreQuery1Response, error)

	// RemoveDatastoreFromClusterWithResponse request
	RemoveDatastoreFromClusterWithResponse(ctx context.Context, id string, datastoreId string, reqEditors ...RequestEditorFn) (*RemoveDatastoreFromClusterResponse, error)

	// GetHostCriteriaWithResponse request
	GetHostCriteriaWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostCriteriaResponse, error)

	// GetHostCriterionWithResponse request
	GetHostCriterionWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*GetHostCriterionResponse, error)

	// PostHostQueryWithBodyWithResponse request with any body
	PostHostQueryWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHostQueryResponse, error)

	PostHostQueryWithResponse(ctx context.Context, id string, body PostHostQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostHostQueryResponse, error)

	// GetClusterNetworkConfigurationCriteriaWithResponse request
	GetClusterNetworkConfigurationCriteriaWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterNetworkConfigurationCriteriaResponse, error)

	// GetClusterNetworkConfigurationWithBodyWithResponse request with any body
	GetClusterNetworkConfigurationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetClusterNetworkConfigurationResponse, error)

	GetClusterNetworkConfigurationWithResponse(ctx context.Context, id string, body GetClusterNetworkConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*GetClusterNetworkConfigurationResponse, error)

	// GetClusterNetworkConfigurationQueryResponseWithResponse request
	GetClusterNetworkConfigurationQueryResponseWithResponse(ctx context.Context, id string, queryId string, reqEditors ...RequestEditorFn) (*GetClusterNetworkConfigurationQueryResponseResponse, error)

	// RemoveTagsFromClusterWithBodyWithResponse request with any body
	RemoveTagsFromClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTagsFromClusterResponse, error)

	RemoveTagsFromClusterWithResponse(ctx context.Context, id string, body RemoveTagsFromClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTagsFromClusterResponse, error)

	// GetTagsAssignedToClusterWithResponse request
	GetTagsAssignedToClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTagsAssignedToClusterResponse, error)

	// AssignTagsToClusterWithBodyWithResponse request with any body
	AssignTagsToClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignTagsToClusterResponse, error)

	AssignTagsToClusterWithResponse(ctx context.Context, id string, body AssignTagsToClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignTagsToClusterResponse, error)

	// GetTagAssignableForClusterWithResponse request
	GetTagAssignableForClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTagAssignableForClusterResponse, error)

	// GetClusterTagManagerUrlWithResponse request
	GetClusterTagManagerUrlWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterTagManagerUrlResponse, error)

	// ValidateClusterUpdateSpecWithBodyWithResponse request with any body
	ValidateClusterUpdateSpecWithBodyWithResponse(ctx context.Context, id string, params *ValidateClusterUpdateSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateClusterUpdateSpecResponse, error)

	ValidateClusterUpdateSpecWithResponse(ctx context.Context, id string, params *ValidateClusterUpdateSpecParams, body ValidateClusterUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateClusterUpdateSpecResponse, error)

	// GetClusterUpdateValidationWithResponse request
	GetClusterUpdateValidationWithResponse(ctx context.Context, id openapi_types.UUID, validationId openapi_types.UUID, params *GetClusterUpdateValidationParams, reqEditors ...RequestEditorFn) (*GetClusterUpdateValidationResponse, error)

	// GetCompatibilityMatricesWithResponse request
	GetCompatibilityMatricesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompatibilityMatricesResponse, error)

	// UpdateCompatibilityMatrixWithBodyWithResponse request with any body
	UpdateCompatibilityMatrixWithBodyWithResponse(ctx context.Context, params *UpdateCompatibilityMatrixParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCompatibilityMatrixResponse, error)

	// GetCompatibilityMatrixWithResponse request
	GetCompatibilityMatrixWithResponse(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*GetCompatibilityMatrixResponse, error)

	// GetCompatibilityMatrixContentWithResponse request
	GetCompatibilityMatrixContentWithResponse(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*GetCompatibilityMatrixContentResponse, error)

	// GetCompatibilityMatrixMetadataWithResponse request
	GetCompatibilityMatrixMetadataWithResponse(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*GetCompatibilityMatrixMetadataResponse, error)

	// GetComplianceAuditHistoryWithResponse request
	GetComplianceAuditHistoryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetComplianceAuditHistoryResponse, error)

	// GetComplianceAuditWithResponse request
	GetComplianceAuditWithResponse(ctx context.Context, complianceAuditId string, reqEditors ...RequestEditorFn) (*GetComplianceAuditResponse, error)

	// GetComplianceAuditItemsWithResponse request
	GetComplianceAuditItemsWithResponse(ctx context.Context, complianceAuditId string, reqEditors ...RequestEditorFn) (*GetComplianceAuditItemsResponse, error)

	// GetComplianceConfigurationsWithResponse request
	GetComplianceConfigurationsWithResponse(ctx context.Context, params *GetComplianceConfigurationsParams, reqEditors ...RequestEditorFn) (*GetComplianceConfigurationsResponse, error)

	// GetComplianceStandardsWithResponse request
	GetComplianceStandardsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetComplianceStandardsResponse, error)

	// ReconcileConfigsWithBodyWithResponse request with any body
	ReconcileConfigsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReconcileConfigsResponse, error)

	ReconcileConfigsWithResponse(ctx context.Context, body ReconcileConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReconcileConfigsResponse, error)

	// GetReconciliationTaskWithResponse request
	GetReconciliationTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetReconciliationTaskResponse, error)

	// GetConfigsWithResponse request
	GetConfigsWithResponse(ctx context.Context, params *GetConfigsParams, reqEditors ...RequestEditorFn) (*GetConfigsResponse, error)

	// GetCredentialsWithResponse request
	GetCredentialsWithResponse(ctx context.Context, params *GetCredentialsParams, reqEditors ...RequestEditorFn) (*GetCredentialsResponse, error)

	// UpdateOrRotatePasswordsWithBodyWithResponse request with any body
	UpdateOrRotatePasswordsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrRotatePasswordsResponse, error)

	UpdateOrRotatePasswordsWithResponse(ctx context.Context, body UpdateOrRotatePasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrRotatePasswordsResponse, error)

	// GetPasswordExpirationWithBodyWithResponse request with any body
	GetPasswordExpirationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPasswordExpirationResponse, error)

	GetPasswordExpirationWithResponse(ctx context.Context, body GetPasswordExpirationJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPasswordExpirationResponse, error)

	// GetPasswordExpirationByTaskIDWithResponse request
	GetPasswordExpirationByTaskIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPasswordExpirationByTaskIDResponse, error)

	// GetCredentialsTasksWithResponse request
	GetCredentialsTasksWithResponse(ctx context.Context, params *GetCredentialsTasksParams, reqEditors ...RequestEditorFn) (*GetCredentialsTasksResponse, error)

	// CancelCredentialsTaskWithResponse request
	CancelCredentialsTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CancelCredentialsTaskResponse, error)

	// GetCredentialsTaskWithResponse request
	GetCredentialsTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCredentialsTaskResponse, error)

	// RetryCredentialsTaskWithBodyWithResponse request with any body
	RetryCredentialsTaskWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RetryCredentialsTaskResponse, error)

	RetryCredentialsTaskWithResponse(ctx context.Context, id string, body RetryCredentialsTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*RetryCredentialsTaskResponse, error)

	// GetCredentialTaskByResourceIDWithResponse request
	GetCredentialTaskByResourceIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCredentialTaskByResourceIDResponse, error)

	// GetCredentialsSubTaskWithResponse request
	GetCredentialsSubTaskWithResponse(ctx context.Context, id string, subtaskId string, reqEditors ...RequestEditorFn) (*GetCredentialsSubTaskResponse, error)

	// GetCredentialWithResponse request
	GetCredentialWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCredentialResponse, error)

	// GetCustomIsosWithResponse request
	GetCustomIsosWithResponse(ctx context.Context, params *GetCustomIsosParams, reqEditors ...RequestEditorFn) (*GetCustomIsosResponse, error)

	// UploadCustomIsoWithBodyWithResponse request with any body
	UploadCustomIsoWithBodyWithResponse(ctx context.Context, params *UploadCustomIsoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCustomIsoResponse, error)

	// DeleteCustomIsoByIdWithResponse request
	DeleteCustomIsoByIdWithResponse(ctx context.Context, customIsoId string, reqEditors ...RequestEditorFn) (*DeleteCustomIsoByIdResponse, error)

	// GetCustomIsoByIdWithResponse request
	GetCustomIsoByIdWithResponse(ctx context.Context, customIsoId string, reqEditors ...RequestEditorFn) (*GetCustomIsoByIdResponse, error)

	// RenameCustomIsoByIdWithBodyWithResponse request with any body
	RenameCustomIsoByIdWithBodyWithResponse(ctx context.Context, customIsoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameCustomIsoByIdResponse, error)

	RenameCustomIsoByIdWithResponse(ctx context.Context, customIsoId string, body RenameCustomIsoByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameCustomIsoByIdResponse, error)

	// GetDomainsWithResponse request
	GetDomainsWithResponse(ctx context.Context, params *GetDomainsParams, reqEditors ...RequestEditorFn) (*GetDomainsResponse, error)

	// CreateDomainWithBodyWithResponse request with any body
	CreateDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error)

	CreateDomainWithResponse(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error)

	// GetTagsAssignedToDomainsWithResponse request
	GetTagsAssignedToDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsAssignedToDomainsResponse, error)

	// ValidateDomainCreationSpecWithBodyWithResponse request with any body
	ValidateDomainCreationSpecWithBodyWithResponse(ctx context.Context, params *ValidateDomainCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateDomainCreationSpecResponse, error)

	ValidateDomainCreationSpecWithResponse(ctx context.Context, params *ValidateDomainCreationSpecParams, body ValidateDomainCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateDomainCreationSpecResponse, error)

	// DomainCreateValidationWithResponse request
	DomainCreateValidationWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DomainCreateValidationResponse, error)

	// GetClusterCriteriaWithResponse request
	GetClusterCriteriaWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetClusterCriteriaResponse, error)

	// GetClusterCriterionWithResponse request
	GetClusterCriterionWithResponse(ctx context.Context, domainId string, name string, reqEditors ...RequestEditorFn) (*GetClusterCriterionResponse, error)

	// PostClustersQueryWithBodyWithResponse request with any body
	PostClustersQueryWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClustersQueryResponse, error)

	PostClustersQueryWithResponse(ctx context.Context, domainId string, body PostClustersQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClustersQueryResponse, error)

	// GetClustersQueryResponseWithResponse request
	GetClustersQueryResponseWithResponse(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*GetClustersQueryResponseResponse, error)

	// PostClusterQueryWithBodyWithResponse request with any body
	PostClusterQueryWithBodyWithResponse(ctx context.Context, domainId string, clusterName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClusterQueryResponse, error)

	PostClusterQueryWithResponse(ctx context.Context, domainId string, clusterName string, body PostClusterQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClusterQueryResponse, error)

	// GetClusterQueryResponseWithResponse request
	GetClusterQueryResponseWithResponse(ctx context.Context, domainId string, clusterName string, queryId string, reqEditors ...RequestEditorFn) (*GetClusterQueryResponseResponse, error)

	// GetDatastoresCriteriaWithResponse request
	GetDatastoresCriteriaWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetDatastoresCriteriaResponse, error)

	// GetDatastoreCriterionWithResponse request
	GetDatastoreCriterionWithResponse(ctx context.Context, domainId string, name string, reqEditors ...RequestEditorFn) (*GetDatastoreCriterionResponse, error)

	// PostDatastoreQueryWithBodyWithResponse request with any body
	PostDatastoreQueryWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDatastoreQueryResponse, error)

	PostDatastoreQueryWithResponse(ctx context.Context, domainId string, body PostDatastoreQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDatastoreQueryResponse, error)

	// GetDatastoreQueryResponseWithResponse request
	GetDatastoreQueryResponseWithResponse(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*GetDatastoreQueryResponseResponse, error)

	// GetVsanHealthCheckByDomainWithResponse request
	GetVsanHealthCheckByDomainWithResponse(ctx context.Context, domainId string, params *GetVsanHealthCheckByDomainParams, reqEditors ...RequestEditorFn) (*GetVsanHealthCheckByDomainResponse, error)

	// UpdateVsanHealthCheckByDomainWithBodyWithResponse request with any body
	UpdateVsanHealthCheckByDomainWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVsanHealthCheckByDomainResponse, error)

	UpdateVsanHealthCheckByDomainWithResponse(ctx context.Context, domainId string, body UpdateVsanHealthCheckByDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVsanHealthCheckByDomainResponse, error)

	// GetVsanHealthCheckByQueryIDWithResponse request
	GetVsanHealthCheckByQueryIDWithResponse(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*GetVsanHealthCheckByQueryIDResponse, error)

	// GetVsanHealthCheckByTaskIDWithResponse request
	GetVsanHealthCheckByTaskIDWithResponse(ctx context.Context, domainId string, taskId string, reqEditors ...RequestEditorFn) (*GetVsanHealthCheckByTaskIDResponse, error)

	// PerformDomainIsolationPrecheckWithBodyWithResponse request with any body
	PerformDomainIsolationPrecheckWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PerformDomainIsolationPrecheckResponse, error)

	PerformDomainIsolationPrecheckWithResponse(ctx context.Context, domainId string, body PerformDomainIsolationPrecheckJSONRequestBody, reqEditors ...RequestEditorFn) (*PerformDomainIsolationPrecheckResponse, error)

	// GetDomainIsolationPrecheckStatusWithResponse request
	GetDomainIsolationPrecheckStatusWithResponse(ctx context.Context, domainId string, precheckId string, reqEditors ...RequestEditorFn) (*GetDomainIsolationPrecheckStatusResponse, error)

	// DeleteDomainWithResponse request
	DeleteDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDomainResponse, error)

	// GetDomainWithResponse request
	GetDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDomainResponse, error)

	// UpdateDomainWithBodyWithResponse request with any body
	UpdateDomainWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error)

	UpdateDomainWithResponse(ctx context.Context, id string, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error)

	// GetDomainCertificatesWithResponse request
	GetDomainCertificatesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDomainCertificatesResponse, error)

	// ReplaceCertificatesWithBodyWithResponse request with any body
	ReplaceCertificatesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCertificatesResponse, error)

	ReplaceCertificatesWithResponse(ctx context.Context, id string, body ReplaceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCertificatesResponse, error)

	// GenerateCertificatesWithBodyWithResponse request with any body
	GenerateCertificatesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateCertificatesResponse, error)

	GenerateCertificatesWithResponse(ctx context.Context, id string, body GenerateCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateCertificatesResponse, error)

	// UploadCertificatesWithBodyWithResponse request with any body
	UploadCertificatesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCertificatesResponse, error)

	// GetComplianceAuditHistoryForADomainWithResponse request
	GetComplianceAuditHistoryForADomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetComplianceAuditHistoryForADomainResponse, error)

	// ComplianceAuditWithBodyWithResponse request with any body
	ComplianceAuditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ComplianceAuditResponse, error)

	ComplianceAuditWithResponse(ctx context.Context, id string, body ComplianceAuditJSONRequestBody, reqEditors ...RequestEditorFn) (*ComplianceAuditResponse, error)

	// GetComplianceAuditTaskWithResponse request
	GetComplianceAuditTaskWithResponse(ctx context.Context, id string, taskId string, reqEditors ...RequestEditorFn) (*GetComplianceAuditTaskResponse, error)

	// RetryComplianceAuditTaskWithResponse request
	RetryComplianceAuditTaskWithResponse(ctx context.Context, id string, taskId string, reqEditors ...RequestEditorFn) (*RetryComplianceAuditTaskResponse, error)

	// GetComplianceAuditForADomainWithResponse request
	GetComplianceAuditForADomainWithResponse(ctx context.Context, id string, complianceAuditId string, reqEditors ...RequestEditorFn) (*GetComplianceAuditForADomainResponse, error)

	// GetComplianceAuditItemsForADomainWithResponse request
	GetComplianceAuditItemsForADomainWithResponse(ctx context.Context, id string, complianceAuditId string, reqEditors ...RequestEditorFn) (*GetComplianceAuditItemsForADomainResponse, error)

	// GetCSRsWithResponse request
	GetCSRsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCSRsResponse, error)

	// GeneratesCSRsWithBodyWithResponse request with any body
	GeneratesCSRsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneratesCSRsResponse, error)

	GeneratesCSRsWithResponse(ctx context.Context, id string, body GeneratesCSRsJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneratesCSRsResponse, error)

	// DownloadCSRWithResponse request
	DownloadCSRWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DownloadCSRResponse, error)

	// GetDomainEndpointsWithResponse request
	GetDomainEndpointsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDomainEndpointsResponse, error)

	// GetCertificatesByDomainWithResponse request
	GetCertificatesByDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCertificatesByDomainResponse, error)

	// ReplaceResourceCertificatesWithBodyWithResponse request with any body
	ReplaceResourceCertificatesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceResourceCertificatesResponse, error)

	ReplaceResourceCertificatesWithResponse(ctx context.Context, id string, body ReplaceResourceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceResourceCertificatesResponse, error)

	// ValidateResourceCertificatesWithBodyWithResponse request with any body
	ValidateResourceCertificatesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateResourceCertificatesResponse, error)

	ValidateResourceCertificatesWithResponse(ctx context.Context, id string, body ValidateResourceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateResourceCertificatesResponse, error)

	// GetResourceCertificatesValidationByIDWithResponse request
	GetResourceCertificatesValidationByIDWithResponse(ctx context.Context, id string, validationId string, reqEditors ...RequestEditorFn) (*GetResourceCertificatesValidationByIDResponse, error)

	// RemoveTagsFromDomainWithBodyWithResponse request with any body
	RemoveTagsFromDomainWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTagsFromDomainResponse, error)

	RemoveTagsFromDomainWithResponse(ctx context.Context, id string, body RemoveTagsFromDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTagsFromDomainResponse, error)

	// GetTagsAssignedToDomainWithResponse request
	GetTagsAssignedToDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTagsAssignedToDomainResponse, error)

	// AssignTagsToDomainWithBodyWithResponse request with any body
	AssignTagsToDomainWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignTagsToDomainResponse, error)

	AssignTagsToDomainWithResponse(ctx context.Context, id string, body AssignTagsToDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignTagsToDomainResponse, error)

	// GetAssignableTagsForDomainWithResponse request
	GetAssignableTagsForDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAssignableTagsForDomainResponse, error)

	// GetDomainTagManagerUrlWithResponse request
	GetDomainTagManagerUrlWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDomainTagManagerUrlResponse, error)

	// ValidateDomainUpdateSpecWithBodyWithResponse request with any body
	ValidateDomainUpdateSpecWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateDomainUpdateSpecResponse, error)

	ValidateDomainUpdateSpecWithResponse(ctx context.Context, id string, body ValidateDomainUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateDomainUpdateSpecResponse, error)

	// GetDomainUpdateValidationWithResponse request
	GetDomainUpdateValidationWithResponse(ctx context.Context, id openapi_types.UUID, validationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDomainUpdateValidationResponse, error)

	// GetEdgeClustersWithResponse request
	GetEdgeClustersWithResponse(ctx context.Context, params *GetEdgeClustersParams, reqEditors ...RequestEditorFn) (*GetEdgeClustersResponse, error)

	// CreateEdgeClusterWithBodyWithResponse request with any body
	CreateEdgeClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEdgeClusterResponse, error)

	CreateEdgeClusterWithResponse(ctx context.Context, body CreateEdgeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEdgeClusterResponse, error)

	// ValidateEdgeClusterCreationSpecWithBodyWithResponse request with any body
	ValidateEdgeClusterCreationSpecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateEdgeClusterCreationSpecResponse, error)

	ValidateEdgeClusterCreationSpecWithResponse(ctx context.Context, body ValidateEdgeClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateEdgeClusterCreationSpecResponse, error)

	// GetEdgeClusterValidationByIDWithResponse request
	GetEdgeClusterValidationByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEdgeClusterValidationByIDResponse, error)

	// GetEdgeClusterQueryCriteriaWithResponse request
	GetEdgeClusterQueryCriteriaWithResponse(ctx context.Context, edgeClusterId string, reqEditors ...RequestEditorFn) (*GetEdgeClusterQueryCriteriaResponse, error)

	// GetEdgeClusterWithResponse request
	GetEdgeClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEdgeClusterResponse, error)

	// UpdateEdgeClusterWithBodyWithResponse request with any body
	UpdateEdgeClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEdgeClusterResponse, error)

	UpdateEdgeClusterWithResponse(ctx context.Context, id string, body UpdateEdgeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEdgeClusterResponse, error)

	// ValidateEdgeClusterUpdateSpecWithBodyWithResponse request with any body
	ValidateEdgeClusterUpdateSpecWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateEdgeClusterUpdateSpecResponse, error)

	ValidateEdgeClusterUpdateSpecWithResponse(ctx context.Context, id string, body ValidateEdgeClusterUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateEdgeClusterUpdateSpecResponse, error)

	// DecommissionHostsWithBodyWithResponse request with any body
	DecommissionHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DecommissionHostsResponse, error)

	DecommissionHostsWithResponse(ctx context.Context, body DecommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*DecommissionHostsResponse, error)

	// GetHostsWithResponse request
	GetHostsWithResponse(ctx context.Context, params *GetHostsParams, reqEditors ...RequestEditorFn) (*GetHostsResponse, error)

	// CommissionHostsWithBodyWithResponse request with any body
	CommissionHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommissionHostsResponse, error)

	CommissionHostsWithResponse(ctx context.Context, body CommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*CommissionHostsResponse, error)

	// GetCriteriaWithResponse request
	GetCriteriaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCriteriaResponse, error)

	// GetCriterionWithResponse request
	GetCriterionWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetCriterionResponse, error)

	// PostHostsPrechecks1WithBodyWithResponse request with any body
	PostHostsPrechecks1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHostsPrechecks1Response, error)

	PostHostsPrechecks1WithResponse(ctx context.Context, body PostHostsPrechecks1JSONRequestBody, reqEditors ...RequestEditorFn) (*PostHostsPrechecks1Response, error)

	// GetHostsPrechecksResponseWithResponse request
	GetHostsPrechecksResponseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostsPrechecksResponseResponse, error)

	// PostQueryWithBodyWithResponse request with any body
	PostQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostQueryResponse, error)

	PostQueryWithResponse(ctx context.Context, body PostQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostQueryResponse, error)

	// GetHostQueryResponseWithResponse request
	GetHostQueryResponseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostQueryResponseResponse, error)

	// GetTagsAssignedToHostsWithResponse request
	GetTagsAssignedToHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsAssignedToHostsResponse, error)

	// ValidateHostCommissionSpecWithBodyWithResponse request with any body
	ValidateHostCommissionSpecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateHostCommissionSpecResponse, error)

	ValidateHostCommissionSpecWithResponse(ctx context.Context, body ValidateHostCommissionSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateHostCommissionSpecResponse, error)

	// ValidateCommissionHostsWithBodyWithResponse request with any body
	ValidateCommissionHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateCommissionHostsResponse, error)

	ValidateCommissionHostsWithResponse(ctx context.Context, body ValidateCommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateCommissionHostsResponse, error)

	// GetHostCommissionValidationByIDWithResponse request
	GetHostCommissionValidationByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostCommissionValidationByIDResponse, error)

	// GetHostWithResponse request
	GetHostWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostResponse, error)

	// RemoveTagsFromHostWithBodyWithResponse request with any body
	RemoveTagsFromHostWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTagsFromHostResponse, error)

	RemoveTagsFromHostWithResponse(ctx context.Context, id string, body RemoveTagsFromHostJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTagsFromHostResponse, error)

	// GetTagsAssignedToHostWithResponse request
	GetTagsAssignedToHostWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTagsAssignedToHostResponse, error)

	// AssignTagsToHostWithBodyWithResponse request with any body
	AssignTagsToHostWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignTagsToHostResponse, error)

	AssignTagsToHostWithResponse(ctx context.Context, id string, body AssignTagsToHostJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignTagsToHostResponse, error)

	// GetAssignableTagForHostWithResponse request
	GetAssignableTagForHostWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAssignableTagForHostResponse, error)

	// GetHostTagManagerUrlWithResponse request
	GetHostTagManagerUrlWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostTagManagerUrlResponse, error)

	// GetIdentityPrecheckResultWithResponse request
	GetIdentityPrecheckResultWithResponse(ctx context.Context, params *GetIdentityPrecheckResultParams, reqEditors ...RequestEditorFn) (*GetIdentityPrecheckResultResponse, error)

	// GetSddcWs1bOidcInfoWithResponse request
	GetSddcWs1bOidcInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSddcWs1bOidcInfoResponse, error)

	// GetIdentityProvidersWithResponse request
	GetIdentityProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetIdentityProvidersResponse, error)

	// AddExternalIdentityProviderWithBodyWithResponse request with any body
	AddExternalIdentityProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddExternalIdentityProviderResponse, error)

	AddExternalIdentityProviderWithResponse(ctx context.Context, body AddExternalIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddExternalIdentityProviderResponse, error)

	// DeleteExternalIdentityProviderWithResponse request
	DeleteExternalIdentityProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteExternalIdentityProviderResponse, error)

	// GetIdentityProviderByIdWithResponse request
	GetIdentityProviderByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetIdentityProviderByIdResponse, error)

	// UpdateExternalIdentityProviderWithBodyWithResponse request with any body
	UpdateExternalIdentityProviderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExternalIdentityProviderResponse, error)

	UpdateExternalIdentityProviderWithResponse(ctx context.Context, id string, body UpdateExternalIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExternalIdentityProviderResponse, error)

	// AddEmbeddedIdentitySourceWithBodyWithResponse request with any body
	AddEmbeddedIdentitySourceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddEmbeddedIdentitySourceResponse, error)

	AddEmbeddedIdentitySourceWithResponse(ctx context.Context, id string, body AddEmbeddedIdentitySourceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddEmbeddedIdentitySourceResponse, error)

	// DeleteIdentitySourceWithResponse request
	DeleteIdentitySourceWithResponse(ctx context.Context, id string, domainName string, reqEditors ...RequestEditorFn) (*DeleteIdentitySourceResponse, error)

	// UpdateEmbeddedIdentitySourceWithBodyWithResponse request with any body
	UpdateEmbeddedIdentitySourceWithBodyWithResponse(ctx context.Context, id string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmbeddedIdentitySourceResponse, error)

	UpdateEmbeddedIdentitySourceWithResponse(ctx context.Context, id string, domainName string, body UpdateEmbeddedIdentitySourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmbeddedIdentitySourceResponse, error)

	// GenerateSyncClientTokenWithResponse request
	GenerateSyncClientTokenWithResponse(ctx context.Context, id string, params *GenerateSyncClientTokenParams, reqEditors ...RequestEditorFn) (*GenerateSyncClientTokenResponse, error)

	// GetLicenseKeysWithResponse request
	GetLicenseKeysWithResponse(ctx context.Context, params *GetLicenseKeysParams, reqEditors ...RequestEditorFn) (*GetLicenseKeysResponse, error)

	// AddLicenseKeyWithBodyWithResponse request with any body
	AddLicenseKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLicenseKeyResponse, error)

	AddLicenseKeyWithResponse(ctx context.Context, body AddLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLicenseKeyResponse, error)

	// GetLicenseProductTypesWithResponse request
	GetLicenseProductTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseProductTypesResponse, error)

	// RemoveLicenseKeyWithResponse request
	RemoveLicenseKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*RemoveLicenseKeyResponse, error)

	// GetLicenseKeyWithResponse request
	GetLicenseKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetLicenseKeyResponse, error)

	// UpdateLicenseKeyWithBodyWithResponse request with any body
	UpdateLicenseKeyWithBodyWithResponse(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLicenseKeyResponse, error)

	UpdateLicenseKeyWithResponse(ctx context.Context, key string, body UpdateLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLicenseKeyResponse, error)

	// GetLicenseInformationWithResponse request
	GetLicenseInformationWithResponse(ctx context.Context, params *GetLicenseInformationParams, reqEditors ...RequestEditorFn) (*GetLicenseInformationResponse, error)

	// GetDomainLicensingInfoWithResponse request
	GetDomainLicensingInfoWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDomainLicensingInfoResponse, error)

	// GetSystemLicensingInfoWithResponse request
	GetSystemLicensingInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLicensingInfoResponse, error)

	// GetManifestWithResponse request
	GetManifestWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetManifestResponse, error)

	// SaveManifestWithBodyWithResponse request with any body
	SaveManifestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveManifestResponse, error)

	SaveManifestWithResponse(ctx context.Context, body SaveManifestJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveManifestResponse, error)

	// GetNetworkPoolWithResponse request
	GetNetworkPoolWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNetworkPoolResponse, error)

	// CreateNetworkPoolWithBodyWithResponse request with any body
	CreateNetworkPoolWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetworkPoolResponse, error)

	CreateNetworkPoolWithResponse(ctx context.Context, body CreateNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetworkPoolResponse, error)

	// DeleteNetworkPoolWithResponse request
	DeleteNetworkPoolWithResponse(ctx context.Context, id string, params *DeleteNetworkPoolParams, reqEditors ...RequestEditorFn) (*DeleteNetworkPoolResponse, error)

	// GetNetworkPoolByIDWithResponse request
	GetNetworkPoolByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNetworkPoolByIDResponse, error)

	// UpdateNetworkPoolWithBodyWithResponse request with any body
	UpdateNetworkPoolWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNetworkPoolResponse, error)

	UpdateNetworkPoolWithResponse(ctx context.Context, id string, body UpdateNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNetworkPoolResponse, error)

	// GetNetworksOfNetworkPoolWithResponse request
	GetNetworksOfNetworkPoolWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNetworksOfNetworkPoolResponse, error)

	// GetNetworkOfNetworkPoolWithResponse request
	GetNetworkOfNetworkPoolWithResponse(ctx context.Context, id string, networkId string, reqEditors ...RequestEditorFn) (*GetNetworkOfNetworkPoolResponse, error)

	// DeleteIpPoolFromNetworkOfNetworkPoolWithBodyWithResponse request with any body
	DeleteIpPoolFromNetworkOfNetworkPoolWithBodyWithResponse(ctx context.Context, id string, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIpPoolFromNetworkOfNetworkPoolResponse, error)

	DeleteIpPoolFromNetworkOfNetworkPoolWithResponse(ctx context.Context, id string, networkId string, body DeleteIpPoolFromNetworkOfNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIpPoolFromNetworkOfNetworkPoolResponse, error)

	// AddIpPoolToNetworkOfNetworkPoolWithBodyWithResponse request with any body
	AddIpPoolToNetworkOfNetworkPoolWithBodyWithResponse(ctx context.Context, id string, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddIpPoolToNetworkOfNetworkPoolResponse, error)

	AddIpPoolToNetworkOfNetworkPoolWithResponse(ctx context.Context, id string, networkId string, body AddIpPoolToNetworkOfNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*AddIpPoolToNetworkOfNetworkPoolResponse, error)

	// GetALBClustersWithResponse request
	GetALBClustersWithResponse(ctx context.Context, params *GetALBClustersParams, reqEditors ...RequestEditorFn) (*GetALBClustersResponse, error)

	// GetALBClustersFormFactorsWithResponse request
	GetALBClustersFormFactorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetALBClustersFormFactorsResponse, error)

	// ValidateALBClusterCreationSpecWithBodyWithResponse request with any body
	ValidateALBClusterCreationSpecWithBodyWithResponse(ctx context.Context, params *ValidateALBClusterCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateALBClusterCreationSpecResponse, error)

	ValidateALBClusterCreationSpecWithResponse(ctx context.Context, params *ValidateALBClusterCreationSpecParams, body ValidateALBClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateALBClusterCreationSpecResponse, error)

	// ValidateNsxALBCompatibilityWithBodyWithResponse request with any body
	ValidateNsxALBCompatibilityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateNsxALBCompatibilityResponse, error)

	ValidateNsxALBCompatibilityWithResponse(ctx context.Context, body ValidateNsxALBCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateNsxALBCompatibilityResponse, error)

	// DeleteALBClusterWithResponse request
	DeleteALBClusterWithResponse(ctx context.Context, id string, params *DeleteALBClusterParams, reqEditors ...RequestEditorFn) (*DeleteALBClusterResponse, error)

	// GetALBClusterWithResponse request
	GetALBClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetALBClusterResponse, error)

	// GetNsxClustersWithResponse request
	GetNsxClustersWithResponse(ctx context.Context, params *GetNsxClustersParams, reqEditors ...RequestEditorFn) (*GetNsxClustersResponse, error)

	// GetNsxCriteriaWithResponse request
	GetNsxCriteriaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNsxCriteriaResponse, error)

	// GetNsxCriterionWithResponse request
	GetNsxCriterionWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetNsxCriterionResponse, error)

	// ValidateIpPoolWithBodyWithResponse request with any body
	ValidateIpPoolWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateIpPoolResponse, error)

	ValidateIpPoolWithResponse(ctx context.Context, body ValidateIpPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateIpPoolResponse, error)

	// GetValidationResultWithResponse request
	GetValidationResultWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetValidationResultResponse, error)

	// ConnectOpenIdWithBodyWithResponse request with any body
	ConnectOpenIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectOpenIdResponse, error)

	ConnectOpenIdWithResponse(ctx context.Context, body ConnectOpenIdJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectOpenIdResponse, error)

	// StartNsxCriteriaQueryWithBodyWithResponse request with any body
	StartNsxCriteriaQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartNsxCriteriaQueryResponse, error)

	StartNsxCriteriaQueryWithResponse(ctx context.Context, body StartNsxCriteriaQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*StartNsxCriteriaQueryResponse, error)

	// GetNsxClusterQueryResponseWithResponse request
	GetNsxClusterQueryResponseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNsxClusterQueryResponseResponse, error)

	// GetNsxClusterWithResponse request
	GetNsxClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNsxClusterResponse, error)

	// GetNsxIpAddressPoolsWithResponse request
	GetNsxIpAddressPoolsWithResponse(ctx context.Context, nsxtClusterId string, reqEditors ...RequestEditorFn) (*GetNsxIpAddressPoolsResponse, error)

	// GetNsxIpAddressPoolWithResponse request
	GetNsxIpAddressPoolWithResponse(ctx context.Context, nsxtClusterId string, name string, reqEditors ...RequestEditorFn) (*GetNsxIpAddressPoolResponse, error)

	// GetNsxTransportZonesWithResponse request
	GetNsxTransportZonesWithResponse(ctx context.Context, nsxtClusterId string, reqEditors ...RequestEditorFn) (*GetNsxTransportZonesResponse, error)

	// DeletePersonalityWithResponse request
	DeletePersonalityWithResponse(ctx context.Context, params *DeletePersonalityParams, reqEditors ...RequestEditorFn) (*DeletePersonalityResponse, error)

	// GetPersonalitiesWithResponse request
	GetPersonalitiesWithResponse(ctx context.Context, params *GetPersonalitiesParams, reqEditors ...RequestEditorFn) (*GetPersonalitiesResponse, error)

	// UploadPersonalityWithBodyWithResponse request with any body
	UploadPersonalityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPersonalityResponse, error)

	UploadPersonalityWithResponse(ctx context.Context, body UploadPersonalityJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadPersonalityResponse, error)

	// UploadPersonalityFilesWithBodyWithResponse request with any body
	UploadPersonalityFilesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPersonalityFilesResponse, error)

	// GetPersonalityWithResponse request
	GetPersonalityWithResponse(ctx context.Context, personalityId string, reqEditors ...RequestEditorFn) (*GetPersonalityResponse, error)

	// RenamePersonalityByIdWithBodyWithResponse request with any body
	RenamePersonalityByIdWithBodyWithResponse(ctx context.Context, personalityId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenamePersonalityByIdResponse, error)

	RenamePersonalityByIdWithResponse(ctx context.Context, personalityId string, body RenamePersonalityByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*RenamePersonalityByIdResponse, error)

	// GetProductVersionCatalogWithResponse request
	GetProductVersionCatalogWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProductVersionCatalogResponse, error)

	// UploadProductVersionCatalogWithBodyWithResponse request with any body
	UploadProductVersionCatalogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadProductVersionCatalogResponse, error)

	UploadProductVersionCatalogWithResponse(ctx context.Context, body UploadProductVersionCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadProductVersionCatalogResponse, error)

	// GetPscsWithResponse request
	GetPscsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPscsResponse, error)

	// GetPscWithResponse request
	GetPscWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPscResponse, error)

	// GetReleasesWithResponse request
	GetReleasesWithResponse(ctx context.Context, params *GetReleasesParams, reqEditors ...RequestEditorFn) (*GetReleasesResponse, error)

	// GetReleaseByDomainsWithResponse request
	GetReleaseByDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReleaseByDomainsResponse, error)

	// GetDomainReleaseViewValidationWithResponse request
	GetDomainReleaseViewValidationWithResponse(ctx context.Context, validationId string, reqEditors ...RequestEditorFn) (*GetDomainReleaseViewValidationResponse, error)

	// DeleteReleaseByDomainIDWithResponse request
	DeleteReleaseByDomainIDWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*DeleteReleaseByDomainIDResponse, error)

	// GetReleaseByDomainWithResponse request
	GetReleaseByDomainWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetReleaseByDomainResponse, error)

	// UpdateReleaseByDomainIDWithBodyWithResponse request with any body
	UpdateReleaseByDomainIDWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateReleaseByDomainIDResponse, error)

	UpdateReleaseByDomainIDWithResponse(ctx context.Context, domainId string, body UpdateReleaseByDomainIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateReleaseByDomainIDResponse, error)

	// GetCustomPatchesWithResponse request
	GetCustomPatchesWithResponse(ctx context.Context, domainId string, params *GetCustomPatchesParams, reqEditors ...RequestEditorFn) (*GetCustomPatchesResponse, error)

	// GetFutureReleasesWithResponse request
	GetFutureReleasesWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetFutureReleasesResponse, error)

	// ValidateReleaseByDomainIDWithBodyWithResponse request with any body
	ValidateReleaseByDomainIDWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateReleaseByDomainIDResponse, error)

	ValidateReleaseByDomainIDWithResponse(ctx context.Context, domainId string, body ValidateReleaseByDomainIDJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateReleaseByDomainIDResponse, error)

	// GetSystemReleaseWithResponse request
	GetSystemReleaseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemReleaseResponse, error)

	// GetResourceFunctionalitiesWithResponse request
	GetResourceFunctionalitiesWithResponse(ctx context.Context, params *GetResourceFunctionalitiesParams, reqEditors ...RequestEditorFn) (*GetResourceFunctionalitiesResponse, error)

	// UpdateResourcesFunctionalitiesWithBodyWithResponse request with any body
	UpdateResourcesFunctionalitiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourcesFunctionalitiesResponse, error)

	UpdateResourcesFunctionalitiesWithResponse(ctx context.Context, body UpdateResourcesFunctionalitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourcesFunctionalitiesResponse, error)

	// GetResourcesFunctionalitiesAllowedGlobalWithResponse request
	GetResourcesFunctionalitiesAllowedGlobalWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResourcesFunctionalitiesAllowedGlobalResponse, error)

	// UpdateResourcesFunctionalities1WithBodyWithResponse request with any body
	UpdateResourcesFunctionalities1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourcesFunctionalities1Response, error)

	UpdateResourcesFunctionalities1WithResponse(ctx context.Context, body UpdateResourcesFunctionalities1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourcesFunctionalities1Response, error)

	// GetResourceWarningsWithResponse request
	GetResourceWarningsWithResponse(ctx context.Context, params *GetResourceWarningsParams, reqEditors ...RequestEditorFn) (*GetResourceWarningsResponse, error)

	// CreateResourceWarningWithBodyWithResponse request with any body
	CreateResourceWarningWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceWarningResponse, error)

	CreateResourceWarningWithResponse(ctx context.Context, body CreateResourceWarningJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceWarningResponse, error)

	// GetResourceWarningWithResponse request
	GetResourceWarningWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetResourceWarningResponse, error)

	// StartLicenseCheckByResourceWithBodyWithResponse request with any body
	StartLicenseCheckByResourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartLicenseCheckByResourceResponse, error)

	StartLicenseCheckByResourceWithResponse(ctx context.Context, body StartLicenseCheckByResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*StartLicenseCheckByResourceResponse, error)

	// GetLicenseCheckResultByIDWithResponse request
	GetLicenseCheckResultByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLicenseCheckResultByIDResponse, error)

	// SetLicenseKeyForResourceWithBodyWithResponse request with any body
	SetLicenseKeyForResourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetLicenseKeyForResourceResponse, error)

	SetLicenseKeyForResourceWithResponse(ctx context.Context, body SetLicenseKeyForResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetLicenseKeyForResourceResponse, error)

	// StartRestoreWithBodyWithResponse request with any body
	StartRestoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartRestoreResponse, error)

	StartRestoreWithResponse(ctx context.Context, body StartRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*StartRestoreResponse, error)

	// GetRestoreTaskWithResponse request
	GetRestoreTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRestoreTaskResponse, error)

	// GetRolesWithResponse request
	GetRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRolesResponse, error)

	// GetLocalOsUserAccountsWithResponse request
	GetLocalOsUserAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalOsUserAccountsResponse, error)

	// GetTrustedCertificatesWithResponse request
	GetTrustedCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTrustedCertificatesResponse, error)

	// AddTrustedCertificateWithBodyWithResponse request with any body
	AddTrustedCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTrustedCertificateResponse, error)

	AddTrustedCertificateWithResponse(ctx context.Context, body AddTrustedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTrustedCertificateResponse, error)

	// DeleteTrustedCertificateWithResponse request
	DeleteTrustedCertificateWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*DeleteTrustedCertificateResponse, error)

	// GetSddcManagerUpgradablesWithResponse request
	GetSddcManagerUpgradablesWithResponse(ctx context.Context, params *GetSddcManagerUpgradablesParams, reqEditors ...RequestEditorFn) (*GetSddcManagerUpgradablesResponse, error)

	// GetSddcManagersWithResponse request
	GetSddcManagersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSddcManagersResponse, error)

	// GetSddcManagerWithResponse request
	GetSddcManagerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcManagerResponse, error)

	// GetSddcManagerHistoryWithResponse request
	GetSddcManagerHistoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcManagerHistoryResponse, error)

	// GetBringupTasksWithResponse request
	GetBringupTasksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBringupTasksResponse, error)

	// StartBringupWithBodyWithResponse request with any body
	StartBringupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBringupResponse, error)

	StartBringupWithResponse(ctx context.Context, body StartBringupJSONRequestBody, reqEditors ...RequestEditorFn) (*StartBringupResponse, error)

	// GetBringupAppInfoWithResponse request
	GetBringupAppInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBringupAppInfoResponse, error)

	// GetBringupValidationsWithResponse request
	GetBringupValidationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBringupValidationsResponse, error)

	// ValidateBringupSpecWithBodyWithResponse request with any body
	ValidateBringupSpecWithBodyWithResponse(ctx context.Context, params *ValidateBringupSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateBringupSpecResponse, error)

	ValidateBringupSpecWithResponse(ctx context.Context, params *ValidateBringupSpecParams, body ValidateBringupSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateBringupSpecResponse, error)

	// GetBringupValidationWithResponse request
	GetBringupValidationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBringupValidationResponse, error)

	// RetryBringupValidationWithResponse request
	RetryBringupValidationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetryBringupValidationResponse, error)

	// ExportBringupValidationReportWithResponse request
	ExportBringupValidationReportWithResponse(ctx context.Context, validationId string, params *ExportBringupValidationReportParams, reqEditors ...RequestEditorFn) (*ExportBringupValidationReportResponse, error)

	// GetBringupTaskByIDWithResponse request
	GetBringupTaskByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBringupTaskByIDResponse, error)

	// RetrySddcWithBodyWithResponse request with any body
	RetrySddcWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RetrySddcResponse, error)

	RetrySddcWithResponse(ctx context.Context, id string, body RetrySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*RetrySddcResponse, error)

	// ExportBringupDetailReportWithResponse request
	ExportBringupDetailReportWithResponse(ctx context.Context, id string, params *ExportBringupDetailReportParams, reqEditors ...RequestEditorFn) (*ExportBringupDetailReportResponse, error)

	// GetSddcManagerInfoWithResponse request
	GetSddcManagerInfoWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcManagerInfoResponse, error)

	// GetSSODomainsWithResponse request
	GetSSODomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSSODomainsResponse, error)

	// GetSSODomainEntitiesWithResponse request
	GetSSODomainEntitiesWithResponse(ctx context.Context, ssoDomain string, params *GetSSODomainEntitiesParams, reqEditors ...RequestEditorFn) (*GetSSODomainEntitiesResponse, error)

	// GetSystemConfigurationWithResponse request
	GetSystemConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemConfigurationResponse, error)

	// UpdateSystemConfigurationWithBodyWithResponse request with any body
	UpdateSystemConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSystemConfigurationResponse, error)

	UpdateSystemConfigurationWithResponse(ctx context.Context, body UpdateSystemConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSystemConfigurationResponse, error)

	// GetBackupConfigurationWithResponse request
	GetBackupConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBackupConfigurationResponse, error)

	// UpdateBackupConfigurationWithBodyWithResponse request with any body
	UpdateBackupConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBackupConfigurationResponse, error)

	UpdateBackupConfigurationWithResponse(ctx context.Context, body UpdateBackupConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBackupConfigurationResponse, error)

	// SetBackupConfigurationWithBodyWithResponse request with any body
	SetBackupConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBackupConfigurationResponse, error)

	SetBackupConfigurationWithResponse(ctx context.Context, body SetBackupConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBackupConfigurationResponse, error)

	// GetBackupLocationWithResponse request
	GetBackupLocationWithResponse(ctx context.Context, params *GetBackupLocationParams, reqEditors ...RequestEditorFn) (*GetBackupLocationResponse, error)

	// ValidateBackupConfigurationsOperationsWithBodyWithResponse request with any body
	ValidateBackupConfigurationsOperationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateBackupConfigurationsOperationsResponse, error)

	ValidateBackupConfigurationsOperationsWithResponse(ctx context.Context, body ValidateBackupConfigurationsOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateBackupConfigurationsOperationsResponse, error)

	// GetCeipStatusWithResponse request
	GetCeipStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCeipStatusResponse, error)

	// SetCeipStatusWithBodyWithResponse request with any body
	SetCeipStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCeipStatusResponse, error)

	SetCeipStatusWithResponse(ctx context.Context, body SetCeipStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCeipStatusResponse, error)

	// GetLastAssessmentRunInfoWithResponse request
	GetLastAssessmentRunInfoWithResponse(ctx context.Context, params *GetLastAssessmentRunInfoParams, reqEditors ...RequestEditorFn) (*GetLastAssessmentRunInfoResponse, error)

	// TriggerCheckRunWithBodyWithResponse request with any body
	TriggerCheckRunWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerCheckRunResponse, error)

	TriggerCheckRunWithResponse(ctx context.Context, body TriggerCheckRunJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerCheckRunResponse, error)

	// QueryCheckSetsWithBodyWithResponse request with any body
	QueryCheckSetsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryCheckSetsResponse, error)

	QueryCheckSetsWithResponse(ctx context.Context, body QueryCheckSetsJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryCheckSetsResponse, error)

	// GetResultWithResponse request
	GetResultWithResponse(ctx context.Context, runId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetResultResponse, error)

	// TriggerPartialRetryOfCheckRunWithBodyWithResponse request with any body
	TriggerPartialRetryOfCheckRunWithBodyWithResponse(ctx context.Context, runId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerPartialRetryOfCheckRunResponse, error)

	TriggerPartialRetryOfCheckRunWithResponse(ctx context.Context, runId openapi_types.UUID, body TriggerPartialRetryOfCheckRunJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerPartialRetryOfCheckRunResponse, error)

	// GetDnsConfigurationWithResponse request
	GetDnsConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDnsConfigurationResponse, error)

	// ConfigureDnsWithBodyWithResponse request with any body
	ConfigureDnsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureDnsResponse, error)

	ConfigureDnsWithResponse(ctx context.Context, body ConfigureDnsJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureDnsResponse, error)

	// GetValidationsOfDNSConfigurationWithResponse request
	GetValidationsOfDNSConfigurationWithResponse(ctx context.Context, params *GetValidationsOfDNSConfigurationParams, reqEditors ...RequestEditorFn) (*GetValidationsOfDNSConfigurationResponse, error)

	// ValidateDnsConfigurationWithBodyWithResponse request with any body
	ValidateDnsConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateDnsConfigurationResponse, error)

	ValidateDnsConfigurationWithResponse(ctx context.Context, body ValidateDnsConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateDnsConfigurationResponse, error)

	// GetValidationOfDnsConfigurationWithResponse request
	GetValidationOfDnsConfigurationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetValidationOfDnsConfigurationResponse, error)

	// GetHealthCheckTaskWithResponse request
	GetHealthCheckTaskWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthCheckTaskResponse, error)

	// StartHealthCheckWithBodyWithResponse request with any body
	StartHealthCheckWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartHealthCheckResponse, error)

	StartHealthCheckWithResponse(ctx context.Context, body StartHealthCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*StartHealthCheckResponse, error)

	// GetHealthCheckStatusWithResponse request
	GetHealthCheckStatusWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHealthCheckStatusResponse, error)

	// ExportHealthCheckByIDWithResponse request
	ExportHealthCheckByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ExportHealthCheckByIDResponse, error)

	// GetNtpConfigurationWithResponse request
	GetNtpConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNtpConfigurationResponse, error)

	// ConfigureNtpWithBodyWithResponse request with any body
	ConfigureNtpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureNtpResponse, error)

	ConfigureNtpWithResponse(ctx context.Context, body ConfigureNtpJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureNtpResponse, error)

	// GetValidationsOfNtpConfigurationWithResponse request
	GetValidationsOfNtpConfigurationWithResponse(ctx context.Context, params *GetValidationsOfNtpConfigurationParams, reqEditors ...RequestEditorFn) (*GetValidationsOfNtpConfigurationResponse, error)

	// ValidateNtpConfigurationWithBodyWithResponse request with any body
	ValidateNtpConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateNtpConfigurationResponse, error)

	ValidateNtpConfigurationWithResponse(ctx context.Context, body ValidateNtpConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateNtpConfigurationResponse, error)

	// GetValidationOfNtpConfigurationWithResponse request
	GetValidationOfNtpConfigurationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetValidationOfNtpConfigurationResponse, error)

	// StartPrecheckWithBodyWithResponse request with any body
	StartPrecheckWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartPrecheckResponse, error)

	StartPrecheckWithResponse(ctx context.Context, body StartPrecheckJSONRequestBody, reqEditors ...RequestEditorFn) (*StartPrecheckResponse, error)

	// GetPrecheckTaskWithResponse request
	GetPrecheckTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPrecheckTaskResponse, error)

	// GetProxyConfigurationWithResponse request
	GetProxyConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProxyConfigurationResponse, error)

	// UpdateProxyConfigurationWithBodyWithResponse request with any body
	UpdateProxyConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProxyConfigurationResponse, error)

	UpdateProxyConfigurationWithResponse(ctx context.Context, body UpdateProxyConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProxyConfigurationResponse, error)

	// StartBringupSpecConversionWithBodyWithResponse request with any body
	StartBringupSpecConversionWithBodyWithResponse(ctx context.Context, params *StartBringupSpecConversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBringupSpecConversionResponse, error)

	// GetFIPSConfigurationWithResponse request
	GetFIPSConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFIPSConfigurationResponse, error)

	// DeleteDepotSettingsWithResponse request
	DeleteDepotSettingsWithResponse(ctx context.Context, params *DeleteDepotSettingsParams, reqEditors ...RequestEditorFn) (*DeleteDepotSettingsResponse, error)

	// GetDepotSettingsWithResponse request
	GetDepotSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDepotSettingsResponse, error)

	// UpdateDepotSettingsWithBodyWithResponse request with any body
	UpdateDepotSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDepotSettingsResponse, error)

	UpdateDepotSettingsWithResponse(ctx context.Context, body UpdateDepotSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDepotSettingsResponse, error)

	// GetVersionAliasConfigurationWithResponse request
	GetVersionAliasConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionAliasConfigurationResponse, error)

	// UpdateVersionAliasConfigurationsWithBodyWithResponse request with any body
	UpdateVersionAliasConfigurationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVersionAliasConfigurationsResponse, error)

	UpdateVersionAliasConfigurationsWithResponse(ctx context.Context, body UpdateVersionAliasConfigurationsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVersionAliasConfigurationsResponse, error)

	// DeleteVersionAliasBySoftwareTypeWithResponse request
	DeleteVersionAliasBySoftwareTypeWithResponse(ctx context.Context, bundleComponentType string, reqEditors ...RequestEditorFn) (*DeleteVersionAliasBySoftwareTypeResponse, error)

	// DeleteAliasVersionsBySoftwareTypeAndBaseVersionWithBodyWithResponse request with any body
	DeleteAliasVersionsBySoftwareTypeAndBaseVersionWithBodyWithResponse(ctx context.Context, bundleComponentType string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse, error)

	DeleteAliasVersionsBySoftwareTypeAndBaseVersionWithResponse(ctx context.Context, bundleComponentType string, version string, body DeleteAliasVersionsBySoftwareTypeAndBaseVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse, error)

	// UpdateVersionAliasConfigurationWithBodyWithResponse request with any body
	UpdateVersionAliasConfigurationWithBodyWithResponse(ctx context.Context, bundleComponentType string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVersionAliasConfigurationResponse, error)

	UpdateVersionAliasConfigurationWithResponse(ctx context.Context, bundleComponentType string, version string, body UpdateVersionAliasConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVersionAliasConfigurationResponse, error)

	// GetSupportBundleTaskWithResponse request
	GetSupportBundleTaskWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSupportBundleTaskResponse, error)

	// StartSupportBundleWithBodyWithResponse request with any body
	StartSupportBundleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartSupportBundleResponse, error)

	StartSupportBundleWithResponse(ctx context.Context, body StartSupportBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*StartSupportBundleResponse, error)

	// GetSupportBundleStatusWithResponse request
	GetSupportBundleStatusWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSupportBundleStatusResponse, error)

	// ExportSupportBundleByIDWithResponse request
	ExportSupportBundleByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ExportSupportBundleByIDResponse, error)

	// GetUpgradablesWithResponse request
	GetUpgradablesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUpgradablesResponse, error)

	// GetTasksWithResponse request
	GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error)

	// CancelTaskWithResponse request
	CancelTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CancelTaskResponse, error)

	// GetTaskWithResponse request
	GetTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTaskResponse, error)

	// RetryTaskWithResponse request
	RetryTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetryTaskResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// RefreshAccessTokenWithBodyWithResponse request with any body
	RefreshAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error)

	RefreshAccessTokenWithResponse(ctx context.Context, body RefreshAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error)

	// InvalidateRefreshTokenWithBodyWithResponse request with any body
	InvalidateRefreshTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvalidateRefreshTokenResponse, error)

	InvalidateRefreshTokenWithResponse(ctx context.Context, body InvalidateRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*InvalidateRefreshTokenResponse, error)

	// GetUpgradablesByDomainWithResponse request
	GetUpgradablesByDomainWithResponse(ctx context.Context, domainId string, params *GetUpgradablesByDomainParams, reqEditors ...RequestEditorFn) (*GetUpgradablesByDomainResponse, error)

	// GetUpgradablesClustersWithResponse request
	GetUpgradablesClustersWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetUpgradablesClustersResponse, error)

	// GetNsxUpgradeResourcesWithResponse request
	GetNsxUpgradeResourcesWithResponse(ctx context.Context, domainId string, params *GetNsxUpgradeResourcesParams, reqEditors ...RequestEditorFn) (*GetNsxUpgradeResourcesResponse, error)

	// GetUpgradesWithResponse request
	GetUpgradesWithResponse(ctx context.Context, params *GetUpgradesParams, reqEditors ...RequestEditorFn) (*GetUpgradesResponse, error)

	// PerformUpgradeWithBodyWithResponse request with any body
	PerformUpgradeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PerformUpgradeResponse, error)

	PerformUpgradeWithResponse(ctx context.Context, body PerformUpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*PerformUpgradeResponse, error)

	// GetUpgradeByIdWithResponse request
	GetUpgradeByIdWithResponse(ctx context.Context, upgradeId string, reqEditors ...RequestEditorFn) (*GetUpgradeByIdResponse, error)

	// UpdateUpgradeScheduleWithBodyWithResponse request with any body
	UpdateUpgradeScheduleWithBodyWithResponse(ctx context.Context, upgradeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUpgradeScheduleResponse, error)

	UpdateUpgradeScheduleWithResponse(ctx context.Context, upgradeId string, body UpdateUpgradeScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUpgradeScheduleResponse, error)

	// StartUpgradePrecheckWithResponse request
	StartUpgradePrecheckWithResponse(ctx context.Context, upgradeId string, reqEditors ...RequestEditorFn) (*StartUpgradePrecheckResponse, error)

	// GetUpgradePrecheckByIDWithResponse request
	GetUpgradePrecheckByIDWithResponse(ctx context.Context, upgradeId string, precheckId string, reqEditors ...RequestEditorFn) (*GetUpgradePrecheckByIDResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// AddUsersWithBodyWithResponse request with any body
	AddUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUsersResponse, error)

	AddUsersWithResponse(ctx context.Context, body AddUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUsersResponse, error)

	// DisableLocalAccountWithResponse request
	DisableLocalAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DisableLocalAccountResponse, error)

	// GetLocalAccountWithResponse request
	GetLocalAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalAccountResponse, error)

	// UpdateLocalUserPasswordWithBodyWithResponse request with any body
	UpdateLocalUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLocalUserPasswordResponse, error)

	UpdateLocalUserPasswordWithResponse(ctx context.Context, body UpdateLocalUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLocalUserPasswordResponse, error)

	// GetUiUsersWithResponse request
	GetUiUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUiUsersResponse, error)

	// RemoveUserWithResponse request
	RemoveUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RemoveUserResponse, error)

	// GetVasaProvidersWithResponse request
	GetVasaProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVasaProvidersResponse, error)

	// AddVasaProviderWithBodyWithResponse request with any body
	AddVasaProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVasaProviderResponse, error)

	AddVasaProviderWithResponse(ctx context.Context, body AddVasaProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVasaProviderResponse, error)

	// ValidateVasaProviderSpecWithBodyWithResponse request with any body
	ValidateVasaProviderSpecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateVasaProviderSpecResponse, error)

	ValidateVasaProviderSpecWithResponse(ctx context.Context, body ValidateVasaProviderSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateVasaProviderSpecResponse, error)

	// GetVasaProviderValidationWithResponse request
	GetVasaProviderValidationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVasaProviderValidationResponse, error)

	// RemoveVasaProviderWithResponse request
	RemoveVasaProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RemoveVasaProviderResponse, error)

	// GetVasaProviderWithResponse request
	GetVasaProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVasaProviderResponse, error)

	// UpdateVasaProviderWithBodyWithResponse request with any body
	UpdateVasaProviderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVasaProviderResponse, error)

	UpdateVasaProviderWithResponse(ctx context.Context, id string, body UpdateVasaProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVasaProviderResponse, error)

	// GetVasaProviderStorageContainersWithResponse request
	GetVasaProviderStorageContainersWithResponse(ctx context.Context, id string, params *GetVasaProviderStorageContainersParams, reqEditors ...RequestEditorFn) (*GetVasaProviderStorageContainersResponse, error)

	// AddVasaProviderStorageContainerWithBodyWithResponse request with any body
	AddVasaProviderStorageContainerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVasaProviderStorageContainerResponse, error)

	AddVasaProviderStorageContainerWithResponse(ctx context.Context, id string, body AddVasaProviderStorageContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVasaProviderStorageContainerResponse, error)

	// RemoveVasaProviderStorageContainerWithResponse request
	RemoveVasaProviderStorageContainerWithResponse(ctx context.Context, id string, storageContainerId string, reqEditors ...RequestEditorFn) (*RemoveVasaProviderStorageContainerResponse, error)

	// UpdateVasaProviderStorageContainerWithBodyWithResponse request with any body
	UpdateVasaProviderStorageContainerWithBodyWithResponse(ctx context.Context, id string, storageContainerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVasaProviderStorageContainerResponse, error)

	UpdateVasaProviderStorageContainerWithResponse(ctx context.Context, id string, storageContainerId string, body UpdateVasaProviderStorageContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVasaProviderStorageContainerResponse, error)

	// GetVasaProviderUserWithResponse request
	GetVasaProviderUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVasaProviderUserResponse, error)

	// AddVasaProviderUserWithBodyWithResponse request with any body
	AddVasaProviderUserWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVasaProviderUserResponse, error)

	AddVasaProviderUserWithResponse(ctx context.Context, id string, body AddVasaProviderUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVasaProviderUserResponse, error)

	// UpdateVasaProviderUserWithBodyWithResponse request with any body
	UpdateVasaProviderUserWithBodyWithResponse(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVasaProviderUserResponse, error)

	UpdateVasaProviderUserWithResponse(ctx context.Context, id string, userId string, body UpdateVasaProviderUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVasaProviderUserResponse, error)

	// GetVcentersWithResponse request
	GetVcentersWithResponse(ctx context.Context, params *GetVcentersParams, reqEditors ...RequestEditorFn) (*GetVcentersResponse, error)

	// GetVcenterWithResponse request
	GetVcenterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVcenterResponse, error)

	// GetVcfServicesWithResponse request
	GetVcfServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVcfServicesResponse, error)

	// GetVcfServiceWithResponse request
	GetVcfServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVcfServiceResponse, error)

	// GetVrasWithResponse request
	GetVrasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrasResponse, error)

	// GetVrliIntegratedDomainsWithResponse request
	GetVrliIntegratedDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrliIntegratedDomainsResponse, error)

	// ConnectVrliWithDomainWithBodyWithResponse request with any body
	ConnectVrliWithDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectVrliWithDomainResponse, error)

	ConnectVrliWithDomainWithResponse(ctx context.Context, body ConnectVrliWithDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectVrliWithDomainResponse, error)

	// GetVrlisWithResponse request
	GetVrlisWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrlisResponse, error)

	// GetVropsIntegratedDomainsWithResponse request
	GetVropsIntegratedDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVropsIntegratedDomainsResponse, error)

	// ConnectVropsWithDomainWithBodyWithResponse request with any body
	ConnectVropsWithDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectVropsWithDomainResponse, error)

	ConnectVropsWithDomainWithResponse(ctx context.Context, body ConnectVropsWithDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectVropsWithDomainResponse, error)

	// GetVropsesWithResponse request
	GetVropsesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVropsesResponse, error)

	// RollbackVrslcmWithResponse request
	RollbackVrslcmWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RollbackVrslcmResponse, error)

	// GetVrslcmWithResponse request
	GetVrslcmWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrslcmResponse, error)

	// UpdateVrslcmVersionInInventoryWithBodyWithResponse request with any body
	UpdateVrslcmVersionInInventoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVrslcmVersionInInventoryResponse, error)

	UpdateVrslcmVersionInInventoryWithResponse(ctx context.Context, body UpdateVrslcmVersionInInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVrslcmVersionInInventoryResponse, error)

	// GetVrslcmStatusWithResponse request
	GetVrslcmStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrslcmStatusResponse, error)

	// GetVrslcmsWithResponse request
	GetVrslcmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrslcmsResponse, error)

	// DeployVrslcmWithBodyWithResponse request with any body
	DeployVrslcmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployVrslcmResponse, error)

	DeployVrslcmWithResponse(ctx context.Context, body DeployVrslcmJSONRequestBody, reqEditors ...RequestEditorFn) (*DeployVrslcmResponse, error)

	// ValidateVrslcmWithBodyWithResponse request with any body
	ValidateVrslcmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateVrslcmResponse, error)

	ValidateVrslcmWithResponse(ctx context.Context, body ValidateVrslcmJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateVrslcmResponse, error)

	// GetVrslcmValidationWithResponse request
	GetVrslcmValidationWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetVrslcmValidationResponse, error)

	// UpdateVrslcmVersionByIdInInventoryWithBodyWithResponse request with any body
	UpdateVrslcmVersionByIdInInventoryWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVrslcmVersionByIdInInventoryResponse, error)

	UpdateVrslcmVersionByIdInInventoryWithResponse(ctx context.Context, id string, body UpdateVrslcmVersionByIdInInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVrslcmVersionByIdInInventoryResponse, error)

	// DownloadVsanHclWithResponse request
	DownloadVsanHclWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DownloadVsanHclResponse, error)

	// GetVsanHclAttributesWithResponse request
	GetVsanHclAttributesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVsanHclAttributesResponse, error)

	// GetVsanHclConfigurationWithResponse request
	GetVsanHclConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVsanHclConfigurationResponse, error)

	// UpdateVsanHclConfigurationWithBodyWithResponse request with any body
	UpdateVsanHclConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVsanHclConfigurationResponse, error)

	UpdateVsanHclConfigurationWithResponse(ctx context.Context, body UpdateVsanHclConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVsanHclConfigurationResponse, error)

	// GetWsasWithResponse request
	GetWsasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWsasResponse, error)
}

type GetAvnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Avn
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAvnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAvnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateAvnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAvnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateAvnSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateAvnSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateAvnSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *BackupTask
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StartBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBundlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfBundle
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetBundlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBundlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UploadBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBundleCompatibilitySetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateBundleCompatibilitySetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBundleCompatibilitySetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBundlesForSkipUpgradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfBundle
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetBundlesForSkipUpgradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBundlesForSkipUpgradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bundle
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartBundleDownloadByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StartBundleDownloadByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartBundleDownloadByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertificateAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfCertificateAuthority
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCertificateAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertificateAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigureCertificateAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ConfigureCertificateAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigureCertificateAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCertificateAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateCertificateAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCertificateAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveCertificateAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RemoveCertificateAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveCertificateAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertificateAuthorityByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateAuthority
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCertificateAuthorityByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertificateAuthorityByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfCluster
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsAssignedToClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTagsForResource
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsAssignedToClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsAssignedToClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateClusterCreationSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateClusterCreationSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateClusterCreationSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterCreateValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterCreateValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterCreateValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatastoreQueryResponse1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatastoreQueryResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDatastoreQueryResponse1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatastoreQueryResponse1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateVsanRemoteDatastoreSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateVsanRemoteDatastoreSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateVsanRemoteDatastoreSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateVsanRemoteDatastoreMountSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateVsanRemoteDatastoreMountSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateVsanRemoteDatastoreMountSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostQueryResponse1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HostQueryResponse
	JSON202      *HostQueryResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetHostQueryResponse1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostQueryResponse1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVdsesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Vds
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVdsesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVdsesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportVdsToInventoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ImportVdsToInventoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportVdsToInventoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cluster
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Task
	JSON202      *Task
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterDatastoresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Datastore
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterDatastoresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterDatastoresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDatastoreToClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AddDatastoreToClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDatastoreToClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatastoresCriteria1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfDatastoreCriterion
}

// Status returns HTTPResponse.Status
func (r GetDatastoresCriteria1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatastoresCriteria1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatastoreCriterion1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatastoreCriterion
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetDatastoreCriterion1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatastoreCriterion1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDatastoreQuery1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatastoreQueryResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostDatastoreQuery1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDatastoreQuery1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveDatastoreFromClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Task
	JSON202      *Task
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RemoveDatastoreFromClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveDatastoreFromClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostCriteriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfHostCriterion
}

// Status returns HTTPResponse.Status
func (r GetHostCriteriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostCriteriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostCriterionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HostCriterion
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetHostCriterionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostCriterionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostHostQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *HostQueryResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostHostQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostHostQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterNetworkConfigurationCriteriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetClusterNetworkConfigurationCriteriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterNetworkConfigurationCriteriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterNetworkConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterNetworkConfigurationQueryResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterNetworkConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterNetworkConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterNetworkConfigurationQueryResponseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterNetworkConfigurationQueryResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterNetworkConfigurationQueryResponseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterNetworkConfigurationQueryResponseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTagsFromClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagAssignmentResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RemoveTagsFromClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTagsFromClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsAssignedToClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTag
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsAssignedToClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsAssignedToClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignTagsToClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagAssignmentResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AssignTagsToClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignTagsToClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagAssignableForClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTag
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTagAssignableForClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagAssignableForClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterTagManagerUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagManagerModel
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterTagManagerUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterTagManagerUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateClusterUpdateSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateClusterUpdateSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateClusterUpdateSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterUpdateValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterUpdateValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterUpdateValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompatibilityMatricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfCompatibilityMatrix
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCompatibilityMatricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompatibilityMatricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCompatibilityMatrixResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateCompatibilityMatrixResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCompatibilityMatrixResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompatibilityMatrixResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompatibilityMatrix
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCompatibilityMatrixResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompatibilityMatrixResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompatibilityMatrixContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCompatibilityMatrixContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompatibilityMatrixContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompatibilityMatrixMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompatibilityMatrixMetadata
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCompatibilityMatrixMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompatibilityMatrixMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplianceAuditHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfComplianceAudit
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetComplianceAuditHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplianceAuditHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplianceAuditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ComplianceAudit
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetComplianceAuditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplianceAuditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplianceAuditItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfComplianceAuditItem
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetComplianceAuditItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplianceAuditItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplianceConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfComplianceConfiguration
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetComplianceConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplianceConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplianceStandardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfComplianceStandard
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetComplianceStandardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplianceStandardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReconcileConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ReconcileConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReconcileConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReconciliationTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Task
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetReconciliationTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReconciliationTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfConfigDriftSpec
	JSON500      *Error
	JSON503      *Error
}

// Status returns HTTPResponse.Status
func (r GetConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfCredential
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrRotatePasswordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateOrRotatePasswordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrRotatePasswordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPasswordExpirationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CredentialsExpiration
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetPasswordExpirationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPasswordExpirationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPasswordExpirationByTaskIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsExpiration
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetPasswordExpirationByTaskIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPasswordExpirationByTaskIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialsTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfCredentialsTask
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCredentialsTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialsTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelCredentialsTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CancelCredentialsTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelCredentialsTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialsTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsTask
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCredentialsTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialsTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetryCredentialsTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RetryCredentialsTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryCredentialsTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialTaskByResourceIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ResourceCredentials
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCredentialTaskByResourceIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialTaskByResourceIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialsSubTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsTask
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCredentialsSubTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialsSubTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Credential
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomIsosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfCustomIso
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCustomIsosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomIsosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadCustomIsoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UploadCustomIsoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadCustomIsoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomIsoByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteCustomIsoByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomIsoByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomIsoByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomIso
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCustomIsoByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomIsoByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenameCustomIsoByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomIso
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RenameCustomIsoByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenameCustomIsoByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfDomain
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsAssignedToDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTagsForResource
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsAssignedToDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsAssignedToDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateDomainCreationSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateDomainCreationSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateDomainCreationSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DomainCreateValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DomainCreateValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DomainCreateValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterCriteriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfClusterCriterion
}

// Status returns HTTPResponse.Status
func (r GetClusterCriteriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterCriteriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterCriterionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterCriterion
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterCriterionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterCriterionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClustersQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterQueryResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostClustersQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClustersQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClustersQueryResponseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterQueryResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetClustersQueryResponseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClustersQueryResponseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClusterQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterQueryResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostClusterQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClusterQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterQueryResponseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterQueryResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterQueryResponseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterQueryResponseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatastoresCriteriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfDatastoreCriterion
}

// Status returns HTTPResponse.Status
func (r GetDatastoresCriteriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatastoresCriteriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatastoreCriterionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatastoreCriterion
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetDatastoreCriterionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatastoreCriterionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDatastoreQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatastoreQueryResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostDatastoreQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDatastoreQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatastoreQueryResponseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatastoreQueryResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDatastoreQueryResponseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatastoreQueryResponseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVsanHealthCheckByDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *HealthCheckQueryResult
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVsanHealthCheckByDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVsanHealthCheckByDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVsanHealthCheckByDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *HealthCheckTask
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVsanHealthCheckByDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVsanHealthCheckByDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVsanHealthCheckByQueryIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthCheckQueryResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVsanHealthCheckByQueryIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVsanHealthCheckByQueryIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVsanHealthCheckByTaskIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthCheckTask
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVsanHealthCheckByTaskIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVsanHealthCheckByTaskIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PerformDomainIsolationPrecheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PerformDomainIsolationPrecheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PerformDomainIsolationPrecheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainIsolationPrecheckStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IsolationPrecheckResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDomainIsolationPrecheckStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainIsolationPrecheckStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Domain
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Task
	JSON202      *Task
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfCertificate
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDomainCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ReplaceCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON404      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GenerateCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UploadCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplianceAuditHistoryForADomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfComplianceAudit
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetComplianceAuditHistoryForADomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplianceAuditHistoryForADomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ComplianceAuditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ComplianceTask
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ComplianceAuditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ComplianceAuditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplianceAuditTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ComplianceTask
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetComplianceAuditTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplianceAuditTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetryComplianceAuditTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ComplianceTask
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RetryComplianceAuditTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryComplianceAuditTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplianceAuditForADomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ComplianceAudit
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetComplianceAuditForADomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplianceAuditForADomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplianceAuditItemsForADomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfComplianceAuditItem
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetComplianceAuditItemsForADomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplianceAuditItemsForADomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCSRsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfCsr
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCSRsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCSRsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneratesCSRsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON404      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GeneratesCSRsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneratesCSRsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadCSRResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]byte
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DownloadCSRResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadCSRResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfEndpoint
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDomainEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertificatesByDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfCertificate
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCertificatesByDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertificatesByDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceResourceCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ReplaceResourceCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceResourceCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateResourceCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CertificateValidationTask
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateResourceCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateResourceCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceCertificatesValidationByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfCertificate
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetResourceCertificatesValidationByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceCertificatesValidationByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTagsFromDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagAssignmentResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RemoveTagsFromDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTagsFromDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsAssignedToDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTag
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsAssignedToDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsAssignedToDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignTagsToDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagAssignmentResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AssignTagsToDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignTagsToDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssignableTagsForDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTag
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAssignableTagsForDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssignableTagsForDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainTagManagerUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagManagerModel
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDomainTagManagerUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainTagManagerUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateDomainUpdateSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateDomainUpdateSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateDomainUpdateSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainUpdateValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetDomainUpdateValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainUpdateValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfEdgeCluster
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEdgeClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateEdgeClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEdgeClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateEdgeClusterCreationSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Validation
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateEdgeClusterCreationSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateEdgeClusterCreationSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeClusterValidationByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *Validation
}

// Status returns HTTPResponse.Status
func (r GetEdgeClusterValidationByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeClusterValidationByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeClusterQueryCriteriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfEdgeClusterNsxtEntityCriterion
	JSON404      *Page
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeClusterQueryCriteriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeClusterQueryCriteriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EdgeCluster
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEdgeClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateEdgeClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEdgeClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateEdgeClusterUpdateSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Validation
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateEdgeClusterUpdateSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateEdgeClusterUpdateSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DecommissionHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Task
}

// Status returns HTTPResponse.Status
func (r DecommissionHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DecommissionHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfHost
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommissionHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *string
}

// Status returns HTTPResponse.Status
func (r CommissionHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommissionHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCriteriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfHostCriterion
}

// Status returns HTTPResponse.Status
func (r GetCriteriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCriteriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCriterionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HostCriterion
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetCriterionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCriterionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostHostsPrechecks1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HostsPrechecksResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostHostsPrechecks1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostHostsPrechecks1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostsPrechecksResponseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HostsPrechecksResponse
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetHostsPrechecksResponseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostsPrechecksResponseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HostQueryResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostQueryResponseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HostQueryResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetHostQueryResponseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostQueryResponseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsAssignedToHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTagsForResource
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsAssignedToHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsAssignedToHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateHostCommissionSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Validation
	JSON400      *Error
	JSON500      *Validation
}

// Status returns HTTPResponse.Status
func (r ValidateHostCommissionSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateHostCommissionSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateCommissionHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Validation
	JSON400      *Error
	JSON500      *Validation
}

// Status returns HTTPResponse.Status
func (r ValidateCommissionHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateCommissionHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostCommissionValidationByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Validation
	JSON400      *Error
	JSON500      *Validation
}

// Status returns HTTPResponse.Status
func (r GetHostCommissionValidationByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostCommissionValidationByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Host
	JSON400      *Error
	JSON500      *string
}

// Status returns HTTPResponse.Status
func (r GetHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTagsFromHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagAssignmentResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RemoveTagsFromHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTagsFromHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsAssignedToHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTag
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsAssignedToHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsAssignedToHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignTagsToHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagAssignmentResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AssignTagsToHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignTagsToHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssignableTagForHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTag
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAssignableTagForHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssignableTagForHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostTagManagerUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagManagerModel
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetHostTagManagerUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostTagManagerUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIdentityPrecheckResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentityProviderPrecheckResult
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetIdentityPrecheckResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIdentityPrecheckResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSddcWs1bOidcInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SDDCManagerOidcInfo
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSddcWs1bOidcInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSddcWs1bOidcInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIdentityProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfIdentityProvider
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetIdentityProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIdentityProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddExternalIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AddExternalIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddExternalIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExternalIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteExternalIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExternalIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIdentityProviderByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentityProvider
	JSON401      *ErrorResponse
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetIdentityProviderByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIdentityProviderByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateExternalIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateExternalIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateExternalIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddEmbeddedIdentitySourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AddEmbeddedIdentitySourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddEmbeddedIdentitySourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIdentitySourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteIdentitySourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIdentitySourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEmbeddedIdentitySourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateEmbeddedIdentitySourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEmbeddedIdentitySourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateSyncClientTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GenerateSyncClientTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateSyncClientTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfLicenseKey
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLicenseKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddLicenseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AddLicenseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddLicenseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseProductTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLicenseProductTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseProductTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveLicenseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RemoveLicenseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveLicenseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LicenseKey
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLicenseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLicenseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateLicenseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLicenseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLicenseInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainLicensingInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDomainLicensingInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainLicensingInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemLicensingInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemLicensingInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemLicensingInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Manifest
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SaveManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfNetworkPool
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNetworkPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNetworkPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NetworkPool
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateNetworkPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNetworkPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNetworkPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteNetworkPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNetworkPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkPoolByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkPool
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNetworkPoolByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkPoolByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNetworkPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkPool
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateNetworkPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNetworkPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworksOfNetworkPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfNetwork
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNetworksOfNetworkPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworksOfNetworkPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkOfNetworkPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Network
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNetworkOfNetworkPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkOfNetworkPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIpPoolFromNetworkOfNetworkPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteIpPoolFromNetworkOfNetworkPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIpPoolFromNetworkOfNetworkPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddIpPoolToNetworkOfNetworkPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Network
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AddIpPoolToNetworkOfNetworkPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddIpPoolToNetworkOfNetworkPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetALBClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfNsxALBCluster
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetALBClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetALBClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetALBClustersFormFactorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ALBControllerNodeFormFactors
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetALBClustersFormFactorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetALBClustersFormFactorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateALBClusterCreationSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateALBClusterCreationSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateALBClusterCreationSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateNsxALBCompatibilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateNsxALBCompatibilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateNsxALBCompatibilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteALBClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteALBClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteALBClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetALBClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NsxALBCluster
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetALBClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetALBClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNsxClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfNsxTCluster
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNsxClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNsxClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNsxCriteriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfNsxTCriterion
}

// Status returns HTTPResponse.Status
func (r GetNsxCriteriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNsxCriteriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNsxCriterionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NsxTCriterion
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetNsxCriterionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNsxCriterionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateIpPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
}

// Status returns HTTPResponse.Status
func (r ValidateIpPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateIpPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetValidationResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
}

// Status returns HTTPResponse.Status
func (r GetValidationResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetValidationResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectOpenIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConnectOpenIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectOpenIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartNsxCriteriaQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *NsxTQueryResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StartNsxCriteriaQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartNsxCriteriaQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNsxClusterQueryResponseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NsxTQueryResponse
	JSON202      *NsxTQueryResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNsxClusterQueryResponseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNsxClusterQueryResponseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNsxClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NsxTCluster
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNsxClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNsxClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNsxIpAddressPoolsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfNsxtIpAddressPool
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNsxIpAddressPoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNsxIpAddressPoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNsxIpAddressPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NsxtIpAddressPool
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNsxIpAddressPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNsxIpAddressPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNsxTransportZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfNsxtTransportZoneInfo
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNsxTransportZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNsxTransportZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersonalityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeletePersonalityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersonalityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonalitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfPersonality
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetPersonalitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonalitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadPersonalityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UploadPersonalityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadPersonalityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadPersonalityFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UploadPersonalityFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadPersonalityFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonalityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Personality
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetPersonalityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonalityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenamePersonalityByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Personality
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RenamePersonalityByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenamePersonalityByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductVersionCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductVersionCatalog
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetProductVersionCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductVersionCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadProductVersionCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UploadProductVersionCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadProductVersionCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPscsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfPsc
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetPscsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPscsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPscResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Psc
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetPscResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPscResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfRelease
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetReleasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleaseByDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfDomainReleaseView
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetReleaseByDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleaseByDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainReleaseViewValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDomainReleaseViewValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainReleaseViewValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReleaseByDomainIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteReleaseByDomainIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReleaseByDomainIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleaseByDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DomainReleaseView
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetReleaseByDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleaseByDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateReleaseByDomainIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateReleaseByDomainIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateReleaseByDomainIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomPatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlexibleProductPatches
}

// Status returns HTTPResponse.Status
func (r GetCustomPatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomPatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFutureReleasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfDomainFutureRelease
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetFutureReleasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFutureReleasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateReleaseByDomainIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Validation
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateReleaseByDomainIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateReleaseByDomainIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Release
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceFunctionalitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfResourceFunctionalities
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetResourceFunctionalitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceFunctionalitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourcesFunctionalitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceFunctionalitiesCaller
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateResourcesFunctionalitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourcesFunctionalitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcesFunctionalitiesAllowedGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceFunctionalitiesGlobalConfiguration
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetResourcesFunctionalitiesAllowedGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcesFunctionalitiesAllowedGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourcesFunctionalities1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceFunctionalitiesGlobalConfigurationCaller
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateResourcesFunctionalities1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourcesFunctionalities1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceWarningsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfResourceWarning
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetResourceWarningsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceWarningsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResourceWarningResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ResourceWarning
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateResourceWarningResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResourceWarningResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceWarningResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceWarning
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetResourceWarningResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceWarningResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartLicenseCheckByResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StartLicenseCheckByResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartLicenseCheckByResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseCheckResultByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLicenseCheckResultByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseCheckResultByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetLicenseKeyForResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SetLicenseKeyForResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetLicenseKeyForResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartRestoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StartRestoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartRestoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRestoreTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRestoreTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRestoreTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfRole
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocalOsUserAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LocalOsUserAccount
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLocalOsUserAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocalOsUserAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTrustedCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTrustedCertificate
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTrustedCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTrustedCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTrustedCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AddTrustedCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTrustedCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTrustedCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTrustedCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTrustedCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSddcManagerUpgradablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSddcManagerUpgradablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSddcManagerUpgradablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSddcManagersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfSddcManager
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSddcManagersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSddcManagersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSddcManagerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SddcManager
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSddcManagerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSddcManagerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSddcManagerHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *History
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSddcManagerHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSddcManagerHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBringupTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfSddcTask
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetBringupTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBringupTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartBringupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SddcTask
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StartBringupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartBringupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBringupAppInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VcfService
	JSON404      *VcfService
	JSON500      *VcfService
	JSON501      *VcfService
}

// Status returns HTTPResponse.Status
func (r GetBringupAppInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBringupAppInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBringupValidationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfValidation
	JSON404      *Error
	JSON500      *Error
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r GetBringupValidationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBringupValidationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateBringupSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON202      *Validation
	JSON403      *Validation
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateBringupSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateBringupSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBringupValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Validation
	JSON404      *Error
	JSON500      *Error
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r GetBringupValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBringupValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetryBringupValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RetryBringupValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryBringupValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportBringupValidationReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r ExportBringupValidationReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportBringupValidationReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBringupTaskByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SddcTask
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetBringupTaskByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBringupTaskByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrySddcResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SddcTask
	JSON400      *Error
	JSON404      *Error
	JSON405      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RetrySddcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrySddcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportBringupDetailReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON204      *string
}

// Status returns HTTPResponse.Status
func (r ExportBringupDetailReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportBringupDetailReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSddcManagerInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SddcManagerInfo
	JSON404      *SddcManagerInfo
	JSON500      *SddcManagerInfo
	JSON501      *SddcManagerInfo
}

// Status returns HTTPResponse.Status
func (r GetSddcManagerInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSddcManagerInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSSODomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfString
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSSODomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSSODomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSSODomainEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfSsoDomainEntity
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSSODomainEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSSODomainEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *System
	JSON400      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSystemConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSystemConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateSystemConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSystemConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupConfiguration
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetBackupConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBackupConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateBackupConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBackupConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBackupConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SetBackupConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBackupConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupLocation
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetBackupLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateBackupConfigurationsOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateBackupConfigurationsOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateBackupConfigurationsOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCeipStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ceip
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCeipStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCeipStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCeipStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SetCeipStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCeipStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLastAssessmentRunInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AssessmentTaskInfo
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLastAssessmentRunInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLastAssessmentRunInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerCheckRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r TriggerCheckRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerCheckRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryCheckSetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckSetQueryResult
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r QueryCheckSetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryCheckSetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssessmentOutput
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerPartialRetryOfCheckRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r TriggerPartialRetryOfCheckRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerPartialRetryOfCheckRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDnsConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnsConfiguration
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDnsConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDnsConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigureDnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ConfigureDnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigureDnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetValidationsOfDNSConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *[]Validation
}

// Status returns HTTPResponse.Status
func (r GetValidationsOfDNSConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetValidationsOfDNSConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateDnsConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Validation
	JSON400      *Error
	JSON500      *Validation
}

// Status returns HTTPResponse.Status
func (r ValidateDnsConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateDnsConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetValidationOfDnsConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *Validation
}

// Status returns HTTPResponse.Status
func (r GetValidationOfDnsConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetValidationOfDnsConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthCheckTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfHealthSummary
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetHealthCheckTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthCheckTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartHealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *HealthSummary
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StartHealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartHealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthCheckStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthSummary
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetHealthCheckStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthCheckStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportHealthCheckByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExportHealthCheckByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportHealthCheckByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNtpConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NtpConfiguration
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNtpConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNtpConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigureNtpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ConfigureNtpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigureNtpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetValidationsOfNtpConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *[]Validation
}

// Status returns HTTPResponse.Status
func (r GetValidationsOfNtpConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetValidationsOfNtpConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateNtpConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Validation
	JSON400      *Error
	JSON500      *Validation
}

// Status returns HTTPResponse.Status
func (r ValidateNtpConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateNtpConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetValidationOfNtpConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON500      *Validation
}

// Status returns HTTPResponse.Status
func (r GetValidationOfNtpConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetValidationOfNtpConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartPrecheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StartPrecheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartPrecheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrecheckTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Task
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetPrecheckTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrecheckTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProxyConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyConfiguration
	JSON400      *Error
	JSON500      *ProxyConfiguration
}

// Status returns HTTPResponse.Status
func (r GetProxyConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProxyConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProxyConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateProxyConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProxyConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartBringupSpecConversionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SddcSpec
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r StartBringupSpecConversionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartBringupSpecConversionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFIPSConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Fips
	JSON500      *Fips
}

// Status returns HTTPResponse.Status
func (r GetFIPSConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFIPSConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDepotSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDepotSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDepotSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDepotSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DepotSettings
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDepotSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDepotSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDepotSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *DepotSettings
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateDepotSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDepotSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionAliasConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfVersionAliasesForBundleComponentType
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionAliasConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionAliasConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVersionAliasConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfVersionAliasesForBundleComponentType
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVersionAliasConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVersionAliasConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVersionAliasBySoftwareTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVersionAliasBySoftwareTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVersionAliasBySoftwareTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVersionAliasConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfVersionAliasesForBundleComponentType
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVersionAliasConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVersionAliasConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSupportBundleTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfSupportBundle
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSupportBundleTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupportBundleTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartSupportBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SupportBundle
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StartSupportBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartSupportBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSupportBundleStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupportBundle
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSupportBundleStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupportBundleStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportSupportBundleByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExportSupportBundleByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportSupportBundleByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUpgradablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfUpgradable
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUpgradablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUpgradablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfTask
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CancelTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Task
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetryTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RetryTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenPair
	JSON201      *TokenPair
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RefreshAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InvalidateRefreshTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InvalidateRefreshTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InvalidateRefreshTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUpgradablesByDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfUpgradable
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUpgradablesByDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUpgradablesByDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUpgradablesClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfUpgradablesClusterResource
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUpgradablesClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUpgradablesClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNsxUpgradeResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NsxtResources
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNsxUpgradeResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNsxUpgradeResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUpgradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfUpgrade
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUpgradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUpgradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PerformUpgradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON403      *Error
	JSON424      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PerformUpgradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PerformUpgradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUpgradeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Upgrade
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUpgradeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUpgradeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUpgradeScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Upgrade
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateUpgradeScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUpgradeScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartUpgradePrecheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StartUpgradePrecheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartUpgradePrecheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUpgradePrecheckByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Task
	JSON400      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUpgradePrecheckByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUpgradePrecheckByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfUser
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PageOfUser
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableLocalAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DisableLocalAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableLocalAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocalAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LocalUser
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocalAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocalAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLocalUserPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateLocalUserPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLocalUserPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUiUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfUser
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUiUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUiUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RemoveUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVasaProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfVasaProvider
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVasaProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVasaProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddVasaProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VasaProvider
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AddVasaProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddVasaProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateVasaProviderSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Validation
	JSON400      *Error
	JSON500      *Validation
}

// Status returns HTTPResponse.Status
func (r ValidateVasaProviderSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateVasaProviderSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVasaProviderValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON404      *Error
	JSON500      *Validation
}

// Status returns HTTPResponse.Status
func (r GetVasaProviderValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVasaProviderValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveVasaProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RemoveVasaProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveVasaProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVasaProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VasaProvider
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVasaProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVasaProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVasaProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VasaProvider
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVasaProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVasaProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVasaProviderStorageContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]StorageContainer
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVasaProviderStorageContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVasaProviderStorageContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddVasaProviderStorageContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VasaProvider
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AddVasaProviderStorageContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddVasaProviderStorageContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveVasaProviderStorageContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RemoveVasaProviderStorageContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveVasaProviderStorageContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVasaProviderStorageContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VasaProvider
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVasaProviderStorageContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVasaProviderStorageContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVasaProviderUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VasaUser
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVasaProviderUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVasaProviderUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddVasaProviderUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VasaProvider
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AddVasaProviderUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddVasaProviderUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVasaProviderUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VasaProvider
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVasaProviderUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVasaProviderUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVcentersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfVcenter
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVcentersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVcentersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVcenterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vcenter
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVcenterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVcenterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVcfServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfVcfService
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVcfServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVcfServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVcfServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VcfService
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVcfServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVcfServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVrasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfVra
}

// Status returns HTTPResponse.Status
func (r GetVrasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVrasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVrliIntegratedDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfDomainIntegration
}

// Status returns HTTPResponse.Status
func (r GetVrliIntegratedDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVrliIntegratedDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectVrliWithDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
}

// Status returns HTTPResponse.Status
func (r ConnectVrliWithDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectVrliWithDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVrlisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfVrli
}

// Status returns HTTPResponse.Status
func (r GetVrlisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVrlisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVropsIntegratedDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfDomainIntegration
}

// Status returns HTTPResponse.Status
func (r GetVropsIntegratedDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVropsIntegratedDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectVropsWithDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ConnectVropsWithDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectVropsWithDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVropsesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfVrops
}

// Status returns HTTPResponse.Status
func (r GetVropsesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVropsesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RollbackVrslcmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON405      *Error
}

// Status returns HTTPResponse.Status
func (r RollbackVrslcmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RollbackVrslcmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVrslcmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vrslcm
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetVrslcmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVrslcmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVrslcmVersionInInventoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON405      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVrslcmVersionInInventoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVrslcmVersionInInventoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVrslcmStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrslcmStatus
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetVrslcmStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVrslcmStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVrslcmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfVrslcm
}

// Status returns HTTPResponse.Status
func (r GetVrslcmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVrslcmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeployVrslcmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Task
	JSON400      *Error
	JSON405      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeployVrslcmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeployVrslcmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateVrslcmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Validation
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateVrslcmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateVrslcmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVrslcmValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Validation
	JSON400      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetVrslcmValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVrslcmValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVrslcmVersionByIdInInventoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON405      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVrslcmVersionByIdInInventoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVrslcmVersionByIdInInventoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadVsanHclResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DownloadVsanHclResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadVsanHclResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVsanHclAttributesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VsanHclAttributes
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVsanHclAttributesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVsanHclAttributesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVsanHclConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VsanHclConfiguration
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVsanHclConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVsanHclConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVsanHclConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VsanHclConfiguration
	JSON202      *VsanHclConfiguration
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVsanHclConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVsanHclConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWsasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageOfWsa
}

// Status returns HTTPResponse.Status
func (r GetWsasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWsasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAvnsWithResponse request returning *GetAvnsResponse
func (c *ClientWithResponses) GetAvnsWithResponse(ctx context.Context, params *GetAvnsParams, reqEditors ...RequestEditorFn) (*GetAvnsResponse, error) {
	rsp, err := c.GetAvns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvnsResponse(rsp)
}

// CreateAvnsWithBodyWithResponse request with arbitrary body returning *CreateAvnsResponse
func (c *ClientWithResponses) CreateAvnsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAvnsResponse, error) {
	rsp, err := c.CreateAvnsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAvnsResponse(rsp)
}

func (c *ClientWithResponses) CreateAvnsWithResponse(ctx context.Context, body CreateAvnsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAvnsResponse, error) {
	rsp, err := c.CreateAvns(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAvnsResponse(rsp)
}

// ValidateAvnSpecWithBodyWithResponse request with arbitrary body returning *ValidateAvnSpecResponse
func (c *ClientWithResponses) ValidateAvnSpecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateAvnSpecResponse, error) {
	rsp, err := c.ValidateAvnSpecWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateAvnSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateAvnSpecWithResponse(ctx context.Context, body ValidateAvnSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateAvnSpecResponse, error) {
	rsp, err := c.ValidateAvnSpec(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateAvnSpecResponse(rsp)
}

// StartBackupWithBodyWithResponse request with arbitrary body returning *StartBackupResponse
func (c *ClientWithResponses) StartBackupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBackupResponse, error) {
	rsp, err := c.StartBackupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBackupResponse(rsp)
}

func (c *ClientWithResponses) StartBackupWithResponse(ctx context.Context, body StartBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*StartBackupResponse, error) {
	rsp, err := c.StartBackup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBackupResponse(rsp)
}

// GetBundlesWithResponse request returning *GetBundlesResponse
func (c *ClientWithResponses) GetBundlesWithResponse(ctx context.Context, params *GetBundlesParams, reqEditors ...RequestEditorFn) (*GetBundlesResponse, error) {
	rsp, err := c.GetBundles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBundlesResponse(rsp)
}

// UploadBundleWithBodyWithResponse request with arbitrary body returning *UploadBundleResponse
func (c *ClientWithResponses) UploadBundleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadBundleResponse, error) {
	rsp, err := c.UploadBundleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadBundleResponse(rsp)
}

func (c *ClientWithResponses) UploadBundleWithResponse(ctx context.Context, body UploadBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadBundleResponse, error) {
	rsp, err := c.UploadBundle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadBundleResponse(rsp)
}

// UpdateBundleCompatibilitySetsWithBodyWithResponse request with arbitrary body returning *UpdateBundleCompatibilitySetsResponse
func (c *ClientWithResponses) UpdateBundleCompatibilitySetsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBundleCompatibilitySetsResponse, error) {
	rsp, err := c.UpdateBundleCompatibilitySetsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBundleCompatibilitySetsResponse(rsp)
}

func (c *ClientWithResponses) UpdateBundleCompatibilitySetsWithResponse(ctx context.Context, body UpdateBundleCompatibilitySetsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBundleCompatibilitySetsResponse, error) {
	rsp, err := c.UpdateBundleCompatibilitySets(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBundleCompatibilitySetsResponse(rsp)
}

// GetBundlesForSkipUpgradeWithResponse request returning *GetBundlesForSkipUpgradeResponse
func (c *ClientWithResponses) GetBundlesForSkipUpgradeWithResponse(ctx context.Context, id string, params *GetBundlesForSkipUpgradeParams, reqEditors ...RequestEditorFn) (*GetBundlesForSkipUpgradeResponse, error) {
	rsp, err := c.GetBundlesForSkipUpgrade(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBundlesForSkipUpgradeResponse(rsp)
}

// DeleteBundleWithResponse request returning *DeleteBundleResponse
func (c *ClientWithResponses) DeleteBundleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBundleResponse, error) {
	rsp, err := c.DeleteBundle(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBundleResponse(rsp)
}

// GetBundleWithResponse request returning *GetBundleResponse
func (c *ClientWithResponses) GetBundleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBundleResponse, error) {
	rsp, err := c.GetBundle(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBundleResponse(rsp)
}

// StartBundleDownloadByIDWithBodyWithResponse request with arbitrary body returning *StartBundleDownloadByIDResponse
func (c *ClientWithResponses) StartBundleDownloadByIDWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBundleDownloadByIDResponse, error) {
	rsp, err := c.StartBundleDownloadByIDWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBundleDownloadByIDResponse(rsp)
}

func (c *ClientWithResponses) StartBundleDownloadByIDWithResponse(ctx context.Context, id string, body StartBundleDownloadByIDJSONRequestBody, reqEditors ...RequestEditorFn) (*StartBundleDownloadByIDResponse, error) {
	rsp, err := c.StartBundleDownloadByID(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBundleDownloadByIDResponse(rsp)
}

// GetCertificateAuthoritiesWithResponse request returning *GetCertificateAuthoritiesResponse
func (c *ClientWithResponses) GetCertificateAuthoritiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCertificateAuthoritiesResponse, error) {
	rsp, err := c.GetCertificateAuthorities(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertificateAuthoritiesResponse(rsp)
}

// ConfigureCertificateAuthorityWithBodyWithResponse request with arbitrary body returning *ConfigureCertificateAuthorityResponse
func (c *ClientWithResponses) ConfigureCertificateAuthorityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureCertificateAuthorityResponse, error) {
	rsp, err := c.ConfigureCertificateAuthorityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureCertificateAuthorityResponse(rsp)
}

func (c *ClientWithResponses) ConfigureCertificateAuthorityWithResponse(ctx context.Context, body ConfigureCertificateAuthorityJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureCertificateAuthorityResponse, error) {
	rsp, err := c.ConfigureCertificateAuthority(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureCertificateAuthorityResponse(rsp)
}

// CreateCertificateAuthorityWithBodyWithResponse request with arbitrary body returning *CreateCertificateAuthorityResponse
func (c *ClientWithResponses) CreateCertificateAuthorityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCertificateAuthorityResponse, error) {
	rsp, err := c.CreateCertificateAuthorityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCertificateAuthorityResponse(rsp)
}

func (c *ClientWithResponses) CreateCertificateAuthorityWithResponse(ctx context.Context, body CreateCertificateAuthorityJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCertificateAuthorityResponse, error) {
	rsp, err := c.CreateCertificateAuthority(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCertificateAuthorityResponse(rsp)
}

// RemoveCertificateAuthorityWithResponse request returning *RemoveCertificateAuthorityResponse
func (c *ClientWithResponses) RemoveCertificateAuthorityWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RemoveCertificateAuthorityResponse, error) {
	rsp, err := c.RemoveCertificateAuthority(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveCertificateAuthorityResponse(rsp)
}

// GetCertificateAuthorityByIdWithResponse request returning *GetCertificateAuthorityByIdResponse
func (c *ClientWithResponses) GetCertificateAuthorityByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCertificateAuthorityByIdResponse, error) {
	rsp, err := c.GetCertificateAuthorityById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertificateAuthorityByIdResponse(rsp)
}

// GetClustersWithResponse request returning *GetClustersResponse
func (c *ClientWithResponses) GetClustersWithResponse(ctx context.Context, params *GetClustersParams, reqEditors ...RequestEditorFn) (*GetClustersResponse, error) {
	rsp, err := c.GetClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// GetTagsAssignedToClustersWithResponse request returning *GetTagsAssignedToClustersResponse
func (c *ClientWithResponses) GetTagsAssignedToClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsAssignedToClustersResponse, error) {
	rsp, err := c.GetTagsAssignedToClusters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsAssignedToClustersResponse(rsp)
}

// ValidateClusterCreationSpecWithBodyWithResponse request with arbitrary body returning *ValidateClusterCreationSpecResponse
func (c *ClientWithResponses) ValidateClusterCreationSpecWithBodyWithResponse(ctx context.Context, params *ValidateClusterCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateClusterCreationSpecResponse, error) {
	rsp, err := c.ValidateClusterCreationSpecWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateClusterCreationSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateClusterCreationSpecWithResponse(ctx context.Context, params *ValidateClusterCreationSpecParams, body ValidateClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateClusterCreationSpecResponse, error) {
	rsp, err := c.ValidateClusterCreationSpec(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateClusterCreationSpecResponse(rsp)
}

// GetClusterCreateValidationWithResponse request returning *GetClusterCreateValidationResponse
func (c *ClientWithResponses) GetClusterCreateValidationWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetClusterCreateValidationResponse, error) {
	rsp, err := c.GetClusterCreateValidation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterCreateValidationResponse(rsp)
}

// GetDatastoreQueryResponse1WithResponse request returning *GetDatastoreQueryResponse1Response
func (c *ClientWithResponses) GetDatastoreQueryResponse1WithResponse(ctx context.Context, clusterId string, queryId string, reqEditors ...RequestEditorFn) (*GetDatastoreQueryResponse1Response, error) {
	rsp, err := c.GetDatastoreQueryResponse1(ctx, clusterId, queryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatastoreQueryResponse1Response(rsp)
}

// ValidateVsanRemoteDatastoreSpecWithBodyWithResponse request with arbitrary body returning *ValidateVsanRemoteDatastoreSpecResponse
func (c *ClientWithResponses) ValidateVsanRemoteDatastoreSpecWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateVsanRemoteDatastoreSpecResponse, error) {
	rsp, err := c.ValidateVsanRemoteDatastoreSpecWithBody(ctx, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateVsanRemoteDatastoreSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateVsanRemoteDatastoreSpecWithResponse(ctx context.Context, clusterId string, body ValidateVsanRemoteDatastoreSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateVsanRemoteDatastoreSpecResponse, error) {
	rsp, err := c.ValidateVsanRemoteDatastoreSpec(ctx, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateVsanRemoteDatastoreSpecResponse(rsp)
}

// ValidateVsanRemoteDatastoreMountSpecWithBodyWithResponse request with arbitrary body returning *ValidateVsanRemoteDatastoreMountSpecResponse
func (c *ClientWithResponses) ValidateVsanRemoteDatastoreMountSpecWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateVsanRemoteDatastoreMountSpecResponse, error) {
	rsp, err := c.ValidateVsanRemoteDatastoreMountSpecWithBody(ctx, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateVsanRemoteDatastoreMountSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateVsanRemoteDatastoreMountSpecWithResponse(ctx context.Context, clusterId string, body ValidateVsanRemoteDatastoreMountSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateVsanRemoteDatastoreMountSpecResponse, error) {
	rsp, err := c.ValidateVsanRemoteDatastoreMountSpec(ctx, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateVsanRemoteDatastoreMountSpecResponse(rsp)
}

// GetHostQueryResponse1WithResponse request returning *GetHostQueryResponse1Response
func (c *ClientWithResponses) GetHostQueryResponse1WithResponse(ctx context.Context, clusterId string, queryId string, reqEditors ...RequestEditorFn) (*GetHostQueryResponse1Response, error) {
	rsp, err := c.GetHostQueryResponse1(ctx, clusterId, queryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostQueryResponse1Response(rsp)
}

// GetVdsesWithResponse request returning *GetVdsesResponse
func (c *ClientWithResponses) GetVdsesWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*GetVdsesResponse, error) {
	rsp, err := c.GetVdses(ctx, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVdsesResponse(rsp)
}

// ImportVdsToInventoryWithBodyWithResponse request with arbitrary body returning *ImportVdsToInventoryResponse
func (c *ClientWithResponses) ImportVdsToInventoryWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportVdsToInventoryResponse, error) {
	rsp, err := c.ImportVdsToInventoryWithBody(ctx, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportVdsToInventoryResponse(rsp)
}

func (c *ClientWithResponses) ImportVdsToInventoryWithResponse(ctx context.Context, clusterId string, body ImportVdsToInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportVdsToInventoryResponse, error) {
	rsp, err := c.ImportVdsToInventory(ctx, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportVdsToInventoryResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, id string, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// GetClusterDatastoresWithResponse request returning *GetClusterDatastoresResponse
func (c *ClientWithResponses) GetClusterDatastoresWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterDatastoresResponse, error) {
	rsp, err := c.GetClusterDatastores(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterDatastoresResponse(rsp)
}

// AddDatastoreToClusterWithBodyWithResponse request with arbitrary body returning *AddDatastoreToClusterResponse
func (c *ClientWithResponses) AddDatastoreToClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDatastoreToClusterResponse, error) {
	rsp, err := c.AddDatastoreToClusterWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDatastoreToClusterResponse(rsp)
}

func (c *ClientWithResponses) AddDatastoreToClusterWithResponse(ctx context.Context, id string, body AddDatastoreToClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDatastoreToClusterResponse, error) {
	rsp, err := c.AddDatastoreToCluster(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDatastoreToClusterResponse(rsp)
}

// GetDatastoresCriteria1WithResponse request returning *GetDatastoresCriteria1Response
func (c *ClientWithResponses) GetDatastoresCriteria1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDatastoresCriteria1Response, error) {
	rsp, err := c.GetDatastoresCriteria1(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatastoresCriteria1Response(rsp)
}

// GetDatastoreCriterion1WithResponse request returning *GetDatastoreCriterion1Response
func (c *ClientWithResponses) GetDatastoreCriterion1WithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*GetDatastoreCriterion1Response, error) {
	rsp, err := c.GetDatastoreCriterion1(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatastoreCriterion1Response(rsp)
}

// PostDatastoreQuery1WithBodyWithResponse request with arbitrary body returning *PostDatastoreQuery1Response
func (c *ClientWithResponses) PostDatastoreQuery1WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDatastoreQuery1Response, error) {
	rsp, err := c.PostDatastoreQuery1WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDatastoreQuery1Response(rsp)
}

func (c *ClientWithResponses) PostDatastoreQuery1WithResponse(ctx context.Context, id string, body PostDatastoreQuery1JSONRequestBody, reqEditors ...RequestEditorFn) (*PostDatastoreQuery1Response, error) {
	rsp, err := c.PostDatastoreQuery1(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDatastoreQuery1Response(rsp)
}

// RemoveDatastoreFromClusterWithResponse request returning *RemoveDatastoreFromClusterResponse
func (c *ClientWithResponses) RemoveDatastoreFromClusterWithResponse(ctx context.Context, id string, datastoreId string, reqEditors ...RequestEditorFn) (*RemoveDatastoreFromClusterResponse, error) {
	rsp, err := c.RemoveDatastoreFromCluster(ctx, id, datastoreId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveDatastoreFromClusterResponse(rsp)
}

// GetHostCriteriaWithResponse request returning *GetHostCriteriaResponse
func (c *ClientWithResponses) GetHostCriteriaWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostCriteriaResponse, error) {
	rsp, err := c.GetHostCriteria(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostCriteriaResponse(rsp)
}

// GetHostCriterionWithResponse request returning *GetHostCriterionResponse
func (c *ClientWithResponses) GetHostCriterionWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*GetHostCriterionResponse, error) {
	rsp, err := c.GetHostCriterion(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostCriterionResponse(rsp)
}

// PostHostQueryWithBodyWithResponse request with arbitrary body returning *PostHostQueryResponse
func (c *ClientWithResponses) PostHostQueryWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHostQueryResponse, error) {
	rsp, err := c.PostHostQueryWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHostQueryResponse(rsp)
}

func (c *ClientWithResponses) PostHostQueryWithResponse(ctx context.Context, id string, body PostHostQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostHostQueryResponse, error) {
	rsp, err := c.PostHostQuery(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHostQueryResponse(rsp)
}

// GetClusterNetworkConfigurationCriteriaWithResponse request returning *GetClusterNetworkConfigurationCriteriaResponse
func (c *ClientWithResponses) GetClusterNetworkConfigurationCriteriaWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterNetworkConfigurationCriteriaResponse, error) {
	rsp, err := c.GetClusterNetworkConfigurationCriteria(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterNetworkConfigurationCriteriaResponse(rsp)
}

// GetClusterNetworkConfigurationWithBodyWithResponse request with arbitrary body returning *GetClusterNetworkConfigurationResponse
func (c *ClientWithResponses) GetClusterNetworkConfigurationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetClusterNetworkConfigurationResponse, error) {
	rsp, err := c.GetClusterNetworkConfigurationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterNetworkConfigurationResponse(rsp)
}

func (c *ClientWithResponses) GetClusterNetworkConfigurationWithResponse(ctx context.Context, id string, body GetClusterNetworkConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*GetClusterNetworkConfigurationResponse, error) {
	rsp, err := c.GetClusterNetworkConfiguration(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterNetworkConfigurationResponse(rsp)
}

// GetClusterNetworkConfigurationQueryResponseWithResponse request returning *GetClusterNetworkConfigurationQueryResponseResponse
func (c *ClientWithResponses) GetClusterNetworkConfigurationQueryResponseWithResponse(ctx context.Context, id string, queryId string, reqEditors ...RequestEditorFn) (*GetClusterNetworkConfigurationQueryResponseResponse, error) {
	rsp, err := c.GetClusterNetworkConfigurationQueryResponse(ctx, id, queryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterNetworkConfigurationQueryResponseResponse(rsp)
}

// RemoveTagsFromClusterWithBodyWithResponse request with arbitrary body returning *RemoveTagsFromClusterResponse
func (c *ClientWithResponses) RemoveTagsFromClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTagsFromClusterResponse, error) {
	rsp, err := c.RemoveTagsFromClusterWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTagsFromClusterResponse(rsp)
}

func (c *ClientWithResponses) RemoveTagsFromClusterWithResponse(ctx context.Context, id string, body RemoveTagsFromClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTagsFromClusterResponse, error) {
	rsp, err := c.RemoveTagsFromCluster(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTagsFromClusterResponse(rsp)
}

// GetTagsAssignedToClusterWithResponse request returning *GetTagsAssignedToClusterResponse
func (c *ClientWithResponses) GetTagsAssignedToClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTagsAssignedToClusterResponse, error) {
	rsp, err := c.GetTagsAssignedToCluster(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsAssignedToClusterResponse(rsp)
}

// AssignTagsToClusterWithBodyWithResponse request with arbitrary body returning *AssignTagsToClusterResponse
func (c *ClientWithResponses) AssignTagsToClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignTagsToClusterResponse, error) {
	rsp, err := c.AssignTagsToClusterWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignTagsToClusterResponse(rsp)
}

func (c *ClientWithResponses) AssignTagsToClusterWithResponse(ctx context.Context, id string, body AssignTagsToClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignTagsToClusterResponse, error) {
	rsp, err := c.AssignTagsToCluster(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignTagsToClusterResponse(rsp)
}

// GetTagAssignableForClusterWithResponse request returning *GetTagAssignableForClusterResponse
func (c *ClientWithResponses) GetTagAssignableForClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTagAssignableForClusterResponse, error) {
	rsp, err := c.GetTagAssignableForCluster(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagAssignableForClusterResponse(rsp)
}

// GetClusterTagManagerUrlWithResponse request returning *GetClusterTagManagerUrlResponse
func (c *ClientWithResponses) GetClusterTagManagerUrlWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterTagManagerUrlResponse, error) {
	rsp, err := c.GetClusterTagManagerUrl(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterTagManagerUrlResponse(rsp)
}

// ValidateClusterUpdateSpecWithBodyWithResponse request with arbitrary body returning *ValidateClusterUpdateSpecResponse
func (c *ClientWithResponses) ValidateClusterUpdateSpecWithBodyWithResponse(ctx context.Context, id string, params *ValidateClusterUpdateSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateClusterUpdateSpecResponse, error) {
	rsp, err := c.ValidateClusterUpdateSpecWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateClusterUpdateSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateClusterUpdateSpecWithResponse(ctx context.Context, id string, params *ValidateClusterUpdateSpecParams, body ValidateClusterUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateClusterUpdateSpecResponse, error) {
	rsp, err := c.ValidateClusterUpdateSpec(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateClusterUpdateSpecResponse(rsp)
}

// GetClusterUpdateValidationWithResponse request returning *GetClusterUpdateValidationResponse
func (c *ClientWithResponses) GetClusterUpdateValidationWithResponse(ctx context.Context, id openapi_types.UUID, validationId openapi_types.UUID, params *GetClusterUpdateValidationParams, reqEditors ...RequestEditorFn) (*GetClusterUpdateValidationResponse, error) {
	rsp, err := c.GetClusterUpdateValidation(ctx, id, validationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterUpdateValidationResponse(rsp)
}

// GetCompatibilityMatricesWithResponse request returning *GetCompatibilityMatricesResponse
func (c *ClientWithResponses) GetCompatibilityMatricesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompatibilityMatricesResponse, error) {
	rsp, err := c.GetCompatibilityMatrices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompatibilityMatricesResponse(rsp)
}

// UpdateCompatibilityMatrixWithBodyWithResponse request with arbitrary body returning *UpdateCompatibilityMatrixResponse
func (c *ClientWithResponses) UpdateCompatibilityMatrixWithBodyWithResponse(ctx context.Context, params *UpdateCompatibilityMatrixParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCompatibilityMatrixResponse, error) {
	rsp, err := c.UpdateCompatibilityMatrixWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCompatibilityMatrixResponse(rsp)
}

// GetCompatibilityMatrixWithResponse request returning *GetCompatibilityMatrixResponse
func (c *ClientWithResponses) GetCompatibilityMatrixWithResponse(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*GetCompatibilityMatrixResponse, error) {
	rsp, err := c.GetCompatibilityMatrix(ctx, compatibilityMatrixSource, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompatibilityMatrixResponse(rsp)
}

// GetCompatibilityMatrixContentWithResponse request returning *GetCompatibilityMatrixContentResponse
func (c *ClientWithResponses) GetCompatibilityMatrixContentWithResponse(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*GetCompatibilityMatrixContentResponse, error) {
	rsp, err := c.GetCompatibilityMatrixContent(ctx, compatibilityMatrixSource, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompatibilityMatrixContentResponse(rsp)
}

// GetCompatibilityMatrixMetadataWithResponse request returning *GetCompatibilityMatrixMetadataResponse
func (c *ClientWithResponses) GetCompatibilityMatrixMetadataWithResponse(ctx context.Context, compatibilityMatrixSource string, reqEditors ...RequestEditorFn) (*GetCompatibilityMatrixMetadataResponse, error) {
	rsp, err := c.GetCompatibilityMatrixMetadata(ctx, compatibilityMatrixSource, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompatibilityMatrixMetadataResponse(rsp)
}

// GetComplianceAuditHistoryWithResponse request returning *GetComplianceAuditHistoryResponse
func (c *ClientWithResponses) GetComplianceAuditHistoryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetComplianceAuditHistoryResponse, error) {
	rsp, err := c.GetComplianceAuditHistory(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplianceAuditHistoryResponse(rsp)
}

// GetComplianceAuditWithResponse request returning *GetComplianceAuditResponse
func (c *ClientWithResponses) GetComplianceAuditWithResponse(ctx context.Context, complianceAuditId string, reqEditors ...RequestEditorFn) (*GetComplianceAuditResponse, error) {
	rsp, err := c.GetComplianceAudit(ctx, complianceAuditId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplianceAuditResponse(rsp)
}

// GetComplianceAuditItemsWithResponse request returning *GetComplianceAuditItemsResponse
func (c *ClientWithResponses) GetComplianceAuditItemsWithResponse(ctx context.Context, complianceAuditId string, reqEditors ...RequestEditorFn) (*GetComplianceAuditItemsResponse, error) {
	rsp, err := c.GetComplianceAuditItems(ctx, complianceAuditId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplianceAuditItemsResponse(rsp)
}

// GetComplianceConfigurationsWithResponse request returning *GetComplianceConfigurationsResponse
func (c *ClientWithResponses) GetComplianceConfigurationsWithResponse(ctx context.Context, params *GetComplianceConfigurationsParams, reqEditors ...RequestEditorFn) (*GetComplianceConfigurationsResponse, error) {
	rsp, err := c.GetComplianceConfigurations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplianceConfigurationsResponse(rsp)
}

// GetComplianceStandardsWithResponse request returning *GetComplianceStandardsResponse
func (c *ClientWithResponses) GetComplianceStandardsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetComplianceStandardsResponse, error) {
	rsp, err := c.GetComplianceStandards(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplianceStandardsResponse(rsp)
}

// ReconcileConfigsWithBodyWithResponse request with arbitrary body returning *ReconcileConfigsResponse
func (c *ClientWithResponses) ReconcileConfigsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReconcileConfigsResponse, error) {
	rsp, err := c.ReconcileConfigsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReconcileConfigsResponse(rsp)
}

func (c *ClientWithResponses) ReconcileConfigsWithResponse(ctx context.Context, body ReconcileConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReconcileConfigsResponse, error) {
	rsp, err := c.ReconcileConfigs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReconcileConfigsResponse(rsp)
}

// GetReconciliationTaskWithResponse request returning *GetReconciliationTaskResponse
func (c *ClientWithResponses) GetReconciliationTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetReconciliationTaskResponse, error) {
	rsp, err := c.GetReconciliationTask(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReconciliationTaskResponse(rsp)
}

// GetConfigsWithResponse request returning *GetConfigsResponse
func (c *ClientWithResponses) GetConfigsWithResponse(ctx context.Context, params *GetConfigsParams, reqEditors ...RequestEditorFn) (*GetConfigsResponse, error) {
	rsp, err := c.GetConfigs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigsResponse(rsp)
}

// GetCredentialsWithResponse request returning *GetCredentialsResponse
func (c *ClientWithResponses) GetCredentialsWithResponse(ctx context.Context, params *GetCredentialsParams, reqEditors ...RequestEditorFn) (*GetCredentialsResponse, error) {
	rsp, err := c.GetCredentials(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialsResponse(rsp)
}

// UpdateOrRotatePasswordsWithBodyWithResponse request with arbitrary body returning *UpdateOrRotatePasswordsResponse
func (c *ClientWithResponses) UpdateOrRotatePasswordsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrRotatePasswordsResponse, error) {
	rsp, err := c.UpdateOrRotatePasswordsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrRotatePasswordsResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrRotatePasswordsWithResponse(ctx context.Context, body UpdateOrRotatePasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrRotatePasswordsResponse, error) {
	rsp, err := c.UpdateOrRotatePasswords(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrRotatePasswordsResponse(rsp)
}

// GetPasswordExpirationWithBodyWithResponse request with arbitrary body returning *GetPasswordExpirationResponse
func (c *ClientWithResponses) GetPasswordExpirationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPasswordExpirationResponse, error) {
	rsp, err := c.GetPasswordExpirationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPasswordExpirationResponse(rsp)
}

func (c *ClientWithResponses) GetPasswordExpirationWithResponse(ctx context.Context, body GetPasswordExpirationJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPasswordExpirationResponse, error) {
	rsp, err := c.GetPasswordExpiration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPasswordExpirationResponse(rsp)
}

// GetPasswordExpirationByTaskIDWithResponse request returning *GetPasswordExpirationByTaskIDResponse
func (c *ClientWithResponses) GetPasswordExpirationByTaskIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPasswordExpirationByTaskIDResponse, error) {
	rsp, err := c.GetPasswordExpirationByTaskID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPasswordExpirationByTaskIDResponse(rsp)
}

// GetCredentialsTasksWithResponse request returning *GetCredentialsTasksResponse
func (c *ClientWithResponses) GetCredentialsTasksWithResponse(ctx context.Context, params *GetCredentialsTasksParams, reqEditors ...RequestEditorFn) (*GetCredentialsTasksResponse, error) {
	rsp, err := c.GetCredentialsTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialsTasksResponse(rsp)
}

// CancelCredentialsTaskWithResponse request returning *CancelCredentialsTaskResponse
func (c *ClientWithResponses) CancelCredentialsTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CancelCredentialsTaskResponse, error) {
	rsp, err := c.CancelCredentialsTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelCredentialsTaskResponse(rsp)
}

// GetCredentialsTaskWithResponse request returning *GetCredentialsTaskResponse
func (c *ClientWithResponses) GetCredentialsTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCredentialsTaskResponse, error) {
	rsp, err := c.GetCredentialsTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialsTaskResponse(rsp)
}

// RetryCredentialsTaskWithBodyWithResponse request with arbitrary body returning *RetryCredentialsTaskResponse
func (c *ClientWithResponses) RetryCredentialsTaskWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RetryCredentialsTaskResponse, error) {
	rsp, err := c.RetryCredentialsTaskWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryCredentialsTaskResponse(rsp)
}

func (c *ClientWithResponses) RetryCredentialsTaskWithResponse(ctx context.Context, id string, body RetryCredentialsTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*RetryCredentialsTaskResponse, error) {
	rsp, err := c.RetryCredentialsTask(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryCredentialsTaskResponse(rsp)
}

// GetCredentialTaskByResourceIDWithResponse request returning *GetCredentialTaskByResourceIDResponse
func (c *ClientWithResponses) GetCredentialTaskByResourceIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCredentialTaskByResourceIDResponse, error) {
	rsp, err := c.GetCredentialTaskByResourceID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialTaskByResourceIDResponse(rsp)
}

// GetCredentialsSubTaskWithResponse request returning *GetCredentialsSubTaskResponse
func (c *ClientWithResponses) GetCredentialsSubTaskWithResponse(ctx context.Context, id string, subtaskId string, reqEditors ...RequestEditorFn) (*GetCredentialsSubTaskResponse, error) {
	rsp, err := c.GetCredentialsSubTask(ctx, id, subtaskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialsSubTaskResponse(rsp)
}

// GetCredentialWithResponse request returning *GetCredentialResponse
func (c *ClientWithResponses) GetCredentialWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCredentialResponse, error) {
	rsp, err := c.GetCredential(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialResponse(rsp)
}

// GetCustomIsosWithResponse request returning *GetCustomIsosResponse
func (c *ClientWithResponses) GetCustomIsosWithResponse(ctx context.Context, params *GetCustomIsosParams, reqEditors ...RequestEditorFn) (*GetCustomIsosResponse, error) {
	rsp, err := c.GetCustomIsos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomIsosResponse(rsp)
}

// UploadCustomIsoWithBodyWithResponse request with arbitrary body returning *UploadCustomIsoResponse
func (c *ClientWithResponses) UploadCustomIsoWithBodyWithResponse(ctx context.Context, params *UploadCustomIsoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCustomIsoResponse, error) {
	rsp, err := c.UploadCustomIsoWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadCustomIsoResponse(rsp)
}

// DeleteCustomIsoByIdWithResponse request returning *DeleteCustomIsoByIdResponse
func (c *ClientWithResponses) DeleteCustomIsoByIdWithResponse(ctx context.Context, customIsoId string, reqEditors ...RequestEditorFn) (*DeleteCustomIsoByIdResponse, error) {
	rsp, err := c.DeleteCustomIsoById(ctx, customIsoId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomIsoByIdResponse(rsp)
}

// GetCustomIsoByIdWithResponse request returning *GetCustomIsoByIdResponse
func (c *ClientWithResponses) GetCustomIsoByIdWithResponse(ctx context.Context, customIsoId string, reqEditors ...RequestEditorFn) (*GetCustomIsoByIdResponse, error) {
	rsp, err := c.GetCustomIsoById(ctx, customIsoId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomIsoByIdResponse(rsp)
}

// RenameCustomIsoByIdWithBodyWithResponse request with arbitrary body returning *RenameCustomIsoByIdResponse
func (c *ClientWithResponses) RenameCustomIsoByIdWithBodyWithResponse(ctx context.Context, customIsoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameCustomIsoByIdResponse, error) {
	rsp, err := c.RenameCustomIsoByIdWithBody(ctx, customIsoId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameCustomIsoByIdResponse(rsp)
}

func (c *ClientWithResponses) RenameCustomIsoByIdWithResponse(ctx context.Context, customIsoId string, body RenameCustomIsoByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameCustomIsoByIdResponse, error) {
	rsp, err := c.RenameCustomIsoById(ctx, customIsoId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameCustomIsoByIdResponse(rsp)
}

// GetDomainsWithResponse request returning *GetDomainsResponse
func (c *ClientWithResponses) GetDomainsWithResponse(ctx context.Context, params *GetDomainsParams, reqEditors ...RequestEditorFn) (*GetDomainsResponse, error) {
	rsp, err := c.GetDomains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainsResponse(rsp)
}

// CreateDomainWithBodyWithResponse request with arbitrary body returning *CreateDomainResponse
func (c *ClientWithResponses) CreateDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error) {
	rsp, err := c.CreateDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainResponse(rsp)
}

func (c *ClientWithResponses) CreateDomainWithResponse(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error) {
	rsp, err := c.CreateDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainResponse(rsp)
}

// GetTagsAssignedToDomainsWithResponse request returning *GetTagsAssignedToDomainsResponse
func (c *ClientWithResponses) GetTagsAssignedToDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsAssignedToDomainsResponse, error) {
	rsp, err := c.GetTagsAssignedToDomains(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsAssignedToDomainsResponse(rsp)
}

// ValidateDomainCreationSpecWithBodyWithResponse request with arbitrary body returning *ValidateDomainCreationSpecResponse
func (c *ClientWithResponses) ValidateDomainCreationSpecWithBodyWithResponse(ctx context.Context, params *ValidateDomainCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateDomainCreationSpecResponse, error) {
	rsp, err := c.ValidateDomainCreationSpecWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateDomainCreationSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateDomainCreationSpecWithResponse(ctx context.Context, params *ValidateDomainCreationSpecParams, body ValidateDomainCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateDomainCreationSpecResponse, error) {
	rsp, err := c.ValidateDomainCreationSpec(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateDomainCreationSpecResponse(rsp)
}

// DomainCreateValidationWithResponse request returning *DomainCreateValidationResponse
func (c *ClientWithResponses) DomainCreateValidationWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DomainCreateValidationResponse, error) {
	rsp, err := c.DomainCreateValidation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDomainCreateValidationResponse(rsp)
}

// GetClusterCriteriaWithResponse request returning *GetClusterCriteriaResponse
func (c *ClientWithResponses) GetClusterCriteriaWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetClusterCriteriaResponse, error) {
	rsp, err := c.GetClusterCriteria(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterCriteriaResponse(rsp)
}

// GetClusterCriterionWithResponse request returning *GetClusterCriterionResponse
func (c *ClientWithResponses) GetClusterCriterionWithResponse(ctx context.Context, domainId string, name string, reqEditors ...RequestEditorFn) (*GetClusterCriterionResponse, error) {
	rsp, err := c.GetClusterCriterion(ctx, domainId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterCriterionResponse(rsp)
}

// PostClustersQueryWithBodyWithResponse request with arbitrary body returning *PostClustersQueryResponse
func (c *ClientWithResponses) PostClustersQueryWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClustersQueryResponse, error) {
	rsp, err := c.PostClustersQueryWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClustersQueryResponse(rsp)
}

func (c *ClientWithResponses) PostClustersQueryWithResponse(ctx context.Context, domainId string, body PostClustersQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClustersQueryResponse, error) {
	rsp, err := c.PostClustersQuery(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClustersQueryResponse(rsp)
}

// GetClustersQueryResponseWithResponse request returning *GetClustersQueryResponseResponse
func (c *ClientWithResponses) GetClustersQueryResponseWithResponse(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*GetClustersQueryResponseResponse, error) {
	rsp, err := c.GetClustersQueryResponse(ctx, domainId, queryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClustersQueryResponseResponse(rsp)
}

// PostClusterQueryWithBodyWithResponse request with arbitrary body returning *PostClusterQueryResponse
func (c *ClientWithResponses) PostClusterQueryWithBodyWithResponse(ctx context.Context, domainId string, clusterName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClusterQueryResponse, error) {
	rsp, err := c.PostClusterQueryWithBody(ctx, domainId, clusterName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClusterQueryResponse(rsp)
}

func (c *ClientWithResponses) PostClusterQueryWithResponse(ctx context.Context, domainId string, clusterName string, body PostClusterQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClusterQueryResponse, error) {
	rsp, err := c.PostClusterQuery(ctx, domainId, clusterName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClusterQueryResponse(rsp)
}

// GetClusterQueryResponseWithResponse request returning *GetClusterQueryResponseResponse
func (c *ClientWithResponses) GetClusterQueryResponseWithResponse(ctx context.Context, domainId string, clusterName string, queryId string, reqEditors ...RequestEditorFn) (*GetClusterQueryResponseResponse, error) {
	rsp, err := c.GetClusterQueryResponse(ctx, domainId, clusterName, queryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterQueryResponseResponse(rsp)
}

// GetDatastoresCriteriaWithResponse request returning *GetDatastoresCriteriaResponse
func (c *ClientWithResponses) GetDatastoresCriteriaWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetDatastoresCriteriaResponse, error) {
	rsp, err := c.GetDatastoresCriteria(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatastoresCriteriaResponse(rsp)
}

// GetDatastoreCriterionWithResponse request returning *GetDatastoreCriterionResponse
func (c *ClientWithResponses) GetDatastoreCriterionWithResponse(ctx context.Context, domainId string, name string, reqEditors ...RequestEditorFn) (*GetDatastoreCriterionResponse, error) {
	rsp, err := c.GetDatastoreCriterion(ctx, domainId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatastoreCriterionResponse(rsp)
}

// PostDatastoreQueryWithBodyWithResponse request with arbitrary body returning *PostDatastoreQueryResponse
func (c *ClientWithResponses) PostDatastoreQueryWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDatastoreQueryResponse, error) {
	rsp, err := c.PostDatastoreQueryWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDatastoreQueryResponse(rsp)
}

func (c *ClientWithResponses) PostDatastoreQueryWithResponse(ctx context.Context, domainId string, body PostDatastoreQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDatastoreQueryResponse, error) {
	rsp, err := c.PostDatastoreQuery(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDatastoreQueryResponse(rsp)
}

// GetDatastoreQueryResponseWithResponse request returning *GetDatastoreQueryResponseResponse
func (c *ClientWithResponses) GetDatastoreQueryResponseWithResponse(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*GetDatastoreQueryResponseResponse, error) {
	rsp, err := c.GetDatastoreQueryResponse(ctx, domainId, queryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatastoreQueryResponseResponse(rsp)
}

// GetVsanHealthCheckByDomainWithResponse request returning *GetVsanHealthCheckByDomainResponse
func (c *ClientWithResponses) GetVsanHealthCheckByDomainWithResponse(ctx context.Context, domainId string, params *GetVsanHealthCheckByDomainParams, reqEditors ...RequestEditorFn) (*GetVsanHealthCheckByDomainResponse, error) {
	rsp, err := c.GetVsanHealthCheckByDomain(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVsanHealthCheckByDomainResponse(rsp)
}

// UpdateVsanHealthCheckByDomainWithBodyWithResponse request with arbitrary body returning *UpdateVsanHealthCheckByDomainResponse
func (c *ClientWithResponses) UpdateVsanHealthCheckByDomainWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVsanHealthCheckByDomainResponse, error) {
	rsp, err := c.UpdateVsanHealthCheckByDomainWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVsanHealthCheckByDomainResponse(rsp)
}

func (c *ClientWithResponses) UpdateVsanHealthCheckByDomainWithResponse(ctx context.Context, domainId string, body UpdateVsanHealthCheckByDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVsanHealthCheckByDomainResponse, error) {
	rsp, err := c.UpdateVsanHealthCheckByDomain(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVsanHealthCheckByDomainResponse(rsp)
}

// GetVsanHealthCheckByQueryIDWithResponse request returning *GetVsanHealthCheckByQueryIDResponse
func (c *ClientWithResponses) GetVsanHealthCheckByQueryIDWithResponse(ctx context.Context, domainId string, queryId string, reqEditors ...RequestEditorFn) (*GetVsanHealthCheckByQueryIDResponse, error) {
	rsp, err := c.GetVsanHealthCheckByQueryID(ctx, domainId, queryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVsanHealthCheckByQueryIDResponse(rsp)
}

// GetVsanHealthCheckByTaskIDWithResponse request returning *GetVsanHealthCheckByTaskIDResponse
func (c *ClientWithResponses) GetVsanHealthCheckByTaskIDWithResponse(ctx context.Context, domainId string, taskId string, reqEditors ...RequestEditorFn) (*GetVsanHealthCheckByTaskIDResponse, error) {
	rsp, err := c.GetVsanHealthCheckByTaskID(ctx, domainId, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVsanHealthCheckByTaskIDResponse(rsp)
}

// PerformDomainIsolationPrecheckWithBodyWithResponse request with arbitrary body returning *PerformDomainIsolationPrecheckResponse
func (c *ClientWithResponses) PerformDomainIsolationPrecheckWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PerformDomainIsolationPrecheckResponse, error) {
	rsp, err := c.PerformDomainIsolationPrecheckWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePerformDomainIsolationPrecheckResponse(rsp)
}

func (c *ClientWithResponses) PerformDomainIsolationPrecheckWithResponse(ctx context.Context, domainId string, body PerformDomainIsolationPrecheckJSONRequestBody, reqEditors ...RequestEditorFn) (*PerformDomainIsolationPrecheckResponse, error) {
	rsp, err := c.PerformDomainIsolationPrecheck(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePerformDomainIsolationPrecheckResponse(rsp)
}

// GetDomainIsolationPrecheckStatusWithResponse request returning *GetDomainIsolationPrecheckStatusResponse
func (c *ClientWithResponses) GetDomainIsolationPrecheckStatusWithResponse(ctx context.Context, domainId string, precheckId string, reqEditors ...RequestEditorFn) (*GetDomainIsolationPrecheckStatusResponse, error) {
	rsp, err := c.GetDomainIsolationPrecheckStatus(ctx, domainId, precheckId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainIsolationPrecheckStatusResponse(rsp)
}

// DeleteDomainWithResponse request returning *DeleteDomainResponse
func (c *ClientWithResponses) DeleteDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDomainResponse, error) {
	rsp, err := c.DeleteDomain(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDomainResponse(rsp)
}

// GetDomainWithResponse request returning *GetDomainResponse
func (c *ClientWithResponses) GetDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDomainResponse, error) {
	rsp, err := c.GetDomain(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainResponse(rsp)
}

// UpdateDomainWithBodyWithResponse request with arbitrary body returning *UpdateDomainResponse
func (c *ClientWithResponses) UpdateDomainWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error) {
	rsp, err := c.UpdateDomainWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainResponse(rsp)
}

func (c *ClientWithResponses) UpdateDomainWithResponse(ctx context.Context, id string, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error) {
	rsp, err := c.UpdateDomain(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainResponse(rsp)
}

// GetDomainCertificatesWithResponse request returning *GetDomainCertificatesResponse
func (c *ClientWithResponses) GetDomainCertificatesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDomainCertificatesResponse, error) {
	rsp, err := c.GetDomainCertificates(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainCertificatesResponse(rsp)
}

// ReplaceCertificatesWithBodyWithResponse request with arbitrary body returning *ReplaceCertificatesResponse
func (c *ClientWithResponses) ReplaceCertificatesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCertificatesResponse, error) {
	rsp, err := c.ReplaceCertificatesWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCertificatesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceCertificatesWithResponse(ctx context.Context, id string, body ReplaceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCertificatesResponse, error) {
	rsp, err := c.ReplaceCertificates(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCertificatesResponse(rsp)
}

// GenerateCertificatesWithBodyWithResponse request with arbitrary body returning *GenerateCertificatesResponse
func (c *ClientWithResponses) GenerateCertificatesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateCertificatesResponse, error) {
	rsp, err := c.GenerateCertificatesWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateCertificatesResponse(rsp)
}

func (c *ClientWithResponses) GenerateCertificatesWithResponse(ctx context.Context, id string, body GenerateCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateCertificatesResponse, error) {
	rsp, err := c.GenerateCertificates(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateCertificatesResponse(rsp)
}

// UploadCertificatesWithBodyWithResponse request with arbitrary body returning *UploadCertificatesResponse
func (c *ClientWithResponses) UploadCertificatesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCertificatesResponse, error) {
	rsp, err := c.UploadCertificatesWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadCertificatesResponse(rsp)
}

// GetComplianceAuditHistoryForADomainWithResponse request returning *GetComplianceAuditHistoryForADomainResponse
func (c *ClientWithResponses) GetComplianceAuditHistoryForADomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetComplianceAuditHistoryForADomainResponse, error) {
	rsp, err := c.GetComplianceAuditHistoryForADomain(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplianceAuditHistoryForADomainResponse(rsp)
}

// ComplianceAuditWithBodyWithResponse request with arbitrary body returning *ComplianceAuditResponse
func (c *ClientWithResponses) ComplianceAuditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ComplianceAuditResponse, error) {
	rsp, err := c.ComplianceAuditWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseComplianceAuditResponse(rsp)
}

func (c *ClientWithResponses) ComplianceAuditWithResponse(ctx context.Context, id string, body ComplianceAuditJSONRequestBody, reqEditors ...RequestEditorFn) (*ComplianceAuditResponse, error) {
	rsp, err := c.ComplianceAudit(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseComplianceAuditResponse(rsp)
}

// GetComplianceAuditTaskWithResponse request returning *GetComplianceAuditTaskResponse
func (c *ClientWithResponses) GetComplianceAuditTaskWithResponse(ctx context.Context, id string, taskId string, reqEditors ...RequestEditorFn) (*GetComplianceAuditTaskResponse, error) {
	rsp, err := c.GetComplianceAuditTask(ctx, id, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplianceAuditTaskResponse(rsp)
}

// RetryComplianceAuditTaskWithResponse request returning *RetryComplianceAuditTaskResponse
func (c *ClientWithResponses) RetryComplianceAuditTaskWithResponse(ctx context.Context, id string, taskId string, reqEditors ...RequestEditorFn) (*RetryComplianceAuditTaskResponse, error) {
	rsp, err := c.RetryComplianceAuditTask(ctx, id, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryComplianceAuditTaskResponse(rsp)
}

// GetComplianceAuditForADomainWithResponse request returning *GetComplianceAuditForADomainResponse
func (c *ClientWithResponses) GetComplianceAuditForADomainWithResponse(ctx context.Context, id string, complianceAuditId string, reqEditors ...RequestEditorFn) (*GetComplianceAuditForADomainResponse, error) {
	rsp, err := c.GetComplianceAuditForADomain(ctx, id, complianceAuditId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplianceAuditForADomainResponse(rsp)
}

// GetComplianceAuditItemsForADomainWithResponse request returning *GetComplianceAuditItemsForADomainResponse
func (c *ClientWithResponses) GetComplianceAuditItemsForADomainWithResponse(ctx context.Context, id string, complianceAuditId string, reqEditors ...RequestEditorFn) (*GetComplianceAuditItemsForADomainResponse, error) {
	rsp, err := c.GetComplianceAuditItemsForADomain(ctx, id, complianceAuditId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplianceAuditItemsForADomainResponse(rsp)
}

// GetCSRsWithResponse request returning *GetCSRsResponse
func (c *ClientWithResponses) GetCSRsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCSRsResponse, error) {
	rsp, err := c.GetCSRs(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCSRsResponse(rsp)
}

// GeneratesCSRsWithBodyWithResponse request with arbitrary body returning *GeneratesCSRsResponse
func (c *ClientWithResponses) GeneratesCSRsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GeneratesCSRsResponse, error) {
	rsp, err := c.GeneratesCSRsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneratesCSRsResponse(rsp)
}

func (c *ClientWithResponses) GeneratesCSRsWithResponse(ctx context.Context, id string, body GeneratesCSRsJSONRequestBody, reqEditors ...RequestEditorFn) (*GeneratesCSRsResponse, error) {
	rsp, err := c.GeneratesCSRs(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeneratesCSRsResponse(rsp)
}

// DownloadCSRWithResponse request returning *DownloadCSRResponse
func (c *ClientWithResponses) DownloadCSRWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DownloadCSRResponse, error) {
	rsp, err := c.DownloadCSR(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadCSRResponse(rsp)
}

// GetDomainEndpointsWithResponse request returning *GetDomainEndpointsResponse
func (c *ClientWithResponses) GetDomainEndpointsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDomainEndpointsResponse, error) {
	rsp, err := c.GetDomainEndpoints(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEndpointsResponse(rsp)
}

// GetCertificatesByDomainWithResponse request returning *GetCertificatesByDomainResponse
func (c *ClientWithResponses) GetCertificatesByDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCertificatesByDomainResponse, error) {
	rsp, err := c.GetCertificatesByDomain(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertificatesByDomainResponse(rsp)
}

// ReplaceResourceCertificatesWithBodyWithResponse request with arbitrary body returning *ReplaceResourceCertificatesResponse
func (c *ClientWithResponses) ReplaceResourceCertificatesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceResourceCertificatesResponse, error) {
	rsp, err := c.ReplaceResourceCertificatesWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceResourceCertificatesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceResourceCertificatesWithResponse(ctx context.Context, id string, body ReplaceResourceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceResourceCertificatesResponse, error) {
	rsp, err := c.ReplaceResourceCertificates(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceResourceCertificatesResponse(rsp)
}

// ValidateResourceCertificatesWithBodyWithResponse request with arbitrary body returning *ValidateResourceCertificatesResponse
func (c *ClientWithResponses) ValidateResourceCertificatesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateResourceCertificatesResponse, error) {
	rsp, err := c.ValidateResourceCertificatesWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateResourceCertificatesResponse(rsp)
}

func (c *ClientWithResponses) ValidateResourceCertificatesWithResponse(ctx context.Context, id string, body ValidateResourceCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateResourceCertificatesResponse, error) {
	rsp, err := c.ValidateResourceCertificates(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateResourceCertificatesResponse(rsp)
}

// GetResourceCertificatesValidationByIDWithResponse request returning *GetResourceCertificatesValidationByIDResponse
func (c *ClientWithResponses) GetResourceCertificatesValidationByIDWithResponse(ctx context.Context, id string, validationId string, reqEditors ...RequestEditorFn) (*GetResourceCertificatesValidationByIDResponse, error) {
	rsp, err := c.GetResourceCertificatesValidationByID(ctx, id, validationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceCertificatesValidationByIDResponse(rsp)
}

// RemoveTagsFromDomainWithBodyWithResponse request with arbitrary body returning *RemoveTagsFromDomainResponse
func (c *ClientWithResponses) RemoveTagsFromDomainWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTagsFromDomainResponse, error) {
	rsp, err := c.RemoveTagsFromDomainWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTagsFromDomainResponse(rsp)
}

func (c *ClientWithResponses) RemoveTagsFromDomainWithResponse(ctx context.Context, id string, body RemoveTagsFromDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTagsFromDomainResponse, error) {
	rsp, err := c.RemoveTagsFromDomain(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTagsFromDomainResponse(rsp)
}

// GetTagsAssignedToDomainWithResponse request returning *GetTagsAssignedToDomainResponse
func (c *ClientWithResponses) GetTagsAssignedToDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTagsAssignedToDomainResponse, error) {
	rsp, err := c.GetTagsAssignedToDomain(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsAssignedToDomainResponse(rsp)
}

// AssignTagsToDomainWithBodyWithResponse request with arbitrary body returning *AssignTagsToDomainResponse
func (c *ClientWithResponses) AssignTagsToDomainWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignTagsToDomainResponse, error) {
	rsp, err := c.AssignTagsToDomainWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignTagsToDomainResponse(rsp)
}

func (c *ClientWithResponses) AssignTagsToDomainWithResponse(ctx context.Context, id string, body AssignTagsToDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignTagsToDomainResponse, error) {
	rsp, err := c.AssignTagsToDomain(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignTagsToDomainResponse(rsp)
}

// GetAssignableTagsForDomainWithResponse request returning *GetAssignableTagsForDomainResponse
func (c *ClientWithResponses) GetAssignableTagsForDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAssignableTagsForDomainResponse, error) {
	rsp, err := c.GetAssignableTagsForDomain(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssignableTagsForDomainResponse(rsp)
}

// GetDomainTagManagerUrlWithResponse request returning *GetDomainTagManagerUrlResponse
func (c *ClientWithResponses) GetDomainTagManagerUrlWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDomainTagManagerUrlResponse, error) {
	rsp, err := c.GetDomainTagManagerUrl(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainTagManagerUrlResponse(rsp)
}

// ValidateDomainUpdateSpecWithBodyWithResponse request with arbitrary body returning *ValidateDomainUpdateSpecResponse
func (c *ClientWithResponses) ValidateDomainUpdateSpecWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateDomainUpdateSpecResponse, error) {
	rsp, err := c.ValidateDomainUpdateSpecWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateDomainUpdateSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateDomainUpdateSpecWithResponse(ctx context.Context, id string, body ValidateDomainUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateDomainUpdateSpecResponse, error) {
	rsp, err := c.ValidateDomainUpdateSpec(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateDomainUpdateSpecResponse(rsp)
}

// GetDomainUpdateValidationWithResponse request returning *GetDomainUpdateValidationResponse
func (c *ClientWithResponses) GetDomainUpdateValidationWithResponse(ctx context.Context, id openapi_types.UUID, validationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDomainUpdateValidationResponse, error) {
	rsp, err := c.GetDomainUpdateValidation(ctx, id, validationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainUpdateValidationResponse(rsp)
}

// GetEdgeClustersWithResponse request returning *GetEdgeClustersResponse
func (c *ClientWithResponses) GetEdgeClustersWithResponse(ctx context.Context, params *GetEdgeClustersParams, reqEditors ...RequestEditorFn) (*GetEdgeClustersResponse, error) {
	rsp, err := c.GetEdgeClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeClustersResponse(rsp)
}

// CreateEdgeClusterWithBodyWithResponse request with arbitrary body returning *CreateEdgeClusterResponse
func (c *ClientWithResponses) CreateEdgeClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEdgeClusterResponse, error) {
	rsp, err := c.CreateEdgeClusterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEdgeClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateEdgeClusterWithResponse(ctx context.Context, body CreateEdgeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEdgeClusterResponse, error) {
	rsp, err := c.CreateEdgeCluster(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEdgeClusterResponse(rsp)
}

// ValidateEdgeClusterCreationSpecWithBodyWithResponse request with arbitrary body returning *ValidateEdgeClusterCreationSpecResponse
func (c *ClientWithResponses) ValidateEdgeClusterCreationSpecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateEdgeClusterCreationSpecResponse, error) {
	rsp, err := c.ValidateEdgeClusterCreationSpecWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateEdgeClusterCreationSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateEdgeClusterCreationSpecWithResponse(ctx context.Context, body ValidateEdgeClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateEdgeClusterCreationSpecResponse, error) {
	rsp, err := c.ValidateEdgeClusterCreationSpec(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateEdgeClusterCreationSpecResponse(rsp)
}

// GetEdgeClusterValidationByIDWithResponse request returning *GetEdgeClusterValidationByIDResponse
func (c *ClientWithResponses) GetEdgeClusterValidationByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEdgeClusterValidationByIDResponse, error) {
	rsp, err := c.GetEdgeClusterValidationByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeClusterValidationByIDResponse(rsp)
}

// GetEdgeClusterQueryCriteriaWithResponse request returning *GetEdgeClusterQueryCriteriaResponse
func (c *ClientWithResponses) GetEdgeClusterQueryCriteriaWithResponse(ctx context.Context, edgeClusterId string, reqEditors ...RequestEditorFn) (*GetEdgeClusterQueryCriteriaResponse, error) {
	rsp, err := c.GetEdgeClusterQueryCriteria(ctx, edgeClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeClusterQueryCriteriaResponse(rsp)
}

// GetEdgeClusterWithResponse request returning *GetEdgeClusterResponse
func (c *ClientWithResponses) GetEdgeClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEdgeClusterResponse, error) {
	rsp, err := c.GetEdgeCluster(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeClusterResponse(rsp)
}

// UpdateEdgeClusterWithBodyWithResponse request with arbitrary body returning *UpdateEdgeClusterResponse
func (c *ClientWithResponses) UpdateEdgeClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEdgeClusterResponse, error) {
	rsp, err := c.UpdateEdgeClusterWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEdgeClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateEdgeClusterWithResponse(ctx context.Context, id string, body UpdateEdgeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEdgeClusterResponse, error) {
	rsp, err := c.UpdateEdgeCluster(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEdgeClusterResponse(rsp)
}

// ValidateEdgeClusterUpdateSpecWithBodyWithResponse request with arbitrary body returning *ValidateEdgeClusterUpdateSpecResponse
func (c *ClientWithResponses) ValidateEdgeClusterUpdateSpecWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateEdgeClusterUpdateSpecResponse, error) {
	rsp, err := c.ValidateEdgeClusterUpdateSpecWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateEdgeClusterUpdateSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateEdgeClusterUpdateSpecWithResponse(ctx context.Context, id string, body ValidateEdgeClusterUpdateSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateEdgeClusterUpdateSpecResponse, error) {
	rsp, err := c.ValidateEdgeClusterUpdateSpec(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateEdgeClusterUpdateSpecResponse(rsp)
}

// DecommissionHostsWithBodyWithResponse request with arbitrary body returning *DecommissionHostsResponse
func (c *ClientWithResponses) DecommissionHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DecommissionHostsResponse, error) {
	rsp, err := c.DecommissionHostsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDecommissionHostsResponse(rsp)
}

func (c *ClientWithResponses) DecommissionHostsWithResponse(ctx context.Context, body DecommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*DecommissionHostsResponse, error) {
	rsp, err := c.DecommissionHosts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDecommissionHostsResponse(rsp)
}

// GetHostsWithResponse request returning *GetHostsResponse
func (c *ClientWithResponses) GetHostsWithResponse(ctx context.Context, params *GetHostsParams, reqEditors ...RequestEditorFn) (*GetHostsResponse, error) {
	rsp, err := c.GetHosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostsResponse(rsp)
}

// CommissionHostsWithBodyWithResponse request with arbitrary body returning *CommissionHostsResponse
func (c *ClientWithResponses) CommissionHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommissionHostsResponse, error) {
	rsp, err := c.CommissionHostsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommissionHostsResponse(rsp)
}

func (c *ClientWithResponses) CommissionHostsWithResponse(ctx context.Context, body CommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*CommissionHostsResponse, error) {
	rsp, err := c.CommissionHosts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommissionHostsResponse(rsp)
}

// GetCriteriaWithResponse request returning *GetCriteriaResponse
func (c *ClientWithResponses) GetCriteriaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCriteriaResponse, error) {
	rsp, err := c.GetCriteria(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCriteriaResponse(rsp)
}

// GetCriterionWithResponse request returning *GetCriterionResponse
func (c *ClientWithResponses) GetCriterionWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetCriterionResponse, error) {
	rsp, err := c.GetCriterion(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCriterionResponse(rsp)
}

// PostHostsPrechecks1WithBodyWithResponse request with arbitrary body returning *PostHostsPrechecks1Response
func (c *ClientWithResponses) PostHostsPrechecks1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHostsPrechecks1Response, error) {
	rsp, err := c.PostHostsPrechecks1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHostsPrechecks1Response(rsp)
}

func (c *ClientWithResponses) PostHostsPrechecks1WithResponse(ctx context.Context, body PostHostsPrechecks1JSONRequestBody, reqEditors ...RequestEditorFn) (*PostHostsPrechecks1Response, error) {
	rsp, err := c.PostHostsPrechecks1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHostsPrechecks1Response(rsp)
}

// GetHostsPrechecksResponseWithResponse request returning *GetHostsPrechecksResponseResponse
func (c *ClientWithResponses) GetHostsPrechecksResponseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostsPrechecksResponseResponse, error) {
	rsp, err := c.GetHostsPrechecksResponse(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostsPrechecksResponseResponse(rsp)
}

// PostQueryWithBodyWithResponse request with arbitrary body returning *PostQueryResponse
func (c *ClientWithResponses) PostQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostQueryResponse, error) {
	rsp, err := c.PostQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostQueryResponse(rsp)
}

func (c *ClientWithResponses) PostQueryWithResponse(ctx context.Context, body PostQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostQueryResponse, error) {
	rsp, err := c.PostQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostQueryResponse(rsp)
}

// GetHostQueryResponseWithResponse request returning *GetHostQueryResponseResponse
func (c *ClientWithResponses) GetHostQueryResponseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostQueryResponseResponse, error) {
	rsp, err := c.GetHostQueryResponse(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostQueryResponseResponse(rsp)
}

// GetTagsAssignedToHostsWithResponse request returning *GetTagsAssignedToHostsResponse
func (c *ClientWithResponses) GetTagsAssignedToHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsAssignedToHostsResponse, error) {
	rsp, err := c.GetTagsAssignedToHosts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsAssignedToHostsResponse(rsp)
}

// ValidateHostCommissionSpecWithBodyWithResponse request with arbitrary body returning *ValidateHostCommissionSpecResponse
func (c *ClientWithResponses) ValidateHostCommissionSpecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateHostCommissionSpecResponse, error) {
	rsp, err := c.ValidateHostCommissionSpecWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateHostCommissionSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateHostCommissionSpecWithResponse(ctx context.Context, body ValidateHostCommissionSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateHostCommissionSpecResponse, error) {
	rsp, err := c.ValidateHostCommissionSpec(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateHostCommissionSpecResponse(rsp)
}

// ValidateCommissionHostsWithBodyWithResponse request with arbitrary body returning *ValidateCommissionHostsResponse
func (c *ClientWithResponses) ValidateCommissionHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateCommissionHostsResponse, error) {
	rsp, err := c.ValidateCommissionHostsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateCommissionHostsResponse(rsp)
}

func (c *ClientWithResponses) ValidateCommissionHostsWithResponse(ctx context.Context, body ValidateCommissionHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateCommissionHostsResponse, error) {
	rsp, err := c.ValidateCommissionHosts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateCommissionHostsResponse(rsp)
}

// GetHostCommissionValidationByIDWithResponse request returning *GetHostCommissionValidationByIDResponse
func (c *ClientWithResponses) GetHostCommissionValidationByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostCommissionValidationByIDResponse, error) {
	rsp, err := c.GetHostCommissionValidationByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostCommissionValidationByIDResponse(rsp)
}

// GetHostWithResponse request returning *GetHostResponse
func (c *ClientWithResponses) GetHostWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostResponse, error) {
	rsp, err := c.GetHost(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostResponse(rsp)
}

// RemoveTagsFromHostWithBodyWithResponse request with arbitrary body returning *RemoveTagsFromHostResponse
func (c *ClientWithResponses) RemoveTagsFromHostWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTagsFromHostResponse, error) {
	rsp, err := c.RemoveTagsFromHostWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTagsFromHostResponse(rsp)
}

func (c *ClientWithResponses) RemoveTagsFromHostWithResponse(ctx context.Context, id string, body RemoveTagsFromHostJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTagsFromHostResponse, error) {
	rsp, err := c.RemoveTagsFromHost(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTagsFromHostResponse(rsp)
}

// GetTagsAssignedToHostWithResponse request returning *GetTagsAssignedToHostResponse
func (c *ClientWithResponses) GetTagsAssignedToHostWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTagsAssignedToHostResponse, error) {
	rsp, err := c.GetTagsAssignedToHost(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsAssignedToHostResponse(rsp)
}

// AssignTagsToHostWithBodyWithResponse request with arbitrary body returning *AssignTagsToHostResponse
func (c *ClientWithResponses) AssignTagsToHostWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignTagsToHostResponse, error) {
	rsp, err := c.AssignTagsToHostWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignTagsToHostResponse(rsp)
}

func (c *ClientWithResponses) AssignTagsToHostWithResponse(ctx context.Context, id string, body AssignTagsToHostJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignTagsToHostResponse, error) {
	rsp, err := c.AssignTagsToHost(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignTagsToHostResponse(rsp)
}

// GetAssignableTagForHostWithResponse request returning *GetAssignableTagForHostResponse
func (c *ClientWithResponses) GetAssignableTagForHostWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAssignableTagForHostResponse, error) {
	rsp, err := c.GetAssignableTagForHost(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssignableTagForHostResponse(rsp)
}

// GetHostTagManagerUrlWithResponse request returning *GetHostTagManagerUrlResponse
func (c *ClientWithResponses) GetHostTagManagerUrlWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostTagManagerUrlResponse, error) {
	rsp, err := c.GetHostTagManagerUrl(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostTagManagerUrlResponse(rsp)
}

// GetIdentityPrecheckResultWithResponse request returning *GetIdentityPrecheckResultResponse
func (c *ClientWithResponses) GetIdentityPrecheckResultWithResponse(ctx context.Context, params *GetIdentityPrecheckResultParams, reqEditors ...RequestEditorFn) (*GetIdentityPrecheckResultResponse, error) {
	rsp, err := c.GetIdentityPrecheckResult(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIdentityPrecheckResultResponse(rsp)
}

// GetSddcWs1bOidcInfoWithResponse request returning *GetSddcWs1bOidcInfoResponse
func (c *ClientWithResponses) GetSddcWs1bOidcInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSddcWs1bOidcInfoResponse, error) {
	rsp, err := c.GetSddcWs1bOidcInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSddcWs1bOidcInfoResponse(rsp)
}

// GetIdentityProvidersWithResponse request returning *GetIdentityProvidersResponse
func (c *ClientWithResponses) GetIdentityProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetIdentityProvidersResponse, error) {
	rsp, err := c.GetIdentityProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIdentityProvidersResponse(rsp)
}

// AddExternalIdentityProviderWithBodyWithResponse request with arbitrary body returning *AddExternalIdentityProviderResponse
func (c *ClientWithResponses) AddExternalIdentityProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddExternalIdentityProviderResponse, error) {
	rsp, err := c.AddExternalIdentityProviderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddExternalIdentityProviderResponse(rsp)
}

func (c *ClientWithResponses) AddExternalIdentityProviderWithResponse(ctx context.Context, body AddExternalIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddExternalIdentityProviderResponse, error) {
	rsp, err := c.AddExternalIdentityProvider(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddExternalIdentityProviderResponse(rsp)
}

// DeleteExternalIdentityProviderWithResponse request returning *DeleteExternalIdentityProviderResponse
func (c *ClientWithResponses) DeleteExternalIdentityProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteExternalIdentityProviderResponse, error) {
	rsp, err := c.DeleteExternalIdentityProvider(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExternalIdentityProviderResponse(rsp)
}

// GetIdentityProviderByIdWithResponse request returning *GetIdentityProviderByIdResponse
func (c *ClientWithResponses) GetIdentityProviderByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetIdentityProviderByIdResponse, error) {
	rsp, err := c.GetIdentityProviderById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIdentityProviderByIdResponse(rsp)
}

// UpdateExternalIdentityProviderWithBodyWithResponse request with arbitrary body returning *UpdateExternalIdentityProviderResponse
func (c *ClientWithResponses) UpdateExternalIdentityProviderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExternalIdentityProviderResponse, error) {
	rsp, err := c.UpdateExternalIdentityProviderWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExternalIdentityProviderResponse(rsp)
}

func (c *ClientWithResponses) UpdateExternalIdentityProviderWithResponse(ctx context.Context, id string, body UpdateExternalIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExternalIdentityProviderResponse, error) {
	rsp, err := c.UpdateExternalIdentityProvider(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExternalIdentityProviderResponse(rsp)
}

// AddEmbeddedIdentitySourceWithBodyWithResponse request with arbitrary body returning *AddEmbeddedIdentitySourceResponse
func (c *ClientWithResponses) AddEmbeddedIdentitySourceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddEmbeddedIdentitySourceResponse, error) {
	rsp, err := c.AddEmbeddedIdentitySourceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddEmbeddedIdentitySourceResponse(rsp)
}

func (c *ClientWithResponses) AddEmbeddedIdentitySourceWithResponse(ctx context.Context, id string, body AddEmbeddedIdentitySourceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddEmbeddedIdentitySourceResponse, error) {
	rsp, err := c.AddEmbeddedIdentitySource(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddEmbeddedIdentitySourceResponse(rsp)
}

// DeleteIdentitySourceWithResponse request returning *DeleteIdentitySourceResponse
func (c *ClientWithResponses) DeleteIdentitySourceWithResponse(ctx context.Context, id string, domainName string, reqEditors ...RequestEditorFn) (*DeleteIdentitySourceResponse, error) {
	rsp, err := c.DeleteIdentitySource(ctx, id, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIdentitySourceResponse(rsp)
}

// UpdateEmbeddedIdentitySourceWithBodyWithResponse request with arbitrary body returning *UpdateEmbeddedIdentitySourceResponse
func (c *ClientWithResponses) UpdateEmbeddedIdentitySourceWithBodyWithResponse(ctx context.Context, id string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmbeddedIdentitySourceResponse, error) {
	rsp, err := c.UpdateEmbeddedIdentitySourceWithBody(ctx, id, domainName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmbeddedIdentitySourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateEmbeddedIdentitySourceWithResponse(ctx context.Context, id string, domainName string, body UpdateEmbeddedIdentitySourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmbeddedIdentitySourceResponse, error) {
	rsp, err := c.UpdateEmbeddedIdentitySource(ctx, id, domainName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmbeddedIdentitySourceResponse(rsp)
}

// GenerateSyncClientTokenWithResponse request returning *GenerateSyncClientTokenResponse
func (c *ClientWithResponses) GenerateSyncClientTokenWithResponse(ctx context.Context, id string, params *GenerateSyncClientTokenParams, reqEditors ...RequestEditorFn) (*GenerateSyncClientTokenResponse, error) {
	rsp, err := c.GenerateSyncClientToken(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateSyncClientTokenResponse(rsp)
}

// GetLicenseKeysWithResponse request returning *GetLicenseKeysResponse
func (c *ClientWithResponses) GetLicenseKeysWithResponse(ctx context.Context, params *GetLicenseKeysParams, reqEditors ...RequestEditorFn) (*GetLicenseKeysResponse, error) {
	rsp, err := c.GetLicenseKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseKeysResponse(rsp)
}

// AddLicenseKeyWithBodyWithResponse request with arbitrary body returning *AddLicenseKeyResponse
func (c *ClientWithResponses) AddLicenseKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLicenseKeyResponse, error) {
	rsp, err := c.AddLicenseKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLicenseKeyResponse(rsp)
}

func (c *ClientWithResponses) AddLicenseKeyWithResponse(ctx context.Context, body AddLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLicenseKeyResponse, error) {
	rsp, err := c.AddLicenseKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLicenseKeyResponse(rsp)
}

// GetLicenseProductTypesWithResponse request returning *GetLicenseProductTypesResponse
func (c *ClientWithResponses) GetLicenseProductTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseProductTypesResponse, error) {
	rsp, err := c.GetLicenseProductTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseProductTypesResponse(rsp)
}

// RemoveLicenseKeyWithResponse request returning *RemoveLicenseKeyResponse
func (c *ClientWithResponses) RemoveLicenseKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*RemoveLicenseKeyResponse, error) {
	rsp, err := c.RemoveLicenseKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveLicenseKeyResponse(rsp)
}

// GetLicenseKeyWithResponse request returning *GetLicenseKeyResponse
func (c *ClientWithResponses) GetLicenseKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetLicenseKeyResponse, error) {
	rsp, err := c.GetLicenseKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseKeyResponse(rsp)
}

// UpdateLicenseKeyWithBodyWithResponse request with arbitrary body returning *UpdateLicenseKeyResponse
func (c *ClientWithResponses) UpdateLicenseKeyWithBodyWithResponse(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLicenseKeyResponse, error) {
	rsp, err := c.UpdateLicenseKeyWithBody(ctx, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLicenseKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdateLicenseKeyWithResponse(ctx context.Context, key string, body UpdateLicenseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLicenseKeyResponse, error) {
	rsp, err := c.UpdateLicenseKey(ctx, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLicenseKeyResponse(rsp)
}

// GetLicenseInformationWithResponse request returning *GetLicenseInformationResponse
func (c *ClientWithResponses) GetLicenseInformationWithResponse(ctx context.Context, params *GetLicenseInformationParams, reqEditors ...RequestEditorFn) (*GetLicenseInformationResponse, error) {
	rsp, err := c.GetLicenseInformation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseInformationResponse(rsp)
}

// GetDomainLicensingInfoWithResponse request returning *GetDomainLicensingInfoResponse
func (c *ClientWithResponses) GetDomainLicensingInfoWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDomainLicensingInfoResponse, error) {
	rsp, err := c.GetDomainLicensingInfo(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainLicensingInfoResponse(rsp)
}

// GetSystemLicensingInfoWithResponse request returning *GetSystemLicensingInfoResponse
func (c *ClientWithResponses) GetSystemLicensingInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLicensingInfoResponse, error) {
	rsp, err := c.GetSystemLicensingInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemLicensingInfoResponse(rsp)
}

// GetManifestWithResponse request returning *GetManifestResponse
func (c *ClientWithResponses) GetManifestWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetManifestResponse, error) {
	rsp, err := c.GetManifest(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetManifestResponse(rsp)
}

// SaveManifestWithBodyWithResponse request with arbitrary body returning *SaveManifestResponse
func (c *ClientWithResponses) SaveManifestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveManifestResponse, error) {
	rsp, err := c.SaveManifestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveManifestResponse(rsp)
}

func (c *ClientWithResponses) SaveManifestWithResponse(ctx context.Context, body SaveManifestJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveManifestResponse, error) {
	rsp, err := c.SaveManifest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveManifestResponse(rsp)
}

// GetNetworkPoolWithResponse request returning *GetNetworkPoolResponse
func (c *ClientWithResponses) GetNetworkPoolWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNetworkPoolResponse, error) {
	rsp, err := c.GetNetworkPool(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkPoolResponse(rsp)
}

// CreateNetworkPoolWithBodyWithResponse request with arbitrary body returning *CreateNetworkPoolResponse
func (c *ClientWithResponses) CreateNetworkPoolWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetworkPoolResponse, error) {
	rsp, err := c.CreateNetworkPoolWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetworkPoolResponse(rsp)
}

func (c *ClientWithResponses) CreateNetworkPoolWithResponse(ctx context.Context, body CreateNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetworkPoolResponse, error) {
	rsp, err := c.CreateNetworkPool(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetworkPoolResponse(rsp)
}

// DeleteNetworkPoolWithResponse request returning *DeleteNetworkPoolResponse
func (c *ClientWithResponses) DeleteNetworkPoolWithResponse(ctx context.Context, id string, params *DeleteNetworkPoolParams, reqEditors ...RequestEditorFn) (*DeleteNetworkPoolResponse, error) {
	rsp, err := c.DeleteNetworkPool(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNetworkPoolResponse(rsp)
}

// GetNetworkPoolByIDWithResponse request returning *GetNetworkPoolByIDResponse
func (c *ClientWithResponses) GetNetworkPoolByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNetworkPoolByIDResponse, error) {
	rsp, err := c.GetNetworkPoolByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkPoolByIDResponse(rsp)
}

// UpdateNetworkPoolWithBodyWithResponse request with arbitrary body returning *UpdateNetworkPoolResponse
func (c *ClientWithResponses) UpdateNetworkPoolWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNetworkPoolResponse, error) {
	rsp, err := c.UpdateNetworkPoolWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNetworkPoolResponse(rsp)
}

func (c *ClientWithResponses) UpdateNetworkPoolWithResponse(ctx context.Context, id string, body UpdateNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNetworkPoolResponse, error) {
	rsp, err := c.UpdateNetworkPool(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNetworkPoolResponse(rsp)
}

// GetNetworksOfNetworkPoolWithResponse request returning *GetNetworksOfNetworkPoolResponse
func (c *ClientWithResponses) GetNetworksOfNetworkPoolWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNetworksOfNetworkPoolResponse, error) {
	rsp, err := c.GetNetworksOfNetworkPool(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworksOfNetworkPoolResponse(rsp)
}

// GetNetworkOfNetworkPoolWithResponse request returning *GetNetworkOfNetworkPoolResponse
func (c *ClientWithResponses) GetNetworkOfNetworkPoolWithResponse(ctx context.Context, id string, networkId string, reqEditors ...RequestEditorFn) (*GetNetworkOfNetworkPoolResponse, error) {
	rsp, err := c.GetNetworkOfNetworkPool(ctx, id, networkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkOfNetworkPoolResponse(rsp)
}

// DeleteIpPoolFromNetworkOfNetworkPoolWithBodyWithResponse request with arbitrary body returning *DeleteIpPoolFromNetworkOfNetworkPoolResponse
func (c *ClientWithResponses) DeleteIpPoolFromNetworkOfNetworkPoolWithBodyWithResponse(ctx context.Context, id string, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIpPoolFromNetworkOfNetworkPoolResponse, error) {
	rsp, err := c.DeleteIpPoolFromNetworkOfNetworkPoolWithBody(ctx, id, networkId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIpPoolFromNetworkOfNetworkPoolResponse(rsp)
}

func (c *ClientWithResponses) DeleteIpPoolFromNetworkOfNetworkPoolWithResponse(ctx context.Context, id string, networkId string, body DeleteIpPoolFromNetworkOfNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIpPoolFromNetworkOfNetworkPoolResponse, error) {
	rsp, err := c.DeleteIpPoolFromNetworkOfNetworkPool(ctx, id, networkId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIpPoolFromNetworkOfNetworkPoolResponse(rsp)
}

// AddIpPoolToNetworkOfNetworkPoolWithBodyWithResponse request with arbitrary body returning *AddIpPoolToNetworkOfNetworkPoolResponse
func (c *ClientWithResponses) AddIpPoolToNetworkOfNetworkPoolWithBodyWithResponse(ctx context.Context, id string, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddIpPoolToNetworkOfNetworkPoolResponse, error) {
	rsp, err := c.AddIpPoolToNetworkOfNetworkPoolWithBody(ctx, id, networkId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddIpPoolToNetworkOfNetworkPoolResponse(rsp)
}

func (c *ClientWithResponses) AddIpPoolToNetworkOfNetworkPoolWithResponse(ctx context.Context, id string, networkId string, body AddIpPoolToNetworkOfNetworkPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*AddIpPoolToNetworkOfNetworkPoolResponse, error) {
	rsp, err := c.AddIpPoolToNetworkOfNetworkPool(ctx, id, networkId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddIpPoolToNetworkOfNetworkPoolResponse(rsp)
}

// GetALBClustersWithResponse request returning *GetALBClustersResponse
func (c *ClientWithResponses) GetALBClustersWithResponse(ctx context.Context, params *GetALBClustersParams, reqEditors ...RequestEditorFn) (*GetALBClustersResponse, error) {
	rsp, err := c.GetALBClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetALBClustersResponse(rsp)
}

// GetALBClustersFormFactorsWithResponse request returning *GetALBClustersFormFactorsResponse
func (c *ClientWithResponses) GetALBClustersFormFactorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetALBClustersFormFactorsResponse, error) {
	rsp, err := c.GetALBClustersFormFactors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetALBClustersFormFactorsResponse(rsp)
}

// ValidateALBClusterCreationSpecWithBodyWithResponse request with arbitrary body returning *ValidateALBClusterCreationSpecResponse
func (c *ClientWithResponses) ValidateALBClusterCreationSpecWithBodyWithResponse(ctx context.Context, params *ValidateALBClusterCreationSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateALBClusterCreationSpecResponse, error) {
	rsp, err := c.ValidateALBClusterCreationSpecWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateALBClusterCreationSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateALBClusterCreationSpecWithResponse(ctx context.Context, params *ValidateALBClusterCreationSpecParams, body ValidateALBClusterCreationSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateALBClusterCreationSpecResponse, error) {
	rsp, err := c.ValidateALBClusterCreationSpec(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateALBClusterCreationSpecResponse(rsp)
}

// ValidateNsxALBCompatibilityWithBodyWithResponse request with arbitrary body returning *ValidateNsxALBCompatibilityResponse
func (c *ClientWithResponses) ValidateNsxALBCompatibilityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateNsxALBCompatibilityResponse, error) {
	rsp, err := c.ValidateNsxALBCompatibilityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateNsxALBCompatibilityResponse(rsp)
}

func (c *ClientWithResponses) ValidateNsxALBCompatibilityWithResponse(ctx context.Context, body ValidateNsxALBCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateNsxALBCompatibilityResponse, error) {
	rsp, err := c.ValidateNsxALBCompatibility(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateNsxALBCompatibilityResponse(rsp)
}

// DeleteALBClusterWithResponse request returning *DeleteALBClusterResponse
func (c *ClientWithResponses) DeleteALBClusterWithResponse(ctx context.Context, id string, params *DeleteALBClusterParams, reqEditors ...RequestEditorFn) (*DeleteALBClusterResponse, error) {
	rsp, err := c.DeleteALBCluster(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteALBClusterResponse(rsp)
}

// GetALBClusterWithResponse request returning *GetALBClusterResponse
func (c *ClientWithResponses) GetALBClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetALBClusterResponse, error) {
	rsp, err := c.GetALBCluster(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetALBClusterResponse(rsp)
}

// GetNsxClustersWithResponse request returning *GetNsxClustersResponse
func (c *ClientWithResponses) GetNsxClustersWithResponse(ctx context.Context, params *GetNsxClustersParams, reqEditors ...RequestEditorFn) (*GetNsxClustersResponse, error) {
	rsp, err := c.GetNsxClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNsxClustersResponse(rsp)
}

// GetNsxCriteriaWithResponse request returning *GetNsxCriteriaResponse
func (c *ClientWithResponses) GetNsxCriteriaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNsxCriteriaResponse, error) {
	rsp, err := c.GetNsxCriteria(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNsxCriteriaResponse(rsp)
}

// GetNsxCriterionWithResponse request returning *GetNsxCriterionResponse
func (c *ClientWithResponses) GetNsxCriterionWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetNsxCriterionResponse, error) {
	rsp, err := c.GetNsxCriterion(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNsxCriterionResponse(rsp)
}

// ValidateIpPoolWithBodyWithResponse request with arbitrary body returning *ValidateIpPoolResponse
func (c *ClientWithResponses) ValidateIpPoolWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateIpPoolResponse, error) {
	rsp, err := c.ValidateIpPoolWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateIpPoolResponse(rsp)
}

func (c *ClientWithResponses) ValidateIpPoolWithResponse(ctx context.Context, body ValidateIpPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateIpPoolResponse, error) {
	rsp, err := c.ValidateIpPool(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateIpPoolResponse(rsp)
}

// GetValidationResultWithResponse request returning *GetValidationResultResponse
func (c *ClientWithResponses) GetValidationResultWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetValidationResultResponse, error) {
	rsp, err := c.GetValidationResult(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetValidationResultResponse(rsp)
}

// ConnectOpenIdWithBodyWithResponse request with arbitrary body returning *ConnectOpenIdResponse
func (c *ClientWithResponses) ConnectOpenIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectOpenIdResponse, error) {
	rsp, err := c.ConnectOpenIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectOpenIdResponse(rsp)
}

func (c *ClientWithResponses) ConnectOpenIdWithResponse(ctx context.Context, body ConnectOpenIdJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectOpenIdResponse, error) {
	rsp, err := c.ConnectOpenId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectOpenIdResponse(rsp)
}

// StartNsxCriteriaQueryWithBodyWithResponse request with arbitrary body returning *StartNsxCriteriaQueryResponse
func (c *ClientWithResponses) StartNsxCriteriaQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartNsxCriteriaQueryResponse, error) {
	rsp, err := c.StartNsxCriteriaQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartNsxCriteriaQueryResponse(rsp)
}

func (c *ClientWithResponses) StartNsxCriteriaQueryWithResponse(ctx context.Context, body StartNsxCriteriaQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*StartNsxCriteriaQueryResponse, error) {
	rsp, err := c.StartNsxCriteriaQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartNsxCriteriaQueryResponse(rsp)
}

// GetNsxClusterQueryResponseWithResponse request returning *GetNsxClusterQueryResponseResponse
func (c *ClientWithResponses) GetNsxClusterQueryResponseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNsxClusterQueryResponseResponse, error) {
	rsp, err := c.GetNsxClusterQueryResponse(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNsxClusterQueryResponseResponse(rsp)
}

// GetNsxClusterWithResponse request returning *GetNsxClusterResponse
func (c *ClientWithResponses) GetNsxClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNsxClusterResponse, error) {
	rsp, err := c.GetNsxCluster(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNsxClusterResponse(rsp)
}

// GetNsxIpAddressPoolsWithResponse request returning *GetNsxIpAddressPoolsResponse
func (c *ClientWithResponses) GetNsxIpAddressPoolsWithResponse(ctx context.Context, nsxtClusterId string, reqEditors ...RequestEditorFn) (*GetNsxIpAddressPoolsResponse, error) {
	rsp, err := c.GetNsxIpAddressPools(ctx, nsxtClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNsxIpAddressPoolsResponse(rsp)
}

// GetNsxIpAddressPoolWithResponse request returning *GetNsxIpAddressPoolResponse
func (c *ClientWithResponses) GetNsxIpAddressPoolWithResponse(ctx context.Context, nsxtClusterId string, name string, reqEditors ...RequestEditorFn) (*GetNsxIpAddressPoolResponse, error) {
	rsp, err := c.GetNsxIpAddressPool(ctx, nsxtClusterId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNsxIpAddressPoolResponse(rsp)
}

// GetNsxTransportZonesWithResponse request returning *GetNsxTransportZonesResponse
func (c *ClientWithResponses) GetNsxTransportZonesWithResponse(ctx context.Context, nsxtClusterId string, reqEditors ...RequestEditorFn) (*GetNsxTransportZonesResponse, error) {
	rsp, err := c.GetNsxTransportZones(ctx, nsxtClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNsxTransportZonesResponse(rsp)
}

// DeletePersonalityWithResponse request returning *DeletePersonalityResponse
func (c *ClientWithResponses) DeletePersonalityWithResponse(ctx context.Context, params *DeletePersonalityParams, reqEditors ...RequestEditorFn) (*DeletePersonalityResponse, error) {
	rsp, err := c.DeletePersonality(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersonalityResponse(rsp)
}

// GetPersonalitiesWithResponse request returning *GetPersonalitiesResponse
func (c *ClientWithResponses) GetPersonalitiesWithResponse(ctx context.Context, params *GetPersonalitiesParams, reqEditors ...RequestEditorFn) (*GetPersonalitiesResponse, error) {
	rsp, err := c.GetPersonalities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonalitiesResponse(rsp)
}

// UploadPersonalityWithBodyWithResponse request with arbitrary body returning *UploadPersonalityResponse
func (c *ClientWithResponses) UploadPersonalityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPersonalityResponse, error) {
	rsp, err := c.UploadPersonalityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPersonalityResponse(rsp)
}

func (c *ClientWithResponses) UploadPersonalityWithResponse(ctx context.Context, body UploadPersonalityJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadPersonalityResponse, error) {
	rsp, err := c.UploadPersonality(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPersonalityResponse(rsp)
}

// UploadPersonalityFilesWithBodyWithResponse request with arbitrary body returning *UploadPersonalityFilesResponse
func (c *ClientWithResponses) UploadPersonalityFilesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPersonalityFilesResponse, error) {
	rsp, err := c.UploadPersonalityFilesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPersonalityFilesResponse(rsp)
}

// GetPersonalityWithResponse request returning *GetPersonalityResponse
func (c *ClientWithResponses) GetPersonalityWithResponse(ctx context.Context, personalityId string, reqEditors ...RequestEditorFn) (*GetPersonalityResponse, error) {
	rsp, err := c.GetPersonality(ctx, personalityId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonalityResponse(rsp)
}

// RenamePersonalityByIdWithBodyWithResponse request with arbitrary body returning *RenamePersonalityByIdResponse
func (c *ClientWithResponses) RenamePersonalityByIdWithBodyWithResponse(ctx context.Context, personalityId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenamePersonalityByIdResponse, error) {
	rsp, err := c.RenamePersonalityByIdWithBody(ctx, personalityId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenamePersonalityByIdResponse(rsp)
}

func (c *ClientWithResponses) RenamePersonalityByIdWithResponse(ctx context.Context, personalityId string, body RenamePersonalityByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*RenamePersonalityByIdResponse, error) {
	rsp, err := c.RenamePersonalityById(ctx, personalityId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenamePersonalityByIdResponse(rsp)
}

// GetProductVersionCatalogWithResponse request returning *GetProductVersionCatalogResponse
func (c *ClientWithResponses) GetProductVersionCatalogWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProductVersionCatalogResponse, error) {
	rsp, err := c.GetProductVersionCatalog(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductVersionCatalogResponse(rsp)
}

// UploadProductVersionCatalogWithBodyWithResponse request with arbitrary body returning *UploadProductVersionCatalogResponse
func (c *ClientWithResponses) UploadProductVersionCatalogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadProductVersionCatalogResponse, error) {
	rsp, err := c.UploadProductVersionCatalogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadProductVersionCatalogResponse(rsp)
}

func (c *ClientWithResponses) UploadProductVersionCatalogWithResponse(ctx context.Context, body UploadProductVersionCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadProductVersionCatalogResponse, error) {
	rsp, err := c.UploadProductVersionCatalog(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadProductVersionCatalogResponse(rsp)
}

// GetPscsWithResponse request returning *GetPscsResponse
func (c *ClientWithResponses) GetPscsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPscsResponse, error) {
	rsp, err := c.GetPscs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPscsResponse(rsp)
}

// GetPscWithResponse request returning *GetPscResponse
func (c *ClientWithResponses) GetPscWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPscResponse, error) {
	rsp, err := c.GetPsc(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPscResponse(rsp)
}

// GetReleasesWithResponse request returning *GetReleasesResponse
func (c *ClientWithResponses) GetReleasesWithResponse(ctx context.Context, params *GetReleasesParams, reqEditors ...RequestEditorFn) (*GetReleasesResponse, error) {
	rsp, err := c.GetReleases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReleasesResponse(rsp)
}

// GetReleaseByDomainsWithResponse request returning *GetReleaseByDomainsResponse
func (c *ClientWithResponses) GetReleaseByDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReleaseByDomainsResponse, error) {
	rsp, err := c.GetReleaseByDomains(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReleaseByDomainsResponse(rsp)
}

// GetDomainReleaseViewValidationWithResponse request returning *GetDomainReleaseViewValidationResponse
func (c *ClientWithResponses) GetDomainReleaseViewValidationWithResponse(ctx context.Context, validationId string, reqEditors ...RequestEditorFn) (*GetDomainReleaseViewValidationResponse, error) {
	rsp, err := c.GetDomainReleaseViewValidation(ctx, validationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainReleaseViewValidationResponse(rsp)
}

// DeleteReleaseByDomainIDWithResponse request returning *DeleteReleaseByDomainIDResponse
func (c *ClientWithResponses) DeleteReleaseByDomainIDWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*DeleteReleaseByDomainIDResponse, error) {
	rsp, err := c.DeleteReleaseByDomainID(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReleaseByDomainIDResponse(rsp)
}

// GetReleaseByDomainWithResponse request returning *GetReleaseByDomainResponse
func (c *ClientWithResponses) GetReleaseByDomainWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetReleaseByDomainResponse, error) {
	rsp, err := c.GetReleaseByDomain(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReleaseByDomainResponse(rsp)
}

// UpdateReleaseByDomainIDWithBodyWithResponse request with arbitrary body returning *UpdateReleaseByDomainIDResponse
func (c *ClientWithResponses) UpdateReleaseByDomainIDWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateReleaseByDomainIDResponse, error) {
	rsp, err := c.UpdateReleaseByDomainIDWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReleaseByDomainIDResponse(rsp)
}

func (c *ClientWithResponses) UpdateReleaseByDomainIDWithResponse(ctx context.Context, domainId string, body UpdateReleaseByDomainIDJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateReleaseByDomainIDResponse, error) {
	rsp, err := c.UpdateReleaseByDomainID(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReleaseByDomainIDResponse(rsp)
}

// GetCustomPatchesWithResponse request returning *GetCustomPatchesResponse
func (c *ClientWithResponses) GetCustomPatchesWithResponse(ctx context.Context, domainId string, params *GetCustomPatchesParams, reqEditors ...RequestEditorFn) (*GetCustomPatchesResponse, error) {
	rsp, err := c.GetCustomPatches(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomPatchesResponse(rsp)
}

// GetFutureReleasesWithResponse request returning *GetFutureReleasesResponse
func (c *ClientWithResponses) GetFutureReleasesWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetFutureReleasesResponse, error) {
	rsp, err := c.GetFutureReleases(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFutureReleasesResponse(rsp)
}

// ValidateReleaseByDomainIDWithBodyWithResponse request with arbitrary body returning *ValidateReleaseByDomainIDResponse
func (c *ClientWithResponses) ValidateReleaseByDomainIDWithBodyWithResponse(ctx context.Context, domainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateReleaseByDomainIDResponse, error) {
	rsp, err := c.ValidateReleaseByDomainIDWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateReleaseByDomainIDResponse(rsp)
}

func (c *ClientWithResponses) ValidateReleaseByDomainIDWithResponse(ctx context.Context, domainId string, body ValidateReleaseByDomainIDJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateReleaseByDomainIDResponse, error) {
	rsp, err := c.ValidateReleaseByDomainID(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateReleaseByDomainIDResponse(rsp)
}

// GetSystemReleaseWithResponse request returning *GetSystemReleaseResponse
func (c *ClientWithResponses) GetSystemReleaseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemReleaseResponse, error) {
	rsp, err := c.GetSystemRelease(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemReleaseResponse(rsp)
}

// GetResourceFunctionalitiesWithResponse request returning *GetResourceFunctionalitiesResponse
func (c *ClientWithResponses) GetResourceFunctionalitiesWithResponse(ctx context.Context, params *GetResourceFunctionalitiesParams, reqEditors ...RequestEditorFn) (*GetResourceFunctionalitiesResponse, error) {
	rsp, err := c.GetResourceFunctionalities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceFunctionalitiesResponse(rsp)
}

// UpdateResourcesFunctionalitiesWithBodyWithResponse request with arbitrary body returning *UpdateResourcesFunctionalitiesResponse
func (c *ClientWithResponses) UpdateResourcesFunctionalitiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourcesFunctionalitiesResponse, error) {
	rsp, err := c.UpdateResourcesFunctionalitiesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourcesFunctionalitiesResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourcesFunctionalitiesWithResponse(ctx context.Context, body UpdateResourcesFunctionalitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourcesFunctionalitiesResponse, error) {
	rsp, err := c.UpdateResourcesFunctionalities(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourcesFunctionalitiesResponse(rsp)
}

// GetResourcesFunctionalitiesAllowedGlobalWithResponse request returning *GetResourcesFunctionalitiesAllowedGlobalResponse
func (c *ClientWithResponses) GetResourcesFunctionalitiesAllowedGlobalWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResourcesFunctionalitiesAllowedGlobalResponse, error) {
	rsp, err := c.GetResourcesFunctionalitiesAllowedGlobal(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcesFunctionalitiesAllowedGlobalResponse(rsp)
}

// UpdateResourcesFunctionalities1WithBodyWithResponse request with arbitrary body returning *UpdateResourcesFunctionalities1Response
func (c *ClientWithResponses) UpdateResourcesFunctionalities1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourcesFunctionalities1Response, error) {
	rsp, err := c.UpdateResourcesFunctionalities1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourcesFunctionalities1Response(rsp)
}

func (c *ClientWithResponses) UpdateResourcesFunctionalities1WithResponse(ctx context.Context, body UpdateResourcesFunctionalities1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourcesFunctionalities1Response, error) {
	rsp, err := c.UpdateResourcesFunctionalities1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourcesFunctionalities1Response(rsp)
}

// GetResourceWarningsWithResponse request returning *GetResourceWarningsResponse
func (c *ClientWithResponses) GetResourceWarningsWithResponse(ctx context.Context, params *GetResourceWarningsParams, reqEditors ...RequestEditorFn) (*GetResourceWarningsResponse, error) {
	rsp, err := c.GetResourceWarnings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceWarningsResponse(rsp)
}

// CreateResourceWarningWithBodyWithResponse request with arbitrary body returning *CreateResourceWarningResponse
func (c *ClientWithResponses) CreateResourceWarningWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceWarningResponse, error) {
	rsp, err := c.CreateResourceWarningWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceWarningResponse(rsp)
}

func (c *ClientWithResponses) CreateResourceWarningWithResponse(ctx context.Context, body CreateResourceWarningJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceWarningResponse, error) {
	rsp, err := c.CreateResourceWarning(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceWarningResponse(rsp)
}

// GetResourceWarningWithResponse request returning *GetResourceWarningResponse
func (c *ClientWithResponses) GetResourceWarningWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetResourceWarningResponse, error) {
	rsp, err := c.GetResourceWarning(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceWarningResponse(rsp)
}

// StartLicenseCheckByResourceWithBodyWithResponse request with arbitrary body returning *StartLicenseCheckByResourceResponse
func (c *ClientWithResponses) StartLicenseCheckByResourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartLicenseCheckByResourceResponse, error) {
	rsp, err := c.StartLicenseCheckByResourceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartLicenseCheckByResourceResponse(rsp)
}

func (c *ClientWithResponses) StartLicenseCheckByResourceWithResponse(ctx context.Context, body StartLicenseCheckByResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*StartLicenseCheckByResourceResponse, error) {
	rsp, err := c.StartLicenseCheckByResource(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartLicenseCheckByResourceResponse(rsp)
}

// GetLicenseCheckResultByIDWithResponse request returning *GetLicenseCheckResultByIDResponse
func (c *ClientWithResponses) GetLicenseCheckResultByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLicenseCheckResultByIDResponse, error) {
	rsp, err := c.GetLicenseCheckResultByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseCheckResultByIDResponse(rsp)
}

// SetLicenseKeyForResourceWithBodyWithResponse request with arbitrary body returning *SetLicenseKeyForResourceResponse
func (c *ClientWithResponses) SetLicenseKeyForResourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetLicenseKeyForResourceResponse, error) {
	rsp, err := c.SetLicenseKeyForResourceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetLicenseKeyForResourceResponse(rsp)
}

func (c *ClientWithResponses) SetLicenseKeyForResourceWithResponse(ctx context.Context, body SetLicenseKeyForResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetLicenseKeyForResourceResponse, error) {
	rsp, err := c.SetLicenseKeyForResource(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetLicenseKeyForResourceResponse(rsp)
}

// StartRestoreWithBodyWithResponse request with arbitrary body returning *StartRestoreResponse
func (c *ClientWithResponses) StartRestoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartRestoreResponse, error) {
	rsp, err := c.StartRestoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartRestoreResponse(rsp)
}

func (c *ClientWithResponses) StartRestoreWithResponse(ctx context.Context, body StartRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*StartRestoreResponse, error) {
	rsp, err := c.StartRestore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartRestoreResponse(rsp)
}

// GetRestoreTaskWithResponse request returning *GetRestoreTaskResponse
func (c *ClientWithResponses) GetRestoreTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRestoreTaskResponse, error) {
	rsp, err := c.GetRestoreTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRestoreTaskResponse(rsp)
}

// GetRolesWithResponse request returning *GetRolesResponse
func (c *ClientWithResponses) GetRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRolesResponse, error) {
	rsp, err := c.GetRoles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolesResponse(rsp)
}

// GetLocalOsUserAccountsWithResponse request returning *GetLocalOsUserAccountsResponse
func (c *ClientWithResponses) GetLocalOsUserAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalOsUserAccountsResponse, error) {
	rsp, err := c.GetLocalOsUserAccounts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocalOsUserAccountsResponse(rsp)
}

// GetTrustedCertificatesWithResponse request returning *GetTrustedCertificatesResponse
func (c *ClientWithResponses) GetTrustedCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTrustedCertificatesResponse, error) {
	rsp, err := c.GetTrustedCertificates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTrustedCertificatesResponse(rsp)
}

// AddTrustedCertificateWithBodyWithResponse request with arbitrary body returning *AddTrustedCertificateResponse
func (c *ClientWithResponses) AddTrustedCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTrustedCertificateResponse, error) {
	rsp, err := c.AddTrustedCertificateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTrustedCertificateResponse(rsp)
}

func (c *ClientWithResponses) AddTrustedCertificateWithResponse(ctx context.Context, body AddTrustedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTrustedCertificateResponse, error) {
	rsp, err := c.AddTrustedCertificate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTrustedCertificateResponse(rsp)
}

// DeleteTrustedCertificateWithResponse request returning *DeleteTrustedCertificateResponse
func (c *ClientWithResponses) DeleteTrustedCertificateWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*DeleteTrustedCertificateResponse, error) {
	rsp, err := c.DeleteTrustedCertificate(ctx, alias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTrustedCertificateResponse(rsp)
}

// GetSddcManagerUpgradablesWithResponse request returning *GetSddcManagerUpgradablesResponse
func (c *ClientWithResponses) GetSddcManagerUpgradablesWithResponse(ctx context.Context, params *GetSddcManagerUpgradablesParams, reqEditors ...RequestEditorFn) (*GetSddcManagerUpgradablesResponse, error) {
	rsp, err := c.GetSddcManagerUpgradables(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSddcManagerUpgradablesResponse(rsp)
}

// GetSddcManagersWithResponse request returning *GetSddcManagersResponse
func (c *ClientWithResponses) GetSddcManagersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSddcManagersResponse, error) {
	rsp, err := c.GetSddcManagers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSddcManagersResponse(rsp)
}

// GetSddcManagerWithResponse request returning *GetSddcManagerResponse
func (c *ClientWithResponses) GetSddcManagerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcManagerResponse, error) {
	rsp, err := c.GetSddcManager(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSddcManagerResponse(rsp)
}

// GetSddcManagerHistoryWithResponse request returning *GetSddcManagerHistoryResponse
func (c *ClientWithResponses) GetSddcManagerHistoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcManagerHistoryResponse, error) {
	rsp, err := c.GetSddcManagerHistory(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSddcManagerHistoryResponse(rsp)
}

// GetBringupTasksWithResponse request returning *GetBringupTasksResponse
func (c *ClientWithResponses) GetBringupTasksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBringupTasksResponse, error) {
	rsp, err := c.GetBringupTasks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBringupTasksResponse(rsp)
}

// StartBringupWithBodyWithResponse request with arbitrary body returning *StartBringupResponse
func (c *ClientWithResponses) StartBringupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBringupResponse, error) {
	rsp, err := c.StartBringupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBringupResponse(rsp)
}

func (c *ClientWithResponses) StartBringupWithResponse(ctx context.Context, body StartBringupJSONRequestBody, reqEditors ...RequestEditorFn) (*StartBringupResponse, error) {
	rsp, err := c.StartBringup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBringupResponse(rsp)
}

// GetBringupAppInfoWithResponse request returning *GetBringupAppInfoResponse
func (c *ClientWithResponses) GetBringupAppInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBringupAppInfoResponse, error) {
	rsp, err := c.GetBringupAppInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBringupAppInfoResponse(rsp)
}

// GetBringupValidationsWithResponse request returning *GetBringupValidationsResponse
func (c *ClientWithResponses) GetBringupValidationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBringupValidationsResponse, error) {
	rsp, err := c.GetBringupValidations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBringupValidationsResponse(rsp)
}

// ValidateBringupSpecWithBodyWithResponse request with arbitrary body returning *ValidateBringupSpecResponse
func (c *ClientWithResponses) ValidateBringupSpecWithBodyWithResponse(ctx context.Context, params *ValidateBringupSpecParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateBringupSpecResponse, error) {
	rsp, err := c.ValidateBringupSpecWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateBringupSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateBringupSpecWithResponse(ctx context.Context, params *ValidateBringupSpecParams, body ValidateBringupSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateBringupSpecResponse, error) {
	rsp, err := c.ValidateBringupSpec(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateBringupSpecResponse(rsp)
}

// GetBringupValidationWithResponse request returning *GetBringupValidationResponse
func (c *ClientWithResponses) GetBringupValidationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBringupValidationResponse, error) {
	rsp, err := c.GetBringupValidation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBringupValidationResponse(rsp)
}

// RetryBringupValidationWithResponse request returning *RetryBringupValidationResponse
func (c *ClientWithResponses) RetryBringupValidationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetryBringupValidationResponse, error) {
	rsp, err := c.RetryBringupValidation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryBringupValidationResponse(rsp)
}

// ExportBringupValidationReportWithResponse request returning *ExportBringupValidationReportResponse
func (c *ClientWithResponses) ExportBringupValidationReportWithResponse(ctx context.Context, validationId string, params *ExportBringupValidationReportParams, reqEditors ...RequestEditorFn) (*ExportBringupValidationReportResponse, error) {
	rsp, err := c.ExportBringupValidationReport(ctx, validationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportBringupValidationReportResponse(rsp)
}

// GetBringupTaskByIDWithResponse request returning *GetBringupTaskByIDResponse
func (c *ClientWithResponses) GetBringupTaskByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBringupTaskByIDResponse, error) {
	rsp, err := c.GetBringupTaskByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBringupTaskByIDResponse(rsp)
}

// RetrySddcWithBodyWithResponse request with arbitrary body returning *RetrySddcResponse
func (c *ClientWithResponses) RetrySddcWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RetrySddcResponse, error) {
	rsp, err := c.RetrySddcWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrySddcResponse(rsp)
}

func (c *ClientWithResponses) RetrySddcWithResponse(ctx context.Context, id string, body RetrySddcJSONRequestBody, reqEditors ...RequestEditorFn) (*RetrySddcResponse, error) {
	rsp, err := c.RetrySddc(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrySddcResponse(rsp)
}

// ExportBringupDetailReportWithResponse request returning *ExportBringupDetailReportResponse
func (c *ClientWithResponses) ExportBringupDetailReportWithResponse(ctx context.Context, id string, params *ExportBringupDetailReportParams, reqEditors ...RequestEditorFn) (*ExportBringupDetailReportResponse, error) {
	rsp, err := c.ExportBringupDetailReport(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportBringupDetailReportResponse(rsp)
}

// GetSddcManagerInfoWithResponse request returning *GetSddcManagerInfoResponse
func (c *ClientWithResponses) GetSddcManagerInfoWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSddcManagerInfoResponse, error) {
	rsp, err := c.GetSddcManagerInfo(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSddcManagerInfoResponse(rsp)
}

// GetSSODomainsWithResponse request returning *GetSSODomainsResponse
func (c *ClientWithResponses) GetSSODomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSSODomainsResponse, error) {
	rsp, err := c.GetSSODomains(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSSODomainsResponse(rsp)
}

// GetSSODomainEntitiesWithResponse request returning *GetSSODomainEntitiesResponse
func (c *ClientWithResponses) GetSSODomainEntitiesWithResponse(ctx context.Context, ssoDomain string, params *GetSSODomainEntitiesParams, reqEditors ...RequestEditorFn) (*GetSSODomainEntitiesResponse, error) {
	rsp, err := c.GetSSODomainEntities(ctx, ssoDomain, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSSODomainEntitiesResponse(rsp)
}

// GetSystemConfigurationWithResponse request returning *GetSystemConfigurationResponse
func (c *ClientWithResponses) GetSystemConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemConfigurationResponse, error) {
	rsp, err := c.GetSystemConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemConfigurationResponse(rsp)
}

// UpdateSystemConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateSystemConfigurationResponse
func (c *ClientWithResponses) UpdateSystemConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSystemConfigurationResponse, error) {
	rsp, err := c.UpdateSystemConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSystemConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateSystemConfigurationWithResponse(ctx context.Context, body UpdateSystemConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSystemConfigurationResponse, error) {
	rsp, err := c.UpdateSystemConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSystemConfigurationResponse(rsp)
}

// GetBackupConfigurationWithResponse request returning *GetBackupConfigurationResponse
func (c *ClientWithResponses) GetBackupConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBackupConfigurationResponse, error) {
	rsp, err := c.GetBackupConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupConfigurationResponse(rsp)
}

// UpdateBackupConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateBackupConfigurationResponse
func (c *ClientWithResponses) UpdateBackupConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBackupConfigurationResponse, error) {
	rsp, err := c.UpdateBackupConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBackupConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateBackupConfigurationWithResponse(ctx context.Context, body UpdateBackupConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBackupConfigurationResponse, error) {
	rsp, err := c.UpdateBackupConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBackupConfigurationResponse(rsp)
}

// SetBackupConfigurationWithBodyWithResponse request with arbitrary body returning *SetBackupConfigurationResponse
func (c *ClientWithResponses) SetBackupConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBackupConfigurationResponse, error) {
	rsp, err := c.SetBackupConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBackupConfigurationResponse(rsp)
}

func (c *ClientWithResponses) SetBackupConfigurationWithResponse(ctx context.Context, body SetBackupConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBackupConfigurationResponse, error) {
	rsp, err := c.SetBackupConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBackupConfigurationResponse(rsp)
}

// GetBackupLocationWithResponse request returning *GetBackupLocationResponse
func (c *ClientWithResponses) GetBackupLocationWithResponse(ctx context.Context, params *GetBackupLocationParams, reqEditors ...RequestEditorFn) (*GetBackupLocationResponse, error) {
	rsp, err := c.GetBackupLocation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupLocationResponse(rsp)
}

// ValidateBackupConfigurationsOperationsWithBodyWithResponse request with arbitrary body returning *ValidateBackupConfigurationsOperationsResponse
func (c *ClientWithResponses) ValidateBackupConfigurationsOperationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateBackupConfigurationsOperationsResponse, error) {
	rsp, err := c.ValidateBackupConfigurationsOperationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateBackupConfigurationsOperationsResponse(rsp)
}

func (c *ClientWithResponses) ValidateBackupConfigurationsOperationsWithResponse(ctx context.Context, body ValidateBackupConfigurationsOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateBackupConfigurationsOperationsResponse, error) {
	rsp, err := c.ValidateBackupConfigurationsOperations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateBackupConfigurationsOperationsResponse(rsp)
}

// GetCeipStatusWithResponse request returning *GetCeipStatusResponse
func (c *ClientWithResponses) GetCeipStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCeipStatusResponse, error) {
	rsp, err := c.GetCeipStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCeipStatusResponse(rsp)
}

// SetCeipStatusWithBodyWithResponse request with arbitrary body returning *SetCeipStatusResponse
func (c *ClientWithResponses) SetCeipStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCeipStatusResponse, error) {
	rsp, err := c.SetCeipStatusWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCeipStatusResponse(rsp)
}

func (c *ClientWithResponses) SetCeipStatusWithResponse(ctx context.Context, body SetCeipStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCeipStatusResponse, error) {
	rsp, err := c.SetCeipStatus(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCeipStatusResponse(rsp)
}

// GetLastAssessmentRunInfoWithResponse request returning *GetLastAssessmentRunInfoResponse
func (c *ClientWithResponses) GetLastAssessmentRunInfoWithResponse(ctx context.Context, params *GetLastAssessmentRunInfoParams, reqEditors ...RequestEditorFn) (*GetLastAssessmentRunInfoResponse, error) {
	rsp, err := c.GetLastAssessmentRunInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLastAssessmentRunInfoResponse(rsp)
}

// TriggerCheckRunWithBodyWithResponse request with arbitrary body returning *TriggerCheckRunResponse
func (c *ClientWithResponses) TriggerCheckRunWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerCheckRunResponse, error) {
	rsp, err := c.TriggerCheckRunWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerCheckRunResponse(rsp)
}

func (c *ClientWithResponses) TriggerCheckRunWithResponse(ctx context.Context, body TriggerCheckRunJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerCheckRunResponse, error) {
	rsp, err := c.TriggerCheckRun(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerCheckRunResponse(rsp)
}

// QueryCheckSetsWithBodyWithResponse request with arbitrary body returning *QueryCheckSetsResponse
func (c *ClientWithResponses) QueryCheckSetsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryCheckSetsResponse, error) {
	rsp, err := c.QueryCheckSetsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryCheckSetsResponse(rsp)
}

func (c *ClientWithResponses) QueryCheckSetsWithResponse(ctx context.Context, body QueryCheckSetsJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryCheckSetsResponse, error) {
	rsp, err := c.QueryCheckSets(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryCheckSetsResponse(rsp)
}

// GetResultWithResponse request returning *GetResultResponse
func (c *ClientWithResponses) GetResultWithResponse(ctx context.Context, runId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetResultResponse, error) {
	rsp, err := c.GetResult(ctx, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResultResponse(rsp)
}

// TriggerPartialRetryOfCheckRunWithBodyWithResponse request with arbitrary body returning *TriggerPartialRetryOfCheckRunResponse
func (c *ClientWithResponses) TriggerPartialRetryOfCheckRunWithBodyWithResponse(ctx context.Context, runId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerPartialRetryOfCheckRunResponse, error) {
	rsp, err := c.TriggerPartialRetryOfCheckRunWithBody(ctx, runId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerPartialRetryOfCheckRunResponse(rsp)
}

func (c *ClientWithResponses) TriggerPartialRetryOfCheckRunWithResponse(ctx context.Context, runId openapi_types.UUID, body TriggerPartialRetryOfCheckRunJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerPartialRetryOfCheckRunResponse, error) {
	rsp, err := c.TriggerPartialRetryOfCheckRun(ctx, runId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerPartialRetryOfCheckRunResponse(rsp)
}

// GetDnsConfigurationWithResponse request returning *GetDnsConfigurationResponse
func (c *ClientWithResponses) GetDnsConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDnsConfigurationResponse, error) {
	rsp, err := c.GetDnsConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDnsConfigurationResponse(rsp)
}

// ConfigureDnsWithBodyWithResponse request with arbitrary body returning *ConfigureDnsResponse
func (c *ClientWithResponses) ConfigureDnsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureDnsResponse, error) {
	rsp, err := c.ConfigureDnsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureDnsResponse(rsp)
}

func (c *ClientWithResponses) ConfigureDnsWithResponse(ctx context.Context, body ConfigureDnsJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureDnsResponse, error) {
	rsp, err := c.ConfigureDns(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureDnsResponse(rsp)
}

// GetValidationsOfDNSConfigurationWithResponse request returning *GetValidationsOfDNSConfigurationResponse
func (c *ClientWithResponses) GetValidationsOfDNSConfigurationWithResponse(ctx context.Context, params *GetValidationsOfDNSConfigurationParams, reqEditors ...RequestEditorFn) (*GetValidationsOfDNSConfigurationResponse, error) {
	rsp, err := c.GetValidationsOfDNSConfiguration(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetValidationsOfDNSConfigurationResponse(rsp)
}

// ValidateDnsConfigurationWithBodyWithResponse request with arbitrary body returning *ValidateDnsConfigurationResponse
func (c *ClientWithResponses) ValidateDnsConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateDnsConfigurationResponse, error) {
	rsp, err := c.ValidateDnsConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateDnsConfigurationResponse(rsp)
}

func (c *ClientWithResponses) ValidateDnsConfigurationWithResponse(ctx context.Context, body ValidateDnsConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateDnsConfigurationResponse, error) {
	rsp, err := c.ValidateDnsConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateDnsConfigurationResponse(rsp)
}

// GetValidationOfDnsConfigurationWithResponse request returning *GetValidationOfDnsConfigurationResponse
func (c *ClientWithResponses) GetValidationOfDnsConfigurationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetValidationOfDnsConfigurationResponse, error) {
	rsp, err := c.GetValidationOfDnsConfiguration(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetValidationOfDnsConfigurationResponse(rsp)
}

// GetHealthCheckTaskWithResponse request returning *GetHealthCheckTaskResponse
func (c *ClientWithResponses) GetHealthCheckTaskWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthCheckTaskResponse, error) {
	rsp, err := c.GetHealthCheckTask(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthCheckTaskResponse(rsp)
}

// StartHealthCheckWithBodyWithResponse request with arbitrary body returning *StartHealthCheckResponse
func (c *ClientWithResponses) StartHealthCheckWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartHealthCheckResponse, error) {
	rsp, err := c.StartHealthCheckWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartHealthCheckResponse(rsp)
}

func (c *ClientWithResponses) StartHealthCheckWithResponse(ctx context.Context, body StartHealthCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*StartHealthCheckResponse, error) {
	rsp, err := c.StartHealthCheck(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartHealthCheckResponse(rsp)
}

// GetHealthCheckStatusWithResponse request returning *GetHealthCheckStatusResponse
func (c *ClientWithResponses) GetHealthCheckStatusWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHealthCheckStatusResponse, error) {
	rsp, err := c.GetHealthCheckStatus(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthCheckStatusResponse(rsp)
}

// ExportHealthCheckByIDWithResponse request returning *ExportHealthCheckByIDResponse
func (c *ClientWithResponses) ExportHealthCheckByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ExportHealthCheckByIDResponse, error) {
	rsp, err := c.ExportHealthCheckByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportHealthCheckByIDResponse(rsp)
}

// GetNtpConfigurationWithResponse request returning *GetNtpConfigurationResponse
func (c *ClientWithResponses) GetNtpConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNtpConfigurationResponse, error) {
	rsp, err := c.GetNtpConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNtpConfigurationResponse(rsp)
}

// ConfigureNtpWithBodyWithResponse request with arbitrary body returning *ConfigureNtpResponse
func (c *ClientWithResponses) ConfigureNtpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureNtpResponse, error) {
	rsp, err := c.ConfigureNtpWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureNtpResponse(rsp)
}

func (c *ClientWithResponses) ConfigureNtpWithResponse(ctx context.Context, body ConfigureNtpJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureNtpResponse, error) {
	rsp, err := c.ConfigureNtp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureNtpResponse(rsp)
}

// GetValidationsOfNtpConfigurationWithResponse request returning *GetValidationsOfNtpConfigurationResponse
func (c *ClientWithResponses) GetValidationsOfNtpConfigurationWithResponse(ctx context.Context, params *GetValidationsOfNtpConfigurationParams, reqEditors ...RequestEditorFn) (*GetValidationsOfNtpConfigurationResponse, error) {
	rsp, err := c.GetValidationsOfNtpConfiguration(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetValidationsOfNtpConfigurationResponse(rsp)
}

// ValidateNtpConfigurationWithBodyWithResponse request with arbitrary body returning *ValidateNtpConfigurationResponse
func (c *ClientWithResponses) ValidateNtpConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateNtpConfigurationResponse, error) {
	rsp, err := c.ValidateNtpConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateNtpConfigurationResponse(rsp)
}

func (c *ClientWithResponses) ValidateNtpConfigurationWithResponse(ctx context.Context, body ValidateNtpConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateNtpConfigurationResponse, error) {
	rsp, err := c.ValidateNtpConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateNtpConfigurationResponse(rsp)
}

// GetValidationOfNtpConfigurationWithResponse request returning *GetValidationOfNtpConfigurationResponse
func (c *ClientWithResponses) GetValidationOfNtpConfigurationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetValidationOfNtpConfigurationResponse, error) {
	rsp, err := c.GetValidationOfNtpConfiguration(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetValidationOfNtpConfigurationResponse(rsp)
}

// StartPrecheckWithBodyWithResponse request with arbitrary body returning *StartPrecheckResponse
func (c *ClientWithResponses) StartPrecheckWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartPrecheckResponse, error) {
	rsp, err := c.StartPrecheckWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartPrecheckResponse(rsp)
}

func (c *ClientWithResponses) StartPrecheckWithResponse(ctx context.Context, body StartPrecheckJSONRequestBody, reqEditors ...RequestEditorFn) (*StartPrecheckResponse, error) {
	rsp, err := c.StartPrecheck(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartPrecheckResponse(rsp)
}

// GetPrecheckTaskWithResponse request returning *GetPrecheckTaskResponse
func (c *ClientWithResponses) GetPrecheckTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPrecheckTaskResponse, error) {
	rsp, err := c.GetPrecheckTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrecheckTaskResponse(rsp)
}

// GetProxyConfigurationWithResponse request returning *GetProxyConfigurationResponse
func (c *ClientWithResponses) GetProxyConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProxyConfigurationResponse, error) {
	rsp, err := c.GetProxyConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProxyConfigurationResponse(rsp)
}

// UpdateProxyConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateProxyConfigurationResponse
func (c *ClientWithResponses) UpdateProxyConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProxyConfigurationResponse, error) {
	rsp, err := c.UpdateProxyConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProxyConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateProxyConfigurationWithResponse(ctx context.Context, body UpdateProxyConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProxyConfigurationResponse, error) {
	rsp, err := c.UpdateProxyConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProxyConfigurationResponse(rsp)
}

// StartBringupSpecConversionWithBodyWithResponse request with arbitrary body returning *StartBringupSpecConversionResponse
func (c *ClientWithResponses) StartBringupSpecConversionWithBodyWithResponse(ctx context.Context, params *StartBringupSpecConversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBringupSpecConversionResponse, error) {
	rsp, err := c.StartBringupSpecConversionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBringupSpecConversionResponse(rsp)
}

// GetFIPSConfigurationWithResponse request returning *GetFIPSConfigurationResponse
func (c *ClientWithResponses) GetFIPSConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFIPSConfigurationResponse, error) {
	rsp, err := c.GetFIPSConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFIPSConfigurationResponse(rsp)
}

// DeleteDepotSettingsWithResponse request returning *DeleteDepotSettingsResponse
func (c *ClientWithResponses) DeleteDepotSettingsWithResponse(ctx context.Context, params *DeleteDepotSettingsParams, reqEditors ...RequestEditorFn) (*DeleteDepotSettingsResponse, error) {
	rsp, err := c.DeleteDepotSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDepotSettingsResponse(rsp)
}

// GetDepotSettingsWithResponse request returning *GetDepotSettingsResponse
func (c *ClientWithResponses) GetDepotSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDepotSettingsResponse, error) {
	rsp, err := c.GetDepotSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDepotSettingsResponse(rsp)
}

// UpdateDepotSettingsWithBodyWithResponse request with arbitrary body returning *UpdateDepotSettingsResponse
func (c *ClientWithResponses) UpdateDepotSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDepotSettingsResponse, error) {
	rsp, err := c.UpdateDepotSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDepotSettingsResponse(rsp)
}

func (c *ClientWithResponses) UpdateDepotSettingsWithResponse(ctx context.Context, body UpdateDepotSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDepotSettingsResponse, error) {
	rsp, err := c.UpdateDepotSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDepotSettingsResponse(rsp)
}

// GetVersionAliasConfigurationWithResponse request returning *GetVersionAliasConfigurationResponse
func (c *ClientWithResponses) GetVersionAliasConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionAliasConfigurationResponse, error) {
	rsp, err := c.GetVersionAliasConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionAliasConfigurationResponse(rsp)
}

// UpdateVersionAliasConfigurationsWithBodyWithResponse request with arbitrary body returning *UpdateVersionAliasConfigurationsResponse
func (c *ClientWithResponses) UpdateVersionAliasConfigurationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVersionAliasConfigurationsResponse, error) {
	rsp, err := c.UpdateVersionAliasConfigurationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVersionAliasConfigurationsResponse(rsp)
}

func (c *ClientWithResponses) UpdateVersionAliasConfigurationsWithResponse(ctx context.Context, body UpdateVersionAliasConfigurationsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVersionAliasConfigurationsResponse, error) {
	rsp, err := c.UpdateVersionAliasConfigurations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVersionAliasConfigurationsResponse(rsp)
}

// DeleteVersionAliasBySoftwareTypeWithResponse request returning *DeleteVersionAliasBySoftwareTypeResponse
func (c *ClientWithResponses) DeleteVersionAliasBySoftwareTypeWithResponse(ctx context.Context, bundleComponentType string, reqEditors ...RequestEditorFn) (*DeleteVersionAliasBySoftwareTypeResponse, error) {
	rsp, err := c.DeleteVersionAliasBySoftwareType(ctx, bundleComponentType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVersionAliasBySoftwareTypeResponse(rsp)
}

// DeleteAliasVersionsBySoftwareTypeAndBaseVersionWithBodyWithResponse request with arbitrary body returning *DeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse
func (c *ClientWithResponses) DeleteAliasVersionsBySoftwareTypeAndBaseVersionWithBodyWithResponse(ctx context.Context, bundleComponentType string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse, error) {
	rsp, err := c.DeleteAliasVersionsBySoftwareTypeAndBaseVersionWithBody(ctx, bundleComponentType, version, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse(rsp)
}

func (c *ClientWithResponses) DeleteAliasVersionsBySoftwareTypeAndBaseVersionWithResponse(ctx context.Context, bundleComponentType string, version string, body DeleteAliasVersionsBySoftwareTypeAndBaseVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse, error) {
	rsp, err := c.DeleteAliasVersionsBySoftwareTypeAndBaseVersion(ctx, bundleComponentType, version, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse(rsp)
}

// UpdateVersionAliasConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateVersionAliasConfigurationResponse
func (c *ClientWithResponses) UpdateVersionAliasConfigurationWithBodyWithResponse(ctx context.Context, bundleComponentType string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVersionAliasConfigurationResponse, error) {
	rsp, err := c.UpdateVersionAliasConfigurationWithBody(ctx, bundleComponentType, version, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVersionAliasConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateVersionAliasConfigurationWithResponse(ctx context.Context, bundleComponentType string, version string, body UpdateVersionAliasConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVersionAliasConfigurationResponse, error) {
	rsp, err := c.UpdateVersionAliasConfiguration(ctx, bundleComponentType, version, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVersionAliasConfigurationResponse(rsp)
}

// GetSupportBundleTaskWithResponse request returning *GetSupportBundleTaskResponse
func (c *ClientWithResponses) GetSupportBundleTaskWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSupportBundleTaskResponse, error) {
	rsp, err := c.GetSupportBundleTask(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSupportBundleTaskResponse(rsp)
}

// StartSupportBundleWithBodyWithResponse request with arbitrary body returning *StartSupportBundleResponse
func (c *ClientWithResponses) StartSupportBundleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartSupportBundleResponse, error) {
	rsp, err := c.StartSupportBundleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartSupportBundleResponse(rsp)
}

func (c *ClientWithResponses) StartSupportBundleWithResponse(ctx context.Context, body StartSupportBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*StartSupportBundleResponse, error) {
	rsp, err := c.StartSupportBundle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartSupportBundleResponse(rsp)
}

// GetSupportBundleStatusWithResponse request returning *GetSupportBundleStatusResponse
func (c *ClientWithResponses) GetSupportBundleStatusWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSupportBundleStatusResponse, error) {
	rsp, err := c.GetSupportBundleStatus(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSupportBundleStatusResponse(rsp)
}

// ExportSupportBundleByIDWithResponse request returning *ExportSupportBundleByIDResponse
func (c *ClientWithResponses) ExportSupportBundleByIDWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ExportSupportBundleByIDResponse, error) {
	rsp, err := c.ExportSupportBundleByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSupportBundleByIDResponse(rsp)
}

// GetUpgradablesWithResponse request returning *GetUpgradablesResponse
func (c *ClientWithResponses) GetUpgradablesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUpgradablesResponse, error) {
	rsp, err := c.GetUpgradables(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUpgradablesResponse(rsp)
}

// GetTasksWithResponse request returning *GetTasksResponse
func (c *ClientWithResponses) GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error) {
	rsp, err := c.GetTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTasksResponse(rsp)
}

// CancelTaskWithResponse request returning *CancelTaskResponse
func (c *ClientWithResponses) CancelTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CancelTaskResponse, error) {
	rsp, err := c.CancelTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelTaskResponse(rsp)
}

// GetTaskWithResponse request returning *GetTaskResponse
func (c *ClientWithResponses) GetTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTaskResponse, error) {
	rsp, err := c.GetTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaskResponse(rsp)
}

// RetryTaskWithResponse request returning *RetryTaskResponse
func (c *ClientWithResponses) RetryTaskWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetryTaskResponse, error) {
	rsp, err := c.RetryTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryTaskResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// RefreshAccessTokenWithBodyWithResponse request with arbitrary body returning *RefreshAccessTokenResponse
func (c *ClientWithResponses) RefreshAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error) {
	rsp, err := c.RefreshAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) RefreshAccessTokenWithResponse(ctx context.Context, body RefreshAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshAccessTokenResponse, error) {
	rsp, err := c.RefreshAccessToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshAccessTokenResponse(rsp)
}

// InvalidateRefreshTokenWithBodyWithResponse request with arbitrary body returning *InvalidateRefreshTokenResponse
func (c *ClientWithResponses) InvalidateRefreshTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvalidateRefreshTokenResponse, error) {
	rsp, err := c.InvalidateRefreshTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvalidateRefreshTokenResponse(rsp)
}

func (c *ClientWithResponses) InvalidateRefreshTokenWithResponse(ctx context.Context, body InvalidateRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*InvalidateRefreshTokenResponse, error) {
	rsp, err := c.InvalidateRefreshToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvalidateRefreshTokenResponse(rsp)
}

// GetUpgradablesByDomainWithResponse request returning *GetUpgradablesByDomainResponse
func (c *ClientWithResponses) GetUpgradablesByDomainWithResponse(ctx context.Context, domainId string, params *GetUpgradablesByDomainParams, reqEditors ...RequestEditorFn) (*GetUpgradablesByDomainResponse, error) {
	rsp, err := c.GetUpgradablesByDomain(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUpgradablesByDomainResponse(rsp)
}

// GetUpgradablesClustersWithResponse request returning *GetUpgradablesClustersResponse
func (c *ClientWithResponses) GetUpgradablesClustersWithResponse(ctx context.Context, domainId string, reqEditors ...RequestEditorFn) (*GetUpgradablesClustersResponse, error) {
	rsp, err := c.GetUpgradablesClusters(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUpgradablesClustersResponse(rsp)
}

// GetNsxUpgradeResourcesWithResponse request returning *GetNsxUpgradeResourcesResponse
func (c *ClientWithResponses) GetNsxUpgradeResourcesWithResponse(ctx context.Context, domainId string, params *GetNsxUpgradeResourcesParams, reqEditors ...RequestEditorFn) (*GetNsxUpgradeResourcesResponse, error) {
	rsp, err := c.GetNsxUpgradeResources(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNsxUpgradeResourcesResponse(rsp)
}

// GetUpgradesWithResponse request returning *GetUpgradesResponse
func (c *ClientWithResponses) GetUpgradesWithResponse(ctx context.Context, params *GetUpgradesParams, reqEditors ...RequestEditorFn) (*GetUpgradesResponse, error) {
	rsp, err := c.GetUpgrades(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUpgradesResponse(rsp)
}

// PerformUpgradeWithBodyWithResponse request with arbitrary body returning *PerformUpgradeResponse
func (c *ClientWithResponses) PerformUpgradeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PerformUpgradeResponse, error) {
	rsp, err := c.PerformUpgradeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePerformUpgradeResponse(rsp)
}

func (c *ClientWithResponses) PerformUpgradeWithResponse(ctx context.Context, body PerformUpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*PerformUpgradeResponse, error) {
	rsp, err := c.PerformUpgrade(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePerformUpgradeResponse(rsp)
}

// GetUpgradeByIdWithResponse request returning *GetUpgradeByIdResponse
func (c *ClientWithResponses) GetUpgradeByIdWithResponse(ctx context.Context, upgradeId string, reqEditors ...RequestEditorFn) (*GetUpgradeByIdResponse, error) {
	rsp, err := c.GetUpgradeById(ctx, upgradeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUpgradeByIdResponse(rsp)
}

// UpdateUpgradeScheduleWithBodyWithResponse request with arbitrary body returning *UpdateUpgradeScheduleResponse
func (c *ClientWithResponses) UpdateUpgradeScheduleWithBodyWithResponse(ctx context.Context, upgradeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUpgradeScheduleResponse, error) {
	rsp, err := c.UpdateUpgradeScheduleWithBody(ctx, upgradeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUpgradeScheduleResponse(rsp)
}

func (c *ClientWithResponses) UpdateUpgradeScheduleWithResponse(ctx context.Context, upgradeId string, body UpdateUpgradeScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUpgradeScheduleResponse, error) {
	rsp, err := c.UpdateUpgradeSchedule(ctx, upgradeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUpgradeScheduleResponse(rsp)
}

// StartUpgradePrecheckWithResponse request returning *StartUpgradePrecheckResponse
func (c *ClientWithResponses) StartUpgradePrecheckWithResponse(ctx context.Context, upgradeId string, reqEditors ...RequestEditorFn) (*StartUpgradePrecheckResponse, error) {
	rsp, err := c.StartUpgradePrecheck(ctx, upgradeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartUpgradePrecheckResponse(rsp)
}

// GetUpgradePrecheckByIDWithResponse request returning *GetUpgradePrecheckByIDResponse
func (c *ClientWithResponses) GetUpgradePrecheckByIDWithResponse(ctx context.Context, upgradeId string, precheckId string, reqEditors ...RequestEditorFn) (*GetUpgradePrecheckByIDResponse, error) {
	rsp, err := c.GetUpgradePrecheckByID(ctx, upgradeId, precheckId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUpgradePrecheckByIDResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// AddUsersWithBodyWithResponse request with arbitrary body returning *AddUsersResponse
func (c *ClientWithResponses) AddUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUsersResponse, error) {
	rsp, err := c.AddUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUsersResponse(rsp)
}

func (c *ClientWithResponses) AddUsersWithResponse(ctx context.Context, body AddUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUsersResponse, error) {
	rsp, err := c.AddUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUsersResponse(rsp)
}

// DisableLocalAccountWithResponse request returning *DisableLocalAccountResponse
func (c *ClientWithResponses) DisableLocalAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DisableLocalAccountResponse, error) {
	rsp, err := c.DisableLocalAccount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableLocalAccountResponse(rsp)
}

// GetLocalAccountWithResponse request returning *GetLocalAccountResponse
func (c *ClientWithResponses) GetLocalAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalAccountResponse, error) {
	rsp, err := c.GetLocalAccount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocalAccountResponse(rsp)
}

// UpdateLocalUserPasswordWithBodyWithResponse request with arbitrary body returning *UpdateLocalUserPasswordResponse
func (c *ClientWithResponses) UpdateLocalUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLocalUserPasswordResponse, error) {
	rsp, err := c.UpdateLocalUserPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLocalUserPasswordResponse(rsp)
}

func (c *ClientWithResponses) UpdateLocalUserPasswordWithResponse(ctx context.Context, body UpdateLocalUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLocalUserPasswordResponse, error) {
	rsp, err := c.UpdateLocalUserPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLocalUserPasswordResponse(rsp)
}

// GetUiUsersWithResponse request returning *GetUiUsersResponse
func (c *ClientWithResponses) GetUiUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUiUsersResponse, error) {
	rsp, err := c.GetUiUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUiUsersResponse(rsp)
}

// RemoveUserWithResponse request returning *RemoveUserResponse
func (c *ClientWithResponses) RemoveUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RemoveUserResponse, error) {
	rsp, err := c.RemoveUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserResponse(rsp)
}

// GetVasaProvidersWithResponse request returning *GetVasaProvidersResponse
func (c *ClientWithResponses) GetVasaProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVasaProvidersResponse, error) {
	rsp, err := c.GetVasaProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVasaProvidersResponse(rsp)
}

// AddVasaProviderWithBodyWithResponse request with arbitrary body returning *AddVasaProviderResponse
func (c *ClientWithResponses) AddVasaProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVasaProviderResponse, error) {
	rsp, err := c.AddVasaProviderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVasaProviderResponse(rsp)
}

func (c *ClientWithResponses) AddVasaProviderWithResponse(ctx context.Context, body AddVasaProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVasaProviderResponse, error) {
	rsp, err := c.AddVasaProvider(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVasaProviderResponse(rsp)
}

// ValidateVasaProviderSpecWithBodyWithResponse request with arbitrary body returning *ValidateVasaProviderSpecResponse
func (c *ClientWithResponses) ValidateVasaProviderSpecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateVasaProviderSpecResponse, error) {
	rsp, err := c.ValidateVasaProviderSpecWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateVasaProviderSpecResponse(rsp)
}

func (c *ClientWithResponses) ValidateVasaProviderSpecWithResponse(ctx context.Context, body ValidateVasaProviderSpecJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateVasaProviderSpecResponse, error) {
	rsp, err := c.ValidateVasaProviderSpec(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateVasaProviderSpecResponse(rsp)
}

// GetVasaProviderValidationWithResponse request returning *GetVasaProviderValidationResponse
func (c *ClientWithResponses) GetVasaProviderValidationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVasaProviderValidationResponse, error) {
	rsp, err := c.GetVasaProviderValidation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVasaProviderValidationResponse(rsp)
}

// RemoveVasaProviderWithResponse request returning *RemoveVasaProviderResponse
func (c *ClientWithResponses) RemoveVasaProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RemoveVasaProviderResponse, error) {
	rsp, err := c.RemoveVasaProvider(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveVasaProviderResponse(rsp)
}

// GetVasaProviderWithResponse request returning *GetVasaProviderResponse
func (c *ClientWithResponses) GetVasaProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVasaProviderResponse, error) {
	rsp, err := c.GetVasaProvider(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVasaProviderResponse(rsp)
}

// UpdateVasaProviderWithBodyWithResponse request with arbitrary body returning *UpdateVasaProviderResponse
func (c *ClientWithResponses) UpdateVasaProviderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVasaProviderResponse, error) {
	rsp, err := c.UpdateVasaProviderWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVasaProviderResponse(rsp)
}

func (c *ClientWithResponses) UpdateVasaProviderWithResponse(ctx context.Context, id string, body UpdateVasaProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVasaProviderResponse, error) {
	rsp, err := c.UpdateVasaProvider(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVasaProviderResponse(rsp)
}

// GetVasaProviderStorageContainersWithResponse request returning *GetVasaProviderStorageContainersResponse
func (c *ClientWithResponses) GetVasaProviderStorageContainersWithResponse(ctx context.Context, id string, params *GetVasaProviderStorageContainersParams, reqEditors ...RequestEditorFn) (*GetVasaProviderStorageContainersResponse, error) {
	rsp, err := c.GetVasaProviderStorageContainers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVasaProviderStorageContainersResponse(rsp)
}

// AddVasaProviderStorageContainerWithBodyWithResponse request with arbitrary body returning *AddVasaProviderStorageContainerResponse
func (c *ClientWithResponses) AddVasaProviderStorageContainerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVasaProviderStorageContainerResponse, error) {
	rsp, err := c.AddVasaProviderStorageContainerWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVasaProviderStorageContainerResponse(rsp)
}

func (c *ClientWithResponses) AddVasaProviderStorageContainerWithResponse(ctx context.Context, id string, body AddVasaProviderStorageContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVasaProviderStorageContainerResponse, error) {
	rsp, err := c.AddVasaProviderStorageContainer(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVasaProviderStorageContainerResponse(rsp)
}

// RemoveVasaProviderStorageContainerWithResponse request returning *RemoveVasaProviderStorageContainerResponse
func (c *ClientWithResponses) RemoveVasaProviderStorageContainerWithResponse(ctx context.Context, id string, storageContainerId string, reqEditors ...RequestEditorFn) (*RemoveVasaProviderStorageContainerResponse, error) {
	rsp, err := c.RemoveVasaProviderStorageContainer(ctx, id, storageContainerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveVasaProviderStorageContainerResponse(rsp)
}

// UpdateVasaProviderStorageContainerWithBodyWithResponse request with arbitrary body returning *UpdateVasaProviderStorageContainerResponse
func (c *ClientWithResponses) UpdateVasaProviderStorageContainerWithBodyWithResponse(ctx context.Context, id string, storageContainerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVasaProviderStorageContainerResponse, error) {
	rsp, err := c.UpdateVasaProviderStorageContainerWithBody(ctx, id, storageContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVasaProviderStorageContainerResponse(rsp)
}

func (c *ClientWithResponses) UpdateVasaProviderStorageContainerWithResponse(ctx context.Context, id string, storageContainerId string, body UpdateVasaProviderStorageContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVasaProviderStorageContainerResponse, error) {
	rsp, err := c.UpdateVasaProviderStorageContainer(ctx, id, storageContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVasaProviderStorageContainerResponse(rsp)
}

// GetVasaProviderUserWithResponse request returning *GetVasaProviderUserResponse
func (c *ClientWithResponses) GetVasaProviderUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVasaProviderUserResponse, error) {
	rsp, err := c.GetVasaProviderUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVasaProviderUserResponse(rsp)
}

// AddVasaProviderUserWithBodyWithResponse request with arbitrary body returning *AddVasaProviderUserResponse
func (c *ClientWithResponses) AddVasaProviderUserWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVasaProviderUserResponse, error) {
	rsp, err := c.AddVasaProviderUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVasaProviderUserResponse(rsp)
}

func (c *ClientWithResponses) AddVasaProviderUserWithResponse(ctx context.Context, id string, body AddVasaProviderUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVasaProviderUserResponse, error) {
	rsp, err := c.AddVasaProviderUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVasaProviderUserResponse(rsp)
}

// UpdateVasaProviderUserWithBodyWithResponse request with arbitrary body returning *UpdateVasaProviderUserResponse
func (c *ClientWithResponses) UpdateVasaProviderUserWithBodyWithResponse(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVasaProviderUserResponse, error) {
	rsp, err := c.UpdateVasaProviderUserWithBody(ctx, id, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVasaProviderUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateVasaProviderUserWithResponse(ctx context.Context, id string, userId string, body UpdateVasaProviderUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVasaProviderUserResponse, error) {
	rsp, err := c.UpdateVasaProviderUser(ctx, id, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVasaProviderUserResponse(rsp)
}

// GetVcentersWithResponse request returning *GetVcentersResponse
func (c *ClientWithResponses) GetVcentersWithResponse(ctx context.Context, params *GetVcentersParams, reqEditors ...RequestEditorFn) (*GetVcentersResponse, error) {
	rsp, err := c.GetVcenters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVcentersResponse(rsp)
}

// GetVcenterWithResponse request returning *GetVcenterResponse
func (c *ClientWithResponses) GetVcenterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVcenterResponse, error) {
	rsp, err := c.GetVcenter(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVcenterResponse(rsp)
}

// GetVcfServicesWithResponse request returning *GetVcfServicesResponse
func (c *ClientWithResponses) GetVcfServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVcfServicesResponse, error) {
	rsp, err := c.GetVcfServices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVcfServicesResponse(rsp)
}

// GetVcfServiceWithResponse request returning *GetVcfServiceResponse
func (c *ClientWithResponses) GetVcfServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVcfServiceResponse, error) {
	rsp, err := c.GetVcfService(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVcfServiceResponse(rsp)
}

// GetVrasWithResponse request returning *GetVrasResponse
func (c *ClientWithResponses) GetVrasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrasResponse, error) {
	rsp, err := c.GetVras(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVrasResponse(rsp)
}

// GetVrliIntegratedDomainsWithResponse request returning *GetVrliIntegratedDomainsResponse
func (c *ClientWithResponses) GetVrliIntegratedDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrliIntegratedDomainsResponse, error) {
	rsp, err := c.GetVrliIntegratedDomains(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVrliIntegratedDomainsResponse(rsp)
}

// ConnectVrliWithDomainWithBodyWithResponse request with arbitrary body returning *ConnectVrliWithDomainResponse
func (c *ClientWithResponses) ConnectVrliWithDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectVrliWithDomainResponse, error) {
	rsp, err := c.ConnectVrliWithDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectVrliWithDomainResponse(rsp)
}

func (c *ClientWithResponses) ConnectVrliWithDomainWithResponse(ctx context.Context, body ConnectVrliWithDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectVrliWithDomainResponse, error) {
	rsp, err := c.ConnectVrliWithDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectVrliWithDomainResponse(rsp)
}

// GetVrlisWithResponse request returning *GetVrlisResponse
func (c *ClientWithResponses) GetVrlisWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrlisResponse, error) {
	rsp, err := c.GetVrlis(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVrlisResponse(rsp)
}

// GetVropsIntegratedDomainsWithResponse request returning *GetVropsIntegratedDomainsResponse
func (c *ClientWithResponses) GetVropsIntegratedDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVropsIntegratedDomainsResponse, error) {
	rsp, err := c.GetVropsIntegratedDomains(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVropsIntegratedDomainsResponse(rsp)
}

// ConnectVropsWithDomainWithBodyWithResponse request with arbitrary body returning *ConnectVropsWithDomainResponse
func (c *ClientWithResponses) ConnectVropsWithDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectVropsWithDomainResponse, error) {
	rsp, err := c.ConnectVropsWithDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectVropsWithDomainResponse(rsp)
}

func (c *ClientWithResponses) ConnectVropsWithDomainWithResponse(ctx context.Context, body ConnectVropsWithDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectVropsWithDomainResponse, error) {
	rsp, err := c.ConnectVropsWithDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectVropsWithDomainResponse(rsp)
}

// GetVropsesWithResponse request returning *GetVropsesResponse
func (c *ClientWithResponses) GetVropsesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVropsesResponse, error) {
	rsp, err := c.GetVropses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVropsesResponse(rsp)
}

// RollbackVrslcmWithResponse request returning *RollbackVrslcmResponse
func (c *ClientWithResponses) RollbackVrslcmWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RollbackVrslcmResponse, error) {
	rsp, err := c.RollbackVrslcm(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRollbackVrslcmResponse(rsp)
}

// GetVrslcmWithResponse request returning *GetVrslcmResponse
func (c *ClientWithResponses) GetVrslcmWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrslcmResponse, error) {
	rsp, err := c.GetVrslcm(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVrslcmResponse(rsp)
}

// UpdateVrslcmVersionInInventoryWithBodyWithResponse request with arbitrary body returning *UpdateVrslcmVersionInInventoryResponse
func (c *ClientWithResponses) UpdateVrslcmVersionInInventoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVrslcmVersionInInventoryResponse, error) {
	rsp, err := c.UpdateVrslcmVersionInInventoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVrslcmVersionInInventoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateVrslcmVersionInInventoryWithResponse(ctx context.Context, body UpdateVrslcmVersionInInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVrslcmVersionInInventoryResponse, error) {
	rsp, err := c.UpdateVrslcmVersionInInventory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVrslcmVersionInInventoryResponse(rsp)
}

// GetVrslcmStatusWithResponse request returning *GetVrslcmStatusResponse
func (c *ClientWithResponses) GetVrslcmStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrslcmStatusResponse, error) {
	rsp, err := c.GetVrslcmStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVrslcmStatusResponse(rsp)
}

// GetVrslcmsWithResponse request returning *GetVrslcmsResponse
func (c *ClientWithResponses) GetVrslcmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVrslcmsResponse, error) {
	rsp, err := c.GetVrslcms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVrslcmsResponse(rsp)
}

// DeployVrslcmWithBodyWithResponse request with arbitrary body returning *DeployVrslcmResponse
func (c *ClientWithResponses) DeployVrslcmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployVrslcmResponse, error) {
	rsp, err := c.DeployVrslcmWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeployVrslcmResponse(rsp)
}

func (c *ClientWithResponses) DeployVrslcmWithResponse(ctx context.Context, body DeployVrslcmJSONRequestBody, reqEditors ...RequestEditorFn) (*DeployVrslcmResponse, error) {
	rsp, err := c.DeployVrslcm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeployVrslcmResponse(rsp)
}

// ValidateVrslcmWithBodyWithResponse request with arbitrary body returning *ValidateVrslcmResponse
func (c *ClientWithResponses) ValidateVrslcmWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateVrslcmResponse, error) {
	rsp, err := c.ValidateVrslcmWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateVrslcmResponse(rsp)
}

func (c *ClientWithResponses) ValidateVrslcmWithResponse(ctx context.Context, body ValidateVrslcmJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateVrslcmResponse, error) {
	rsp, err := c.ValidateVrslcm(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateVrslcmResponse(rsp)
}

// GetVrslcmValidationWithResponse request returning *GetVrslcmValidationResponse
func (c *ClientWithResponses) GetVrslcmValidationWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetVrslcmValidationResponse, error) {
	rsp, err := c.GetVrslcmValidation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVrslcmValidationResponse(rsp)
}

// UpdateVrslcmVersionByIdInInventoryWithBodyWithResponse request with arbitrary body returning *UpdateVrslcmVersionByIdInInventoryResponse
func (c *ClientWithResponses) UpdateVrslcmVersionByIdInInventoryWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVrslcmVersionByIdInInventoryResponse, error) {
	rsp, err := c.UpdateVrslcmVersionByIdInInventoryWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVrslcmVersionByIdInInventoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateVrslcmVersionByIdInInventoryWithResponse(ctx context.Context, id string, body UpdateVrslcmVersionByIdInInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVrslcmVersionByIdInInventoryResponse, error) {
	rsp, err := c.UpdateVrslcmVersionByIdInInventory(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVrslcmVersionByIdInInventoryResponse(rsp)
}

// DownloadVsanHclWithResponse request returning *DownloadVsanHclResponse
func (c *ClientWithResponses) DownloadVsanHclWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DownloadVsanHclResponse, error) {
	rsp, err := c.DownloadVsanHcl(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadVsanHclResponse(rsp)
}

// GetVsanHclAttributesWithResponse request returning *GetVsanHclAttributesResponse
func (c *ClientWithResponses) GetVsanHclAttributesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVsanHclAttributesResponse, error) {
	rsp, err := c.GetVsanHclAttributes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVsanHclAttributesResponse(rsp)
}

// GetVsanHclConfigurationWithResponse request returning *GetVsanHclConfigurationResponse
func (c *ClientWithResponses) GetVsanHclConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVsanHclConfigurationResponse, error) {
	rsp, err := c.GetVsanHclConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVsanHclConfigurationResponse(rsp)
}

// UpdateVsanHclConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateVsanHclConfigurationResponse
func (c *ClientWithResponses) UpdateVsanHclConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVsanHclConfigurationResponse, error) {
	rsp, err := c.UpdateVsanHclConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVsanHclConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateVsanHclConfigurationWithResponse(ctx context.Context, body UpdateVsanHclConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVsanHclConfigurationResponse, error) {
	rsp, err := c.UpdateVsanHclConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVsanHclConfigurationResponse(rsp)
}

// GetWsasWithResponse request returning *GetWsasResponse
func (c *ClientWithResponses) GetWsasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWsasResponse, error) {
	rsp, err := c.GetWsas(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWsasResponse(rsp)
}

// ParseGetAvnsResponse parses an HTTP response from a GetAvnsWithResponse call
func ParseGetAvnsResponse(rsp *http.Response) (*GetAvnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Avn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAvnsResponse parses an HTTP response from a CreateAvnsWithResponse call
func ParseCreateAvnsResponse(rsp *http.Response) (*CreateAvnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAvnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateAvnSpecResponse parses an HTTP response from a ValidateAvnSpecWithResponse call
func ParseValidateAvnSpecResponse(rsp *http.Response) (*ValidateAvnSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateAvnSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartBackupResponse parses an HTTP response from a StartBackupWithResponse call
func ParseStartBackupResponse(rsp *http.Response) (*StartBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BackupTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBundlesResponse parses an HTTP response from a GetBundlesWithResponse call
func ParseGetBundlesResponse(rsp *http.Response) (*GetBundlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBundlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfBundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadBundleResponse parses an HTTP response from a UploadBundleWithResponse call
func ParseUploadBundleResponse(rsp *http.Response) (*UploadBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateBundleCompatibilitySetsResponse parses an HTTP response from a UpdateBundleCompatibilitySetsWithResponse call
func ParseUpdateBundleCompatibilitySetsResponse(rsp *http.Response) (*UpdateBundleCompatibilitySetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBundleCompatibilitySetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBundlesForSkipUpgradeResponse parses an HTTP response from a GetBundlesForSkipUpgradeWithResponse call
func ParseGetBundlesForSkipUpgradeResponse(rsp *http.Response) (*GetBundlesForSkipUpgradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBundlesForSkipUpgradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfBundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBundleResponse parses an HTTP response from a DeleteBundleWithResponse call
func ParseDeleteBundleResponse(rsp *http.Response) (*DeleteBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBundleResponse parses an HTTP response from a GetBundleWithResponse call
func ParseGetBundleResponse(rsp *http.Response) (*GetBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartBundleDownloadByIDResponse parses an HTTP response from a StartBundleDownloadByIDWithResponse call
func ParseStartBundleDownloadByIDResponse(rsp *http.Response) (*StartBundleDownloadByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartBundleDownloadByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertificateAuthoritiesResponse parses an HTTP response from a GetCertificateAuthoritiesWithResponse call
func ParseGetCertificateAuthoritiesResponse(rsp *http.Response) (*GetCertificateAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertificateAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfCertificateAuthority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseConfigureCertificateAuthorityResponse parses an HTTP response from a ConfigureCertificateAuthorityWithResponse call
func ParseConfigureCertificateAuthorityResponse(rsp *http.Response) (*ConfigureCertificateAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigureCertificateAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateCertificateAuthorityResponse parses an HTTP response from a CreateCertificateAuthorityWithResponse call
func ParseCreateCertificateAuthorityResponse(rsp *http.Response) (*CreateCertificateAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCertificateAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveCertificateAuthorityResponse parses an HTTP response from a RemoveCertificateAuthorityWithResponse call
func ParseRemoveCertificateAuthorityResponse(rsp *http.Response) (*RemoveCertificateAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveCertificateAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertificateAuthorityByIdResponse parses an HTTP response from a GetCertificateAuthorityByIdWithResponse call
func ParseGetCertificateAuthorityByIdResponse(rsp *http.Response) (*GetCertificateAuthorityByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertificateAuthorityByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateAuthority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClustersResponse parses an HTTP response from a GetClustersWithResponse call
func ParseGetClustersResponse(rsp *http.Response) (*GetClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTagsAssignedToClustersResponse parses an HTTP response from a GetTagsAssignedToClustersWithResponse call
func ParseGetTagsAssignedToClustersResponse(rsp *http.Response) (*GetTagsAssignedToClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsAssignedToClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTagsForResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateClusterCreationSpecResponse parses an HTTP response from a ValidateClusterCreationSpecWithResponse call
func ParseValidateClusterCreationSpecResponse(rsp *http.Response) (*ValidateClusterCreationSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateClusterCreationSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterCreateValidationResponse parses an HTTP response from a GetClusterCreateValidationWithResponse call
func ParseGetClusterCreateValidationResponse(rsp *http.Response) (*GetClusterCreateValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterCreateValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDatastoreQueryResponse1Response parses an HTTP response from a GetDatastoreQueryResponse1WithResponse call
func ParseGetDatastoreQueryResponse1Response(rsp *http.Response) (*GetDatastoreQueryResponse1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatastoreQueryResponse1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatastoreQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateVsanRemoteDatastoreSpecResponse parses an HTTP response from a ValidateVsanRemoteDatastoreSpecWithResponse call
func ParseValidateVsanRemoteDatastoreSpecResponse(rsp *http.Response) (*ValidateVsanRemoteDatastoreSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateVsanRemoteDatastoreSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateVsanRemoteDatastoreMountSpecResponse parses an HTTP response from a ValidateVsanRemoteDatastoreMountSpecWithResponse call
func ParseValidateVsanRemoteDatastoreMountSpecResponse(rsp *http.Response) (*ValidateVsanRemoteDatastoreMountSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateVsanRemoteDatastoreMountSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHostQueryResponse1Response parses an HTTP response from a GetHostQueryResponse1WithResponse call
func ParseGetHostQueryResponse1Response(rsp *http.Response) (*GetHostQueryResponse1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostQueryResponse1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HostQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HostQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVdsesResponse parses an HTTP response from a GetVdsesWithResponse call
func ParseGetVdsesResponse(rsp *http.Response) (*GetVdsesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVdsesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Vds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseImportVdsToInventoryResponse parses an HTTP response from a ImportVdsToInventoryWithResponse call
func ParseImportVdsToInventoryResponse(rsp *http.Response) (*ImportVdsToInventoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportVdsToInventoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterDatastoresResponse parses an HTTP response from a GetClusterDatastoresWithResponse call
func ParseGetClusterDatastoresResponse(rsp *http.Response) (*GetClusterDatastoresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterDatastoresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Datastore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddDatastoreToClusterResponse parses an HTTP response from a AddDatastoreToClusterWithResponse call
func ParseAddDatastoreToClusterResponse(rsp *http.Response) (*AddDatastoreToClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDatastoreToClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatastoresCriteria1Response parses an HTTP response from a GetDatastoresCriteria1WithResponse call
func ParseGetDatastoresCriteria1Response(rsp *http.Response) (*GetDatastoresCriteria1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatastoresCriteria1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfDatastoreCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDatastoreCriterion1Response parses an HTTP response from a GetDatastoreCriterion1WithResponse call
func ParseGetDatastoreCriterion1Response(rsp *http.Response) (*GetDatastoreCriterion1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatastoreCriterion1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatastoreCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostDatastoreQuery1Response parses an HTTP response from a PostDatastoreQuery1WithResponse call
func ParsePostDatastoreQuery1Response(rsp *http.Response) (*PostDatastoreQuery1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDatastoreQuery1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatastoreQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveDatastoreFromClusterResponse parses an HTTP response from a RemoveDatastoreFromClusterWithResponse call
func ParseRemoveDatastoreFromClusterResponse(rsp *http.Response) (*RemoveDatastoreFromClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveDatastoreFromClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHostCriteriaResponse parses an HTTP response from a GetHostCriteriaWithResponse call
func ParseGetHostCriteriaResponse(rsp *http.Response) (*GetHostCriteriaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostCriteriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfHostCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHostCriterionResponse parses an HTTP response from a GetHostCriterionWithResponse call
func ParseGetHostCriterionResponse(rsp *http.Response) (*GetHostCriterionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostCriterionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HostCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostHostQueryResponse parses an HTTP response from a PostHostQueryWithResponse call
func ParsePostHostQueryResponse(rsp *http.Response) (*PostHostQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostHostQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HostQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterNetworkConfigurationCriteriaResponse parses an HTTP response from a GetClusterNetworkConfigurationCriteriaWithResponse call
func ParseGetClusterNetworkConfigurationCriteriaResponse(rsp *http.Response) (*GetClusterNetworkConfigurationCriteriaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterNetworkConfigurationCriteriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetClusterNetworkConfigurationResponse parses an HTTP response from a GetClusterNetworkConfigurationWithResponse call
func ParseGetClusterNetworkConfigurationResponse(rsp *http.Response) (*GetClusterNetworkConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterNetworkConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterNetworkConfigurationQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterNetworkConfigurationQueryResponseResponse parses an HTTP response from a GetClusterNetworkConfigurationQueryResponseWithResponse call
func ParseGetClusterNetworkConfigurationQueryResponseResponse(rsp *http.Response) (*GetClusterNetworkConfigurationQueryResponseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterNetworkConfigurationQueryResponseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterNetworkConfigurationQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveTagsFromClusterResponse parses an HTTP response from a RemoveTagsFromClusterWithResponse call
func ParseRemoveTagsFromClusterResponse(rsp *http.Response) (*RemoveTagsFromClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTagsFromClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagAssignmentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTagsAssignedToClusterResponse parses an HTTP response from a GetTagsAssignedToClusterWithResponse call
func ParseGetTagsAssignedToClusterResponse(rsp *http.Response) (*GetTagsAssignedToClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsAssignedToClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAssignTagsToClusterResponse parses an HTTP response from a AssignTagsToClusterWithResponse call
func ParseAssignTagsToClusterResponse(rsp *http.Response) (*AssignTagsToClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignTagsToClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagAssignmentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTagAssignableForClusterResponse parses an HTTP response from a GetTagAssignableForClusterWithResponse call
func ParseGetTagAssignableForClusterResponse(rsp *http.Response) (*GetTagAssignableForClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagAssignableForClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterTagManagerUrlResponse parses an HTTP response from a GetClusterTagManagerUrlWithResponse call
func ParseGetClusterTagManagerUrlResponse(rsp *http.Response) (*GetClusterTagManagerUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterTagManagerUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagManagerModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateClusterUpdateSpecResponse parses an HTTP response from a ValidateClusterUpdateSpecWithResponse call
func ParseValidateClusterUpdateSpecResponse(rsp *http.Response) (*ValidateClusterUpdateSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateClusterUpdateSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterUpdateValidationResponse parses an HTTP response from a GetClusterUpdateValidationWithResponse call
func ParseGetClusterUpdateValidationResponse(rsp *http.Response) (*GetClusterUpdateValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterUpdateValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCompatibilityMatricesResponse parses an HTTP response from a GetCompatibilityMatricesWithResponse call
func ParseGetCompatibilityMatricesResponse(rsp *http.Response) (*GetCompatibilityMatricesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompatibilityMatricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfCompatibilityMatrix
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCompatibilityMatrixResponse parses an HTTP response from a UpdateCompatibilityMatrixWithResponse call
func ParseUpdateCompatibilityMatrixResponse(rsp *http.Response) (*UpdateCompatibilityMatrixResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCompatibilityMatrixResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCompatibilityMatrixResponse parses an HTTP response from a GetCompatibilityMatrixWithResponse call
func ParseGetCompatibilityMatrixResponse(rsp *http.Response) (*GetCompatibilityMatrixResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompatibilityMatrixResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompatibilityMatrix
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCompatibilityMatrixContentResponse parses an HTTP response from a GetCompatibilityMatrixContentWithResponse call
func ParseGetCompatibilityMatrixContentResponse(rsp *http.Response) (*GetCompatibilityMatrixContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompatibilityMatrixContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCompatibilityMatrixMetadataResponse parses an HTTP response from a GetCompatibilityMatrixMetadataWithResponse call
func ParseGetCompatibilityMatrixMetadataResponse(rsp *http.Response) (*GetCompatibilityMatrixMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompatibilityMatrixMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompatibilityMatrixMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComplianceAuditHistoryResponse parses an HTTP response from a GetComplianceAuditHistoryWithResponse call
func ParseGetComplianceAuditHistoryResponse(rsp *http.Response) (*GetComplianceAuditHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplianceAuditHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfComplianceAudit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComplianceAuditResponse parses an HTTP response from a GetComplianceAuditWithResponse call
func ParseGetComplianceAuditResponse(rsp *http.Response) (*GetComplianceAuditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplianceAuditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComplianceAudit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComplianceAuditItemsResponse parses an HTTP response from a GetComplianceAuditItemsWithResponse call
func ParseGetComplianceAuditItemsResponse(rsp *http.Response) (*GetComplianceAuditItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplianceAuditItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfComplianceAuditItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComplianceConfigurationsResponse parses an HTTP response from a GetComplianceConfigurationsWithResponse call
func ParseGetComplianceConfigurationsResponse(rsp *http.Response) (*GetComplianceConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplianceConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfComplianceConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComplianceStandardsResponse parses an HTTP response from a GetComplianceStandardsWithResponse call
func ParseGetComplianceStandardsResponse(rsp *http.Response) (*GetComplianceStandardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplianceStandardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfComplianceStandard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReconcileConfigsResponse parses an HTTP response from a ReconcileConfigsWithResponse call
func ParseReconcileConfigsResponse(rsp *http.Response) (*ReconcileConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReconcileConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReconciliationTaskResponse parses an HTTP response from a GetReconciliationTaskWithResponse call
func ParseGetReconciliationTaskResponse(rsp *http.Response) (*GetReconciliationTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReconciliationTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConfigsResponse parses an HTTP response from a GetConfigsWithResponse call
func ParseGetConfigsResponse(rsp *http.Response) (*GetConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfConfigDriftSpec
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetCredentialsResponse parses an HTTP response from a GetCredentialsWithResponse call
func ParseGetCredentialsResponse(rsp *http.Response) (*GetCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfCredential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateOrRotatePasswordsResponse parses an HTTP response from a UpdateOrRotatePasswordsWithResponse call
func ParseUpdateOrRotatePasswordsResponse(rsp *http.Response) (*UpdateOrRotatePasswordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrRotatePasswordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPasswordExpirationResponse parses an HTTP response from a GetPasswordExpirationWithResponse call
func ParseGetPasswordExpirationResponse(rsp *http.Response) (*GetPasswordExpirationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPasswordExpirationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CredentialsExpiration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPasswordExpirationByTaskIDResponse parses an HTTP response from a GetPasswordExpirationByTaskIDWithResponse call
func ParseGetPasswordExpirationByTaskIDResponse(rsp *http.Response) (*GetPasswordExpirationByTaskIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPasswordExpirationByTaskIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsExpiration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCredentialsTasksResponse parses an HTTP response from a GetCredentialsTasksWithResponse call
func ParseGetCredentialsTasksResponse(rsp *http.Response) (*GetCredentialsTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialsTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfCredentialsTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCancelCredentialsTaskResponse parses an HTTP response from a CancelCredentialsTaskWithResponse call
func ParseCancelCredentialsTaskResponse(rsp *http.Response) (*CancelCredentialsTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelCredentialsTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCredentialsTaskResponse parses an HTTP response from a GetCredentialsTaskWithResponse call
func ParseGetCredentialsTaskResponse(rsp *http.Response) (*GetCredentialsTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialsTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRetryCredentialsTaskResponse parses an HTTP response from a RetryCredentialsTaskWithResponse call
func ParseRetryCredentialsTaskResponse(rsp *http.Response) (*RetryCredentialsTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetryCredentialsTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCredentialTaskByResourceIDResponse parses an HTTP response from a GetCredentialTaskByResourceIDWithResponse call
func ParseGetCredentialTaskByResourceIDResponse(rsp *http.Response) (*GetCredentialTaskByResourceIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialTaskByResourceIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourceCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCredentialsSubTaskResponse parses an HTTP response from a GetCredentialsSubTaskWithResponse call
func ParseGetCredentialsSubTaskResponse(rsp *http.Response) (*GetCredentialsSubTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialsSubTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCredentialResponse parses an HTTP response from a GetCredentialWithResponse call
func ParseGetCredentialResponse(rsp *http.Response) (*GetCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Credential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomIsosResponse parses an HTTP response from a GetCustomIsosWithResponse call
func ParseGetCustomIsosResponse(rsp *http.Response) (*GetCustomIsosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomIsosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfCustomIso
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadCustomIsoResponse parses an HTTP response from a UploadCustomIsoWithResponse call
func ParseUploadCustomIsoResponse(rsp *http.Response) (*UploadCustomIsoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadCustomIsoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCustomIsoByIdResponse parses an HTTP response from a DeleteCustomIsoByIdWithResponse call
func ParseDeleteCustomIsoByIdResponse(rsp *http.Response) (*DeleteCustomIsoByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomIsoByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomIsoByIdResponse parses an HTTP response from a GetCustomIsoByIdWithResponse call
func ParseGetCustomIsoByIdResponse(rsp *http.Response) (*GetCustomIsoByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomIsoByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomIso
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRenameCustomIsoByIdResponse parses an HTTP response from a RenameCustomIsoByIdWithResponse call
func ParseRenameCustomIsoByIdResponse(rsp *http.Response) (*RenameCustomIsoByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenameCustomIsoByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomIso
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainsResponse parses an HTTP response from a GetDomainsWithResponse call
func ParseGetDomainsResponse(rsp *http.Response) (*GetDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateDomainResponse parses an HTTP response from a CreateDomainWithResponse call
func ParseCreateDomainResponse(rsp *http.Response) (*CreateDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTagsAssignedToDomainsResponse parses an HTTP response from a GetTagsAssignedToDomainsWithResponse call
func ParseGetTagsAssignedToDomainsResponse(rsp *http.Response) (*GetTagsAssignedToDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsAssignedToDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTagsForResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateDomainCreationSpecResponse parses an HTTP response from a ValidateDomainCreationSpecWithResponse call
func ParseValidateDomainCreationSpecResponse(rsp *http.Response) (*ValidateDomainCreationSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateDomainCreationSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDomainCreateValidationResponse parses an HTTP response from a DomainCreateValidationWithResponse call
func ParseDomainCreateValidationResponse(rsp *http.Response) (*DomainCreateValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DomainCreateValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetClusterCriteriaResponse parses an HTTP response from a GetClusterCriteriaWithResponse call
func ParseGetClusterCriteriaResponse(rsp *http.Response) (*GetClusterCriteriaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterCriteriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfClusterCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClusterCriterionResponse parses an HTTP response from a GetClusterCriterionWithResponse call
func ParseGetClusterCriterionResponse(rsp *http.Response) (*GetClusterCriterionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterCriterionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostClustersQueryResponse parses an HTTP response from a PostClustersQueryWithResponse call
func ParsePostClustersQueryResponse(rsp *http.Response) (*PostClustersQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClustersQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClustersQueryResponseResponse parses an HTTP response from a GetClustersQueryResponseWithResponse call
func ParseGetClustersQueryResponseResponse(rsp *http.Response) (*GetClustersQueryResponseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClustersQueryResponseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClusterQueryResponse parses an HTTP response from a PostClusterQueryWithResponse call
func ParsePostClusterQueryResponse(rsp *http.Response) (*PostClusterQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClusterQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterQueryResponseResponse parses an HTTP response from a GetClusterQueryResponseWithResponse call
func ParseGetClusterQueryResponseResponse(rsp *http.Response) (*GetClusterQueryResponseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterQueryResponseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatastoresCriteriaResponse parses an HTTP response from a GetDatastoresCriteriaWithResponse call
func ParseGetDatastoresCriteriaResponse(rsp *http.Response) (*GetDatastoresCriteriaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatastoresCriteriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfDatastoreCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDatastoreCriterionResponse parses an HTTP response from a GetDatastoreCriterionWithResponse call
func ParseGetDatastoreCriterionResponse(rsp *http.Response) (*GetDatastoreCriterionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatastoreCriterionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatastoreCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostDatastoreQueryResponse parses an HTTP response from a PostDatastoreQueryWithResponse call
func ParsePostDatastoreQueryResponse(rsp *http.Response) (*PostDatastoreQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDatastoreQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatastoreQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatastoreQueryResponseResponse parses an HTTP response from a GetDatastoreQueryResponseWithResponse call
func ParseGetDatastoreQueryResponseResponse(rsp *http.Response) (*GetDatastoreQueryResponseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatastoreQueryResponseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatastoreQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVsanHealthCheckByDomainResponse parses an HTTP response from a GetVsanHealthCheckByDomainWithResponse call
func ParseGetVsanHealthCheckByDomainResponse(rsp *http.Response) (*GetVsanHealthCheckByDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVsanHealthCheckByDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HealthCheckQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVsanHealthCheckByDomainResponse parses an HTTP response from a UpdateVsanHealthCheckByDomainWithResponse call
func ParseUpdateVsanHealthCheckByDomainResponse(rsp *http.Response) (*UpdateVsanHealthCheckByDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVsanHealthCheckByDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HealthCheckTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVsanHealthCheckByQueryIDResponse parses an HTTP response from a GetVsanHealthCheckByQueryIDWithResponse call
func ParseGetVsanHealthCheckByQueryIDResponse(rsp *http.Response) (*GetVsanHealthCheckByQueryIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVsanHealthCheckByQueryIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthCheckQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVsanHealthCheckByTaskIDResponse parses an HTTP response from a GetVsanHealthCheckByTaskIDWithResponse call
func ParseGetVsanHealthCheckByTaskIDResponse(rsp *http.Response) (*GetVsanHealthCheckByTaskIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVsanHealthCheckByTaskIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthCheckTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePerformDomainIsolationPrecheckResponse parses an HTTP response from a PerformDomainIsolationPrecheckWithResponse call
func ParsePerformDomainIsolationPrecheckResponse(rsp *http.Response) (*PerformDomainIsolationPrecheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PerformDomainIsolationPrecheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainIsolationPrecheckStatusResponse parses an HTTP response from a GetDomainIsolationPrecheckStatusWithResponse call
func ParseGetDomainIsolationPrecheckStatusResponse(rsp *http.Response) (*GetDomainIsolationPrecheckStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainIsolationPrecheckStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IsolationPrecheckResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDomainResponse parses an HTTP response from a DeleteDomainWithResponse call
func ParseDeleteDomainResponse(rsp *http.Response) (*DeleteDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainResponse parses an HTTP response from a GetDomainWithResponse call
func ParseGetDomainResponse(rsp *http.Response) (*GetDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Domain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDomainResponse parses an HTTP response from a UpdateDomainWithResponse call
func ParseUpdateDomainResponse(rsp *http.Response) (*UpdateDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainCertificatesResponse parses an HTTP response from a GetDomainCertificatesWithResponse call
func ParseGetDomainCertificatesResponse(rsp *http.Response) (*GetDomainCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReplaceCertificatesResponse parses an HTTP response from a ReplaceCertificatesWithResponse call
func ParseReplaceCertificatesResponse(rsp *http.Response) (*ReplaceCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateCertificatesResponse parses an HTTP response from a GenerateCertificatesWithResponse call
func ParseGenerateCertificatesResponse(rsp *http.Response) (*GenerateCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadCertificatesResponse parses an HTTP response from a UploadCertificatesWithResponse call
func ParseUploadCertificatesResponse(rsp *http.Response) (*UploadCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComplianceAuditHistoryForADomainResponse parses an HTTP response from a GetComplianceAuditHistoryForADomainWithResponse call
func ParseGetComplianceAuditHistoryForADomainResponse(rsp *http.Response) (*GetComplianceAuditHistoryForADomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplianceAuditHistoryForADomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfComplianceAudit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseComplianceAuditResponse parses an HTTP response from a ComplianceAuditWithResponse call
func ParseComplianceAuditResponse(rsp *http.Response) (*ComplianceAuditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ComplianceAuditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ComplianceTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComplianceAuditTaskResponse parses an HTTP response from a GetComplianceAuditTaskWithResponse call
func ParseGetComplianceAuditTaskResponse(rsp *http.Response) (*GetComplianceAuditTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplianceAuditTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComplianceTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRetryComplianceAuditTaskResponse parses an HTTP response from a RetryComplianceAuditTaskWithResponse call
func ParseRetryComplianceAuditTaskResponse(rsp *http.Response) (*RetryComplianceAuditTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetryComplianceAuditTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ComplianceTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComplianceAuditForADomainResponse parses an HTTP response from a GetComplianceAuditForADomainWithResponse call
func ParseGetComplianceAuditForADomainResponse(rsp *http.Response) (*GetComplianceAuditForADomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplianceAuditForADomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComplianceAudit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComplianceAuditItemsForADomainResponse parses an HTTP response from a GetComplianceAuditItemsForADomainWithResponse call
func ParseGetComplianceAuditItemsForADomainResponse(rsp *http.Response) (*GetComplianceAuditItemsForADomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplianceAuditItemsForADomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfComplianceAuditItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCSRsResponse parses an HTTP response from a GetCSRsWithResponse call
func ParseGetCSRsResponse(rsp *http.Response) (*GetCSRsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCSRsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfCsr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGeneratesCSRsResponse parses an HTTP response from a GeneratesCSRsWithResponse call
func ParseGeneratesCSRsResponse(rsp *http.Response) (*GeneratesCSRsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneratesCSRsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadCSRResponse parses an HTTP response from a DownloadCSRWithResponse call
func ParseDownloadCSRResponse(rsp *http.Response) (*DownloadCSRResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadCSRResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []byte
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEndpointsResponse parses an HTTP response from a GetDomainEndpointsWithResponse call
func ParseGetDomainEndpointsResponse(rsp *http.Response) (*GetDomainEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfEndpoint
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertificatesByDomainResponse parses an HTTP response from a GetCertificatesByDomainWithResponse call
func ParseGetCertificatesByDomainResponse(rsp *http.Response) (*GetCertificatesByDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertificatesByDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReplaceResourceCertificatesResponse parses an HTTP response from a ReplaceResourceCertificatesWithResponse call
func ParseReplaceResourceCertificatesResponse(rsp *http.Response) (*ReplaceResourceCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceResourceCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateResourceCertificatesResponse parses an HTTP response from a ValidateResourceCertificatesWithResponse call
func ParseValidateResourceCertificatesResponse(rsp *http.Response) (*ValidateResourceCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateResourceCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CertificateValidationTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceCertificatesValidationByIDResponse parses an HTTP response from a GetResourceCertificatesValidationByIDWithResponse call
func ParseGetResourceCertificatesValidationByIDResponse(rsp *http.Response) (*GetResourceCertificatesValidationByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceCertificatesValidationByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveTagsFromDomainResponse parses an HTTP response from a RemoveTagsFromDomainWithResponse call
func ParseRemoveTagsFromDomainResponse(rsp *http.Response) (*RemoveTagsFromDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTagsFromDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagAssignmentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTagsAssignedToDomainResponse parses an HTTP response from a GetTagsAssignedToDomainWithResponse call
func ParseGetTagsAssignedToDomainResponse(rsp *http.Response) (*GetTagsAssignedToDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsAssignedToDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAssignTagsToDomainResponse parses an HTTP response from a AssignTagsToDomainWithResponse call
func ParseAssignTagsToDomainResponse(rsp *http.Response) (*AssignTagsToDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignTagsToDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagAssignmentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssignableTagsForDomainResponse parses an HTTP response from a GetAssignableTagsForDomainWithResponse call
func ParseGetAssignableTagsForDomainResponse(rsp *http.Response) (*GetAssignableTagsForDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssignableTagsForDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainTagManagerUrlResponse parses an HTTP response from a GetDomainTagManagerUrlWithResponse call
func ParseGetDomainTagManagerUrlResponse(rsp *http.Response) (*GetDomainTagManagerUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainTagManagerUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagManagerModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateDomainUpdateSpecResponse parses an HTTP response from a ValidateDomainUpdateSpecWithResponse call
func ParseValidateDomainUpdateSpecResponse(rsp *http.Response) (*ValidateDomainUpdateSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateDomainUpdateSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainUpdateValidationResponse parses an HTTP response from a GetDomainUpdateValidationWithResponse call
func ParseGetDomainUpdateValidationResponse(rsp *http.Response) (*GetDomainUpdateValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainUpdateValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetEdgeClustersResponse parses an HTTP response from a GetEdgeClustersWithResponse call
func ParseGetEdgeClustersResponse(rsp *http.Response) (*GetEdgeClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfEdgeCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateEdgeClusterResponse parses an HTTP response from a CreateEdgeClusterWithResponse call
func ParseCreateEdgeClusterResponse(rsp *http.Response) (*CreateEdgeClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEdgeClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateEdgeClusterCreationSpecResponse parses an HTTP response from a ValidateEdgeClusterCreationSpecWithResponse call
func ParseValidateEdgeClusterCreationSpecResponse(rsp *http.Response) (*ValidateEdgeClusterCreationSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateEdgeClusterCreationSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeClusterValidationByIDResponse parses an HTTP response from a GetEdgeClusterValidationByIDWithResponse call
func ParseGetEdgeClusterValidationByIDResponse(rsp *http.Response) (*GetEdgeClusterValidationByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeClusterValidationByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeClusterQueryCriteriaResponse parses an HTTP response from a GetEdgeClusterQueryCriteriaWithResponse call
func ParseGetEdgeClusterQueryCriteriaResponse(rsp *http.Response) (*GetEdgeClusterQueryCriteriaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeClusterQueryCriteriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfEdgeClusterNsxtEntityCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Page
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeClusterResponse parses an HTTP response from a GetEdgeClusterWithResponse call
func ParseGetEdgeClusterResponse(rsp *http.Response) (*GetEdgeClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EdgeCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateEdgeClusterResponse parses an HTTP response from a UpdateEdgeClusterWithResponse call
func ParseUpdateEdgeClusterResponse(rsp *http.Response) (*UpdateEdgeClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEdgeClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseValidateEdgeClusterUpdateSpecResponse parses an HTTP response from a ValidateEdgeClusterUpdateSpecWithResponse call
func ParseValidateEdgeClusterUpdateSpecResponse(rsp *http.Response) (*ValidateEdgeClusterUpdateSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateEdgeClusterUpdateSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDecommissionHostsResponse parses an HTTP response from a DecommissionHostsWithResponse call
func ParseDecommissionHostsResponse(rsp *http.Response) (*DecommissionHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DecommissionHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHostsResponse parses an HTTP response from a GetHostsWithResponse call
func ParseGetHostsResponse(rsp *http.Response) (*GetHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfHost
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCommissionHostsResponse parses an HTTP response from a CommissionHostsWithResponse call
func ParseCommissionHostsResponse(rsp *http.Response) (*CommissionHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommissionHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCriteriaResponse parses an HTTP response from a GetCriteriaWithResponse call
func ParseGetCriteriaResponse(rsp *http.Response) (*GetCriteriaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCriteriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfHostCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCriterionResponse parses an HTTP response from a GetCriterionWithResponse call
func ParseGetCriterionResponse(rsp *http.Response) (*GetCriterionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCriterionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HostCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostHostsPrechecks1Response parses an HTTP response from a PostHostsPrechecks1WithResponse call
func ParsePostHostsPrechecks1Response(rsp *http.Response) (*PostHostsPrechecks1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostHostsPrechecks1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HostsPrechecksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHostsPrechecksResponseResponse parses an HTTP response from a GetHostsPrechecksResponseWithResponse call
func ParseGetHostsPrechecksResponseResponse(rsp *http.Response) (*GetHostsPrechecksResponseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostsPrechecksResponseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HostsPrechecksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostQueryResponse parses an HTTP response from a PostQueryWithResponse call
func ParsePostQueryResponse(rsp *http.Response) (*PostQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HostQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHostQueryResponseResponse parses an HTTP response from a GetHostQueryResponseWithResponse call
func ParseGetHostQueryResponseResponse(rsp *http.Response) (*GetHostQueryResponseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostQueryResponseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HostQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTagsAssignedToHostsResponse parses an HTTP response from a GetTagsAssignedToHostsWithResponse call
func ParseGetTagsAssignedToHostsResponse(rsp *http.Response) (*GetTagsAssignedToHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsAssignedToHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTagsForResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateHostCommissionSpecResponse parses an HTTP response from a ValidateHostCommissionSpecWithResponse call
func ParseValidateHostCommissionSpecResponse(rsp *http.Response) (*ValidateHostCommissionSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateHostCommissionSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateCommissionHostsResponse parses an HTTP response from a ValidateCommissionHostsWithResponse call
func ParseValidateCommissionHostsResponse(rsp *http.Response) (*ValidateCommissionHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateCommissionHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHostCommissionValidationByIDResponse parses an HTTP response from a GetHostCommissionValidationByIDWithResponse call
func ParseGetHostCommissionValidationByIDResponse(rsp *http.Response) (*GetHostCommissionValidationByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostCommissionValidationByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHostResponse parses an HTTP response from a GetHostWithResponse call
func ParseGetHostResponse(rsp *http.Response) (*GetHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Host
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveTagsFromHostResponse parses an HTTP response from a RemoveTagsFromHostWithResponse call
func ParseRemoveTagsFromHostResponse(rsp *http.Response) (*RemoveTagsFromHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTagsFromHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagAssignmentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTagsAssignedToHostResponse parses an HTTP response from a GetTagsAssignedToHostWithResponse call
func ParseGetTagsAssignedToHostResponse(rsp *http.Response) (*GetTagsAssignedToHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsAssignedToHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAssignTagsToHostResponse parses an HTTP response from a AssignTagsToHostWithResponse call
func ParseAssignTagsToHostResponse(rsp *http.Response) (*AssignTagsToHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignTagsToHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagAssignmentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssignableTagForHostResponse parses an HTTP response from a GetAssignableTagForHostWithResponse call
func ParseGetAssignableTagForHostResponse(rsp *http.Response) (*GetAssignableTagForHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssignableTagForHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHostTagManagerUrlResponse parses an HTTP response from a GetHostTagManagerUrlWithResponse call
func ParseGetHostTagManagerUrlResponse(rsp *http.Response) (*GetHostTagManagerUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostTagManagerUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagManagerModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIdentityPrecheckResultResponse parses an HTTP response from a GetIdentityPrecheckResultWithResponse call
func ParseGetIdentityPrecheckResultResponse(rsp *http.Response) (*GetIdentityPrecheckResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIdentityPrecheckResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentityProviderPrecheckResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSddcWs1bOidcInfoResponse parses an HTTP response from a GetSddcWs1bOidcInfoWithResponse call
func ParseGetSddcWs1bOidcInfoResponse(rsp *http.Response) (*GetSddcWs1bOidcInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSddcWs1bOidcInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SDDCManagerOidcInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIdentityProvidersResponse parses an HTTP response from a GetIdentityProvidersWithResponse call
func ParseGetIdentityProvidersResponse(rsp *http.Response) (*GetIdentityProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIdentityProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfIdentityProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddExternalIdentityProviderResponse parses an HTTP response from a AddExternalIdentityProviderWithResponse call
func ParseAddExternalIdentityProviderResponse(rsp *http.Response) (*AddExternalIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddExternalIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteExternalIdentityProviderResponse parses an HTTP response from a DeleteExternalIdentityProviderWithResponse call
func ParseDeleteExternalIdentityProviderResponse(rsp *http.Response) (*DeleteExternalIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExternalIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIdentityProviderByIdResponse parses an HTTP response from a GetIdentityProviderByIdWithResponse call
func ParseGetIdentityProviderByIdResponse(rsp *http.Response) (*GetIdentityProviderByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIdentityProviderByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentityProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateExternalIdentityProviderResponse parses an HTTP response from a UpdateExternalIdentityProviderWithResponse call
func ParseUpdateExternalIdentityProviderResponse(rsp *http.Response) (*UpdateExternalIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateExternalIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddEmbeddedIdentitySourceResponse parses an HTTP response from a AddEmbeddedIdentitySourceWithResponse call
func ParseAddEmbeddedIdentitySourceResponse(rsp *http.Response) (*AddEmbeddedIdentitySourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddEmbeddedIdentitySourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteIdentitySourceResponse parses an HTTP response from a DeleteIdentitySourceWithResponse call
func ParseDeleteIdentitySourceResponse(rsp *http.Response) (*DeleteIdentitySourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIdentitySourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateEmbeddedIdentitySourceResponse parses an HTTP response from a UpdateEmbeddedIdentitySourceWithResponse call
func ParseUpdateEmbeddedIdentitySourceResponse(rsp *http.Response) (*UpdateEmbeddedIdentitySourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEmbeddedIdentitySourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateSyncClientTokenResponse parses an HTTP response from a GenerateSyncClientTokenWithResponse call
func ParseGenerateSyncClientTokenResponse(rsp *http.Response) (*GenerateSyncClientTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateSyncClientTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLicenseKeysResponse parses an HTTP response from a GetLicenseKeysWithResponse call
func ParseGetLicenseKeysResponse(rsp *http.Response) (*GetLicenseKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfLicenseKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddLicenseKeyResponse parses an HTTP response from a AddLicenseKeyWithResponse call
func ParseAddLicenseKeyResponse(rsp *http.Response) (*AddLicenseKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddLicenseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLicenseProductTypesResponse parses an HTTP response from a GetLicenseProductTypesWithResponse call
func ParseGetLicenseProductTypesResponse(rsp *http.Response) (*GetLicenseProductTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseProductTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveLicenseKeyResponse parses an HTTP response from a RemoveLicenseKeyWithResponse call
func ParseRemoveLicenseKeyResponse(rsp *http.Response) (*RemoveLicenseKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveLicenseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLicenseKeyResponse parses an HTTP response from a GetLicenseKeyWithResponse call
func ParseGetLicenseKeyResponse(rsp *http.Response) (*GetLicenseKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LicenseKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateLicenseKeyResponse parses an HTTP response from a UpdateLicenseKeyWithResponse call
func ParseUpdateLicenseKeyResponse(rsp *http.Response) (*UpdateLicenseKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLicenseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLicenseInformationResponse parses an HTTP response from a GetLicenseInformationWithResponse call
func ParseGetLicenseInformationResponse(rsp *http.Response) (*GetLicenseInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainLicensingInfoResponse parses an HTTP response from a GetDomainLicensingInfoWithResponse call
func ParseGetDomainLicensingInfoResponse(rsp *http.Response) (*GetDomainLicensingInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainLicensingInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemLicensingInfoResponse parses an HTTP response from a GetSystemLicensingInfoWithResponse call
func ParseGetSystemLicensingInfoResponse(rsp *http.Response) (*GetSystemLicensingInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemLicensingInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetManifestResponse parses an HTTP response from a GetManifestWithResponse call
func ParseGetManifestResponse(rsp *http.Response) (*GetManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Manifest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSaveManifestResponse parses an HTTP response from a SaveManifestWithResponse call
func ParseSaveManifestResponse(rsp *http.Response) (*SaveManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNetworkPoolResponse parses an HTTP response from a GetNetworkPoolWithResponse call
func ParseGetNetworkPoolResponse(rsp *http.Response) (*GetNetworkPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfNetworkPool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateNetworkPoolResponse parses an HTTP response from a CreateNetworkPoolWithResponse call
func ParseCreateNetworkPoolResponse(rsp *http.Response) (*CreateNetworkPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNetworkPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NetworkPool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNetworkPoolResponse parses an HTTP response from a DeleteNetworkPoolWithResponse call
func ParseDeleteNetworkPoolResponse(rsp *http.Response) (*DeleteNetworkPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNetworkPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNetworkPoolByIDResponse parses an HTTP response from a GetNetworkPoolByIDWithResponse call
func ParseGetNetworkPoolByIDResponse(rsp *http.Response) (*GetNetworkPoolByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkPoolByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkPool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNetworkPoolResponse parses an HTTP response from a UpdateNetworkPoolWithResponse call
func ParseUpdateNetworkPoolResponse(rsp *http.Response) (*UpdateNetworkPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNetworkPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkPool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNetworksOfNetworkPoolResponse parses an HTTP response from a GetNetworksOfNetworkPoolWithResponse call
func ParseGetNetworksOfNetworkPoolResponse(rsp *http.Response) (*GetNetworksOfNetworkPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworksOfNetworkPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfNetwork
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNetworkOfNetworkPoolResponse parses an HTTP response from a GetNetworkOfNetworkPoolWithResponse call
func ParseGetNetworkOfNetworkPoolResponse(rsp *http.Response) (*GetNetworkOfNetworkPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkOfNetworkPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Network
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteIpPoolFromNetworkOfNetworkPoolResponse parses an HTTP response from a DeleteIpPoolFromNetworkOfNetworkPoolWithResponse call
func ParseDeleteIpPoolFromNetworkOfNetworkPoolResponse(rsp *http.Response) (*DeleteIpPoolFromNetworkOfNetworkPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIpPoolFromNetworkOfNetworkPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddIpPoolToNetworkOfNetworkPoolResponse parses an HTTP response from a AddIpPoolToNetworkOfNetworkPoolWithResponse call
func ParseAddIpPoolToNetworkOfNetworkPoolResponse(rsp *http.Response) (*AddIpPoolToNetworkOfNetworkPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddIpPoolToNetworkOfNetworkPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Network
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetALBClustersResponse parses an HTTP response from a GetALBClustersWithResponse call
func ParseGetALBClustersResponse(rsp *http.Response) (*GetALBClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetALBClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfNsxALBCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetALBClustersFormFactorsResponse parses an HTTP response from a GetALBClustersFormFactorsWithResponse call
func ParseGetALBClustersFormFactorsResponse(rsp *http.Response) (*GetALBClustersFormFactorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetALBClustersFormFactorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ALBControllerNodeFormFactors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateALBClusterCreationSpecResponse parses an HTTP response from a ValidateALBClusterCreationSpecWithResponse call
func ParseValidateALBClusterCreationSpecResponse(rsp *http.Response) (*ValidateALBClusterCreationSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateALBClusterCreationSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateNsxALBCompatibilityResponse parses an HTTP response from a ValidateNsxALBCompatibilityWithResponse call
func ParseValidateNsxALBCompatibilityResponse(rsp *http.Response) (*ValidateNsxALBCompatibilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateNsxALBCompatibilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteALBClusterResponse parses an HTTP response from a DeleteALBClusterWithResponse call
func ParseDeleteALBClusterResponse(rsp *http.Response) (*DeleteALBClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteALBClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetALBClusterResponse parses an HTTP response from a GetALBClusterWithResponse call
func ParseGetALBClusterResponse(rsp *http.Response) (*GetALBClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetALBClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NsxALBCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNsxClustersResponse parses an HTTP response from a GetNsxClustersWithResponse call
func ParseGetNsxClustersResponse(rsp *http.Response) (*GetNsxClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNsxClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfNsxTCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNsxCriteriaResponse parses an HTTP response from a GetNsxCriteriaWithResponse call
func ParseGetNsxCriteriaResponse(rsp *http.Response) (*GetNsxCriteriaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNsxCriteriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfNsxTCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNsxCriterionResponse parses an HTTP response from a GetNsxCriterionWithResponse call
func ParseGetNsxCriterionResponse(rsp *http.Response) (*GetNsxCriterionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNsxCriterionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NsxTCriterion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseValidateIpPoolResponse parses an HTTP response from a ValidateIpPoolWithResponse call
func ParseValidateIpPoolResponse(rsp *http.Response) (*ValidateIpPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateIpPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetValidationResultResponse parses an HTTP response from a GetValidationResultWithResponse call
func ParseGetValidationResultResponse(rsp *http.Response) (*GetValidationResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetValidationResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConnectOpenIdResponse parses an HTTP response from a ConnectOpenIdWithResponse call
func ParseConnectOpenIdResponse(rsp *http.Response) (*ConnectOpenIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectOpenIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStartNsxCriteriaQueryResponse parses an HTTP response from a StartNsxCriteriaQueryWithResponse call
func ParseStartNsxCriteriaQueryResponse(rsp *http.Response) (*StartNsxCriteriaQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartNsxCriteriaQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest NsxTQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNsxClusterQueryResponseResponse parses an HTTP response from a GetNsxClusterQueryResponseWithResponse call
func ParseGetNsxClusterQueryResponseResponse(rsp *http.Response) (*GetNsxClusterQueryResponseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNsxClusterQueryResponseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NsxTQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest NsxTQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNsxClusterResponse parses an HTTP response from a GetNsxClusterWithResponse call
func ParseGetNsxClusterResponse(rsp *http.Response) (*GetNsxClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNsxClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NsxTCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNsxIpAddressPoolsResponse parses an HTTP response from a GetNsxIpAddressPoolsWithResponse call
func ParseGetNsxIpAddressPoolsResponse(rsp *http.Response) (*GetNsxIpAddressPoolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNsxIpAddressPoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfNsxtIpAddressPool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNsxIpAddressPoolResponse parses an HTTP response from a GetNsxIpAddressPoolWithResponse call
func ParseGetNsxIpAddressPoolResponse(rsp *http.Response) (*GetNsxIpAddressPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNsxIpAddressPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NsxtIpAddressPool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNsxTransportZonesResponse parses an HTTP response from a GetNsxTransportZonesWithResponse call
func ParseGetNsxTransportZonesResponse(rsp *http.Response) (*GetNsxTransportZonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNsxTransportZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfNsxtTransportZoneInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePersonalityResponse parses an HTTP response from a DeletePersonalityWithResponse call
func ParseDeletePersonalityResponse(rsp *http.Response) (*DeletePersonalityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersonalityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPersonalitiesResponse parses an HTTP response from a GetPersonalitiesWithResponse call
func ParseGetPersonalitiesResponse(rsp *http.Response) (*GetPersonalitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonalitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfPersonality
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadPersonalityResponse parses an HTTP response from a UploadPersonalityWithResponse call
func ParseUploadPersonalityResponse(rsp *http.Response) (*UploadPersonalityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadPersonalityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadPersonalityFilesResponse parses an HTTP response from a UploadPersonalityFilesWithResponse call
func ParseUploadPersonalityFilesResponse(rsp *http.Response) (*UploadPersonalityFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadPersonalityFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPersonalityResponse parses an HTTP response from a GetPersonalityWithResponse call
func ParseGetPersonalityResponse(rsp *http.Response) (*GetPersonalityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonalityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Personality
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRenamePersonalityByIdResponse parses an HTTP response from a RenamePersonalityByIdWithResponse call
func ParseRenamePersonalityByIdResponse(rsp *http.Response) (*RenamePersonalityByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenamePersonalityByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Personality
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductVersionCatalogResponse parses an HTTP response from a GetProductVersionCatalogWithResponse call
func ParseGetProductVersionCatalogResponse(rsp *http.Response) (*GetProductVersionCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductVersionCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductVersionCatalog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadProductVersionCatalogResponse parses an HTTP response from a UploadProductVersionCatalogWithResponse call
func ParseUploadProductVersionCatalogResponse(rsp *http.Response) (*UploadProductVersionCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadProductVersionCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPscsResponse parses an HTTP response from a GetPscsWithResponse call
func ParseGetPscsResponse(rsp *http.Response) (*GetPscsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPscsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfPsc
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPscResponse parses an HTTP response from a GetPscWithResponse call
func ParseGetPscResponse(rsp *http.Response) (*GetPscResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPscResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Psc
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReleasesResponse parses an HTTP response from a GetReleasesWithResponse call
func ParseGetReleasesResponse(rsp *http.Response) (*GetReleasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReleasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfRelease
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReleaseByDomainsResponse parses an HTTP response from a GetReleaseByDomainsWithResponse call
func ParseGetReleaseByDomainsResponse(rsp *http.Response) (*GetReleaseByDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReleaseByDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfDomainReleaseView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainReleaseViewValidationResponse parses an HTTP response from a GetDomainReleaseViewValidationWithResponse call
func ParseGetDomainReleaseViewValidationResponse(rsp *http.Response) (*GetDomainReleaseViewValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainReleaseViewValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReleaseByDomainIDResponse parses an HTTP response from a DeleteReleaseByDomainIDWithResponse call
func ParseDeleteReleaseByDomainIDResponse(rsp *http.Response) (*DeleteReleaseByDomainIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReleaseByDomainIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReleaseByDomainResponse parses an HTTP response from a GetReleaseByDomainWithResponse call
func ParseGetReleaseByDomainResponse(rsp *http.Response) (*GetReleaseByDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReleaseByDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DomainReleaseView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateReleaseByDomainIDResponse parses an HTTP response from a UpdateReleaseByDomainIDWithResponse call
func ParseUpdateReleaseByDomainIDResponse(rsp *http.Response) (*UpdateReleaseByDomainIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateReleaseByDomainIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomPatchesResponse parses an HTTP response from a GetCustomPatchesWithResponse call
func ParseGetCustomPatchesResponse(rsp *http.Response) (*GetCustomPatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomPatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlexibleProductPatches
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFutureReleasesResponse parses an HTTP response from a GetFutureReleasesWithResponse call
func ParseGetFutureReleasesResponse(rsp *http.Response) (*GetFutureReleasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFutureReleasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfDomainFutureRelease
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateReleaseByDomainIDResponse parses an HTTP response from a ValidateReleaseByDomainIDWithResponse call
func ParseValidateReleaseByDomainIDResponse(rsp *http.Response) (*ValidateReleaseByDomainIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateReleaseByDomainIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemReleaseResponse parses an HTTP response from a GetSystemReleaseWithResponse call
func ParseGetSystemReleaseResponse(rsp *http.Response) (*GetSystemReleaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceFunctionalitiesResponse parses an HTTP response from a GetResourceFunctionalitiesWithResponse call
func ParseGetResourceFunctionalitiesResponse(rsp *http.Response) (*GetResourceFunctionalitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceFunctionalitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfResourceFunctionalities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateResourcesFunctionalitiesResponse parses an HTTP response from a UpdateResourcesFunctionalitiesWithResponse call
func ParseUpdateResourcesFunctionalitiesResponse(rsp *http.Response) (*UpdateResourcesFunctionalitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourcesFunctionalitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceFunctionalitiesCaller
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcesFunctionalitiesAllowedGlobalResponse parses an HTTP response from a GetResourcesFunctionalitiesAllowedGlobalWithResponse call
func ParseGetResourcesFunctionalitiesAllowedGlobalResponse(rsp *http.Response) (*GetResourcesFunctionalitiesAllowedGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcesFunctionalitiesAllowedGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceFunctionalitiesGlobalConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateResourcesFunctionalities1Response parses an HTTP response from a UpdateResourcesFunctionalities1WithResponse call
func ParseUpdateResourcesFunctionalities1Response(rsp *http.Response) (*UpdateResourcesFunctionalities1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourcesFunctionalities1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceFunctionalitiesGlobalConfigurationCaller
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceWarningsResponse parses an HTTP response from a GetResourceWarningsWithResponse call
func ParseGetResourceWarningsResponse(rsp *http.Response) (*GetResourceWarningsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceWarningsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfResourceWarning
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateResourceWarningResponse parses an HTTP response from a CreateResourceWarningWithResponse call
func ParseCreateResourceWarningResponse(rsp *http.Response) (*CreateResourceWarningResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResourceWarningResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ResourceWarning
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceWarningResponse parses an HTTP response from a GetResourceWarningWithResponse call
func ParseGetResourceWarningResponse(rsp *http.Response) (*GetResourceWarningResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceWarningResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceWarning
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartLicenseCheckByResourceResponse parses an HTTP response from a StartLicenseCheckByResourceWithResponse call
func ParseStartLicenseCheckByResourceResponse(rsp *http.Response) (*StartLicenseCheckByResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartLicenseCheckByResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLicenseCheckResultByIDResponse parses an HTTP response from a GetLicenseCheckResultByIDWithResponse call
func ParseGetLicenseCheckResultByIDResponse(rsp *http.Response) (*GetLicenseCheckResultByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseCheckResultByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetLicenseKeyForResourceResponse parses an HTTP response from a SetLicenseKeyForResourceWithResponse call
func ParseSetLicenseKeyForResourceResponse(rsp *http.Response) (*SetLicenseKeyForResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetLicenseKeyForResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartRestoreResponse parses an HTTP response from a StartRestoreWithResponse call
func ParseStartRestoreResponse(rsp *http.Response) (*StartRestoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartRestoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRestoreTaskResponse parses an HTTP response from a GetRestoreTaskWithResponse call
func ParseGetRestoreTaskResponse(rsp *http.Response) (*GetRestoreTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRestoreTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRolesResponse parses an HTTP response from a GetRolesWithResponse call
func ParseGetRolesResponse(rsp *http.Response) (*GetRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocalOsUserAccountsResponse parses an HTTP response from a GetLocalOsUserAccountsWithResponse call
func ParseGetLocalOsUserAccountsResponse(rsp *http.Response) (*GetLocalOsUserAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocalOsUserAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LocalOsUserAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTrustedCertificatesResponse parses an HTTP response from a GetTrustedCertificatesWithResponse call
func ParseGetTrustedCertificatesResponse(rsp *http.Response) (*GetTrustedCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTrustedCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTrustedCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddTrustedCertificateResponse parses an HTTP response from a AddTrustedCertificateWithResponse call
func ParseAddTrustedCertificateResponse(rsp *http.Response) (*AddTrustedCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTrustedCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTrustedCertificateResponse parses an HTTP response from a DeleteTrustedCertificateWithResponse call
func ParseDeleteTrustedCertificateResponse(rsp *http.Response) (*DeleteTrustedCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTrustedCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSddcManagerUpgradablesResponse parses an HTTP response from a GetSddcManagerUpgradablesWithResponse call
func ParseGetSddcManagerUpgradablesResponse(rsp *http.Response) (*GetSddcManagerUpgradablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSddcManagerUpgradablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSddcManagersResponse parses an HTTP response from a GetSddcManagersWithResponse call
func ParseGetSddcManagersResponse(rsp *http.Response) (*GetSddcManagersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSddcManagersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfSddcManager
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSddcManagerResponse parses an HTTP response from a GetSddcManagerWithResponse call
func ParseGetSddcManagerResponse(rsp *http.Response) (*GetSddcManagerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSddcManagerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SddcManager
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSddcManagerHistoryResponse parses an HTTP response from a GetSddcManagerHistoryWithResponse call
func ParseGetSddcManagerHistoryResponse(rsp *http.Response) (*GetSddcManagerHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSddcManagerHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest History
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBringupTasksResponse parses an HTTP response from a GetBringupTasksWithResponse call
func ParseGetBringupTasksResponse(rsp *http.Response) (*GetBringupTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBringupTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfSddcTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartBringupResponse parses an HTTP response from a StartBringupWithResponse call
func ParseStartBringupResponse(rsp *http.Response) (*StartBringupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartBringupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SddcTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBringupAppInfoResponse parses an HTTP response from a GetBringupAppInfoWithResponse call
func ParseGetBringupAppInfoResponse(rsp *http.Response) (*GetBringupAppInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBringupAppInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VcfService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest VcfService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest VcfService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest VcfService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetBringupValidationsResponse parses an HTTP response from a GetBringupValidationsWithResponse call
func ParseGetBringupValidationsResponse(rsp *http.Response) (*GetBringupValidationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBringupValidationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfValidation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseValidateBringupSpecResponse parses an HTTP response from a ValidateBringupSpecWithResponse call
func ParseValidateBringupSpecResponse(rsp *http.Response) (*ValidateBringupSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateBringupSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBringupValidationResponse parses an HTTP response from a GetBringupValidationWithResponse call
func ParseGetBringupValidationResponse(rsp *http.Response) (*GetBringupValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBringupValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseRetryBringupValidationResponse parses an HTTP response from a RetryBringupValidationWithResponse call
func ParseRetryBringupValidationResponse(rsp *http.Response) (*RetryBringupValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetryBringupValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExportBringupValidationReportResponse parses an HTTP response from a ExportBringupValidationReportWithResponse call
func ParseExportBringupValidationReportResponse(rsp *http.Response) (*ExportBringupValidationReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportBringupValidationReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBringupTaskByIDResponse parses an HTTP response from a GetBringupTaskByIDWithResponse call
func ParseGetBringupTaskByIDResponse(rsp *http.Response) (*GetBringupTaskByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBringupTaskByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SddcTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRetrySddcResponse parses an HTTP response from a RetrySddcWithResponse call
func ParseRetrySddcResponse(rsp *http.Response) (*RetrySddcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrySddcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SddcTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportBringupDetailReportResponse parses an HTTP response from a ExportBringupDetailReportWithResponse call
func ParseExportBringupDetailReportResponse(rsp *http.Response) (*ExportBringupDetailReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportBringupDetailReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	}

	return response, nil
}

// ParseGetSddcManagerInfoResponse parses an HTTP response from a GetSddcManagerInfoWithResponse call
func ParseGetSddcManagerInfoResponse(rsp *http.Response) (*GetSddcManagerInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSddcManagerInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SddcManagerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SddcManagerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SddcManagerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest SddcManagerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetSSODomainsResponse parses an HTTP response from a GetSSODomainsWithResponse call
func ParseGetSSODomainsResponse(rsp *http.Response) (*GetSSODomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSSODomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSSODomainEntitiesResponse parses an HTTP response from a GetSSODomainEntitiesWithResponse call
func ParseGetSSODomainEntitiesResponse(rsp *http.Response) (*GetSSODomainEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSSODomainEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfSsoDomainEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemConfigurationResponse parses an HTTP response from a GetSystemConfigurationWithResponse call
func ParseGetSystemConfigurationResponse(rsp *http.Response) (*GetSystemConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest System
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSystemConfigurationResponse parses an HTTP response from a UpdateSystemConfigurationWithResponse call
func ParseUpdateSystemConfigurationResponse(rsp *http.Response) (*UpdateSystemConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSystemConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBackupConfigurationResponse parses an HTTP response from a GetBackupConfigurationWithResponse call
func ParseGetBackupConfigurationResponse(rsp *http.Response) (*GetBackupConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateBackupConfigurationResponse parses an HTTP response from a UpdateBackupConfigurationWithResponse call
func ParseUpdateBackupConfigurationResponse(rsp *http.Response) (*UpdateBackupConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBackupConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetBackupConfigurationResponse parses an HTTP response from a SetBackupConfigurationWithResponse call
func ParseSetBackupConfigurationResponse(rsp *http.Response) (*SetBackupConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetBackupConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBackupLocationResponse parses an HTTP response from a GetBackupLocationWithResponse call
func ParseGetBackupLocationResponse(rsp *http.Response) (*GetBackupLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateBackupConfigurationsOperationsResponse parses an HTTP response from a ValidateBackupConfigurationsOperationsWithResponse call
func ParseValidateBackupConfigurationsOperationsResponse(rsp *http.Response) (*ValidateBackupConfigurationsOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateBackupConfigurationsOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCeipStatusResponse parses an HTTP response from a GetCeipStatusWithResponse call
func ParseGetCeipStatusResponse(rsp *http.Response) (*GetCeipStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCeipStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ceip
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetCeipStatusResponse parses an HTTP response from a SetCeipStatusWithResponse call
func ParseSetCeipStatusResponse(rsp *http.Response) (*SetCeipStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCeipStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLastAssessmentRunInfoResponse parses an HTTP response from a GetLastAssessmentRunInfoWithResponse call
func ParseGetLastAssessmentRunInfoResponse(rsp *http.Response) (*GetLastAssessmentRunInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLastAssessmentRunInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AssessmentTaskInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTriggerCheckRunResponse parses an HTTP response from a TriggerCheckRunWithResponse call
func ParseTriggerCheckRunResponse(rsp *http.Response) (*TriggerCheckRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerCheckRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseQueryCheckSetsResponse parses an HTTP response from a QueryCheckSetsWithResponse call
func ParseQueryCheckSetsResponse(rsp *http.Response) (*QueryCheckSetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryCheckSetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckSetQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetResultResponse parses an HTTP response from a GetResultWithResponse call
func ParseGetResultResponse(rsp *http.Response) (*GetResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssessmentOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTriggerPartialRetryOfCheckRunResponse parses an HTTP response from a TriggerPartialRetryOfCheckRunWithResponse call
func ParseTriggerPartialRetryOfCheckRunResponse(rsp *http.Response) (*TriggerPartialRetryOfCheckRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerPartialRetryOfCheckRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDnsConfigurationResponse parses an HTTP response from a GetDnsConfigurationWithResponse call
func ParseGetDnsConfigurationResponse(rsp *http.Response) (*GetDnsConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDnsConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnsConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseConfigureDnsResponse parses an HTTP response from a ConfigureDnsWithResponse call
func ParseConfigureDnsResponse(rsp *http.Response) (*ConfigureDnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigureDnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetValidationsOfDNSConfigurationResponse parses an HTTP response from a GetValidationsOfDNSConfigurationWithResponse call
func ParseGetValidationsOfDNSConfigurationResponse(rsp *http.Response) (*GetValidationsOfDNSConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetValidationsOfDNSConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateDnsConfigurationResponse parses an HTTP response from a ValidateDnsConfigurationWithResponse call
func ParseValidateDnsConfigurationResponse(rsp *http.Response) (*ValidateDnsConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateDnsConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetValidationOfDnsConfigurationResponse parses an HTTP response from a GetValidationOfDnsConfigurationWithResponse call
func ParseGetValidationOfDnsConfigurationResponse(rsp *http.Response) (*GetValidationOfDnsConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetValidationOfDnsConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHealthCheckTaskResponse parses an HTTP response from a GetHealthCheckTaskWithResponse call
func ParseGetHealthCheckTaskResponse(rsp *http.Response) (*GetHealthCheckTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthCheckTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfHealthSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartHealthCheckResponse parses an HTTP response from a StartHealthCheckWithResponse call
func ParseStartHealthCheckResponse(rsp *http.Response) (*StartHealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartHealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HealthSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHealthCheckStatusResponse parses an HTTP response from a GetHealthCheckStatusWithResponse call
func ParseGetHealthCheckStatusResponse(rsp *http.Response) (*GetHealthCheckStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthCheckStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportHealthCheckByIDResponse parses an HTTP response from a ExportHealthCheckByIDWithResponse call
func ParseExportHealthCheckByIDResponse(rsp *http.Response) (*ExportHealthCheckByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportHealthCheckByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNtpConfigurationResponse parses an HTTP response from a GetNtpConfigurationWithResponse call
func ParseGetNtpConfigurationResponse(rsp *http.Response) (*GetNtpConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNtpConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NtpConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseConfigureNtpResponse parses an HTTP response from a ConfigureNtpWithResponse call
func ParseConfigureNtpResponse(rsp *http.Response) (*ConfigureNtpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigureNtpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetValidationsOfNtpConfigurationResponse parses an HTTP response from a GetValidationsOfNtpConfigurationWithResponse call
func ParseGetValidationsOfNtpConfigurationResponse(rsp *http.Response) (*GetValidationsOfNtpConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetValidationsOfNtpConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest []Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateNtpConfigurationResponse parses an HTTP response from a ValidateNtpConfigurationWithResponse call
func ParseValidateNtpConfigurationResponse(rsp *http.Response) (*ValidateNtpConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateNtpConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetValidationOfNtpConfigurationResponse parses an HTTP response from a GetValidationOfNtpConfigurationWithResponse call
func ParseGetValidationOfNtpConfigurationResponse(rsp *http.Response) (*GetValidationOfNtpConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetValidationOfNtpConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartPrecheckResponse parses an HTTP response from a StartPrecheckWithResponse call
func ParseStartPrecheckResponse(rsp *http.Response) (*StartPrecheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartPrecheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPrecheckTaskResponse parses an HTTP response from a GetPrecheckTaskWithResponse call
func ParseGetPrecheckTaskResponse(rsp *http.Response) (*GetPrecheckTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrecheckTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProxyConfigurationResponse parses an HTTP response from a GetProxyConfigurationWithResponse call
func ParseGetProxyConfigurationResponse(rsp *http.Response) (*GetProxyConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProxyConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProxyConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProxyConfigurationResponse parses an HTTP response from a UpdateProxyConfigurationWithResponse call
func ParseUpdateProxyConfigurationResponse(rsp *http.Response) (*UpdateProxyConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProxyConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseStartBringupSpecConversionResponse parses an HTTP response from a StartBringupSpecConversionWithResponse call
func ParseStartBringupSpecConversionResponse(rsp *http.Response) (*StartBringupSpecConversionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartBringupSpecConversionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SddcSpec
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetFIPSConfigurationResponse parses an HTTP response from a GetFIPSConfigurationWithResponse call
func ParseGetFIPSConfigurationResponse(rsp *http.Response) (*GetFIPSConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFIPSConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Fips
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Fips
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDepotSettingsResponse parses an HTTP response from a DeleteDepotSettingsWithResponse call
func ParseDeleteDepotSettingsResponse(rsp *http.Response) (*DeleteDepotSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDepotSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDepotSettingsResponse parses an HTTP response from a GetDepotSettingsWithResponse call
func ParseGetDepotSettingsResponse(rsp *http.Response) (*GetDepotSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDepotSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DepotSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDepotSettingsResponse parses an HTTP response from a UpdateDepotSettingsWithResponse call
func ParseUpdateDepotSettingsResponse(rsp *http.Response) (*UpdateDepotSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDepotSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DepotSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVersionAliasConfigurationResponse parses an HTTP response from a GetVersionAliasConfigurationWithResponse call
func ParseGetVersionAliasConfigurationResponse(rsp *http.Response) (*GetVersionAliasConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionAliasConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfVersionAliasesForBundleComponentType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVersionAliasConfigurationsResponse parses an HTTP response from a UpdateVersionAliasConfigurationsWithResponse call
func ParseUpdateVersionAliasConfigurationsResponse(rsp *http.Response) (*UpdateVersionAliasConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVersionAliasConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfVersionAliasesForBundleComponentType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVersionAliasBySoftwareTypeResponse parses an HTTP response from a DeleteVersionAliasBySoftwareTypeWithResponse call
func ParseDeleteVersionAliasBySoftwareTypeResponse(rsp *http.Response) (*DeleteVersionAliasBySoftwareTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVersionAliasBySoftwareTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse parses an HTTP response from a DeleteAliasVersionsBySoftwareTypeAndBaseVersionWithResponse call
func ParseDeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse(rsp *http.Response) (*DeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVersionAliasConfigurationResponse parses an HTTP response from a UpdateVersionAliasConfigurationWithResponse call
func ParseUpdateVersionAliasConfigurationResponse(rsp *http.Response) (*UpdateVersionAliasConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVersionAliasConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfVersionAliasesForBundleComponentType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSupportBundleTaskResponse parses an HTTP response from a GetSupportBundleTaskWithResponse call
func ParseGetSupportBundleTaskResponse(rsp *http.Response) (*GetSupportBundleTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupportBundleTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfSupportBundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartSupportBundleResponse parses an HTTP response from a StartSupportBundleWithResponse call
func ParseStartSupportBundleResponse(rsp *http.Response) (*StartSupportBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartSupportBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SupportBundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSupportBundleStatusResponse parses an HTTP response from a GetSupportBundleStatusWithResponse call
func ParseGetSupportBundleStatusResponse(rsp *http.Response) (*GetSupportBundleStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupportBundleStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupportBundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportSupportBundleByIDResponse parses an HTTP response from a ExportSupportBundleByIDWithResponse call
func ParseExportSupportBundleByIDResponse(rsp *http.Response) (*ExportSupportBundleByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportSupportBundleByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUpgradablesResponse parses an HTTP response from a GetUpgradablesWithResponse call
func ParseGetUpgradablesResponse(rsp *http.Response) (*GetUpgradablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUpgradablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfUpgradable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTasksResponse parses an HTTP response from a GetTasksWithResponse call
func ParseGetTasksResponse(rsp *http.Response) (*GetTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCancelTaskResponse parses an HTTP response from a CancelTaskWithResponse call
func ParseCancelTaskResponse(rsp *http.Response) (*CancelTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTaskResponse parses an HTTP response from a GetTaskWithResponse call
func ParseGetTaskResponse(rsp *http.Response) (*GetTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRetryTaskResponse parses an HTTP response from a RetryTaskWithResponse call
func ParseRetryTaskResponse(rsp *http.Response) (*RetryTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetryTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenPair
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TokenPair
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRefreshAccessTokenResponse parses an HTTP response from a RefreshAccessTokenWithResponse call
func ParseRefreshAccessTokenResponse(rsp *http.Response) (*RefreshAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInvalidateRefreshTokenResponse parses an HTTP response from a InvalidateRefreshTokenWithResponse call
func ParseInvalidateRefreshTokenResponse(rsp *http.Response) (*InvalidateRefreshTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InvalidateRefreshTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUpgradablesByDomainResponse parses an HTTP response from a GetUpgradablesByDomainWithResponse call
func ParseGetUpgradablesByDomainResponse(rsp *http.Response) (*GetUpgradablesByDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUpgradablesByDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfUpgradable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUpgradablesClustersResponse parses an HTTP response from a GetUpgradablesClustersWithResponse call
func ParseGetUpgradablesClustersResponse(rsp *http.Response) (*GetUpgradablesClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUpgradablesClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfUpgradablesClusterResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNsxUpgradeResourcesResponse parses an HTTP response from a GetNsxUpgradeResourcesWithResponse call
func ParseGetNsxUpgradeResourcesResponse(rsp *http.Response) (*GetNsxUpgradeResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNsxUpgradeResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NsxtResources
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUpgradesResponse parses an HTTP response from a GetUpgradesWithResponse call
func ParseGetUpgradesResponse(rsp *http.Response) (*GetUpgradesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUpgradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfUpgrade
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePerformUpgradeResponse parses an HTTP response from a PerformUpgradeWithResponse call
func ParsePerformUpgradeResponse(rsp *http.Response) (*PerformUpgradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PerformUpgradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 424:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON424 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUpgradeByIdResponse parses an HTTP response from a GetUpgradeByIdWithResponse call
func ParseGetUpgradeByIdResponse(rsp *http.Response) (*GetUpgradeByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUpgradeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Upgrade
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUpgradeScheduleResponse parses an HTTP response from a UpdateUpgradeScheduleWithResponse call
func ParseUpdateUpgradeScheduleResponse(rsp *http.Response) (*UpdateUpgradeScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUpgradeScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Upgrade
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartUpgradePrecheckResponse parses an HTTP response from a StartUpgradePrecheckWithResponse call
func ParseStartUpgradePrecheckResponse(rsp *http.Response) (*StartUpgradePrecheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartUpgradePrecheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUpgradePrecheckByIDResponse parses an HTTP response from a GetUpgradePrecheckByIDWithResponse call
func ParseGetUpgradePrecheckByIDResponse(rsp *http.Response) (*GetUpgradePrecheckByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUpgradePrecheckByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddUsersResponse parses an HTTP response from a AddUsersWithResponse call
func ParseAddUsersResponse(rsp *http.Response) (*AddUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PageOfUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDisableLocalAccountResponse parses an HTTP response from a DisableLocalAccountWithResponse call
func ParseDisableLocalAccountResponse(rsp *http.Response) (*DisableLocalAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableLocalAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocalAccountResponse parses an HTTP response from a GetLocalAccountWithResponse call
func ParseGetLocalAccountResponse(rsp *http.Response) (*GetLocalAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocalAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocalUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateLocalUserPasswordResponse parses an HTTP response from a UpdateLocalUserPasswordWithResponse call
func ParseUpdateLocalUserPasswordResponse(rsp *http.Response) (*UpdateLocalUserPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLocalUserPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUiUsersResponse parses an HTTP response from a GetUiUsersWithResponse call
func ParseGetUiUsersResponse(rsp *http.Response) (*GetUiUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUiUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveUserResponse parses an HTTP response from a RemoveUserWithResponse call
func ParseRemoveUserResponse(rsp *http.Response) (*RemoveUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVasaProvidersResponse parses an HTTP response from a GetVasaProvidersWithResponse call
func ParseGetVasaProvidersResponse(rsp *http.Response) (*GetVasaProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVasaProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfVasaProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddVasaProviderResponse parses an HTTP response from a AddVasaProviderWithResponse call
func ParseAddVasaProviderResponse(rsp *http.Response) (*AddVasaProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddVasaProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VasaProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateVasaProviderSpecResponse parses an HTTP response from a ValidateVasaProviderSpecWithResponse call
func ParseValidateVasaProviderSpecResponse(rsp *http.Response) (*ValidateVasaProviderSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateVasaProviderSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVasaProviderValidationResponse parses an HTTP response from a GetVasaProviderValidationWithResponse call
func ParseGetVasaProviderValidationResponse(rsp *http.Response) (*GetVasaProviderValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVasaProviderValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveVasaProviderResponse parses an HTTP response from a RemoveVasaProviderWithResponse call
func ParseRemoveVasaProviderResponse(rsp *http.Response) (*RemoveVasaProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveVasaProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVasaProviderResponse parses an HTTP response from a GetVasaProviderWithResponse call
func ParseGetVasaProviderResponse(rsp *http.Response) (*GetVasaProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVasaProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VasaProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVasaProviderResponse parses an HTTP response from a UpdateVasaProviderWithResponse call
func ParseUpdateVasaProviderResponse(rsp *http.Response) (*UpdateVasaProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVasaProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VasaProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVasaProviderStorageContainersResponse parses an HTTP response from a GetVasaProviderStorageContainersWithResponse call
func ParseGetVasaProviderStorageContainersResponse(rsp *http.Response) (*GetVasaProviderStorageContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVasaProviderStorageContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []StorageContainer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddVasaProviderStorageContainerResponse parses an HTTP response from a AddVasaProviderStorageContainerWithResponse call
func ParseAddVasaProviderStorageContainerResponse(rsp *http.Response) (*AddVasaProviderStorageContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddVasaProviderStorageContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VasaProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveVasaProviderStorageContainerResponse parses an HTTP response from a RemoveVasaProviderStorageContainerWithResponse call
func ParseRemoveVasaProviderStorageContainerResponse(rsp *http.Response) (*RemoveVasaProviderStorageContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveVasaProviderStorageContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVasaProviderStorageContainerResponse parses an HTTP response from a UpdateVasaProviderStorageContainerWithResponse call
func ParseUpdateVasaProviderStorageContainerResponse(rsp *http.Response) (*UpdateVasaProviderStorageContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVasaProviderStorageContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VasaProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVasaProviderUserResponse parses an HTTP response from a GetVasaProviderUserWithResponse call
func ParseGetVasaProviderUserResponse(rsp *http.Response) (*GetVasaProviderUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVasaProviderUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VasaUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddVasaProviderUserResponse parses an HTTP response from a AddVasaProviderUserWithResponse call
func ParseAddVasaProviderUserResponse(rsp *http.Response) (*AddVasaProviderUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddVasaProviderUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VasaProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVasaProviderUserResponse parses an HTTP response from a UpdateVasaProviderUserWithResponse call
func ParseUpdateVasaProviderUserResponse(rsp *http.Response) (*UpdateVasaProviderUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVasaProviderUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VasaProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVcentersResponse parses an HTTP response from a GetVcentersWithResponse call
func ParseGetVcentersResponse(rsp *http.Response) (*GetVcentersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVcentersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfVcenter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVcenterResponse parses an HTTP response from a GetVcenterWithResponse call
func ParseGetVcenterResponse(rsp *http.Response) (*GetVcenterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVcenterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vcenter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVcfServicesResponse parses an HTTP response from a GetVcfServicesWithResponse call
func ParseGetVcfServicesResponse(rsp *http.Response) (*GetVcfServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVcfServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfVcfService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVcfServiceResponse parses an HTTP response from a GetVcfServiceWithResponse call
func ParseGetVcfServiceResponse(rsp *http.Response) (*GetVcfServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVcfServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VcfService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVrasResponse parses an HTTP response from a GetVrasWithResponse call
func ParseGetVrasResponse(rsp *http.Response) (*GetVrasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVrasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfVra
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVrliIntegratedDomainsResponse parses an HTTP response from a GetVrliIntegratedDomainsWithResponse call
func ParseGetVrliIntegratedDomainsResponse(rsp *http.Response) (*GetVrliIntegratedDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVrliIntegratedDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfDomainIntegration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConnectVrliWithDomainResponse parses an HTTP response from a ConnectVrliWithDomainWithResponse call
func ParseConnectVrliWithDomainResponse(rsp *http.Response) (*ConnectVrliWithDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectVrliWithDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseGetVrlisResponse parses an HTTP response from a GetVrlisWithResponse call
func ParseGetVrlisResponse(rsp *http.Response) (*GetVrlisResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVrlisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfVrli
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVropsIntegratedDomainsResponse parses an HTTP response from a GetVropsIntegratedDomainsWithResponse call
func ParseGetVropsIntegratedDomainsResponse(rsp *http.Response) (*GetVropsIntegratedDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVropsIntegratedDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfDomainIntegration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConnectVropsWithDomainResponse parses an HTTP response from a ConnectVropsWithDomainWithResponse call
func ParseConnectVropsWithDomainResponse(rsp *http.Response) (*ConnectVropsWithDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectVropsWithDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVropsesResponse parses an HTTP response from a GetVropsesWithResponse call
func ParseGetVropsesResponse(rsp *http.Response) (*GetVropsesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVropsesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfVrops
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRollbackVrslcmResponse parses an HTTP response from a RollbackVrslcmWithResponse call
func ParseRollbackVrslcmResponse(rsp *http.Response) (*RollbackVrslcmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RollbackVrslcmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseGetVrslcmResponse parses an HTTP response from a GetVrslcmWithResponse call
func ParseGetVrslcmResponse(rsp *http.Response) (*GetVrslcmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVrslcmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vrslcm
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateVrslcmVersionInInventoryResponse parses an HTTP response from a UpdateVrslcmVersionInInventoryWithResponse call
func ParseUpdateVrslcmVersionInInventoryResponse(rsp *http.Response) (*UpdateVrslcmVersionInInventoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVrslcmVersionInInventoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVrslcmStatusResponse parses an HTTP response from a GetVrslcmStatusWithResponse call
func ParseGetVrslcmStatusResponse(rsp *http.Response) (*GetVrslcmStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVrslcmStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrslcmStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetVrslcmsResponse parses an HTTP response from a GetVrslcmsWithResponse call
func ParseGetVrslcmsResponse(rsp *http.Response) (*GetVrslcmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVrslcmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfVrslcm
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeployVrslcmResponse parses an HTTP response from a DeployVrslcmWithResponse call
func ParseDeployVrslcmResponse(rsp *http.Response) (*DeployVrslcmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeployVrslcmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateVrslcmResponse parses an HTTP response from a ValidateVrslcmWithResponse call
func ParseValidateVrslcmResponse(rsp *http.Response) (*ValidateVrslcmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateVrslcmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetVrslcmValidationResponse parses an HTTP response from a GetVrslcmValidationWithResponse call
func ParseGetVrslcmValidationResponse(rsp *http.Response) (*GetVrslcmValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVrslcmValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Validation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateVrslcmVersionByIdInInventoryResponse parses an HTTP response from a UpdateVrslcmVersionByIdInInventoryWithResponse call
func ParseUpdateVrslcmVersionByIdInInventoryResponse(rsp *http.Response) (*UpdateVrslcmVersionByIdInInventoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVrslcmVersionByIdInInventoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadVsanHclResponse parses an HTTP response from a DownloadVsanHclWithResponse call
func ParseDownloadVsanHclResponse(rsp *http.Response) (*DownloadVsanHclResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadVsanHclResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVsanHclAttributesResponse parses an HTTP response from a GetVsanHclAttributesWithResponse call
func ParseGetVsanHclAttributesResponse(rsp *http.Response) (*GetVsanHclAttributesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVsanHclAttributesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VsanHclAttributes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVsanHclConfigurationResponse parses an HTTP response from a GetVsanHclConfigurationWithResponse call
func ParseGetVsanHclConfigurationResponse(rsp *http.Response) (*GetVsanHclConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVsanHclConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VsanHclConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVsanHclConfigurationResponse parses an HTTP response from a UpdateVsanHclConfigurationWithResponse call
func ParseUpdateVsanHclConfigurationResponse(rsp *http.Response) (*UpdateVsanHclConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVsanHclConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VsanHclConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VsanHclConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWsasResponse parses an HTTP response from a GetWsasWithResponse call
func ParseGetWsasResponse(rsp *http.Response) (*GetWsasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWsasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageOfWsa
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
