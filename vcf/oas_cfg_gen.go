// Code generated by ogen, DO NOT EDIT.

package vcf

import (
	"net/http"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/ogenregex"
)

var regexMap = map[string]ogenregex.Regexp{
	"(((?![BIOS_])\\w){5}-){4}?((?![BIOS_])\\w){5}?":         ogenregex.MustCompile("(((?![BIOS_])\\w){5}-){4}?((?![BIOS_])\\w){5}?"),
	"(ACTIVE_ACTIVE|ACTIVE_STANDBY|)":                        ogenregex.MustCompile("(ACTIVE_ACTIVE|ACTIVE_STANDBY|)"),
	"(CUSTOM|DEFAULT)":                                       ogenregex.MustCompile("(CUSTOM|DEFAULT)"),
	"(EBGP|STATIC|)":                                         ogenregex.MustCompile("(EBGP|STATIC|)"),
	"(EXPANSION|SHRINKAGE)":                                  ogenregex.MustCompile("(EXPANSION|SHRINKAGE)"),
	"(FAILOVER_ORDER|LOADBALANCE_SRCID|LOADBALANCE_SRC_MAC)": ogenregex.MustCompile("(FAILOVER_ORDER|LOADBALANCE_SRCID|LOADBALANCE_SRC_MAC)"),
	"(LARGE|MEDIUM|SMALL)":                                   ogenregex.MustCompile("(LARGE|MEDIUM|SMALL)"),
	"(NSX-T)":                                                ogenregex.MustCompile("(NSX-T)"),
	"(REGION_A|REGION_B|X_REGION)":                           ogenregex.MustCompile("(REGION_A|REGION_B|X_REGION)"),
	"(STANDARD|ENS|ENS_INTERRUPT)":                           ogenregex.MustCompile("(STANDARD|ENS|ENS_INTERRUPT)"),
	"(VCF|VCF_VXRAIL)":                                       ogenregex.MustCompile("(VCF|VCF_VXRAIL)"),
	"(VLAN|OVERLAY)":                                         ogenregex.MustCompile("(VLAN|OVERLAY)"),
	"(XLARGE|LARGE|MEDIUM|SMALL)":                            ogenregex.MustCompile("(XLARGE|LARGE|MEDIUM|SMALL)"),
	"(XLARGE|LARGE|MEDIUM|SMALL|TINY)":                       ogenregex.MustCompile("(XLARGE|LARGE|MEDIUM|SMALL|TINY)"),
	"(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})":      ogenregex.MustCompile("(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})"),
	"(loadbalance_ip|loadbalance_srcmac|loadbalance_srcid|failover_explicit|loadbalance_loadbased)": ogenregex.MustCompile("(loadbalance_ip|loadbalance_srcmac|loadbalance_srcid|failover_explicit|loadbalance_loadbased)"),
	"(lstorage|xlstorage)": ogenregex.MustCompile("(lstorage|xlstorage)"),
	"(uplink1|uplink2|uplink3|uplink4|uplink5|uplink6|uplink7|uplink8)": ogenregex.MustCompile("(uplink1|uplink2|uplink3|uplink4|uplink5|uplink6|uplink7|uplink8)"),
	"(xlarge|large|medium|small)":                                       ogenregex.MustCompile("(xlarge|large|medium|small)"),
	"^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$": ogenregex.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$"),
	"^(?!\\s*$).+": ogenregex.MustCompile("^(?!\\s*$).+"),
	"^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[!\"#$%&'()*+,-./:;<=>?@\\[\\]^_`{|}~])(?=\\S+$).{8,20}$":                                                                              ogenregex.MustCompile("^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[!\"#$%&'()*+,-./:;<=>?@\\[\\]^_`{|}~])(?=\\S+$).{8,20}$"),
	"^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])$":                                  ogenregex.MustCompile("^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])$"),
	"^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\/(([0-9])|([12][0-9])|(3[0-2]))$": ogenregex.MustCompile("^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\/(([0-9])|([12][0-9])|(3[0-2]))$"),
	"^[a-z0-9]+(([-]+[a-z0-9]+)|([.][a-z0-9]+))*\\.[a-z]{2,}$":                                                                                                                     ogenregex.MustCompile("^[a-z0-9]+(([-]+[a-z0-9]+)|([.][a-z0-9]+))*\\.[a-z]{2,}$"),
	"^[a-zA-Z0-9-]+$":        ogenregex.MustCompile("^[a-zA-Z0-9-]+$"),
	"^[a-zA-Z0-9-_]+$":       ogenregex.MustCompile("^[a-zA-Z0-9-_]+$"),
	"^[a-zA-Z\\d\\-]{3,20}$": ogenregex.MustCompile("^[a-zA-Z\\d\\-]{3,20}$"),
	"management|faultTolerance|vmotion|virtualMachine|iSCSI|nfs|hbr|vsan|vdp": ogenregex.MustCompile("management|faultTolerance|vmotion|virtualMachine|iSCSI|nfs|hbr|vsan|vdp"),
}

type (
	optionFunc[C any] func(*C)
)

// ErrorHandler is error handler.
type ErrorHandler = ogenerrors.ErrorHandler

type serverConfig struct {
	NotFound           http.HandlerFunc
	MethodNotAllowed   func(w http.ResponseWriter, r *http.Request, allowed string)
	ErrorHandler       ErrorHandler
	Prefix             string
	Middleware         Middleware
	MaxMultipartMemory int64
}

// ServerOption is server config option.
type ServerOption interface {
	applyServer(*serverConfig)
}

var _ ServerOption = (optionFunc[serverConfig])(nil)

func (o optionFunc[C]) applyServer(c *C) {
	o(c)
}

func newServerConfig(opts ...ServerOption) serverConfig {
	cfg := serverConfig{
		NotFound: http.NotFound,
		MethodNotAllowed: func(w http.ResponseWriter, r *http.Request, allowed string) {
			status := http.StatusMethodNotAllowed
			if r.Method == "OPTIONS" {
				w.Header().Set("Access-Control-Allow-Methods", allowed)
				w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
				status = http.StatusNoContent
			} else {
				w.Header().Set("Allow", allowed)
			}
			w.WriteHeader(status)
		},
		ErrorHandler:       ogenerrors.DefaultErrorHandler,
		Middleware:         nil,
		MaxMultipartMemory: 32 << 20, // 32 MB
	}
	for _, opt := range opts {
		opt.applyServer(&cfg)
	}
	return cfg
}

type baseServer struct {
	cfg serverConfig
}

func (s baseServer) notFound(w http.ResponseWriter, r *http.Request) {
	s.cfg.NotFound(w, r)
}

func (s baseServer) notAllowed(w http.ResponseWriter, r *http.Request, allowed string) {
	s.cfg.MethodNotAllowed(w, r, allowed)
}

func (cfg serverConfig) baseServer() (s baseServer, err error) {
	s = baseServer{cfg: cfg}
	return s, nil
}

type clientConfig struct {
	Client ht.Client
}

// ClientOption is client config option.
type ClientOption interface {
	applyClient(*clientConfig)
}

var _ ClientOption = (optionFunc[clientConfig])(nil)

func (o optionFunc[C]) applyClient(c *C) {
	o(c)
}

func newClientConfig(opts ...ClientOption) clientConfig {
	cfg := clientConfig{
		Client: http.DefaultClient,
	}
	for _, opt := range opts {
		opt.applyClient(&cfg)
	}
	return cfg
}

type baseClient struct {
	cfg clientConfig
}

func (cfg clientConfig) baseClient() (c baseClient, err error) {
	c = baseClient{cfg: cfg}
	return c, nil
}

// Option is config option.
type Option interface {
	ServerOption
	ClientOption
}

// WithClient specifies http client to use.
func WithClient(client ht.Client) ClientOption {
	return optionFunc[clientConfig](func(cfg *clientConfig) {
		if client != nil {
			cfg.Client = client
		}
	})
}

// WithNotFound specifies Not Found handler to use.
func WithNotFound(notFound http.HandlerFunc) ServerOption {
	return optionFunc[serverConfig](func(cfg *serverConfig) {
		if notFound != nil {
			cfg.NotFound = notFound
		}
	})
}

// WithMethodNotAllowed specifies Method Not Allowed handler to use.
func WithMethodNotAllowed(methodNotAllowed func(w http.ResponseWriter, r *http.Request, allowed string)) ServerOption {
	return optionFunc[serverConfig](func(cfg *serverConfig) {
		if methodNotAllowed != nil {
			cfg.MethodNotAllowed = methodNotAllowed
		}
	})
}

// WithErrorHandler specifies error handler to use.
func WithErrorHandler(h ErrorHandler) ServerOption {
	return optionFunc[serverConfig](func(cfg *serverConfig) {
		if h != nil {
			cfg.ErrorHandler = h
		}
	})
}

// WithPathPrefix specifies server path prefix.
func WithPathPrefix(prefix string) ServerOption {
	return optionFunc[serverConfig](func(cfg *serverConfig) {
		cfg.Prefix = prefix
	})
}

// WithMiddleware specifies middlewares to use.
func WithMiddleware(m ...Middleware) ServerOption {
	return optionFunc[serverConfig](func(cfg *serverConfig) {
		switch len(m) {
		case 0:
			cfg.Middleware = nil
		case 1:
			cfg.Middleware = m[0]
		default:
			cfg.Middleware = middleware.ChainMiddlewares(m...)
		}
	})
}

// WithMaxMultipartMemory specifies limit of memory for storing file parts.
// File parts which can't be stored in memory will be stored on disk in temporary files.
func WithMaxMultipartMemory(max int64) ServerOption {
	return optionFunc[serverConfig](func(cfg *serverConfig) {
		if max > 0 {
			cfg.MaxMultipartMemory = max
		}
	})
}
