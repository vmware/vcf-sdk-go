// Code generated by ogen, DO NOT EDIT.

package vcf

import (
	"context"
	"net/http"

	"github.com/go-faster/errors"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
)

func recordError(string, error) {}

// handleAddDatastoreToClusterRequest handles addDatastoreToCluster operation.
//
// Mount a datastore to a cluster.
//
// POST /v1/clusters/{id}/datastores
func (s *Server) handleAddDatastoreToClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AddDatastoreToCluster",
			ID:   "addDatastoreToCluster",
		}
	)
	params, err := decodeAddDatastoreToClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAddDatastoreToClusterRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AddDatastoreToClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AddDatastoreToCluster",
			OperationSummary: "Mount a datastore to a cluster",
			OperationID:      "addDatastoreToCluster",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *DatastoreMountSpec
			Params   = AddDatastoreToClusterParams
			Response = AddDatastoreToClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAddDatastoreToClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AddDatastoreToCluster(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AddDatastoreToCluster(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAddDatastoreToClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAddIpPoolToNetworkOfNetworkPoolRequest handles addIpPoolToNetworkOfNetworkPool operation.
//
// Add an IP Pool to a Network of a Network Pool.
//
// POST /v1/network-pools/{id}/networks/{networkId}/ip-pools
func (s *Server) handleAddIpPoolToNetworkOfNetworkPoolRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AddIpPoolToNetworkOfNetworkPool",
			ID:   "addIpPoolToNetworkOfNetworkPool",
		}
	)
	params, err := decodeAddIpPoolToNetworkOfNetworkPoolParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAddIpPoolToNetworkOfNetworkPoolRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AddIpPoolToNetworkOfNetworkPoolRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AddIpPoolToNetworkOfNetworkPool",
			OperationSummary: "Add an IP Pool to a Network of a Network Pool",
			OperationID:      "addIpPoolToNetworkOfNetworkPool",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "networkId",
					In:   "path",
				}: params.NetworkId,
			},
			Raw: r,
		}

		type (
			Request  = *IpPool
			Params   = AddIpPoolToNetworkOfNetworkPoolParams
			Response = AddIpPoolToNetworkOfNetworkPoolRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAddIpPoolToNetworkOfNetworkPoolParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AddIpPoolToNetworkOfNetworkPool(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AddIpPoolToNetworkOfNetworkPool(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAddIpPoolToNetworkOfNetworkPoolResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAddLicenseKeyRequest handles addLicenseKey operation.
//
// Add a a new license key.
//
// POST /v1/license-keys
func (s *Server) handleAddLicenseKeyRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AddLicenseKey",
			ID:   "addLicenseKey",
		}
	)
	request, close, err := s.decodeAddLicenseKeyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AddLicenseKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AddLicenseKey",
			OperationSummary: "Add a a new license key",
			OperationID:      "addLicenseKey",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *LicenseKey
			Params   = struct{}
			Response = AddLicenseKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AddLicenseKey(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.AddLicenseKey(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAddLicenseKeyResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAddUsersRequest handles addUsers operation.
//
// Add list of users.
//
// POST /v1/users
func (s *Server) handleAddUsersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AddUsers",
			ID:   "addUsers",
		}
	)
	request, close, err := s.decodeAddUsersRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AddUsersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AddUsers",
			OperationSummary: "Assign access to users in SDDC Manager",
			OperationID:      "addUsers",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []User
			Params   = struct{}
			Response = AddUsersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AddUsers(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.AddUsers(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAddUsersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAddVasaProviderRequest handles addVasaProvider operation.
//
// Add a VASA Provider.
//
// POST /v1/vasa-providers
func (s *Server) handleAddVasaProviderRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AddVasaProvider",
			ID:   "addVasaProvider",
		}
	)
	request, close, err := s.decodeAddVasaProviderRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AddVasaProviderRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AddVasaProvider",
			OperationSummary: "Add a VASA Provider",
			OperationID:      "addVasaProvider",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *VasaProvider
			Params   = struct{}
			Response = AddVasaProviderRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AddVasaProvider(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.AddVasaProvider(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAddVasaProviderResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAddVasaProviderStorageContainerRequest handles addVasaProviderStorageContainer operation.
//
// Add the storage containers to a VASA Provider.
//
// POST /v1/vasa-providers/{id}/storage-containers
func (s *Server) handleAddVasaProviderStorageContainerRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AddVasaProviderStorageContainer",
			ID:   "addVasaProviderStorageContainer",
		}
	)
	params, err := decodeAddVasaProviderStorageContainerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAddVasaProviderStorageContainerRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AddVasaProviderStorageContainerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AddVasaProviderStorageContainer",
			OperationSummary: "Add the storage containers to a VASA Provider",
			OperationID:      "addVasaProviderStorageContainer",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = []StorageContainer
			Params   = AddVasaProviderStorageContainerParams
			Response = AddVasaProviderStorageContainerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAddVasaProviderStorageContainerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AddVasaProviderStorageContainer(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AddVasaProviderStorageContainer(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAddVasaProviderStorageContainerResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAddVasaProviderUserRequest handles addVasaProviderUser operation.
//
// Add the users to a VASA Provider.
//
// POST /v1/vasa-providers/{id}/users
func (s *Server) handleAddVasaProviderUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AddVasaProviderUser",
			ID:   "addVasaProviderUser",
		}
	)
	params, err := decodeAddVasaProviderUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAddVasaProviderUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AddVasaProviderUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AddVasaProviderUser",
			OperationSummary: "Add the users to a VASA Provider",
			OperationID:      "addVasaProviderUser",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = []VasaUser
			Params   = AddVasaProviderUserParams
			Response = AddVasaProviderUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAddVasaProviderUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AddVasaProviderUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AddVasaProviderUser(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAddVasaProviderUserResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAssignTagsToClusterRequest handles assignTagsToCluster operation.
//
// Assign Tags to Cluster.
//
// PUT /v1/clusters/{id}/tags
func (s *Server) handleAssignTagsToClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AssignTagsToCluster",
			ID:   "assignTagsToCluster",
		}
	)
	params, err := decodeAssignTagsToClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAssignTagsToClusterRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AssignTagsToClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AssignTagsToCluster",
			OperationSummary: "Assign Tags to Cluster",
			OperationID:      "assignTagsToCluster",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *TagsSpec
			Params   = AssignTagsToClusterParams
			Response = AssignTagsToClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAssignTagsToClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AssignTagsToCluster(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AssignTagsToCluster(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAssignTagsToClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAssignTagsToDomainRequest handles assignTagsToDomain operation.
//
// Assign tags to a domain.
//
// PUT /v1/domains/{id}/tags
func (s *Server) handleAssignTagsToDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AssignTagsToDomain",
			ID:   "assignTagsToDomain",
		}
	)
	params, err := decodeAssignTagsToDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAssignTagsToDomainRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AssignTagsToDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AssignTagsToDomain",
			OperationSummary: "Assign tags to a domain",
			OperationID:      "assignTagsToDomain",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *TagsSpec
			Params   = AssignTagsToDomainParams
			Response = AssignTagsToDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAssignTagsToDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AssignTagsToDomain(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AssignTagsToDomain(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAssignTagsToDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAssignTagsToHostRequest handles assignTagsToHost operation.
//
// Assign tags to a host.
//
// PUT /v1/hosts/{id}/tags
func (s *Server) handleAssignTagsToHostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AssignTagsToHost",
			ID:   "assignTagsToHost",
		}
	)
	params, err := decodeAssignTagsToHostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAssignTagsToHostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AssignTagsToHostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AssignTagsToHost",
			OperationSummary: "",
			OperationID:      "assignTagsToHost",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *TagsSpec
			Params   = AssignTagsToHostParams
			Response = AssignTagsToHostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAssignTagsToHostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AssignTagsToHost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AssignTagsToHost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAssignTagsToHostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCancelCredentialsTaskRequest handles cancelCredentialsTask operation.
//
// Cancel a failed credential task by its ID.
//
// DELETE /v1/credentials/tasks/{id}
func (s *Server) handleCancelCredentialsTaskRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CancelCredentialsTask",
			ID:   "cancelCredentialsTask",
		}
	)
	params, err := decodeCancelCredentialsTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CancelCredentialsTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CancelCredentialsTask",
			OperationSummary: "Cancel a failed credential task by its ID",
			OperationID:      "cancelCredentialsTask",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CancelCredentialsTaskParams
			Response = CancelCredentialsTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCancelCredentialsTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CancelCredentialsTask(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CancelCredentialsTask(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCancelCredentialsTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCancelTaskRequest handles cancelTask operation.
//
// Cancel a Task by ID, if it exists.
//
// DELETE /v1/tasks/{id}
func (s *Server) handleCancelTaskRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CancelTask",
			ID:   "cancelTask",
		}
	)
	params, err := decodeCancelTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CancelTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CancelTask",
			OperationSummary: "Cancel a Task",
			OperationID:      "cancelTask",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CancelTaskParams
			Response = CancelTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCancelTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CancelTask(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CancelTask(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCancelTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCommissionHostsRequest handles commissionHosts operation.
//
// Commission the Hosts.
//
// POST /v1/hosts
func (s *Server) handleCommissionHostsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CommissionHosts",
			ID:   "commissionHosts",
		}
	)
	request, close, err := s.decodeCommissionHostsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CommissionHostsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CommissionHosts",
			OperationSummary: "Commission the Hosts",
			OperationID:      "commissionHosts",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []HostCommissionSpec
			Params   = struct{}
			Response = CommissionHostsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CommissionHosts(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CommissionHosts(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCommissionHostsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleComplianceAuditRequest handles complianceAudit operation.
//
// Compliance audit of resource.
//
// POST /v1/domains/{id}/compliance-audits
func (s *Server) handleComplianceAuditRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ComplianceAudit",
			ID:   "complianceAudit",
		}
	)
	params, err := decodeComplianceAuditParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeComplianceAuditRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ComplianceAuditRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ComplianceAudit",
			OperationSummary: "Compliance audit of resource",
			OperationID:      "complianceAudit",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *ComplianceAuditSpec
			Params   = ComplianceAuditParams
			Response = ComplianceAuditRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackComplianceAuditParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ComplianceAudit(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ComplianceAudit(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeComplianceAuditResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConfigureCertificateAuthorityRequest handles configureCertificateAuthority operation.
//
// Update the configuration of a Certificate Authority.
//
// PATCH /v1/certificate-authorities
func (s *Server) handleConfigureCertificateAuthorityRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConfigureCertificateAuthority",
			ID:   "configureCertificateAuthority",
		}
	)
	request, close, err := s.decodeConfigureCertificateAuthorityRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ConfigureCertificateAuthorityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConfigureCertificateAuthority",
			OperationSummary: "Update the configuration of a Certificate Authority",
			OperationID:      "configureCertificateAuthority",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *CertificateAuthorityCreationSpec
			Params   = struct{}
			Response = ConfigureCertificateAuthorityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConfigureCertificateAuthority(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConfigureCertificateAuthority(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConfigureCertificateAuthorityResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConfigureDnsRequest handles configureDns operation.
//
// Update the DNS configuration.
//
// PUT /v1/system/dns-configuration
func (s *Server) handleConfigureDnsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConfigureDns",
			ID:   "configureDns",
		}
	)
	request, close, err := s.decodeConfigureDnsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ConfigureDnsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConfigureDns",
			OperationSummary: "Update the DNS configuration",
			OperationID:      "configureDns",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *DnsConfiguration
			Params   = struct{}
			Response = ConfigureDnsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConfigureDns(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConfigureDns(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConfigureDnsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConfigureNtpRequest handles configureNtp operation.
//
// Update the NTP configuration.
//
// PUT /v1/system/ntp-configuration
func (s *Server) handleConfigureNtpRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConfigureNtp",
			ID:   "configureNtp",
		}
	)
	request, close, err := s.decodeConfigureNtpRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ConfigureNtpRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConfigureNtp",
			OperationSummary: "Update the NTP configuration",
			OperationID:      "configureNtp",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *NtpConfiguration
			Params   = struct{}
			Response = ConfigureNtpRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConfigureNtp(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConfigureNtp(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConfigureNtpResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectOpenIdRequest handles connectOpenId operation.
//
// POST /v1/nsxt-clusters/oidcs
func (s *Server) handleConnectOpenIdRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectOpenId",
			ID:   "connectOpenId",
		}
	)
	request, close, err := s.decodeConnectOpenIdRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ConnectOpenIdOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectOpenId",
			OperationSummary: "",
			OperationID:      "connectOpenId",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *NsxtOidcSpec
			Params   = struct{}
			Response = *ConnectOpenIdOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ConnectOpenId(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.ConnectOpenId(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectOpenIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectVrliWithDomainRequest handles connectVrliWithDomain operation.
//
// Connect or disconnect a domain with VMware Aria Operations for Logs.
//
// PUT /v1/vrli/domains
func (s *Server) handleConnectVrliWithDomainRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectVrliWithDomain",
			ID:   "connectVrliWithDomain",
		}
	)
	request, close, err := s.decodeConnectVrliWithDomainRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Task
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectVrliWithDomain",
			OperationSummary: "",
			OperationID:      "connectVrliWithDomain",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *DomainIntegration
			Params   = struct{}
			Response = *Task
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectVrliWithDomain(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectVrliWithDomain(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectVrliWithDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectVropsWithDomainRequest handles connectVropsWithDomain operation.
//
// Connects/disconnects a workload domains with VMware Aria Operations.
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /v1/vrops/domains
func (s *Server) handleConnectVropsWithDomainRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectVropsWithDomain",
			ID:   "connectVropsWithDomain",
		}
	)
	request, close, err := s.decodeConnectVropsWithDomainRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ConnectVropsWithDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectVropsWithDomain",
			OperationSummary: "Connect or disconnect a domain with VMware Aria Operations",
			OperationID:      "connectVropsWithDomain",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *DomainIntegration
			Params   = struct{}
			Response = ConnectVropsWithDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectVropsWithDomain(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectVropsWithDomain(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectVropsWithDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateAvnsRequest handles createAvns operation.
//
// Create Application Virtual Networks (AVN).
//
// POST /v1/avns
func (s *Server) handleCreateAvnsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CreateAvns",
			ID:   "createAvns",
		}
	)
	request, close, err := s.decodeCreateAvnsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateAvnsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CreateAvns",
			OperationSummary: "Create Application Virtual Networks (AVN)",
			OperationID:      "createAvns",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *AvnsCreationSpec
			Params   = struct{}
			Response = CreateAvnsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateAvns(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateAvns(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateAvnsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateCertificateAuthorityRequest handles createCertificateAuthority operation.
//
// Creates a certificate authority. This is required to generate signed certificates by supporting
// CAs.
//
// PUT /v1/certificate-authorities
func (s *Server) handleCreateCertificateAuthorityRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CreateCertificateAuthority",
			ID:   "createCertificateAuthority",
		}
	)
	request, close, err := s.decodeCreateCertificateAuthorityRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateCertificateAuthorityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CreateCertificateAuthority",
			OperationSummary: "Configure integration with a Certificate Authority",
			OperationID:      "createCertificateAuthority",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *CertificateAuthorityCreationSpec
			Params   = struct{}
			Response = CreateCertificateAuthorityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateCertificateAuthority(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateCertificateAuthority(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateCertificateAuthorityResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateClusterRequest handles createCluster operation.
//
// Create a cluster and add to an existing domain.
//
// POST /v1/clusters
func (s *Server) handleCreateClusterRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CreateCluster",
			ID:   "createCluster",
		}
	)
	request, close, err := s.decodeCreateClusterRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CreateCluster",
			OperationSummary: "Create a cluster and add to an existing domain",
			OperationID:      "createCluster",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *ClusterCreationSpec
			Params   = struct{}
			Response = CreateClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateCluster(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateCluster(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateDomainRequest handles createDomain operation.
//
// Create a domain.
//
// POST /v1/domains
func (s *Server) handleCreateDomainRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CreateDomain",
			ID:   "createDomain",
		}
	)
	request, close, err := s.decodeCreateDomainRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CreateDomain",
			OperationSummary: "Create a domain",
			OperationID:      "createDomain",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *DomainCreationSpec
			Params   = struct{}
			Response = CreateDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateDomain(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateDomain(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateEdgeClusterRequest handles createEdgeCluster operation.
//
// Create an NSX Edge Cluster.
//
// POST /v1/edge-clusters
func (s *Server) handleCreateEdgeClusterRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CreateEdgeCluster",
			ID:   "createEdgeCluster",
		}
	)
	request, close, err := s.decodeCreateEdgeClusterRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateEdgeClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CreateEdgeCluster",
			OperationSummary: "Create an NSX Edge Cluster",
			OperationID:      "createEdgeCluster",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *EdgeClusterCreationSpec
			Params   = struct{}
			Response = CreateEdgeClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateEdgeCluster(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateEdgeCluster(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateEdgeClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateNetworkPoolRequest handles createNetworkPool operation.
//
// Create a Network Pool.
//
// POST /v1/network-pools
func (s *Server) handleCreateNetworkPoolRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CreateNetworkPool",
			ID:   "createNetworkPool",
		}
	)
	request, close, err := s.decodeCreateNetworkPoolRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateNetworkPoolRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CreateNetworkPool",
			OperationSummary: "Create a Network Pool",
			OperationID:      "createNetworkPool",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *NetworkPool
			Params   = struct{}
			Response = CreateNetworkPoolRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateNetworkPool(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateNetworkPool(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateNetworkPoolResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateResourceWarningRequest handles createResourceWarning operation.
//
// Create a new Resource Warning.
//
// POST /v1/resource-warnings
func (s *Server) handleCreateResourceWarningRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CreateResourceWarning",
			ID:   "createResourceWarning",
		}
	)
	request, close, err := s.decodeCreateResourceWarningRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateResourceWarningRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CreateResourceWarning",
			OperationSummary: "Create a new Resource Warning",
			OperationID:      "createResourceWarning",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *ResourceWarningCreationSpec
			Params   = struct{}
			Response = CreateResourceWarningRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateResourceWarning(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateResourceWarning(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateResourceWarningResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateTokenRequest handles createToken operation.
//
// Creates access token and refresh token for user access.
//
// POST /v1/tokens
func (s *Server) handleCreateTokenRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CreateToken",
			ID:   "createToken",
		}
	)
	request, close, err := s.decodeCreateTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CreateToken",
			OperationSummary: "Create Token Pair",
			OperationID:      "createToken",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *TokenCreationSpec
			Params   = struct{}
			Response = CreateTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateToken(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateToken(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateTokenResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDecommissionHostsRequest handles decommissionHosts operation.
//
// Decommission the Hosts.
//
// DELETE /v1/hosts
func (s *Server) handleDecommissionHostsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DecommissionHosts",
			ID:   "decommissionHosts",
		}
	)
	request, close, err := s.decodeDecommissionHostsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response DecommissionHostsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DecommissionHosts",
			OperationSummary: "Decommission the Hosts",
			OperationID:      "decommissionHosts",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []HostDecommissionSpec
			Params   = struct{}
			Response = DecommissionHostsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DecommissionHosts(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.DecommissionHosts(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDecommissionHostsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteALBClusterRequest handles deleteALBCluster operation.
//
// Deletes an NSX ALB Cluster by its ID.
//
// DELETE /v1/nsx-alb-clusters/{id}
func (s *Server) handleDeleteALBClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteALBCluster",
			ID:   "deleteALBCluster",
		}
	)
	params, err := decodeDeleteALBClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteALBClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteALBCluster",
			OperationSummary: "Deletes an NSX ALB Cluster by its ID",
			OperationID:      "deleteALBCluster",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "forceDelete",
					In:   "query",
				}: params.ForceDelete,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteALBClusterParams
			Response = DeleteALBClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteALBClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteALBCluster(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteALBCluster(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteALBClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteAliasVersionsBySoftwareTypeAndBaseVersionRequest handles deleteAliasVersionsBySoftwareTypeAndBaseVersion operation.
//
// Delete Version Alias Configuration by bundle component type, version, and aliases.
//
// DELETE /v1/system/settings/version-aliases/{bundleComponentType}/{version}
func (s *Server) handleDeleteAliasVersionsBySoftwareTypeAndBaseVersionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteAliasVersionsBySoftwareTypeAndBaseVersion",
			ID:   "deleteAliasVersionsBySoftwareTypeAndBaseVersion",
		}
	)
	params, err := decodeDeleteAliasVersionsBySoftwareTypeAndBaseVersionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeDeleteAliasVersionsBySoftwareTypeAndBaseVersionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response DeleteAliasVersionsBySoftwareTypeAndBaseVersionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteAliasVersionsBySoftwareTypeAndBaseVersion",
			OperationSummary: "Removes Version Alias Configuration by component type and version",
			OperationID:      "deleteAliasVersionsBySoftwareTypeAndBaseVersion",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "bundleComponentType",
					In:   "path",
				}: params.BundleComponentType,
				{
					Name: "version",
					In:   "path",
				}: params.Version,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = DeleteAliasVersionsBySoftwareTypeAndBaseVersionParams
			Response = DeleteAliasVersionsBySoftwareTypeAndBaseVersionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteAliasVersionsBySoftwareTypeAndBaseVersionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteAliasVersionsBySoftwareTypeAndBaseVersion(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteAliasVersionsBySoftwareTypeAndBaseVersion(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteBundleRequest handles deleteBundle operation.
//
// Delete a Bundle by bundle ID.
//
// DELETE /v1/bundles/{id}
func (s *Server) handleDeleteBundleRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteBundle",
			ID:   "deleteBundle",
		}
	)
	params, err := decodeDeleteBundleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteBundleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteBundle",
			OperationSummary: "Delete a bundle by bundle ID",
			OperationID:      "deleteBundle",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteBundleParams
			Response = DeleteBundleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteBundleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteBundle(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteBundle(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteBundleResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteClusterRequest handles deleteCluster operation.
//
// Delete a cluster from a domain if it has been previously initialized for deletion.
//
// DELETE /v1/clusters/{id}
func (s *Server) handleDeleteClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteCluster",
			ID:   "deleteCluster",
		}
	)
	params, err := decodeDeleteClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteCluster",
			OperationSummary: "Delete a cluster from a domain if it has been previously initialized for deletion",
			OperationID:      "deleteCluster",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "force",
					In:   "query",
				}: params.Force,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteClusterParams
			Response = DeleteClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteCluster(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteCluster(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteCustomIsoByIdRequest handles deleteCustomIsoById operation.
//
// Delete the Custom ISO based on ID.
//
// DELETE /v1/custom-isos/{custom_iso_id}
func (s *Server) handleDeleteCustomIsoByIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteCustomIsoById",
			ID:   "deleteCustomIsoById",
		}
	)
	params, err := decodeDeleteCustomIsoByIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteCustomIsoByIdRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteCustomIsoById",
			OperationSummary: "Delete the Custom ISO based on ID",
			OperationID:      "deleteCustomIsoById",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "custom_iso_id",
					In:   "path",
				}: params.CustomIsoID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteCustomIsoByIdParams
			Response = DeleteCustomIsoByIdRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteCustomIsoByIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteCustomIsoById(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteCustomIsoById(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteCustomIsoByIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteDepotSettingsRequest handles deleteDepotSettings operation.
//
// Delete the depot configuration if such is present within VCF.
//
// DELETE /v1/system/settings/depot
func (s *Server) handleDeleteDepotSettingsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteDepotSettings",
			ID:   "deleteDepotSettings",
		}
	)
	params, err := decodeDeleteDepotSettingsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteDepotSettingsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteDepotSettings",
			OperationSummary: "Delete the depot configuration",
			OperationID:      "deleteDepotSettings",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "depotType",
					In:   "query",
				}: params.DepotType,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteDepotSettingsParams
			Response = DeleteDepotSettingsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteDepotSettingsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteDepotSettings(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteDepotSettings(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteDepotSettingsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteDomainRequest handles deleteDomain operation.
//
// Remove a domain if it has been previously initialized for deletion.
//
// DELETE /v1/domains/{id}
func (s *Server) handleDeleteDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteDomain",
			ID:   "deleteDomain",
		}
	)
	params, err := decodeDeleteDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteDomain",
			OperationSummary: "Remove a domain if it has been previously initialized for deletion",
			OperationID:      "deleteDomain",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteDomainParams
			Response = DeleteDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteDomain(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteDomain(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteIpPoolFromNetworkOfNetworkPoolRequest handles deleteIpPoolFromNetworkOfNetworkPool operation.
//
// Delete an IP Pool from a Network of a Network Pool.
//
// DELETE /v1/network-pools/{id}/networks/{networkId}/ip-pools
func (s *Server) handleDeleteIpPoolFromNetworkOfNetworkPoolRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteIpPoolFromNetworkOfNetworkPool",
			ID:   "deleteIpPoolFromNetworkOfNetworkPool",
		}
	)
	params, err := decodeDeleteIpPoolFromNetworkOfNetworkPoolParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeDeleteIpPoolFromNetworkOfNetworkPoolRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response DeleteIpPoolFromNetworkOfNetworkPoolRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteIpPoolFromNetworkOfNetworkPool",
			OperationSummary: "Delete an IP Pool from a Network of a Network Pool",
			OperationID:      "deleteIpPoolFromNetworkOfNetworkPool",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "networkId",
					In:   "path",
				}: params.NetworkId,
			},
			Raw: r,
		}

		type (
			Request  = *IpPool
			Params   = DeleteIpPoolFromNetworkOfNetworkPoolParams
			Response = DeleteIpPoolFromNetworkOfNetworkPoolRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteIpPoolFromNetworkOfNetworkPoolParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteIpPoolFromNetworkOfNetworkPool(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteIpPoolFromNetworkOfNetworkPool(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteIpPoolFromNetworkOfNetworkPoolResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteNetworkPoolRequest handles deleteNetworkPool operation.
//
// Delete the Network Pool by the ID, if it exists and is unused.
//
// DELETE /v1/network-pools/{id}
func (s *Server) handleDeleteNetworkPoolRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteNetworkPool",
			ID:   "deleteNetworkPool",
		}
	)
	params, err := decodeDeleteNetworkPoolParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteNetworkPoolRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteNetworkPool",
			OperationSummary: "Delete a Network Pool",
			OperationID:      "deleteNetworkPool",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "force",
					In:   "query",
				}: params.Force,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteNetworkPoolParams
			Response = DeleteNetworkPoolRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteNetworkPoolParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteNetworkPool(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteNetworkPool(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteNetworkPoolResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeletePersonalityRequest handles deletePersonality operation.
//
// Delete the personality based on either name or id.
//
// DELETE /v1/personalities
func (s *Server) handleDeletePersonalityRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeletePersonality",
			ID:   "deletePersonality",
		}
	)
	params, err := decodeDeletePersonalityParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeletePersonalityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeletePersonality",
			OperationSummary: "Delete the personality based on either name or id",
			OperationID:      "deletePersonality",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "personalityId",
					In:   "query",
				}: params.PersonalityId,
				{
					Name: "personalityName",
					In:   "query",
				}: params.PersonalityName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeletePersonalityParams
			Response = DeletePersonalityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeletePersonalityParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeletePersonality(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeletePersonality(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeletePersonalityResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteReleaseByDomainIDRequest handles deleteReleaseByDomainID operation.
//
// Delete last selected upgrade version for the domain.
//
// DELETE /v1/releases/domains/{domainId}
func (s *Server) handleDeleteReleaseByDomainIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteReleaseByDomainID",
			ID:   "deleteReleaseByDomainID",
		}
	)
	params, err := decodeDeleteReleaseByDomainIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteReleaseByDomainIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteReleaseByDomainID",
			OperationSummary: "Delete the target release by its domain ID",
			OperationID:      "deleteReleaseByDomainID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteReleaseByDomainIDParams
			Response = DeleteReleaseByDomainIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteReleaseByDomainIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteReleaseByDomainID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteReleaseByDomainID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteReleaseByDomainIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteTrustedCertificateRequest handles deleteTrustedCertificate operation.
//
// Delete a trusted certificate from the SDDC Manager.
//
// DELETE /v1/sddc-manager/trusted-certificates/{alias}
func (s *Server) handleDeleteTrustedCertificateRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteTrustedCertificate",
			ID:   "deleteTrustedCertificate",
		}
	)
	params, err := decodeDeleteTrustedCertificateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteTrustedCertificateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteTrustedCertificate",
			OperationSummary: "Delete a trusted certificate from the SDDC Manager",
			OperationID:      "deleteTrustedCertificate",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "alias",
					In:   "path",
				}: params.Alias,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteTrustedCertificateParams
			Response = DeleteTrustedCertificateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteTrustedCertificateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteTrustedCertificate(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteTrustedCertificate(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteTrustedCertificateResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteVersionAliasBySoftwareTypeRequest handles deleteVersionAliasBySoftwareType operation.
//
// Removes Version Alias Configuration by component type.
//
// DELETE /v1/system/settings/version-aliases/{bundleComponentType}
func (s *Server) handleDeleteVersionAliasBySoftwareTypeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteVersionAliasBySoftwareType",
			ID:   "deleteVersionAliasBySoftwareType",
		}
	)
	params, err := decodeDeleteVersionAliasBySoftwareTypeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteVersionAliasBySoftwareTypeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteVersionAliasBySoftwareType",
			OperationSummary: "Removes Version Alias Configuration by component type",
			OperationID:      "deleteVersionAliasBySoftwareType",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "bundleComponentType",
					In:   "path",
				}: params.BundleComponentType,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteVersionAliasBySoftwareTypeParams
			Response = DeleteVersionAliasBySoftwareTypeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteVersionAliasBySoftwareTypeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteVersionAliasBySoftwareType(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteVersionAliasBySoftwareType(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteVersionAliasBySoftwareTypeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeployVrslcmRequest handles deployVrslcm operation.
//
// Triggers the VMware Aria Suite Lifecycle deployment operation and returns an URL in the headers to
// track the operation status.
//
// POST /v1/vrslcms
func (s *Server) handleDeployVrslcmRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeployVrslcm",
			ID:   "deployVrslcm",
		}
	)
	request, close, err := s.decodeDeployVrslcmRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response DeployVrslcmRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeployVrslcm",
			OperationSummary: "Deploy VMware Aria Suite Lifecycle",
			OperationID:      "deployVrslcm",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *VrslcmDeploymentSpec
			Params   = struct{}
			Response = DeployVrslcmRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeployVrslcm(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeployVrslcm(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeployVrslcmResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDisableLocalAccountRequest handles disableLocalAccount operation.
//
// Disable local account.
//
// DELETE /v1/users/local/admin
func (s *Server) handleDisableLocalAccountRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response DisableLocalAccountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DisableLocalAccount",
			OperationSummary: "Disable local account",
			OperationID:      "disableLocalAccount",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = DisableLocalAccountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DisableLocalAccount(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.DisableLocalAccount(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDisableLocalAccountResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDomainCreateValidationRequest handles domainCreateValidation operation.
//
// Gets the status of given domain create validation workflow by given validation id.
//
// GET /v1/domains/validations/{id}
func (s *Server) handleDomainCreateValidationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DomainCreateValidation",
			ID:   "domainCreateValidation",
		}
	)
	params, err := decodeDomainCreateValidationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DomainCreateValidationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DomainCreateValidation",
			OperationSummary: "Get the status of the validations for domain related operations",
			OperationID:      "domainCreateValidation",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DomainCreateValidationParams
			Response = DomainCreateValidationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDomainCreateValidationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DomainCreateValidation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DomainCreateValidation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDomainCreateValidationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDownloadCSRRequest handles downloadCSR operation.
//
// Download available CSR(s) in tar.gz format.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /v1/domains/{id}/csrs/downloads
func (s *Server) handleDownloadCSRRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DownloadCSR",
			ID:   "downloadCSR",
		}
	)
	params, err := decodeDownloadCSRParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DownloadCSRRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DownloadCSR",
			OperationSummary: "Request the download of CSR(s) for a domain in tar.gz format",
			OperationID:      "downloadCSR",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DownloadCSRParams
			Response = DownloadCSRRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDownloadCSRParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DownloadCSR(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DownloadCSR(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDownloadCSRResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDownloadVsanHclRequest handles downloadVsanHcl operation.
//
// Download vSAN HCL if online connectivity is available. Timestamp of vSAN HCL on SDDC Manager is
// checked with what is available online before download. vSAN HCL is downloaded only if new data is
// available.
//
// PATCH /v1/vsan-hcl
func (s *Server) handleDownloadVsanHclRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response DownloadVsanHclRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DownloadVsanHcl",
			OperationSummary: "Download vSAN HCL",
			OperationID:      "downloadVsanHcl",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = DownloadVsanHclRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DownloadVsanHcl(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.DownloadVsanHcl(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDownloadVsanHclResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleExportBringupDetailReportRequest handles exportBringupDetailReport operation.
//
// Returns the bringup report. Reports are generated in PDF and CSV formats.
//
// GET /v1/sddcs/{id}/detail-report
func (s *Server) handleExportBringupDetailReportRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ExportBringupDetailReport",
			ID:   "exportBringupDetailReport",
		}
	)
	params, err := decodeExportBringupDetailReportParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ExportBringupDetailReportRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ExportBringupDetailReport",
			OperationSummary: "Get bringup report by ID",
			OperationID:      "exportBringupDetailReport",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "format",
					In:   "query",
				}: params.Format,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ExportBringupDetailReportParams
			Response = ExportBringupDetailReportRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackExportBringupDetailReportParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ExportBringupDetailReport(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ExportBringupDetailReport(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeExportBringupDetailReportResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleExportBringupValidationReportRequest handles exportBringupValidationReport operation.
//
// Returns the bringup report for a validation. Reports are generated in PDF format.
//
// GET /v1/sddcs/validations/{validationId}/report
func (s *Server) handleExportBringupValidationReportRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ExportBringupValidationReport",
			ID:   "exportBringupValidationReport",
		}
	)
	params, err := decodeExportBringupValidationReportParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ExportBringupValidationReportRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ExportBringupValidationReport",
			OperationSummary: "Get validation report by ID",
			OperationID:      "exportBringupValidationReport",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "validationId",
					In:   "path",
				}: params.ValidationId,
				{
					Name: "startTime",
					In:   "query",
				}: params.StartTime,
				{
					Name: "curClientTime",
					In:   "query",
				}: params.CurClientTime,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ExportBringupValidationReportParams
			Response = ExportBringupValidationReportRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackExportBringupValidationReportParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ExportBringupValidationReport(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ExportBringupValidationReport(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeExportBringupValidationReportResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGenerateCertificatesRequest handles generateCertificates operation.
//
// Generate certificate(s) for the selected resource(s) in a domain. CA must be configured and CSR
// must be generated beforehand.
//
// PUT /v1/domains/{id}/certificates
func (s *Server) handleGenerateCertificatesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GenerateCertificates",
			ID:   "generateCertificates",
		}
	)
	params, err := decodeGenerateCertificatesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGenerateCertificatesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GenerateCertificatesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GenerateCertificates",
			OperationSummary: "Request the creation of signed certificate for resources of a domain",
			OperationID:      "generateCertificates",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *CertificatesGenerationSpec
			Params   = GenerateCertificatesParams
			Response = GenerateCertificatesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGenerateCertificatesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GenerateCertificates(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GenerateCertificates(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGenerateCertificatesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGenerateSyncClientTokenRequest handles generateSyncClientToken operation.
//
// Generates a new sync client token.
//
// POST /v1/identity-providers/{id}/sync-client
func (s *Server) handleGenerateSyncClientTokenRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GenerateSyncClientToken",
			ID:   "generateSyncClientToken",
		}
	)
	params, err := decodeGenerateSyncClientTokenParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GenerateSyncClientTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GenerateSyncClientToken",
			OperationSummary: "Generate new sync client token",
			OperationID:      "generateSyncClientToken",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "syncClientTokenTTL",
					In:   "query",
				}: params.SyncClientTokenTTL,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GenerateSyncClientTokenParams
			Response = GenerateSyncClientTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGenerateSyncClientTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GenerateSyncClientToken(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GenerateSyncClientToken(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGenerateSyncClientTokenResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGeneratesCSRsRequest handles generatesCSRs operation.
//
// Generate CSR(s) for the selected resource(s) in the domain.
// *Warning:*
// _Avoid using wildcard certificates. Instead, use subdomain-specific certificates that are rotated
// often. A compromised wildcard certificate can lead to security repercussions_.
//
// PUT /v1/domains/{id}/csrs
func (s *Server) handleGeneratesCSRsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GeneratesCSRs",
			ID:   "generatesCSRs",
		}
	)
	params, err := decodeGeneratesCSRsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGeneratesCSRsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GeneratesCSRsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GeneratesCSRs",
			OperationSummary: "Request the creation of certificate signing request (CSR) files for resources of a domain",
			OperationID:      "generatesCSRs",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *CsrsGenerationSpec
			Params   = GeneratesCSRsParams
			Response = GeneratesCSRsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGeneratesCSRsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GeneratesCSRs(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GeneratesCSRs(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGeneratesCSRsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetALBClusterRequest handles getALBCluster operation.
//
// Retrieve an NSX ALB Cluster by its ID.
//
// GET /v1/nsx-alb-clusters/{id}
func (s *Server) handleGetALBClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetALBCluster",
			ID:   "getALBCluster",
		}
	)
	params, err := decodeGetALBClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetALBClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetALBCluster",
			OperationSummary: "Retrieve an NSX ALB Cluster by its ID",
			OperationID:      "getALBCluster",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetALBClusterParams
			Response = GetALBClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetALBClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetALBCluster(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetALBCluster(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetALBClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetALBClustersRequest handles getALBClusters operation.
//
// Retrieve a list of NSX ALB Clusters.
//
// GET /v1/nsx-alb-clusters
func (s *Server) handleGetALBClustersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetALBClusters",
			ID:   "getALBClusters",
		}
	)
	params, err := decodeGetALBClustersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetALBClustersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetALBClusters",
			OperationSummary: "Retrieve a list of NSX ALB Clusters",
			OperationID:      "getALBClusters",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "query",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetALBClustersParams
			Response = GetALBClustersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetALBClustersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetALBClusters(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetALBClusters(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetALBClustersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetALBClustersFormFactorsRequest handles getALBClustersFormFactors operation.
//
// Retrieve a list of NSX ALB Clusters Form Factors.
//
// GET /v1/nsx-alb-clusters/form-factors
func (s *Server) handleGetALBClustersFormFactorsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetALBClustersFormFactorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetALBClustersFormFactors",
			OperationSummary: "Retrieve a list of NSX ALB Clusters Form Factors",
			OperationID:      "getALBClustersFormFactors",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetALBClustersFormFactorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetALBClustersFormFactors(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetALBClustersFormFactors(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetALBClustersFormFactorsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAssignableTagForHostRequest handles getAssignableTagForHost operation.
//
// Get tags assignable to a host.
//
// GET /v1/hosts/{id}/tags/assignable-tags
func (s *Server) handleGetAssignableTagForHostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAssignableTagForHost",
			ID:   "getAssignableTagForHost",
		}
	)
	params, err := decodeGetAssignableTagForHostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAssignableTagForHostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAssignableTagForHost",
			OperationSummary: "",
			OperationID:      "getAssignableTagForHost",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAssignableTagForHostParams
			Response = GetAssignableTagForHostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAssignableTagForHostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAssignableTagForHost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAssignableTagForHost(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAssignableTagForHostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAssignableTagsForDomainRequest handles getAssignableTagsForDomain operation.
//
// Get tags assignable to a domain.
//
// GET /v1/domains/{id}/tags/assignable-tags
func (s *Server) handleGetAssignableTagsForDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAssignableTagsForDomain",
			ID:   "getAssignableTagsForDomain",
		}
	)
	params, err := decodeGetAssignableTagsForDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAssignableTagsForDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAssignableTagsForDomain",
			OperationSummary: "Get tags assignable to a domain",
			OperationID:      "getAssignableTagsForDomain",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAssignableTagsForDomainParams
			Response = GetAssignableTagsForDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAssignableTagsForDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAssignableTagsForDomain(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAssignableTagsForDomain(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAssignableTagsForDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAvnsRequest handles getAvns operation.
//
// Returns all matching AVNs.
//
// GET /v1/avns
func (s *Server) handleGetAvnsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAvns",
			ID:   "getAvns",
		}
	)
	params, err := decodeGetAvnsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAvnsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAvns",
			OperationSummary: "Retrieve Application Virtual Network (AVN) details",
			OperationID:      "getAvns",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "regionType",
					In:   "query",
				}: params.RegionType,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAvnsParams
			Response = GetAvnsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAvnsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAvns(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAvns(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAvnsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBackupConfigurationRequest handles getBackupConfiguration operation.
//
// Retrieve the backup configuration for SDDC Manager and NSX Manager.
//
// GET /v1/system/backup-configuration
func (s *Server) handleGetBackupConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetBackupConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBackupConfiguration",
			OperationSummary: "Retrieve the backup configuration for SDDC Manager and NSX Manager",
			OperationID:      "getBackupConfiguration",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetBackupConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBackupConfiguration(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBackupConfiguration(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBackupConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBackupLocationRequest handles getBackupLocation operation.
//
// Retrieve the backup location details.
//
// GET /v1/system/backup-configuration/backup-locations
func (s *Server) handleGetBackupLocationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBackupLocation",
			ID:   "getBackupLocation",
		}
	)
	params, err := decodeGetBackupLocationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBackupLocationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBackupLocation",
			OperationSummary: "Retrieve the backup location details",
			OperationID:      "getBackupLocation",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "serverIP",
					In:   "query",
				}: params.ServerIP,
				{
					Name: "port",
					In:   "query",
				}: params.Port,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBackupLocationParams
			Response = GetBackupLocationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBackupLocationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBackupLocation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBackupLocation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBackupLocationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBringupAppInfoRequest handles getBringupAppInfo operation.
//
// GET Method to retrieve information about Bringup app.
//
// GET /v1/sddcs/about
func (s *Server) handleGetBringupAppInfoRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetBringupAppInfoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBringupAppInfo",
			OperationSummary: "Get information about the bringup application",
			OperationID:      "getBringupAppInfo",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetBringupAppInfoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBringupAppInfo(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBringupAppInfo(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBringupAppInfoResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBringupTaskByIDRequest handles getBringupTaskByID operation.
//
// Get a bringup task by its id.
//
// GET /v1/sddcs/{id}
func (s *Server) handleGetBringupTaskByIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBringupTaskByID",
			ID:   "getBringupTaskByID",
		}
	)
	params, err := decodeGetBringupTaskByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBringupTaskByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBringupTaskByID",
			OperationSummary: "Get a bringup task by its id",
			OperationID:      "getBringupTaskByID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBringupTaskByIDParams
			Response = GetBringupTaskByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBringupTaskByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBringupTaskByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBringupTaskByID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBringupTaskByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBringupTasksRequest handles getBringupTasks operation.
//
// Retrieve all bringup tasks.
//
// GET /v1/sddcs
func (s *Server) handleGetBringupTasksRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetBringupTasksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBringupTasks",
			OperationSummary: "Retrieve all bringup tasks",
			OperationID:      "getBringupTasks",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetBringupTasksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBringupTasks(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBringupTasks(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBringupTasksResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBringupValidationRequest handles getBringupValidation operation.
//
// Retrieve the results of a bringup validation by its ID.
//
// GET /v1/sddcs/validations/{id}
func (s *Server) handleGetBringupValidationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBringupValidation",
			ID:   "getBringupValidation",
		}
	)
	params, err := decodeGetBringupValidationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBringupValidationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBringupValidation",
			OperationSummary: "Retrieve the results of a bringup validation by its ID",
			OperationID:      "getBringupValidation",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBringupValidationParams
			Response = GetBringupValidationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBringupValidationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBringupValidation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBringupValidation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBringupValidationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBringupValidationsRequest handles getBringupValidations operation.
//
// Retrieve a list of bringup validations.
//
// GET /v1/sddcs/validations
func (s *Server) handleGetBringupValidationsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetBringupValidationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBringupValidations",
			OperationSummary: "Retrieve a list of bringup validations",
			OperationID:      "getBringupValidations",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetBringupValidationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBringupValidations(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBringupValidations(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBringupValidationsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBundleRequest handles getBundle operation.
//
// Get a Bundle.
//
// GET /v1/bundles/{id}
func (s *Server) handleGetBundleRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBundle",
			ID:   "getBundle",
		}
	)
	params, err := decodeGetBundleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBundleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBundle",
			OperationSummary: "Retrieve a bundle by its ID",
			OperationID:      "getBundle",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBundleParams
			Response = GetBundleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBundleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBundle(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBundle(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBundleResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBundlesRequest handles getBundles operation.
//
// Get all Bundles i.e uploaded bundles and also bundles available via depot access.
//
// GET /v1/bundles
func (s *Server) handleGetBundlesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBundles",
			ID:   "getBundles",
		}
	)
	params, err := decodeGetBundlesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBundlesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBundles",
			OperationSummary: "Retrieve a list of bundles",
			OperationID:      "getBundles",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "productType",
					In:   "query",
				}: params.ProductType,
				{
					Name: "isCompliant",
					In:   "query",
				}: params.IsCompliant,
				{
					Name: "bundleType",
					In:   "query",
				}: params.BundleType,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBundlesParams
			Response = GetBundlesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBundlesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBundles(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBundles(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBundlesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBundlesForSkipUpgradeRequest handles getBundlesForSkipUpgrade operation.
//
// Get bundles for skip upgrade a domain from current version to target version.
//
// GET /v1/bundles/domains/{id}
func (s *Server) handleGetBundlesForSkipUpgradeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBundlesForSkipUpgrade",
			ID:   "getBundlesForSkipUpgrade",
		}
	)
	params, err := decodeGetBundlesForSkipUpgradeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBundlesForSkipUpgradeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBundlesForSkipUpgrade",
			OperationSummary: "Retrieve a list of bundles for skip upgrade by domain ID",
			OperationID:      "getBundlesForSkipUpgrade",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "targetVersion",
					In:   "query",
				}: params.TargetVersion,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBundlesForSkipUpgradeParams
			Response = GetBundlesForSkipUpgradeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBundlesForSkipUpgradeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBundlesForSkipUpgrade(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBundlesForSkipUpgrade(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBundlesForSkipUpgradeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCSRsRequest handles getCSRs operation.
//
// Get available CSR(s) in json format.
//
// GET /v1/domains/{id}/csrs
func (s *Server) handleGetCSRsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCSRs",
			ID:   "getCSRs",
		}
	)
	params, err := decodeGetCSRsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCSRsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCSRs",
			OperationSummary: "Request available CSR(s) in JSON format for a domain",
			OperationID:      "getCSRs",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCSRsParams
			Response = GetCSRsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCSRsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCSRs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCSRs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCSRsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCeipStatusRequest handles getCeipStatus operation.
//
// Get CEIP status and instance id.
//
// GET /v1/system/ceip
func (s *Server) handleGetCeipStatusRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetCeipStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCeipStatus",
			OperationSummary: "Retrieve the CEIP status",
			OperationID:      "getCeipStatus",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCeipStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCeipStatus(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCeipStatus(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCeipStatusResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCertificateAuthoritiesRequest handles getCertificateAuthorities operation.
//
// Get certificate authorities information.
//
// GET /v1/certificate-authorities
func (s *Server) handleGetCertificateAuthoritiesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetCertificateAuthoritiesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCertificateAuthorities",
			OperationSummary: "Retrieve a list of Certificate Authorities",
			OperationID:      "getCertificateAuthorities",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCertificateAuthoritiesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCertificateAuthorities(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCertificateAuthorities(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCertificateAuthoritiesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCertificateAuthorityByIdRequest handles getCertificateAuthorityById operation.
//
// Get certificate authority information.
//
// GET /v1/certificate-authorities/{id}
func (s *Server) handleGetCertificateAuthorityByIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCertificateAuthorityById",
			ID:   "getCertificateAuthorityById",
		}
	)
	params, err := decodeGetCertificateAuthorityByIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCertificateAuthorityByIdRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCertificateAuthorityById",
			OperationSummary: "Retrieve the details of a Certificate Authority by ID",
			OperationID:      "getCertificateAuthorityById",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCertificateAuthorityByIdParams
			Response = GetCertificateAuthorityByIdRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCertificateAuthorityByIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCertificateAuthorityById(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCertificateAuthorityById(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCertificateAuthorityByIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCertificatesByDomainRequest handles getCertificatesByDomain operation.
//
// View detailed metadata about the certificate(s) of all the resources in a domain.
//
// GET /v1/domains/{id}/resource-certificates
func (s *Server) handleGetCertificatesByDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCertificatesByDomain",
			ID:   "getCertificatesByDomain",
		}
	)
	params, err := decodeGetCertificatesByDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCertificatesByDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCertificatesByDomain",
			OperationSummary: "Retrieve the certificate details for all resources in a domain",
			OperationID:      "getCertificatesByDomain",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCertificatesByDomainParams
			Response = GetCertificatesByDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCertificatesByDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCertificatesByDomain(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCertificatesByDomain(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCertificatesByDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClusterRequest handles getCluster operation.
//
// Get a cluster by its ID.
//
// GET /v1/clusters/{id}
func (s *Server) handleGetClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCluster",
			ID:   "getCluster",
		}
	)
	params, err := decodeGetClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCluster",
			OperationSummary: "Get a cluster by its ID",
			OperationID:      "getCluster",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetClusterParams
			Response = GetClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCluster(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCluster(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClusterCreateValidationRequest handles getClusterCreateValidation operation.
//
// Gets the status of given cluster create validation workflow by given validation id.
//
// GET /v1/clusters/validations/{id}
func (s *Server) handleGetClusterCreateValidationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetClusterCreateValidation",
			ID:   "getClusterCreateValidation",
		}
	)
	params, err := decodeGetClusterCreateValidationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetClusterCreateValidationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetClusterCreateValidation",
			OperationSummary: "Get the status of the validations for cluster deployment",
			OperationID:      "getClusterCreateValidation",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetClusterCreateValidationParams
			Response = GetClusterCreateValidationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClusterCreateValidationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetClusterCreateValidation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetClusterCreateValidation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClusterCreateValidationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClusterCriteriaRequest handles getClusterCriteria operation.
//
// Get all cluster criteria.
//
// GET /v1/domains/{domainId}/clusters/criteria
func (s *Server) handleGetClusterCriteriaRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetClusterCriteria",
			ID:   "getClusterCriteria",
		}
	)
	params, err := decodeGetClusterCriteriaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PageOfClusterCriterion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetClusterCriteria",
			OperationSummary: "Get all cluster criteria",
			OperationID:      "getClusterCriteria",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetClusterCriteriaParams
			Response = *PageOfClusterCriterion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClusterCriteriaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetClusterCriteria(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetClusterCriteria(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClusterCriteriaResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClusterCriterionRequest handles getClusterCriterion operation.
//
// Get a criterion to query for cluster.
//
// GET /v1/domains/{domainId}/clusters/criteria/{name}
func (s *Server) handleGetClusterCriterionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetClusterCriterion",
			ID:   "getClusterCriterion",
		}
	)
	params, err := decodeGetClusterCriterionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetClusterCriterionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetClusterCriterion",
			OperationSummary: "Get a criterion to query for cluster",
			OperationID:      "getClusterCriterion",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetClusterCriterionParams
			Response = GetClusterCriterionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClusterCriterionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetClusterCriterion(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetClusterCriterion(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClusterCriterionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClusterDatastoresRequest handles getClusterDatastores operation.
//
// Get the list of all datastores associated with the cluster.
//
// GET /v1/clusters/{id}/datastores
func (s *Server) handleGetClusterDatastoresRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetClusterDatastores",
			ID:   "getClusterDatastores",
		}
	)
	params, err := decodeGetClusterDatastoresParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetClusterDatastoresRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetClusterDatastores",
			OperationSummary: "Get the list of all datastores associated with the cluster.",
			OperationID:      "getClusterDatastores",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetClusterDatastoresParams
			Response = GetClusterDatastoresRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClusterDatastoresParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetClusterDatastores(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetClusterDatastores(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClusterDatastoresResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClusterNetworkConfigurationRequest handles getClusterNetworkConfiguration operation.
//
// Get cluster network configuration.
//
// POST /v1/clusters/{id}/network/queries
func (s *Server) handleGetClusterNetworkConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetClusterNetworkConfiguration",
			ID:   "getClusterNetworkConfiguration",
		}
	)
	params, err := decodeGetClusterNetworkConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGetClusterNetworkConfigurationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GetClusterNetworkConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetClusterNetworkConfiguration",
			OperationSummary: "Get cluster network configuration",
			OperationID:      "getClusterNetworkConfiguration",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *ClusterNetworkConfigurationCriterion
			Params   = GetClusterNetworkConfigurationParams
			Response = GetClusterNetworkConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClusterNetworkConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetClusterNetworkConfiguration(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetClusterNetworkConfiguration(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClusterNetworkConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClusterNetworkConfigurationQueryResponseRequest handles getClusterNetworkConfigurationQueryResponse operation.
//
// The response retrieved is only applicable for pure L2 domain clusters.
//
// GET /v1/clusters/{id}/network/queries/{queryId}
func (s *Server) handleGetClusterNetworkConfigurationQueryResponseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetClusterNetworkConfigurationQueryResponse",
			ID:   "getClusterNetworkConfigurationQueryResponse",
		}
	)
	params, err := decodeGetClusterNetworkConfigurationQueryResponseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetClusterNetworkConfigurationQueryResponseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetClusterNetworkConfigurationQueryResponse",
			OperationSummary: "Get cluster network configuration query response",
			OperationID:      "getClusterNetworkConfigurationQueryResponse",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "queryId",
					In:   "path",
				}: params.QueryId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetClusterNetworkConfigurationQueryResponseParams
			Response = GetClusterNetworkConfigurationQueryResponseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClusterNetworkConfigurationQueryResponseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetClusterNetworkConfigurationQueryResponse(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetClusterNetworkConfigurationQueryResponse(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClusterNetworkConfigurationQueryResponseResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClusterQueryResponseRequest handles getClusterQueryResponse operation.
//
// Get cluster query response.
//
// GET /v1/domains/{domainId}/clusters/{clusterName}/queries/{queryId}
func (s *Server) handleGetClusterQueryResponseRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetClusterQueryResponse",
			ID:   "getClusterQueryResponse",
		}
	)
	params, err := decodeGetClusterQueryResponseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetClusterQueryResponseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetClusterQueryResponse",
			OperationSummary: "Get cluster query response",
			OperationID:      "getClusterQueryResponse",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "clusterName",
					In:   "path",
				}: params.ClusterName,
				{
					Name: "queryId",
					In:   "path",
				}: params.QueryId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetClusterQueryResponseParams
			Response = GetClusterQueryResponseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClusterQueryResponseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetClusterQueryResponse(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetClusterQueryResponse(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClusterQueryResponseResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClusterTagManagerUrlRequest handles getClusterTagManagerUrl operation.
//
// Get Cluster Tag Manager Url.
//
// GET /v1/clusters/{id}/tags/tag-manager
func (s *Server) handleGetClusterTagManagerUrlRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetClusterTagManagerUrl",
			ID:   "getClusterTagManagerUrl",
		}
	)
	params, err := decodeGetClusterTagManagerUrlParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetClusterTagManagerUrlRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetClusterTagManagerUrl",
			OperationSummary: "Get Cluster Tag Manager Url",
			OperationID:      "getClusterTagManagerUrl",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetClusterTagManagerUrlParams
			Response = GetClusterTagManagerUrlRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClusterTagManagerUrlParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetClusterTagManagerUrl(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetClusterTagManagerUrl(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClusterTagManagerUrlResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClusterUpdateValidationRequest handles getClusterUpdateValidation operation.
//
// Gets the status of given cluster updates validation workflow by given validation id.
//
// GET /v1/clusters/{id}/validations/{validationId}
func (s *Server) handleGetClusterUpdateValidationRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetClusterUpdateValidation",
			ID:   "getClusterUpdateValidation",
		}
	)
	params, err := decodeGetClusterUpdateValidationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetClusterUpdateValidationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetClusterUpdateValidation",
			OperationSummary: "Get the status of the validations for cluster updates",
			OperationID:      "getClusterUpdateValidation",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "validationId",
					In:   "path",
				}: params.ValidationId,
				{
					Name: "useAsyncValidation",
					In:   "query",
				}: params.UseAsyncValidation,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetClusterUpdateValidationParams
			Response = GetClusterUpdateValidationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClusterUpdateValidationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetClusterUpdateValidation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetClusterUpdateValidation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClusterUpdateValidationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClustersRequest handles getClusters operation.
//
// Retrieve a list of clusters.
//
// GET /v1/clusters
func (s *Server) handleGetClustersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetClusters",
			ID:   "getClusters",
		}
	)
	params, err := decodeGetClustersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetClustersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetClusters",
			OperationSummary: "Retrieve a list of clusters",
			OperationID:      "getClusters",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "isStretched",
					In:   "query",
				}: params.IsStretched,
				{
					Name: "isImageBased",
					In:   "query",
				}: params.IsImageBased,
				{
					Name: "domainId",
					In:   "query",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetClustersParams
			Response = GetClustersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClustersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetClusters(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetClusters(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClustersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetClustersQueryResponseRequest handles getClustersQueryResponse operation.
//
// Get clusters query response.
//
// GET /v1/domains/{domainId}/clusters/queries/{queryId}
func (s *Server) handleGetClustersQueryResponseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetClustersQueryResponse",
			ID:   "getClustersQueryResponse",
		}
	)
	params, err := decodeGetClustersQueryResponseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetClustersQueryResponseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetClustersQueryResponse",
			OperationSummary: "Get clusters query response",
			OperationID:      "getClustersQueryResponse",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "queryId",
					In:   "path",
				}: params.QueryId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetClustersQueryResponseParams
			Response = GetClustersQueryResponseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetClustersQueryResponseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetClustersQueryResponse(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetClustersQueryResponse(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetClustersQueryResponseResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCompatibilityMatricesRequest handles getCompatibilityMatrices operation.
//
// Get Compatibility Matrices.
//
// GET /v1/compatibility-matrices
func (s *Server) handleGetCompatibilityMatricesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetCompatibilityMatricesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCompatibilityMatrices",
			OperationSummary: "Get Compatibility Matrices",
			OperationID:      "getCompatibilityMatrices",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCompatibilityMatricesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCompatibilityMatrices(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCompatibilityMatrices(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCompatibilityMatricesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCompatibilityMatrixRequest handles getCompatibilityMatrix operation.
//
// Get Compatibility Matrix.
//
// GET /v1/compatibility-matrices/{compatibilityMatrixSource}
func (s *Server) handleGetCompatibilityMatrixRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCompatibilityMatrix",
			ID:   "getCompatibilityMatrix",
		}
	)
	params, err := decodeGetCompatibilityMatrixParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCompatibilityMatrixRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCompatibilityMatrix",
			OperationSummary: "Get Compatibility Matrix",
			OperationID:      "getCompatibilityMatrix",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "compatibilityMatrixSource",
					In:   "path",
				}: params.CompatibilityMatrixSource,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCompatibilityMatrixParams
			Response = GetCompatibilityMatrixRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCompatibilityMatrixParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCompatibilityMatrix(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCompatibilityMatrix(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCompatibilityMatrixResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCompatibilityMatrixContentRequest handles getCompatibilityMatrixContent operation.
//
// Get Compatibility Matrix content.
//
// GET /v1/compatibility-matrices/{compatibilityMatrixSource}/content
func (s *Server) handleGetCompatibilityMatrixContentRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCompatibilityMatrixContent",
			ID:   "getCompatibilityMatrixContent",
		}
	)
	params, err := decodeGetCompatibilityMatrixContentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCompatibilityMatrixContentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCompatibilityMatrixContent",
			OperationSummary: "Get Compatibility Matrix content",
			OperationID:      "getCompatibilityMatrixContent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "compatibilityMatrixSource",
					In:   "path",
				}: params.CompatibilityMatrixSource,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCompatibilityMatrixContentParams
			Response = GetCompatibilityMatrixContentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCompatibilityMatrixContentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCompatibilityMatrixContent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCompatibilityMatrixContent(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCompatibilityMatrixContentResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCompatibilityMatrixMetadataRequest handles getCompatibilityMatrixMetadata operation.
//
// Get Compatibility Matrix Metadata.
//
// GET /v1/compatibility-matrices/{compatibilityMatrixSource}/metadata
func (s *Server) handleGetCompatibilityMatrixMetadataRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCompatibilityMatrixMetadata",
			ID:   "getCompatibilityMatrixMetadata",
		}
	)
	params, err := decodeGetCompatibilityMatrixMetadataParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCompatibilityMatrixMetadataRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCompatibilityMatrixMetadata",
			OperationSummary: "Get Compatibility Matrix Metadata",
			OperationID:      "getCompatibilityMatrixMetadata",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "compatibilityMatrixSource",
					In:   "path",
				}: params.CompatibilityMatrixSource,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCompatibilityMatrixMetadataParams
			Response = GetCompatibilityMatrixMetadataRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCompatibilityMatrixMetadataParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCompatibilityMatrixMetadata(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCompatibilityMatrixMetadata(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCompatibilityMatrixMetadataResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetComplianceAuditRequest handles getComplianceAudit operation.
//
// Get compliance audit.
//
// GET /v1/compliance-audits/{complianceAuditId}
func (s *Server) handleGetComplianceAuditRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetComplianceAudit",
			ID:   "getComplianceAudit",
		}
	)
	params, err := decodeGetComplianceAuditParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetComplianceAuditRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetComplianceAudit",
			OperationSummary: "Get compliance audit",
			OperationID:      "getComplianceAudit",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "complianceAuditId",
					In:   "path",
				}: params.ComplianceAuditId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetComplianceAuditParams
			Response = GetComplianceAuditRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetComplianceAuditParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetComplianceAudit(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetComplianceAudit(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetComplianceAuditResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetComplianceAuditForADomainRequest handles getComplianceAuditForADomain operation.
//
// Get compliance audit for a domain.
//
// GET /v1/domains/{id}/compliance-audits/{complianceAuditId}
func (s *Server) handleGetComplianceAuditForADomainRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetComplianceAuditForADomain",
			ID:   "getComplianceAuditForADomain",
		}
	)
	params, err := decodeGetComplianceAuditForADomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetComplianceAuditForADomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetComplianceAuditForADomain",
			OperationSummary: "Get compliance audit for a domain",
			OperationID:      "getComplianceAuditForADomain",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "complianceAuditId",
					In:   "path",
				}: params.ComplianceAuditId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetComplianceAuditForADomainParams
			Response = GetComplianceAuditForADomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetComplianceAuditForADomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetComplianceAuditForADomain(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetComplianceAuditForADomain(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetComplianceAuditForADomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetComplianceAuditHistoryRequest handles getComplianceAuditHistory operation.
//
// Get compliance audit history.
//
// GET /v1/compliance-audits
func (s *Server) handleGetComplianceAuditHistoryRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetComplianceAuditHistoryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetComplianceAuditHistory",
			OperationSummary: "Get compliance audit history",
			OperationID:      "getComplianceAuditHistory",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetComplianceAuditHistoryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetComplianceAuditHistory(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetComplianceAuditHistory(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetComplianceAuditHistoryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetComplianceAuditHistoryForADomainRequest handles getComplianceAuditHistoryForADomain operation.
//
// Get compliance audit history for a domain.
//
// GET /v1/domains/{id}/compliance-audits
func (s *Server) handleGetComplianceAuditHistoryForADomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetComplianceAuditHistoryForADomain",
			ID:   "getComplianceAuditHistoryForADomain",
		}
	)
	params, err := decodeGetComplianceAuditHistoryForADomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetComplianceAuditHistoryForADomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetComplianceAuditHistoryForADomain",
			OperationSummary: "Get compliance audit history for a domain",
			OperationID:      "getComplianceAuditHistoryForADomain",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetComplianceAuditHistoryForADomainParams
			Response = GetComplianceAuditHistoryForADomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetComplianceAuditHistoryForADomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetComplianceAuditHistoryForADomain(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetComplianceAuditHistoryForADomain(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetComplianceAuditHistoryForADomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetComplianceAuditItemsRequest handles getComplianceAuditItems operation.
//
// Get compliance audit items.
//
// GET /v1/compliance-audits/{complianceAuditId}/compliance-audit-items
func (s *Server) handleGetComplianceAuditItemsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetComplianceAuditItems",
			ID:   "getComplianceAuditItems",
		}
	)
	params, err := decodeGetComplianceAuditItemsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetComplianceAuditItemsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetComplianceAuditItems",
			OperationSummary: "Get compliance audit items",
			OperationID:      "getComplianceAuditItems",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "complianceAuditId",
					In:   "path",
				}: params.ComplianceAuditId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetComplianceAuditItemsParams
			Response = GetComplianceAuditItemsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetComplianceAuditItemsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetComplianceAuditItems(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetComplianceAuditItems(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetComplianceAuditItemsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetComplianceAuditItemsForADomainRequest handles getComplianceAuditItemsForADomain operation.
//
// Get compliance audit items for a domain.
//
// GET /v1/domains/{id}/compliance-audits/{complianceAuditId}/compliance-audit-items
func (s *Server) handleGetComplianceAuditItemsForADomainRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetComplianceAuditItemsForADomain",
			ID:   "getComplianceAuditItemsForADomain",
		}
	)
	params, err := decodeGetComplianceAuditItemsForADomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetComplianceAuditItemsForADomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetComplianceAuditItemsForADomain",
			OperationSummary: "Get compliance audit items for a domain",
			OperationID:      "getComplianceAuditItemsForADomain",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "complianceAuditId",
					In:   "path",
				}: params.ComplianceAuditId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetComplianceAuditItemsForADomainParams
			Response = GetComplianceAuditItemsForADomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetComplianceAuditItemsForADomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetComplianceAuditItemsForADomain(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetComplianceAuditItemsForADomain(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetComplianceAuditItemsForADomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetComplianceAuditTaskRequest handles getComplianceAuditTask operation.
//
// Get compliance audit task.
//
// GET /v1/domains/{id}/compliance-audits/tasks/{taskId}
func (s *Server) handleGetComplianceAuditTaskRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetComplianceAuditTask",
			ID:   "getComplianceAuditTask",
		}
	)
	params, err := decodeGetComplianceAuditTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetComplianceAuditTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetComplianceAuditTask",
			OperationSummary: "Get compliance audit task",
			OperationID:      "getComplianceAuditTask",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetComplianceAuditTaskParams
			Response = GetComplianceAuditTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetComplianceAuditTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetComplianceAuditTask(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetComplianceAuditTask(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetComplianceAuditTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetComplianceConfigurationsRequest handles getComplianceConfigurations operation.
//
// Get a list of all compliance configurations.
//
// GET /v1/compliance-configurations
func (s *Server) handleGetComplianceConfigurationsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetComplianceConfigurations",
			ID:   "getComplianceConfigurations",
		}
	)
	params, err := decodeGetComplianceConfigurationsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetComplianceConfigurationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetComplianceConfigurations",
			OperationSummary: "Get all compliance configurations",
			OperationID:      "getComplianceConfigurations",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "standardType",
					In:   "query",
				}: params.StandardType,
				{
					Name: "standardVersion",
					In:   "query",
				}: params.StandardVersion,
				{
					Name: "resourceType",
					In:   "query",
				}: params.ResourceType,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetComplianceConfigurationsParams
			Response = GetComplianceConfigurationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetComplianceConfigurationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetComplianceConfigurations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetComplianceConfigurations(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetComplianceConfigurationsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetComplianceStandardsRequest handles getComplianceStandards operation.
//
// Get a list of all compliance standards.
//
// GET /v1/compliance-standards
func (s *Server) handleGetComplianceStandardsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetComplianceStandardsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetComplianceStandards",
			OperationSummary: "Get all compliance standards",
			OperationID:      "getComplianceStandards",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetComplianceStandardsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetComplianceStandards(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetComplianceStandards(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetComplianceStandardsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetConfigsRequest handles getConfigs operation.
//
// Get configs associated with the given criteria, all if no criteria is provided.
//
// GET /v1/config-drifts
func (s *Server) handleGetConfigsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetConfigs",
			ID:   "getConfigs",
		}
	)
	params, err := decodeGetConfigsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetConfigsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetConfigs",
			OperationSummary: "Get configs associated with the given criteria",
			OperationID:      "getConfigs",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "resourceId",
					In:   "query",
				}: params.ResourceId,
				{
					Name: "resourceType",
					In:   "query",
				}: params.ResourceType,
				{
					Name: "configId",
					In:   "query",
				}: params.ConfigId,
				{
					Name: "driftType",
					In:   "query",
				}: params.DriftType,
				{
					Name: "size",
					In:   "query",
				}: params.Size,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetConfigsParams
			Response = GetConfigsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetConfigsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetConfigs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetConfigs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetConfigsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCredentialRequest handles getCredential operation.
//
// Retrieve a credential by its ID.
//
// GET /v1/credentials/{id}
func (s *Server) handleGetCredentialRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCredential",
			ID:   "getCredential",
		}
	)
	params, err := decodeGetCredentialParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCredentialRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCredential",
			OperationSummary: "Retrieve a credential by its ID",
			OperationID:      "getCredential",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCredentialParams
			Response = GetCredentialRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCredentialParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCredential(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCredential(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCredentialResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCredentialTaskByResourceIDRequest handles getCredentialTaskByResourceID operation.
//
// Retriece a credential taks by resource ID.
//
// GET /v1/credentials/tasks/{id}/resource-credentials
func (s *Server) handleGetCredentialTaskByResourceIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCredentialTaskByResourceID",
			ID:   "getCredentialTaskByResourceID",
		}
	)
	params, err := decodeGetCredentialTaskByResourceIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCredentialTaskByResourceIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCredentialTaskByResourceID",
			OperationSummary: "Retriece a credential taks by resource ID",
			OperationID:      "getCredentialTaskByResourceID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCredentialTaskByResourceIDParams
			Response = GetCredentialTaskByResourceIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCredentialTaskByResourceIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCredentialTaskByResourceID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCredentialTaskByResourceID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCredentialTaskByResourceIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCredentialsRequest handles getCredentials operation.
//
// Retrieve a list of credentials.
//
// GET /v1/credentials
func (s *Server) handleGetCredentialsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCredentials",
			ID:   "getCredentials",
		}
	)
	params, err := decodeGetCredentialsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCredentialsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCredentials",
			OperationSummary: "Retrieve a list of credentials",
			OperationID:      "getCredentials",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "resourceName",
					In:   "query",
				}: params.ResourceName,
				{
					Name: "resourceIp",
					In:   "query",
				}: params.ResourceIp,
				{
					Name: "resourceType",
					In:   "query",
				}: params.ResourceType,
				{
					Name: "domainName",
					In:   "query",
				}: params.DomainName,
				{
					Name: "pageNumber",
					In:   "query",
				}: params.PageNumber,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
				{
					Name: "accountType",
					In:   "query",
				}: params.AccountType,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCredentialsParams
			Response = GetCredentialsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCredentialsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCredentials(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCredentials(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCredentialsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCredentialsSubTaskRequest handles getCredentialsSubTask operation.
//
// Retrieve a credential sub task by its ID.
//
// GET /v1/credentials/tasks/{id}/subtasks/{subtaskId}
func (s *Server) handleGetCredentialsSubTaskRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCredentialsSubTask",
			ID:   "getCredentialsSubTask",
		}
	)
	params, err := decodeGetCredentialsSubTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCredentialsSubTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCredentialsSubTask",
			OperationSummary: "Retrieve a credential sub task by its ID",
			OperationID:      "getCredentialsSubTask",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "subtaskId",
					In:   "path",
				}: params.SubtaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCredentialsSubTaskParams
			Response = GetCredentialsSubTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCredentialsSubTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCredentialsSubTask(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCredentialsSubTask(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCredentialsSubTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCredentialsTaskRequest handles getCredentialsTask operation.
//
// Retrieve a credential task by ID.
//
// GET /v1/credentials/tasks/{id}
func (s *Server) handleGetCredentialsTaskRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCredentialsTask",
			ID:   "getCredentialsTask",
		}
	)
	params, err := decodeGetCredentialsTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCredentialsTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCredentialsTask",
			OperationSummary: "Retrieve a credential task by ID",
			OperationID:      "getCredentialsTask",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCredentialsTaskParams
			Response = GetCredentialsTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCredentialsTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCredentialsTask(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCredentialsTask(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCredentialsTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCredentialsTasksRequest handles getCredentialsTasks operation.
//
// Retrieve a list of credential tasks.
//
// GET /v1/credentials/tasks
func (s *Server) handleGetCredentialsTasksRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCredentialsTasks",
			ID:   "getCredentialsTasks",
		}
	)
	params, err := decodeGetCredentialsTasksParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCredentialsTasksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCredentialsTasks",
			OperationSummary: "Retrieve a list of credential tasks",
			OperationID:      "getCredentialsTasks",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCredentialsTasksParams
			Response = GetCredentialsTasksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCredentialsTasksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCredentialsTasks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCredentialsTasks(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCredentialsTasksResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCriteriaRequest handles getCriteria operation.
//
// Get all criteria.
//
// GET /v1/hosts/criteria
func (s *Server) handleGetCriteriaRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response *PageOfHostCriterion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCriteria",
			OperationSummary: "",
			OperationID:      "getCriteria",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *PageOfHostCriterion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCriteria(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCriteria(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCriteriaResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCriterionRequest handles getCriterion operation.
//
// Get a criterion.
//
// GET /v1/hosts/criteria/{name}
func (s *Server) handleGetCriterionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCriterion",
			ID:   "getCriterion",
		}
	)
	params, err := decodeGetCriterionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCriterionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCriterion",
			OperationSummary: "",
			OperationID:      "getCriterion",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCriterionParams
			Response = GetCriterionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCriterionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCriterion(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCriterion(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCriterionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCustomIsoByIdRequest handles getCustomIsoById operation.
//
// Get the Custom ISO based matching the ID.
//
// GET /v1/custom-isos/{custom_iso_id}
func (s *Server) handleGetCustomIsoByIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCustomIsoById",
			ID:   "getCustomIsoById",
		}
	)
	params, err := decodeGetCustomIsoByIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCustomIsoByIdRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCustomIsoById",
			OperationSummary: "Get the Custom ISO based on ID",
			OperationID:      "getCustomIsoById",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "custom_iso_id",
					In:   "path",
				}: params.CustomIsoID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCustomIsoByIdParams
			Response = GetCustomIsoByIdRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCustomIsoByIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCustomIsoById(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCustomIsoById(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCustomIsoByIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCustomIsosRequest handles getCustomIsos operation.
//
// Get all Custom ISOs or Custom ISOs that match specified parameters.
//
// GET /v1/custom-isos
func (s *Server) handleGetCustomIsosRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCustomIsos",
			ID:   "getCustomIsos",
		}
	)
	params, err := decodeGetCustomIsosParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCustomIsosRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCustomIsos",
			OperationSummary: "Get the Custom ISOs",
			OperationID:      "getCustomIsos",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "query",
				}: params.Name,
				{
					Name: "vendor",
					In:   "query",
				}: params.Vendor,
				{
					Name: "domainId",
					In:   "query",
				}: params.DomainId,
				{
					Name: "targetVersion",
					In:   "query",
				}: params.TargetVersion,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCustomIsosParams
			Response = GetCustomIsosRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCustomIsosParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCustomIsos(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCustomIsos(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCustomIsosResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCustomPatchesRequest handles getCustomPatches operation.
//
// Filter applicable patches (current/target vcf releases) per product type per domain.
//
// GET /v1/releases/domains/{domainId}/custom-patches
func (s *Server) handleGetCustomPatchesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCustomPatches",
			ID:   "getCustomPatches",
		}
	)
	params, err := decodeGetCustomPatchesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *FlexibleProductPatches
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCustomPatches",
			OperationSummary: "Retrieve the list of custom patches for BOM products associated with or applicable on a VCF domain",
			OperationID:      "getCustomPatches",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "vcfRelease",
					In:   "query",
				}: params.VcfRelease,
				{
					Name: "vxrailReleaseVersion",
					In:   "query",
				}: params.VxrailReleaseVersion,
				{
					Name: "productType",
					In:   "query",
				}: params.ProductType,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetCustomPatchesParams
			Response = *FlexibleProductPatches
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetCustomPatchesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCustomPatches(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCustomPatches(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCustomPatchesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDatastoreCriterionRequest handles getDatastoreCriterion operation.
//
// Get a criterion to query for datastore.
//
// GET /v1/domains/{domainId}/datastores/criteria/{name}
func (s *Server) handleGetDatastoreCriterionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDatastoreCriterion",
			ID:   "getDatastoreCriterion",
		}
	)
	params, err := decodeGetDatastoreCriterionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDatastoreCriterionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDatastoreCriterion",
			OperationSummary: "Get a criterion to query for datastore",
			OperationID:      "getDatastoreCriterion",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDatastoreCriterionParams
			Response = GetDatastoreCriterionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDatastoreCriterionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDatastoreCriterion(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDatastoreCriterion(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDatastoreCriterionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDatastoreCriterion1Request handles getDatastoreCriterion_1 operation.
//
// Get a criterion to query for datastore.
//
// GET /v1/clusters/{id}/datastores/criteria/{name}
func (s *Server) handleGetDatastoreCriterion1Request(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDatastoreCriterion1",
			ID:   "getDatastoreCriterion_1",
		}
	)
	params, err := decodeGetDatastoreCriterion1Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDatastoreCriterion1Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDatastoreCriterion1",
			OperationSummary: "Get a criterion to query for datastore",
			OperationID:      "getDatastoreCriterion_1",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDatastoreCriterion1Params
			Response = GetDatastoreCriterion1Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDatastoreCriterion1Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDatastoreCriterion1(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDatastoreCriterion1(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDatastoreCriterion1Response(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDatastoreQueryResponseRequest handles getDatastoreQueryResponse operation.
//
// Get Datastore query response.
//
// GET /v1/domains/{domainId}/datastores/queries/{queryId}
func (s *Server) handleGetDatastoreQueryResponseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDatastoreQueryResponse",
			ID:   "getDatastoreQueryResponse",
		}
	)
	params, err := decodeGetDatastoreQueryResponseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDatastoreQueryResponseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDatastoreQueryResponse",
			OperationSummary: "Get Datastore query response",
			OperationID:      "getDatastoreQueryResponse",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "queryId",
					In:   "path",
				}: params.QueryId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDatastoreQueryResponseParams
			Response = GetDatastoreQueryResponseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDatastoreQueryResponseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDatastoreQueryResponse(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDatastoreQueryResponse(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDatastoreQueryResponseResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDatastoreQueryResponse1Request handles getDatastoreQueryResponse_1 operation.
//
// Get Datastore query response.
//
// GET /v1/clusters/{clusterId}/datastores/queries/{queryId}
func (s *Server) handleGetDatastoreQueryResponse1Request(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDatastoreQueryResponse1",
			ID:   "getDatastoreQueryResponse_1",
		}
	)
	params, err := decodeGetDatastoreQueryResponse1Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDatastoreQueryResponse1Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDatastoreQueryResponse1",
			OperationSummary: "Get Datastore query response",
			OperationID:      "getDatastoreQueryResponse_1",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "clusterId",
					In:   "path",
				}: params.ClusterId,
				{
					Name: "queryId",
					In:   "path",
				}: params.QueryId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDatastoreQueryResponse1Params
			Response = GetDatastoreQueryResponse1Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDatastoreQueryResponse1Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDatastoreQueryResponse1(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDatastoreQueryResponse1(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDatastoreQueryResponse1Response(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDatastoresCriteriaRequest handles getDatastoresCriteria operation.
//
// Get all datastore criteria.
//
// GET /v1/domains/{domainId}/datastores/criteria
func (s *Server) handleGetDatastoresCriteriaRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDatastoresCriteria",
			ID:   "getDatastoresCriteria",
		}
	)
	params, err := decodeGetDatastoresCriteriaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PageOfDatastoreCriterion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDatastoresCriteria",
			OperationSummary: "Get all datastore criteria",
			OperationID:      "getDatastoresCriteria",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDatastoresCriteriaParams
			Response = *PageOfDatastoreCriterion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDatastoresCriteriaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDatastoresCriteria(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDatastoresCriteria(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDatastoresCriteriaResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDatastoresCriteria1Request handles getDatastoresCriteria_1 operation.
//
// Get all datastore criteria.
//
// GET /v1/clusters/{id}/datastores/criteria
func (s *Server) handleGetDatastoresCriteria1Request(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDatastoresCriteria1",
			ID:   "getDatastoresCriteria_1",
		}
	)
	params, err := decodeGetDatastoresCriteria1Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PageOfDatastoreCriterion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDatastoresCriteria1",
			OperationSummary: "Get all datastore criteria",
			OperationID:      "getDatastoresCriteria_1",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDatastoresCriteria1Params
			Response = *PageOfDatastoreCriterion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDatastoresCriteria1Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDatastoresCriteria1(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDatastoresCriteria1(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDatastoresCriteria1Response(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDepotSettingsRequest handles getDepotSettings operation.
//
// Get the depot configuration. In a fresh setup, this would be empty.
//
// GET /v1/system/settings/depot
func (s *Server) handleGetDepotSettingsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetDepotSettingsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDepotSettings",
			OperationSummary: "Retrieve the depot configuration",
			OperationID:      "getDepotSettings",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDepotSettingsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDepotSettings(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDepotSettings(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDepotSettingsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDnsConfigurationRequest handles getDnsConfiguration operation.
//
// Retrieve the DNS configuration.
//
// GET /v1/system/dns-configuration
func (s *Server) handleGetDnsConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetDnsConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDnsConfiguration",
			OperationSummary: "Retrieve the DNS configuration",
			OperationID:      "getDnsConfiguration",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDnsConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDnsConfiguration(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDnsConfiguration(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDnsConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDomainRequest handles getDomain operation.
//
// Get a domain by its ID.
//
// GET /v1/domains/{id}
func (s *Server) handleGetDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDomain",
			ID:   "getDomain",
		}
	)
	params, err := decodeGetDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDomain",
			OperationSummary: "Get a domain by its ID",
			OperationID:      "getDomain",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDomainParams
			Response = GetDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDomain(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDomain(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDomainCertificatesRequest handles getDomainCertificates operation.
//
// Get latest generated certificate(s) in a domain.
//
// GET /v1/domains/{id}/certificates
func (s *Server) handleGetDomainCertificatesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDomainCertificates",
			ID:   "getDomainCertificates",
		}
	)
	params, err := decodeGetDomainCertificatesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDomainCertificatesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDomainCertificates",
			OperationSummary: "Retrieve the latest generated certificates for a domain by its ID",
			OperationID:      "getDomainCertificates",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDomainCertificatesParams
			Response = GetDomainCertificatesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDomainCertificatesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDomainCertificates(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDomainCertificates(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDomainCertificatesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDomainEndpointsRequest handles getDomainEndpoints operation.
//
// Retrieve a list of endpoints or URLs for a domain by its ID.
//
// GET /v1/domains/{id}/endpoints
func (s *Server) handleGetDomainEndpointsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDomainEndpoints",
			ID:   "getDomainEndpoints",
		}
	)
	params, err := decodeGetDomainEndpointsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDomainEndpointsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDomainEndpoints",
			OperationSummary: "Retrieve a list of endpoints or URLs for a domain by its ID",
			OperationID:      "getDomainEndpoints",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDomainEndpointsParams
			Response = GetDomainEndpointsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDomainEndpointsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDomainEndpoints(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDomainEndpoints(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDomainEndpointsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDomainIsolationPrecheckStatusRequest handles getDomainIsolationPrecheckStatus operation.
//
// Get the status of the Domain Isolation Precheck.
//
// GET /v1/domains/{domainId}/isolation-prechecks/{precheckId}
func (s *Server) handleGetDomainIsolationPrecheckStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDomainIsolationPrecheckStatus",
			ID:   "getDomainIsolationPrecheckStatus",
		}
	)
	params, err := decodeGetDomainIsolationPrecheckStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDomainIsolationPrecheckStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDomainIsolationPrecheckStatus",
			OperationSummary: "Get the status of the Domain Isolation Precheck",
			OperationID:      "getDomainIsolationPrecheckStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "precheckId",
					In:   "path",
				}: params.PrecheckId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDomainIsolationPrecheckStatusParams
			Response = GetDomainIsolationPrecheckStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDomainIsolationPrecheckStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDomainIsolationPrecheckStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDomainIsolationPrecheckStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDomainIsolationPrecheckStatusResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDomainReleaseViewValidationRequest handles getDomainReleaseViewValidation operation.
//
// Monitor the progress of domain target state validation task by the validation id.
//
// GET /v1/releases/domains/validations/{validationId}
func (s *Server) handleGetDomainReleaseViewValidationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDomainReleaseViewValidation",
			ID:   "getDomainReleaseViewValidation",
		}
	)
	params, err := decodeGetDomainReleaseViewValidationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDomainReleaseViewValidationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDomainReleaseViewValidation",
			OperationSummary: "Retrieve a domain target state validation by its validation id",
			OperationID:      "getDomainReleaseViewValidation",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "validationId",
					In:   "path",
				}: params.ValidationId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDomainReleaseViewValidationParams
			Response = GetDomainReleaseViewValidationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDomainReleaseViewValidationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDomainReleaseViewValidation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDomainReleaseViewValidation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDomainReleaseViewValidationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDomainTagManagerUrlRequest handles getDomainTagManagerUrl operation.
//
// Get Domain Tag Manager Url.
//
// GET /v1/domains/{id}/tags/tag-manager
func (s *Server) handleGetDomainTagManagerUrlRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDomainTagManagerUrl",
			ID:   "getDomainTagManagerUrl",
		}
	)
	params, err := decodeGetDomainTagManagerUrlParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDomainTagManagerUrlRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDomainTagManagerUrl",
			OperationSummary: "Get Domain Tag Manager Url",
			OperationID:      "getDomainTagManagerUrl",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDomainTagManagerUrlParams
			Response = GetDomainTagManagerUrlRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDomainTagManagerUrlParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDomainTagManagerUrl(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDomainTagManagerUrl(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDomainTagManagerUrlResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDomainUpdateValidationRequest handles getDomainUpdateValidation operation.
//
// Gets the status of given domain update validation workflow by given validation id.
//
// GET /v1/domains/{id}/validations/{validationId}
func (s *Server) handleGetDomainUpdateValidationRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDomainUpdateValidation",
			ID:   "getDomainUpdateValidation",
		}
	)
	params, err := decodeGetDomainUpdateValidationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDomainUpdateValidationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDomainUpdateValidation",
			OperationSummary: "Get the status of the validations for domain related operations",
			OperationID:      "getDomainUpdateValidation",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "validationId",
					In:   "path",
				}: params.ValidationId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDomainUpdateValidationParams
			Response = GetDomainUpdateValidationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDomainUpdateValidationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDomainUpdateValidation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDomainUpdateValidation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDomainUpdateValidationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDomainsRequest handles getDomains operation.
//
// Retrieve a list of domains.
//
// GET /v1/domains
func (s *Server) handleGetDomainsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDomains",
			ID:   "getDomains",
		}
	)
	params, err := decodeGetDomainsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDomainsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDomains",
			OperationSummary: "Retrieve a list of domains",
			OperationID:      "getDomains",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "type",
					In:   "query",
				}: params.Type,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDomainsParams
			Response = GetDomainsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDomainsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDomains(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDomains(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDomainsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEdgeClusterRequest handles getEdgeCluster operation.
//
// Retrieve an NSX Edge Cluster by its ID.
//
// GET /v1/edge-clusters/{id}
func (s *Server) handleGetEdgeClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEdgeCluster",
			ID:   "getEdgeCluster",
		}
	)
	params, err := decodeGetEdgeClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEdgeClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEdgeCluster",
			OperationSummary: "Retrieve an NSX Edge Cluster by its ID",
			OperationID:      "getEdgeCluster",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEdgeClusterParams
			Response = GetEdgeClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEdgeClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEdgeCluster(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEdgeCluster(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEdgeClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEdgeClusterQueryCriteriaRequest handles getEdgeClusterQueryCriteria operation.
//
// Get the Edge Cluster criterion list for the NSX query.
//
// GET /v1/edge-clusters/{edgeClusterId}/criteria
func (s *Server) handleGetEdgeClusterQueryCriteriaRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEdgeClusterQueryCriteria",
			ID:   "getEdgeClusterQueryCriteria",
		}
	)
	params, err := decodeGetEdgeClusterQueryCriteriaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEdgeClusterQueryCriteriaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEdgeClusterQueryCriteria",
			OperationSummary: "Get the Edge Cluster criterion list for the NSX query",
			OperationID:      "getEdgeClusterQueryCriteria",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "edgeClusterId",
					In:   "path",
				}: params.EdgeClusterId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEdgeClusterQueryCriteriaParams
			Response = GetEdgeClusterQueryCriteriaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEdgeClusterQueryCriteriaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEdgeClusterQueryCriteria(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEdgeClusterQueryCriteria(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEdgeClusterQueryCriteriaResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEdgeClusterValidationByIDRequest handles getEdgeClusterValidationByID operation.
//
// Retrieve the results of a NSX Edge Cluster validation by its ID.
//
// GET /v1/edge-clusters/validations/{id}
func (s *Server) handleGetEdgeClusterValidationByIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEdgeClusterValidationByID",
			ID:   "getEdgeClusterValidationByID",
		}
	)
	params, err := decodeGetEdgeClusterValidationByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEdgeClusterValidationByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEdgeClusterValidationByID",
			OperationSummary: "Retrieve the results of a NSX Edge Cluster validation by its ID",
			OperationID:      "getEdgeClusterValidationByID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEdgeClusterValidationByIDParams
			Response = GetEdgeClusterValidationByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEdgeClusterValidationByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEdgeClusterValidationByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEdgeClusterValidationByID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEdgeClusterValidationByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEdgeClustersRequest handles getEdgeClusters operation.
//
// Retrieve a list of NSX Edge Clusters.
//
// GET /v1/edge-clusters
func (s *Server) handleGetEdgeClustersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEdgeClusters",
			ID:   "getEdgeClusters",
		}
	)
	params, err := decodeGetEdgeClustersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEdgeClustersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEdgeClusters",
			OperationSummary: "Retrieve a list of NSX Edge Clusters",
			OperationID:      "getEdgeClusters",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "clusterId",
					In:   "query",
				}: params.ClusterId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEdgeClustersParams
			Response = GetEdgeClustersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEdgeClustersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEdgeClusters(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEdgeClusters(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEdgeClustersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetFIPSConfigurationRequest handles getFIPSConfiguration operation.
//
// Retrieve VCF security FIPS mode.
//
// GET /v1/system/security/fips
func (s *Server) handleGetFIPSConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetFIPSConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetFIPSConfiguration",
			OperationSummary: "Retrieve the FIPS configration mode",
			OperationID:      "getFIPSConfiguration",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetFIPSConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetFIPSConfiguration(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetFIPSConfiguration(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetFIPSConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetFutureReleasesRequest handles getFutureReleases operation.
//
// Returns all known to the system future target versions for a domain. If some of them are not
// allowed (e.g. stepping stone) includes message why. If the domain does not have a product
// configured at that point, that product will not be included in the BOM or patch bundle list in
// each release.
//
// GET /v1/releases/domains/{domainId}/future-releases
func (s *Server) handleGetFutureReleasesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetFutureReleases",
			ID:   "getFutureReleases",
		}
	)
	params, err := decodeGetFutureReleasesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetFutureReleasesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetFutureReleases",
			OperationSummary: "Retrive a list of future release by domain ID",
			OperationID:      "getFutureReleases",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetFutureReleasesParams
			Response = GetFutureReleasesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetFutureReleasesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetFutureReleases(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetFutureReleases(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetFutureReleasesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHealthCheckStatusRequest handles getHealthCheckStatus operation.
//
// Retrieve the status of the Health Check operations.
//
// GET /v1/system/health-summary/{id}
func (s *Server) handleGetHealthCheckStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHealthCheckStatus",
			ID:   "getHealthCheckStatus",
		}
	)
	params, err := decodeGetHealthCheckStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetHealthCheckStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHealthCheckStatus",
			OperationSummary: "Retrieve the status of the Health Check operations",
			OperationID:      "getHealthCheckStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHealthCheckStatusParams
			Response = GetHealthCheckStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetHealthCheckStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHealthCheckStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHealthCheckStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHealthCheckStatusResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHealthCheckTaskRequest handles getHealthCheckTask operation.
//
// Retieve a list of Health Check tasks.
//
// GET /v1/system/health-summary
func (s *Server) handleGetHealthCheckTaskRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetHealthCheckTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHealthCheckTask",
			OperationSummary: "Retieve a list of Health Check tasks",
			OperationID:      "getHealthCheckTask",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetHealthCheckTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHealthCheckTask(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHealthCheckTask(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHealthCheckTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHostRequest handles getHost operation.
//
// Get a host by its ID.
//
// GET /v1/hosts/{id}
func (s *Server) handleGetHostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHost",
			ID:   "getHost",
		}
	)
	params, err := decodeGetHostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetHostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHost",
			OperationSummary: "Get a host by its ID",
			OperationID:      "getHost",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHostParams
			Response = GetHostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetHostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHost(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHostCommissionValidationByIDRequest handles getHostCommissionValidationByID operation.
//
// Retrieve the results of a host commission validation by its ID.
//
// GET /v1/hosts/validations/{id}
func (s *Server) handleGetHostCommissionValidationByIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHostCommissionValidationByID",
			ID:   "getHostCommissionValidationByID",
		}
	)
	params, err := decodeGetHostCommissionValidationByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetHostCommissionValidationByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHostCommissionValidationByID",
			OperationSummary: "Retrieve the results of a host commission validation by its ID",
			OperationID:      "getHostCommissionValidationByID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHostCommissionValidationByIDParams
			Response = GetHostCommissionValidationByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetHostCommissionValidationByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHostCommissionValidationByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHostCommissionValidationByID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHostCommissionValidationByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHostCriteriaRequest handles getHostCriteria operation.
//
// Get all host criteria.
//
// GET /v1/clusters/{id}/hosts/criteria
func (s *Server) handleGetHostCriteriaRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHostCriteria",
			ID:   "getHostCriteria",
		}
	)
	params, err := decodeGetHostCriteriaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PageOfHostCriterion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHostCriteria",
			OperationSummary: "Get all host criteria",
			OperationID:      "getHostCriteria",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHostCriteriaParams
			Response = *PageOfHostCriterion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetHostCriteriaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHostCriteria(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHostCriteria(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHostCriteriaResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHostCriterionRequest handles getHostCriterion operation.
//
// Get a criterion to query for host.
//
// GET /v1/clusters/{id}/hosts/criteria/{name}
func (s *Server) handleGetHostCriterionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHostCriterion",
			ID:   "getHostCriterion",
		}
	)
	params, err := decodeGetHostCriterionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetHostCriterionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHostCriterion",
			OperationSummary: "Get a criterion to query for host",
			OperationID:      "getHostCriterion",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHostCriterionParams
			Response = GetHostCriterionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetHostCriterionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHostCriterion(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHostCriterion(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHostCriterionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHostQueryResponseRequest handles getHostQueryResponse operation.
//
// Get query response.
//
// GET /v1/hosts/queries/{id}
func (s *Server) handleGetHostQueryResponseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHostQueryResponse",
			ID:   "getHostQueryResponse",
		}
	)
	params, err := decodeGetHostQueryResponseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetHostQueryResponseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHostQueryResponse",
			OperationSummary: "",
			OperationID:      "getHostQueryResponse",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHostQueryResponseParams
			Response = GetHostQueryResponseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetHostQueryResponseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHostQueryResponse(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHostQueryResponse(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHostQueryResponseResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHostQueryResponse1Request handles getHostQueryResponse_1 operation.
//
// Get query response.
//
// GET /v1/clusters/{clusterId}/hosts/queries/{queryId}
func (s *Server) handleGetHostQueryResponse1Request(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHostQueryResponse1",
			ID:   "getHostQueryResponse_1",
		}
	)
	params, err := decodeGetHostQueryResponse1Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetHostQueryResponse1Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHostQueryResponse1",
			OperationSummary: "Get query response",
			OperationID:      "getHostQueryResponse_1",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "clusterId",
					In:   "path",
				}: params.ClusterId,
				{
					Name: "queryId",
					In:   "path",
				}: params.QueryId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHostQueryResponse1Params
			Response = GetHostQueryResponse1Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetHostQueryResponse1Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHostQueryResponse1(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHostQueryResponse1(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHostQueryResponse1Response(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHostTagManagerUrlRequest handles getHostTagManagerUrl operation.
//
// Get Host Tag Manager Url.
//
// GET /v1/hosts/{id}/tags/tag-manager
func (s *Server) handleGetHostTagManagerUrlRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHostTagManagerUrl",
			ID:   "getHostTagManagerUrl",
		}
	)
	params, err := decodeGetHostTagManagerUrlParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetHostTagManagerUrlRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHostTagManagerUrl",
			OperationSummary: "",
			OperationID:      "getHostTagManagerUrl",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHostTagManagerUrlParams
			Response = GetHostTagManagerUrlRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetHostTagManagerUrlParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHostTagManagerUrl(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHostTagManagerUrl(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHostTagManagerUrlResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHostsRequest handles getHosts operation.
//
// Get all hosts.
//
// GET /v1/hosts
func (s *Server) handleGetHostsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHosts",
			ID:   "getHosts",
		}
	)
	params, err := decodeGetHostsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetHostsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHosts",
			OperationSummary: "Get all hosts",
			OperationID:      "getHosts",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "status",
					In:   "query",
				}: params.Status,
				{
					Name: "domainId",
					In:   "query",
				}: params.DomainId,
				{
					Name: "clusterId",
					In:   "query",
				}: params.ClusterId,
				{
					Name: "networkpoolId",
					In:   "query",
				}: params.NetworkpoolId,
				{
					Name: "storageType",
					In:   "query",
				}: params.StorageType,
				{
					Name: "datastoreName",
					In:   "query",
				}: params.DatastoreName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHostsParams
			Response = GetHostsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetHostsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHosts(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHosts(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHostsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHostsPrechecksResponseRequest handles getHostsPrechecksResponse operation.
//
// Get host(s) prechecks response.
//
// GET /v1/hosts/prechecks/{id}
func (s *Server) handleGetHostsPrechecksResponseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHostsPrechecksResponse",
			ID:   "getHostsPrechecksResponse",
		}
	)
	params, err := decodeGetHostsPrechecksResponseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetHostsPrechecksResponseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHostsPrechecksResponse",
			OperationSummary: "",
			OperationID:      "getHostsPrechecksResponse",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHostsPrechecksResponseParams
			Response = GetHostsPrechecksResponseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetHostsPrechecksResponseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHostsPrechecksResponse(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHostsPrechecksResponse(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHostsPrechecksResponseResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetIdentityPrecheckResultRequest handles getIdentityPrecheckResult operation.
//
// Get a list precheck result with warnings/errors.
//
// GET /v1/identity-broker/prechecks
func (s *Server) handleGetIdentityPrecheckResultRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetIdentityPrecheckResult",
			ID:   "getIdentityPrecheckResult",
		}
	)
	params, err := decodeGetIdentityPrecheckResultParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetIdentityPrecheckResultRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetIdentityPrecheckResult",
			OperationSummary: "Get Identity Provider Federation Precheck Result",
			OperationID:      "getIdentityPrecheckResult",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "type",
					In:   "query",
				}: params.Type,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetIdentityPrecheckResultParams
			Response = GetIdentityPrecheckResultRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetIdentityPrecheckResultParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetIdentityPrecheckResult(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetIdentityPrecheckResult(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetIdentityPrecheckResultResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetIdentityProviderByIdRequest handles getIdentityProviderById operation.
//
// Get a specific identity irovider using its id.
//
// GET /v1/identity-providers/{id}
func (s *Server) handleGetIdentityProviderByIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetIdentityProviderById",
			ID:   "getIdentityProviderById",
		}
	)
	params, err := decodeGetIdentityProviderByIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetIdentityProviderByIdRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetIdentityProviderById",
			OperationSummary: "Get an identity provider by its id",
			OperationID:      "getIdentityProviderById",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetIdentityProviderByIdParams
			Response = GetIdentityProviderByIdRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetIdentityProviderByIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetIdentityProviderById(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetIdentityProviderById(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetIdentityProviderByIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetIdentityProvidersRequest handles getIdentityProviders operation.
//
// Get a list of all identity providers.
//
// GET /v1/identity-providers
func (s *Server) handleGetIdentityProvidersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetIdentityProvidersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetIdentityProviders",
			OperationSummary: "Get all identity providers",
			OperationID:      "getIdentityProviders",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetIdentityProvidersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetIdentityProviders(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetIdentityProviders(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetIdentityProvidersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLastAssessmentRunInfoRequest handles getLastAssessmentRunInfo operation.
//
// Get information about the last assessment run.
//
// GET /v1/system/check-sets
func (s *Server) handleGetLastAssessmentRunInfoRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetLastAssessmentRunInfo",
			ID:   "getLastAssessmentRunInfo",
		}
	)
	params, err := decodeGetLastAssessmentRunInfoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetLastAssessmentRunInfoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLastAssessmentRunInfo",
			OperationSummary: "Get information about the last assessment run",
			OperationID:      "getLastAssessmentRunInfo",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "query",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetLastAssessmentRunInfoParams
			Response = GetLastAssessmentRunInfoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetLastAssessmentRunInfoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLastAssessmentRunInfo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLastAssessmentRunInfo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLastAssessmentRunInfoResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLicenseKeyRequest handles getLicenseKey operation.
//
// Retrieve a license key.
//
// GET /v1/license-keys/{key}
func (s *Server) handleGetLicenseKeyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetLicenseKey",
			ID:   "getLicenseKey",
		}
	)
	params, err := decodeGetLicenseKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetLicenseKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLicenseKey",
			OperationSummary: "Retrieve a license key",
			OperationID:      "getLicenseKey",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "key",
					In:   "path",
				}: params.Key,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetLicenseKeyParams
			Response = GetLicenseKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetLicenseKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLicenseKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLicenseKey(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLicenseKeyResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLicenseKeysRequest handles getLicenseKeys operation.
//
// Retrieve a list of license keys.
//
// GET /v1/license-keys
func (s *Server) handleGetLicenseKeysRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetLicenseKeys",
			ID:   "getLicenseKeys",
		}
	)
	params, err := decodeGetLicenseKeysParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetLicenseKeysRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLicenseKeys",
			OperationSummary: "Retrieve a list of license keys",
			OperationID:      "getLicenseKeys",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "productType",
					In:   "query",
				}: params.ProductType,
				{
					Name: "licenseKeyStatus",
					In:   "query",
				}: params.LicenseKeyStatus,
				{
					Name: "licenseUnit",
					In:   "query",
				}: params.LicenseUnit,
				{
					Name: "productVersion",
					In:   "query",
				}: params.ProductVersion,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetLicenseKeysParams
			Response = GetLicenseKeysRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetLicenseKeysParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLicenseKeys(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLicenseKeys(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLicenseKeysResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLicenseProductTypesRequest handles getLicenseProductTypes operation.
//
// Get product types.
//
// GET /v1/license-keys/product-types
func (s *Server) handleGetLicenseProductTypesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetLicenseProductTypesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLicenseProductTypes",
			OperationSummary: "Get product types",
			OperationID:      "getLicenseProductTypes",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetLicenseProductTypesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLicenseProductTypes(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLicenseProductTypes(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLicenseProductTypesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLocalAccountRequest handles getLocalAccount operation.
//
// Get information on the local account.
//
// GET /v1/users/local/admin
func (s *Server) handleGetLocalAccountRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetLocalAccountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLocalAccount",
			OperationSummary: "Get local account details",
			OperationID:      "getLocalAccount",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetLocalAccountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLocalAccount(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLocalAccount(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLocalAccountResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLocalOsUserAccountsRequest handles getLocalOsUserAccounts operation.
//
// Returns a list of local OS user accounts from the SDDC Manager appliance.
//
// GET /v1/sddc-manager/local-os-user-accounts
func (s *Server) handleGetLocalOsUserAccountsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetLocalOsUserAccountsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLocalOsUserAccounts",
			OperationSummary: "Get local OS user accounts from the SDDC Manager appliance",
			OperationID:      "getLocalOsUserAccounts",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetLocalOsUserAccountsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLocalOsUserAccounts(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLocalOsUserAccounts(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLocalOsUserAccountsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNetworkOfNetworkPoolRequest handles getNetworkOfNetworkPool operation.
//
// Get a Network that is part of a Network Pool.
//
// GET /v1/network-pools/{id}/networks/{networkId}
func (s *Server) handleGetNetworkOfNetworkPoolRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNetworkOfNetworkPool",
			ID:   "getNetworkOfNetworkPool",
		}
	)
	params, err := decodeGetNetworkOfNetworkPoolParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNetworkOfNetworkPoolRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNetworkOfNetworkPool",
			OperationSummary: "Get a Network of a Network Pool",
			OperationID:      "getNetworkOfNetworkPool",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "networkId",
					In:   "path",
				}: params.NetworkId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNetworkOfNetworkPoolParams
			Response = GetNetworkOfNetworkPoolRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNetworkOfNetworkPoolParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNetworkOfNetworkPool(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNetworkOfNetworkPool(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNetworkOfNetworkPoolResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNetworkPoolRequest handles getNetworkPool operation.
//
// Get the Network Pools.
//
// GET /v1/network-pools
func (s *Server) handleGetNetworkPoolRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetNetworkPoolRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNetworkPool",
			OperationSummary: "Get the list of all Network Pools",
			OperationID:      "getNetworkPool",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNetworkPoolRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNetworkPool(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNetworkPool(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNetworkPoolResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNetworkPoolByIDRequest handles getNetworkPoolByID operation.
//
// Get a Network Pool by ID, if it exists.
//
// GET /v1/network-pools/{id}
func (s *Server) handleGetNetworkPoolByIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNetworkPoolByID",
			ID:   "getNetworkPoolByID",
		}
	)
	params, err := decodeGetNetworkPoolByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNetworkPoolByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNetworkPoolByID",
			OperationSummary: "Get a Network Pool",
			OperationID:      "getNetworkPoolByID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNetworkPoolByIDParams
			Response = GetNetworkPoolByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNetworkPoolByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNetworkPoolByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNetworkPoolByID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNetworkPoolByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNetworksOfNetworkPoolRequest handles getNetworksOfNetworkPool operation.
//
// Get the Networks that are part of a Network Pool.
//
// GET /v1/network-pools/{id}/networks
func (s *Server) handleGetNetworksOfNetworkPoolRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNetworksOfNetworkPool",
			ID:   "getNetworksOfNetworkPool",
		}
	)
	params, err := decodeGetNetworksOfNetworkPoolParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNetworksOfNetworkPoolRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNetworksOfNetworkPool",
			OperationSummary: "Get the Networks of a Network Pool",
			OperationID:      "getNetworksOfNetworkPool",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNetworksOfNetworkPoolParams
			Response = GetNetworksOfNetworkPoolRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNetworksOfNetworkPoolParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNetworksOfNetworkPool(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNetworksOfNetworkPool(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNetworksOfNetworkPoolResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNsxClusterRequest handles getNsxCluster operation.
//
// Retrieve the details of an NSX cluster by its ID.
//
// GET /v1/nsxt-clusters/{id}
func (s *Server) handleGetNsxClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNsxCluster",
			ID:   "getNsxCluster",
		}
	)
	params, err := decodeGetNsxClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNsxClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNsxCluster",
			OperationSummary: "Retrieve the details of an NSX cluster by its ID",
			OperationID:      "getNsxCluster",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNsxClusterParams
			Response = GetNsxClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNsxClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNsxCluster(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNsxCluster(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNsxClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNsxClusterQueryResponseRequest handles getNsxClusterQueryResponse operation.
//
// Get NSX cluster query response.
//
// GET /v1/nsxt-clusters/queries/{id}
func (s *Server) handleGetNsxClusterQueryResponseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNsxClusterQueryResponse",
			ID:   "getNsxClusterQueryResponse",
		}
	)
	params, err := decodeGetNsxClusterQueryResponseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNsxClusterQueryResponseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNsxClusterQueryResponse",
			OperationSummary: "Get NSX cluster query response",
			OperationID:      "getNsxClusterQueryResponse",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNsxClusterQueryResponseParams
			Response = GetNsxClusterQueryResponseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNsxClusterQueryResponseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNsxClusterQueryResponse(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNsxClusterQueryResponse(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNsxClusterQueryResponseResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNsxClustersRequest handles getNsxClusters operation.
//
// Retrieve a list of NSX clusters.
//
// GET /v1/nsxt-clusters
func (s *Server) handleGetNsxClustersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNsxClusters",
			ID:   "getNsxClusters",
		}
	)
	params, err := decodeGetNsxClustersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNsxClustersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNsxClusters",
			OperationSummary: "Retrieve a list of NSX clusters",
			OperationID:      "getNsxClusters",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "isShareable",
					In:   "query",
				}: params.IsShareable,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNsxClustersParams
			Response = GetNsxClustersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNsxClustersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNsxClusters(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNsxClusters(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNsxClustersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNsxCriteriaRequest handles getNsxCriteria operation.
//
// Get all NSX criteria.
//
// GET /v1/nsxt-clusters/criteria
func (s *Server) handleGetNsxCriteriaRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response *PageOfNsxTCriterion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNsxCriteria",
			OperationSummary: "Get all NSX criteria",
			OperationID:      "getNsxCriteria",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *PageOfNsxTCriterion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNsxCriteria(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNsxCriteria(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNsxCriteriaResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNsxCriterionRequest handles getNsxCriterion operation.
//
// Get a NSX criterion.
//
// GET /v1/nsxt-clusters/criteria/{name}
func (s *Server) handleGetNsxCriterionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNsxCriterion",
			ID:   "getNsxCriterion",
		}
	)
	params, err := decodeGetNsxCriterionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNsxCriterionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNsxCriterion",
			OperationSummary: "Get a NSX criterion",
			OperationID:      "getNsxCriterion",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNsxCriterionParams
			Response = GetNsxCriterionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNsxCriterionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNsxCriterion(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNsxCriterion(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNsxCriterionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNsxIpAddressPoolRequest handles getNsxIpAddressPool operation.
//
// Retrieve an NSX IP Address Pool by its name.
//
// GET /v1/nsxt-clusters/{nsxt-cluster-id}/ip-address-pools/{name}
func (s *Server) handleGetNsxIpAddressPoolRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNsxIpAddressPool",
			ID:   "getNsxIpAddressPool",
		}
	)
	params, err := decodeGetNsxIpAddressPoolParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNsxIpAddressPoolRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNsxIpAddressPool",
			OperationSummary: "Retrieve an NSX IP Address Pool by its name",
			OperationID:      "getNsxIpAddressPool",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "nsxt-cluster-id",
					In:   "path",
				}: params.NsxtClusterID,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNsxIpAddressPoolParams
			Response = GetNsxIpAddressPoolRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNsxIpAddressPoolParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNsxIpAddressPool(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNsxIpAddressPool(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNsxIpAddressPoolResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNsxIpAddressPoolsRequest handles getNsxIpAddressPools operation.
//
// Retrive a list of NSX IP Address Pools by the NSX cluster ID.
//
// GET /v1/nsxt-clusters/{nsxt-cluster-id}/ip-address-pools
func (s *Server) handleGetNsxIpAddressPoolsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNsxIpAddressPools",
			ID:   "getNsxIpAddressPools",
		}
	)
	params, err := decodeGetNsxIpAddressPoolsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNsxIpAddressPoolsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNsxIpAddressPools",
			OperationSummary: "Retrive a list of NSX IP Address Pools by the NSX cluster ID",
			OperationID:      "getNsxIpAddressPools",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "nsxt-cluster-id",
					In:   "path",
				}: params.NsxtClusterID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNsxIpAddressPoolsParams
			Response = GetNsxIpAddressPoolsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNsxIpAddressPoolsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNsxIpAddressPools(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNsxIpAddressPools(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNsxIpAddressPoolsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNsxTransportZonesRequest handles getNsxTransportZones operation.
//
// Retrieve list of all NSX transport zones.
//
// GET /v1/nsxt-clusters/{nsxt-cluster-id}/transport-zones
func (s *Server) handleGetNsxTransportZonesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNsxTransportZones",
			ID:   "getNsxTransportZones",
		}
	)
	params, err := decodeGetNsxTransportZonesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNsxTransportZonesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNsxTransportZones",
			OperationSummary: "Retrieve list of all NSX transport zones",
			OperationID:      "getNsxTransportZones",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "nsxt-cluster-id",
					In:   "path",
				}: params.NsxtClusterID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNsxTransportZonesParams
			Response = GetNsxTransportZonesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNsxTransportZonesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNsxTransportZones(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNsxTransportZones(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNsxTransportZonesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNsxUpgradeResourcesRequest handles getNsxUpgradeResources operation.
//
// Get the list NSX upgradable reosurce with resource metadata info.
//
// GET /v1/upgradables/domains/{domainId}/nsxt
func (s *Server) handleGetNsxUpgradeResourcesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNsxUpgradeResources",
			ID:   "getNsxUpgradeResources",
		}
	)
	params, err := decodeGetNsxUpgradeResourcesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNsxUpgradeResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNsxUpgradeResources",
			OperationSummary: "Retrieve a list of all upgradable NSX resources for a domain by its ID",
			OperationID:      "getNsxUpgradeResources",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "bundleId",
					In:   "query",
				}: params.BundleId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNsxUpgradeResourcesParams
			Response = GetNsxUpgradeResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNsxUpgradeResourcesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNsxUpgradeResources(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNsxUpgradeResources(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNsxUpgradeResourcesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNtpConfigurationRequest handles getNtpConfiguration operation.
//
// Retrieve the NTP configuration.
//
// GET /v1/system/ntp-configuration
func (s *Server) handleGetNtpConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetNtpConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNtpConfiguration",
			OperationSummary: "Retrieve the NTP configuration",
			OperationID:      "getNtpConfiguration",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNtpConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNtpConfiguration(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNtpConfiguration(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNtpConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPasswordExpirationRequest handles getPasswordExpiration operation.
//
// Fetch expiration details of passwords for a list of credentials.
//
// POST /v1/credentials/expirations
func (s *Server) handleGetPasswordExpirationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPasswordExpiration",
			ID:   "getPasswordExpiration",
		}
	)
	request, close, err := s.decodeGetPasswordExpirationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GetPasswordExpirationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPasswordExpiration",
			OperationSummary: "Fetch expiration details of passwords for a list of credentials",
			OperationID:      "getPasswordExpiration",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *CredentialsExpirationSpec
			Params   = struct{}
			Response = GetPasswordExpirationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPasswordExpiration(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPasswordExpiration(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPasswordExpirationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPasswordExpirationByTaskIDRequest handles getPasswordExpirationByTaskID operation.
//
// Retrive a password expiration task by ID.
//
// GET /v1/credentials/expirations/{id}
func (s *Server) handleGetPasswordExpirationByTaskIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPasswordExpirationByTaskID",
			ID:   "getPasswordExpirationByTaskID",
		}
	)
	params, err := decodeGetPasswordExpirationByTaskIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetPasswordExpirationByTaskIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPasswordExpirationByTaskID",
			OperationSummary: "Retrive a password expiration task by ID",
			OperationID:      "getPasswordExpirationByTaskID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetPasswordExpirationByTaskIDParams
			Response = GetPasswordExpirationByTaskIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetPasswordExpirationByTaskIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPasswordExpirationByTaskID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPasswordExpirationByTaskID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPasswordExpirationByTaskIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPersonalitiesRequest handles getPersonalities operation.
//
// Get the Personalities which are available via depot access.
//
// GET /v1/personalities
func (s *Server) handleGetPersonalitiesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPersonalities",
			ID:   "getPersonalities",
		}
	)
	params, err := decodeGetPersonalitiesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetPersonalitiesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPersonalities",
			OperationSummary: "Get the Personalities",
			OperationID:      "getPersonalities",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "baseOSVersion",
					In:   "query",
				}: params.BaseOSVersion,
				{
					Name: "addOnName",
					In:   "query",
				}: params.AddOnName,
				{
					Name: "addOnVendorName",
					In:   "query",
				}: params.AddOnVendorName,
				{
					Name: "componentName",
					In:   "query",
				}: params.ComponentName,
				{
					Name: "componentVendorName",
					In:   "query",
				}: params.ComponentVendorName,
				{
					Name: "personalityName",
					In:   "query",
				}: params.PersonalityName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetPersonalitiesParams
			Response = GetPersonalitiesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetPersonalitiesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPersonalities(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPersonalities(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPersonalitiesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPersonalityRequest handles getPersonality operation.
//
// Get the Personality for id.
//
// GET /v1/personalities/{personalityId}
func (s *Server) handleGetPersonalityRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPersonality",
			ID:   "getPersonality",
		}
	)
	params, err := decodeGetPersonalityParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetPersonalityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPersonality",
			OperationSummary: "Get a Personality by its id",
			OperationID:      "getPersonality",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "personalityId",
					In:   "path",
				}: params.PersonalityId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetPersonalityParams
			Response = GetPersonalityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetPersonalityParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPersonality(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPersonality(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPersonalityResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPrecheckTaskRequest handles getPrecheckTask operation.
//
// Monitor the progress of precheck task by the precheck task ID. As this API is deprecated, please
// use the new LCM Prechecks API - /v1/system/check-sets/{taskId}.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /v1/system/prechecks/tasks/{id}
func (s *Server) handleGetPrecheckTaskRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPrecheckTask",
			ID:   "getPrecheckTask",
		}
	)
	params, err := decodeGetPrecheckTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetPrecheckTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPrecheckTask",
			OperationSummary: "Retrieve a precheck task by its id",
			OperationID:      "getPrecheckTask",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetPrecheckTaskParams
			Response = GetPrecheckTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetPrecheckTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPrecheckTask(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPrecheckTask(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPrecheckTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetProductVersionCatalogRequest handles getProductVersionCatalog operation.
//
// Get product version catalog. There should be only one valid product version catalog in the System.
//
// GET /v1/product-version-catalog
func (s *Server) handleGetProductVersionCatalogRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetProductVersionCatalogRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetProductVersionCatalog",
			OperationSummary: "Get product version catalog",
			OperationID:      "getProductVersionCatalog",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetProductVersionCatalogRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetProductVersionCatalog(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetProductVersionCatalog(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetProductVersionCatalogResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetProxyConfigurationRequest handles getProxyConfiguration operation.
//
// Get the current Proxy configuration.
//
// GET /v1/system/proxy-configuration
func (s *Server) handleGetProxyConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetProxyConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetProxyConfiguration",
			OperationSummary: "Get the current Proxy configuration",
			OperationID:      "getProxyConfiguration",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetProxyConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetProxyConfiguration(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetProxyConfiguration(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetProxyConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPscRequest handles getPsc operation.
//
// Retrieve details of a Platform Service Controller (PSC).
//
// GET /v1/pscs/{id}
func (s *Server) handleGetPscRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPsc",
			ID:   "getPsc",
		}
	)
	params, err := decodeGetPscParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetPscRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPsc",
			OperationSummary: "Retrieve details of a Platform Service Controller (PSC)",
			OperationID:      "getPsc",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetPscParams
			Response = GetPscRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetPscParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPsc(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPsc(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPscResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPscsRequest handles getPscs operation.
//
// Retrieve a list of Platform Service Controller (PSC).
//
// GET /v1/pscs
func (s *Server) handleGetPscsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetPscsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPscs",
			OperationSummary: "Retrieve a list of Platform Service Controller (PSC)",
			OperationID:      "getPscs",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPscsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPscs(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPscs(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPscsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetReconciliationTaskRequest handles getReconciliationTask operation.
//
// Get config reconciliation task associated with the given task Id.
//
// GET /v1/config-drift-reconciliations/{taskId}
func (s *Server) handleGetReconciliationTaskRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetReconciliationTask",
			ID:   "getReconciliationTask",
		}
	)
	params, err := decodeGetReconciliationTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetReconciliationTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetReconciliationTask",
			OperationSummary: "Get config reconciliation task associated with the given task Id",
			OperationID:      "getReconciliationTask",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetReconciliationTaskParams
			Response = GetReconciliationTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetReconciliationTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetReconciliationTask(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetReconciliationTask(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetReconciliationTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetReleaseByDomainRequest handles getReleaseByDomain operation.
//
// Get last selected upgrade version for the domain.
//
// GET /v1/releases/domains/{domainId}
func (s *Server) handleGetReleaseByDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetReleaseByDomain",
			ID:   "getReleaseByDomain",
		}
	)
	params, err := decodeGetReleaseByDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetReleaseByDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetReleaseByDomain",
			OperationSummary: "Retrieve a release view for a domain by its ID",
			OperationID:      "getReleaseByDomain",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetReleaseByDomainParams
			Response = GetReleaseByDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetReleaseByDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetReleaseByDomain(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetReleaseByDomain(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetReleaseByDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetReleaseByDomainsRequest handles getReleaseByDomains operation.
//
// Get last selected upgrade version for WLDs.
//
// GET /v1/releases/domains
func (s *Server) handleGetReleaseByDomainsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetReleaseByDomainsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetReleaseByDomains",
			OperationSummary: "Retrieve a release view for all domains",
			OperationID:      "getReleaseByDomains",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetReleaseByDomainsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetReleaseByDomains(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetReleaseByDomains(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetReleaseByDomainsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetReleasesRequest handles getReleases operation.
//
// Get all Releases, with option to get current release for a domain, get release by version or get
// future releases for a versionor get all the applicable target release.
//
// GET /v1/releases
func (s *Server) handleGetReleasesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetReleases",
			ID:   "getReleases",
		}
	)
	params, err := decodeGetReleasesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetReleasesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetReleases",
			OperationSummary: "Retrieve a list of release including current and target versions",
			OperationID:      "getReleases",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "query",
				}: params.DomainId,
				{
					Name: "versionEq",
					In:   "query",
				}: params.VersionEq,
				{
					Name: "vxRailVersionEq",
					In:   "query",
				}: params.VxRailVersionEq,
				{
					Name: "versionGt",
					In:   "query",
				}: params.VersionGt,
				{
					Name: "vxRailVersionGt",
					In:   "query",
				}: params.VxRailVersionGt,
				{
					Name: "applicableForVersion",
					In:   "query",
				}: params.ApplicableForVersion,
				{
					Name: "applicableForVxRailVersion",
					In:   "query",
				}: params.ApplicableForVxRailVersion,
				{
					Name: "getFutureReleases",
					In:   "query",
				}: params.GetFutureReleases,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetReleasesParams
			Response = GetReleasesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetReleasesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetReleases(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetReleases(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetReleasesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetResourceCertificatesValidationByIDRequest handles getResourceCertificatesValidationByID operation.
//
// Get the resource certificate validation result.
//
// GET /v1/domains/{id}/resource-certificates/validations/{validationId}
func (s *Server) handleGetResourceCertificatesValidationByIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetResourceCertificatesValidationByID",
			ID:   "getResourceCertificatesValidationByID",
		}
	)
	params, err := decodeGetResourceCertificatesValidationByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetResourceCertificatesValidationByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetResourceCertificatesValidationByID",
			OperationSummary: "Retrieve the results of a certificate validation by its ID",
			OperationID:      "getResourceCertificatesValidationByID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "validationId",
					In:   "path",
				}: params.ValidationId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetResourceCertificatesValidationByIDParams
			Response = GetResourceCertificatesValidationByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetResourceCertificatesValidationByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetResourceCertificatesValidationByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetResourceCertificatesValidationByID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetResourceCertificatesValidationByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetResourceFunctionalitiesRequest handles getResourceFunctionalities operation.
//
// Get Resource Functionalities.
//
// GET /v1/resource-functionalities
func (s *Server) handleGetResourceFunctionalitiesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetResourceFunctionalities",
			ID:   "getResourceFunctionalities",
		}
	)
	params, err := decodeGetResourceFunctionalitiesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetResourceFunctionalitiesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetResourceFunctionalities",
			OperationSummary: "Get Resource Functionalities",
			OperationID:      "getResourceFunctionalities",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "resourceType",
					In:   "query",
				}: params.ResourceType,
				{
					Name: "functionalityType",
					In:   "query",
				}: params.FunctionalityType,
				{
					Name: "resourceIds",
					In:   "query",
				}: params.ResourceIds,
				{
					Name: "isAllowed",
					In:   "query",
				}: params.IsAllowed,
				{
					Name: "parentResourceType",
					In:   "query",
				}: params.ParentResourceType,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetResourceFunctionalitiesParams
			Response = GetResourceFunctionalitiesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetResourceFunctionalitiesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetResourceFunctionalities(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetResourceFunctionalities(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetResourceFunctionalitiesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetResourceWarningRequest handles getResourceWarning operation.
//
// Get a Resource Warning by ID.
//
// GET /v1/resource-warnings/{id}
func (s *Server) handleGetResourceWarningRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetResourceWarning",
			ID:   "getResourceWarning",
		}
	)
	params, err := decodeGetResourceWarningParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetResourceWarningRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetResourceWarning",
			OperationSummary: "Get a Resource Warning by ID",
			OperationID:      "getResourceWarning",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetResourceWarningParams
			Response = GetResourceWarningRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetResourceWarningParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetResourceWarning(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetResourceWarning(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetResourceWarningResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetResourceWarningsRequest handles getResourceWarnings operation.
//
// Get Resource Warnings.
//
// GET /v1/resource-warnings
func (s *Server) handleGetResourceWarningsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetResourceWarnings",
			ID:   "getResourceWarnings",
		}
	)
	params, err := decodeGetResourceWarningsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetResourceWarningsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetResourceWarnings",
			OperationSummary: "Get Resource Warnings",
			OperationID:      "getResourceWarnings",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "resourceType",
					In:   "query",
				}: params.ResourceType,
				{
					Name: "resourceIds",
					In:   "query",
				}: params.ResourceIds,
				{
					Name: "resourceNames",
					In:   "query",
				}: params.ResourceNames,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetResourceWarningsParams
			Response = GetResourceWarningsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetResourceWarningsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetResourceWarnings(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetResourceWarnings(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetResourceWarningsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetResourcesFunctionalitiesAllowedGlobalRequest handles getResourcesFunctionalitiesAllowedGlobal operation.
//
// Get Resource Functionalities Allowed Global Configuration.
//
// GET /v1/resource-functionalities/global
func (s *Server) handleGetResourcesFunctionalitiesAllowedGlobalRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetResourcesFunctionalitiesAllowedGlobalRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetResourcesFunctionalitiesAllowedGlobal",
			OperationSummary: "Get Resource Functionalities Allowed Global Configuration",
			OperationID:      "getResourcesFunctionalitiesAllowedGlobal",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetResourcesFunctionalitiesAllowedGlobalRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetResourcesFunctionalitiesAllowedGlobal(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetResourcesFunctionalitiesAllowedGlobal(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetResourcesFunctionalitiesAllowedGlobalResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRestoreTaskRequest handles getRestoreTask operation.
//
// Retrieve the restore task.
//
// GET /v1/restores/tasks/{id}
func (s *Server) handleGetRestoreTaskRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRestoreTask",
			ID:   "getRestoreTask",
		}
	)
	params, err := decodeGetRestoreTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetRestoreTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRestoreTask",
			OperationSummary: "Retrieve the restore task",
			OperationID:      "getRestoreTask",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRestoreTaskParams
			Response = GetRestoreTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRestoreTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRestoreTask(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRestoreTask(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetRestoreTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetResultRequest handles getResult operation.
//
// Get the result for a given check run.
//
// GET /v1/system/check-sets/{runId}
func (s *Server) handleGetResultRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetResult",
			ID:   "getResult",
		}
	)
	params, err := decodeGetResultParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetResultRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetResult",
			OperationSummary: "Get the result for a given check run",
			OperationID:      "getResult",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "runId",
					In:   "path",
				}: params.RunId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetResultParams
			Response = GetResultRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetResultParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetResult(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetResult(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetResultResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRolesRequest handles getRoles operation.
//
// Get a list of all roles.
//
// GET /v1/roles
func (s *Server) handleGetRolesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetRolesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRoles",
			OperationSummary: "Retrieve a list of roles from SDDC Manager",
			OperationID:      "getRoles",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetRolesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRoles(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRoles(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetRolesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSSODomainEntitiesRequest handles getSSODomainEntities operation.
//
// Get a list of all entities in the SSO domain.
//
// GET /v1/sso-domains/{sso-domain}/entities
func (s *Server) handleGetSSODomainEntitiesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetSSODomainEntities",
			ID:   "getSSODomainEntities",
		}
	)
	params, err := decodeGetSSODomainEntitiesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetSSODomainEntitiesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSSODomainEntities",
			OperationSummary: "Retrieve a list of users and groups from a domain in vCenter Single Sign-On",
			OperationID:      "getSSODomainEntities",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "sso-domain",
					In:   "path",
				}: params.SSODomain,
				{
					Name: "entityName",
					In:   "query",
				}: params.EntityName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetSSODomainEntitiesParams
			Response = GetSSODomainEntitiesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetSSODomainEntitiesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSSODomainEntities(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSSODomainEntities(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSSODomainEntitiesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSSODomainsRequest handles getSSODomains operation.
//
// Get a list of all SSO domains.
//
// GET /v1/sso-domains
func (s *Server) handleGetSSODomainsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetSSODomainsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSSODomains",
			OperationSummary: "Retrieive a list of domains from  vCenter Single Sign-On",
			OperationID:      "getSSODomains",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSSODomainsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSSODomains(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSSODomains(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSSODomainsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSddcManagerRequest handles getSddcManager operation.
//
// Retrieve the details of an SDDC Manager by its id.
//
// GET /v1/sddc-managers/{id}
func (s *Server) handleGetSddcManagerRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetSddcManager",
			ID:   "getSddcManager",
		}
	)
	params, err := decodeGetSddcManagerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetSddcManagerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSddcManager",
			OperationSummary: "Retrieve the details of an SDDC Manager by its id",
			OperationID:      "getSddcManager",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetSddcManagerParams
			Response = GetSddcManagerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetSddcManagerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSddcManager(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSddcManager(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSddcManagerResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSddcManagerHistoryRequest handles getSddcManagerHistory operation.
//
// Retrieve the history of SDDC Manager by its id.
//
// GET /v1/sddc-managers/{id}/history
func (s *Server) handleGetSddcManagerHistoryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetSddcManagerHistory",
			ID:   "getSddcManagerHistory",
		}
	)
	params, err := decodeGetSddcManagerHistoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetSddcManagerHistoryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSddcManagerHistory",
			OperationSummary: "Retrieve the history of SDDC Manager by its id",
			OperationID:      "getSddcManagerHistory",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetSddcManagerHistoryParams
			Response = GetSddcManagerHistoryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetSddcManagerHistoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSddcManagerHistory(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSddcManagerHistory(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSddcManagerHistoryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSddcManagerInfoRequest handles getSddcManagerInfo operation.
//
// Retrieves the details of SDDC Manager VM.
//
// GET /v1/sddcs/{id}/sddc-manager
func (s *Server) handleGetSddcManagerInfoRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetSddcManagerInfo",
			ID:   "getSddcManagerInfo",
		}
	)
	params, err := decodeGetSddcManagerInfoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetSddcManagerInfoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSddcManagerInfo",
			OperationSummary: "Retrieve SDDC Manager VM details",
			OperationID:      "getSddcManagerInfo",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetSddcManagerInfoParams
			Response = GetSddcManagerInfoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetSddcManagerInfoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSddcManagerInfo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSddcManagerInfo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSddcManagerInfoResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSddcManagersRequest handles getSddcManagers operation.
//
// Retrieve a list of SDDC Managers.
//
// GET /v1/sddc-managers
func (s *Server) handleGetSddcManagersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetSddcManagersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSddcManagers",
			OperationSummary: "Retrieve a list of SDDC Managers",
			OperationID:      "getSddcManagers",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSddcManagersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSddcManagers(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSddcManagers(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSddcManagersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSddcWs1bOidcInfoRequest handles getSddcWs1bOidcInfo operation.
//
// Get the SDDC Manager WS1B OIDC Information.
//
// GET /v1/identity-broker/sddc-manager-oidc
func (s *Server) handleGetSddcWs1bOidcInfoRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetSddcWs1bOidcInfoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSddcWs1bOidcInfo",
			OperationSummary: "Get the SDDC Manager WS1B OIDC Information",
			OperationID:      "getSddcWs1bOidcInfo",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSddcWs1bOidcInfoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSddcWs1bOidcInfo(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSddcWs1bOidcInfo(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSddcWs1bOidcInfoResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSupportBundleStatusRequest handles getSupportBundleStatus operation.
//
// Retrive the status of the Support Bundle operation.
//
// GET /v1/system/support-bundles/{id}
func (s *Server) handleGetSupportBundleStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetSupportBundleStatus",
			ID:   "getSupportBundleStatus",
		}
	)
	params, err := decodeGetSupportBundleStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetSupportBundleStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSupportBundleStatus",
			OperationSummary: "Retrive the status of the Support Bundle operation",
			OperationID:      "getSupportBundleStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetSupportBundleStatusParams
			Response = GetSupportBundleStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetSupportBundleStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSupportBundleStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSupportBundleStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSupportBundleStatusResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSupportBundleTaskRequest handles getSupportBundleTask operation.
//
// Retrieve a list of Support Bundle tasks.
//
// GET /v1/system/support-bundles
func (s *Server) handleGetSupportBundleTaskRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetSupportBundleTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSupportBundleTask",
			OperationSummary: "Retrieve a list of Support Bundle tasks",
			OperationID:      "getSupportBundleTask",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSupportBundleTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSupportBundleTask(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSupportBundleTask(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSupportBundleTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSystemConfigurationRequest handles getSystemConfiguration operation.
//
// Retrieve the system configuration.
//
// GET /v1/system
func (s *Server) handleGetSystemConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetSystemConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSystemConfiguration",
			OperationSummary: "Retrieve the system configuration",
			OperationID:      "getSystemConfiguration",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSystemConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSystemConfiguration(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSystemConfiguration(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSystemConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSystemReleaseRequest handles getSystemRelease operation.
//
// Returns release for the lowest deployed VCF version for a domain on the environment.If Management
// domain is ahead of WLD domain, VCF BOM version for the WLDdomain will be returned.
//
// GET /v1/releases/system
func (s *Server) handleGetSystemReleaseRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetSystemReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSystemRelease",
			OperationSummary: "Retrieve the lowest deployed release of VMware Cloud Foundation",
			OperationID:      "getSystemRelease",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSystemReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSystemRelease(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSystemRelease(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSystemReleaseResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTagAssignableForClusterRequest handles getTagAssignableForCluster operation.
//
// Get tags assignable to a cluster.
//
// GET /v1/clusters/{id}/tags/assignable-tags
func (s *Server) handleGetTagAssignableForClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetTagAssignableForCluster",
			ID:   "getTagAssignableForCluster",
		}
	)
	params, err := decodeGetTagAssignableForClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetTagAssignableForClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTagAssignableForCluster",
			OperationSummary: "Get tags assignable to a cluster",
			OperationID:      "getTagAssignableForCluster",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetTagAssignableForClusterParams
			Response = GetTagAssignableForClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetTagAssignableForClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTagAssignableForCluster(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTagAssignableForCluster(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTagAssignableForClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTagsAssignedToClusterRequest handles getTagsAssignedToCluster operation.
//
// Get tags assigned to a cluster by its ID.
//
// GET /v1/clusters/{id}/tags
func (s *Server) handleGetTagsAssignedToClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetTagsAssignedToCluster",
			ID:   "getTagsAssignedToCluster",
		}
	)
	params, err := decodeGetTagsAssignedToClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetTagsAssignedToClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTagsAssignedToCluster",
			OperationSummary: "Get tags assigned to a cluster by its ID",
			OperationID:      "getTagsAssignedToCluster",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetTagsAssignedToClusterParams
			Response = GetTagsAssignedToClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetTagsAssignedToClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTagsAssignedToCluster(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTagsAssignedToCluster(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTagsAssignedToClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTagsAssignedToClustersRequest handles getTagsAssignedToClusters operation.
//
// Get tags assigned to clusters.
//
// GET /v1/clusters/tags
func (s *Server) handleGetTagsAssignedToClustersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetTagsAssignedToClustersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTagsAssignedToClusters",
			OperationSummary: "Get tags assigned to clusters",
			OperationID:      "getTagsAssignedToClusters",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetTagsAssignedToClustersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTagsAssignedToClusters(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTagsAssignedToClusters(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTagsAssignedToClustersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTagsAssignedToDomainRequest handles getTagsAssignedToDomain operation.
//
// Get tags assigned to a domain.
//
// GET /v1/domains/{id}/tags
func (s *Server) handleGetTagsAssignedToDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetTagsAssignedToDomain",
			ID:   "getTagsAssignedToDomain",
		}
	)
	params, err := decodeGetTagsAssignedToDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetTagsAssignedToDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTagsAssignedToDomain",
			OperationSummary: "Get tags assigned to a domain",
			OperationID:      "getTagsAssignedToDomain",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetTagsAssignedToDomainParams
			Response = GetTagsAssignedToDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetTagsAssignedToDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTagsAssignedToDomain(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTagsAssignedToDomain(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTagsAssignedToDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTagsAssignedToDomainsRequest handles getTagsAssignedToDomains operation.
//
// Get tags assigned to all domains.
//
// GET /v1/domains/tags
func (s *Server) handleGetTagsAssignedToDomainsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetTagsAssignedToDomainsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTagsAssignedToDomains",
			OperationSummary: "Get tags assigned to all domains",
			OperationID:      "getTagsAssignedToDomains",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetTagsAssignedToDomainsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTagsAssignedToDomains(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTagsAssignedToDomains(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTagsAssignedToDomainsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTagsAssignedToHostRequest handles getTagsAssignedToHost operation.
//
// Get Tags assigned to Host.
//
// GET /v1/hosts/{id}/tags
func (s *Server) handleGetTagsAssignedToHostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetTagsAssignedToHost",
			ID:   "getTagsAssignedToHost",
		}
	)
	params, err := decodeGetTagsAssignedToHostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetTagsAssignedToHostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTagsAssignedToHost",
			OperationSummary: "",
			OperationID:      "getTagsAssignedToHost",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetTagsAssignedToHostParams
			Response = GetTagsAssignedToHostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetTagsAssignedToHostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTagsAssignedToHost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTagsAssignedToHost(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTagsAssignedToHostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTagsAssignedToHostsRequest handles getTagsAssignedToHosts operation.
//
// Get Tags assigned to Hosts.
//
// GET /v1/hosts/tags
func (s *Server) handleGetTagsAssignedToHostsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetTagsAssignedToHostsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTagsAssignedToHosts",
			OperationSummary: "",
			OperationID:      "getTagsAssignedToHosts",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetTagsAssignedToHostsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTagsAssignedToHosts(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTagsAssignedToHosts(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTagsAssignedToHostsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTaskRequest handles getTask operation.
//
// Get a Task by ID, if it exists.
//
// GET /v1/tasks/{id}
func (s *Server) handleGetTaskRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetTask",
			ID:   "getTask",
		}
	)
	params, err := decodeGetTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTask",
			OperationSummary: "Retrieve a task by its ID",
			OperationID:      "getTask",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetTaskParams
			Response = GetTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTask(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTask(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTasksRequest handles getTasks operation.
//
// Get the tasks.
//
// GET /v1/tasks
func (s *Server) handleGetTasksRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetTasks",
			ID:   "getTasks",
		}
	)
	params, err := decodeGetTasksParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetTasksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTasks",
			OperationSummary: "Retrieve a list of all tasks",
			OperationID:      "getTasks",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "taskStatus",
					In:   "query",
				}: params.TaskStatus,
				{
					Name: "taskType",
					In:   "query",
				}: params.TaskType,
				{
					Name: "resourceId",
					In:   "query",
				}: params.ResourceId,
				{
					Name: "resourceType",
					In:   "query",
				}: params.ResourceType,
				{
					Name: "completedAfter",
					In:   "query",
				}: params.CompletedAfter,
				{
					Name: "pageNumber",
					In:   "query",
				}: params.PageNumber,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
				{
					Name: "orderDirection",
					In:   "query",
				}: params.OrderDirection,
				{
					Name: "orderBy",
					In:   "query",
				}: params.OrderBy,
				{
					Name: "taskName",
					In:   "query",
				}: params.TaskName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetTasksParams
			Response = GetTasksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetTasksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTasks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTasks(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTasksResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTrustedCertificatesRequest handles getTrustedCertificates operation.
//
// Retrieve all trusted certificates from SDDC Manager.
//
// GET /v1/sddc-manager/trusted-certificates
func (s *Server) handleGetTrustedCertificatesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetTrustedCertificatesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTrustedCertificates",
			OperationSummary: "Retrieve all trusted certificates from SDDC Manager",
			OperationID:      "getTrustedCertificates",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetTrustedCertificatesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTrustedCertificates(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTrustedCertificates(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTrustedCertificatesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetUiUsersRequest handles getUiUsers operation.
//
// Retrieve a list of users assigned access via SDDC Manager.
//
// GET /v1/users/ui
func (s *Server) handleGetUiUsersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetUiUsersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetUiUsers",
			OperationSummary: "Retrieve a list of users assigned access via SDDC Manager",
			OperationID:      "getUiUsers",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetUiUsersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetUiUsers(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetUiUsers(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetUiUsersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetUpgradablesRequest handles getUpgradables operation.
//
// Fetches the list of Upgradables in the System. Only one Upgradable becomes AVAILABLE for Upgrade.
// The Upgradables provides information that can be use for Precheck API and also in the actual
// Upgrade API call.
//
// GET /v1/system/upgradables
func (s *Server) handleGetUpgradablesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetUpgradablesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetUpgradables",
			OperationSummary: "Retrieve a list of all upgradable resources",
			OperationID:      "getUpgradables",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetUpgradablesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetUpgradables(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetUpgradables(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetUpgradablesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetUpgradablesByDomainRequest handles getUpgradablesByDomain operation.
//
// Fetches the list of Upgradables for a given domain. If a target version is provided, Upgradables
// that are required for given target version become Available. The Upgradables providesinformation
// that can be use for Precheck API and also in the actual Upgrade API call.This API is used only for
// management domain, for all cases please use v1/system/upgradables.
//
// GET /v1/upgradables/domains/{domainId}
func (s *Server) handleGetUpgradablesByDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetUpgradablesByDomain",
			ID:   "getUpgradablesByDomain",
		}
	)
	params, err := decodeGetUpgradablesByDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetUpgradablesByDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetUpgradablesByDomain",
			OperationSummary: "Retrieve a list of all upgradable resources for a domain by its ID",
			OperationID:      "getUpgradablesByDomain",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "targetVersion",
					In:   "query",
				}: params.TargetVersion,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetUpgradablesByDomainParams
			Response = GetUpgradablesByDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetUpgradablesByDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetUpgradablesByDomain(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetUpgradablesByDomain(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetUpgradablesByDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetUpgradablesClustersRequest handles getUpgradablesClusters operation.
//
// Fetches the list of available hardware support managers and configured hardware support managers
// for the give resource along with the hardware support packages and Software details.
//
// GET /v1/upgradables/domains/{domainId}/clusters
func (s *Server) handleGetUpgradablesClustersRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetUpgradablesClusters",
			ID:   "getUpgradablesClusters",
		}
	)
	params, err := decodeGetUpgradablesClustersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetUpgradablesClustersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetUpgradablesClusters",
			OperationSummary: "Retrieve a list of upgradable packages details from HSM for a domain by its ID",
			OperationID:      "getUpgradablesClusters",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetUpgradablesClustersParams
			Response = GetUpgradablesClustersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetUpgradablesClustersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetUpgradablesClusters(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetUpgradablesClusters(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetUpgradablesClustersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetUpgradeByIdRequest handles getUpgradeById operation.
//
// Retrieve an upgrade by ID.
//
// GET /v1/upgrades/{upgradeId}
func (s *Server) handleGetUpgradeByIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetUpgradeById",
			ID:   "getUpgradeById",
		}
	)
	params, err := decodeGetUpgradeByIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetUpgradeByIdRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetUpgradeById",
			OperationSummary: "Retrieve an upgrade by ID",
			OperationID:      "getUpgradeById",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "upgradeId",
					In:   "path",
				}: params.UpgradeId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetUpgradeByIdParams
			Response = GetUpgradeByIdRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetUpgradeByIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetUpgradeById(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetUpgradeById(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetUpgradeByIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetUpgradePrecheckByIDRequest handles getUpgradePrecheckByID operation.
//
// Gets upgrade precheck details.
//
// GET /v1/upgrades/{upgradeId}/prechecks/{precheckId}
func (s *Server) handleGetUpgradePrecheckByIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetUpgradePrecheckByID",
			ID:   "getUpgradePrecheckByID",
		}
	)
	params, err := decodeGetUpgradePrecheckByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetUpgradePrecheckByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetUpgradePrecheckByID",
			OperationSummary: "Retrieve an upgrade precheck task by ID",
			OperationID:      "getUpgradePrecheckByID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "upgradeId",
					In:   "path",
				}: params.UpgradeId,
				{
					Name: "precheckId",
					In:   "path",
				}: params.PrecheckId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetUpgradePrecheckByIDParams
			Response = GetUpgradePrecheckByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetUpgradePrecheckByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetUpgradePrecheckByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetUpgradePrecheckByID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetUpgradePrecheckByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetUpgradesRequest handles getUpgrades operation.
//
// Retrieve a list of upgrades.
//
// GET /v1/upgrades
func (s *Server) handleGetUpgradesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetUpgrades",
			ID:   "getUpgrades",
		}
	)
	params, err := decodeGetUpgradesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetUpgradesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetUpgrades",
			OperationSummary: "Retrieve a list of upgrades",
			OperationID:      "getUpgrades",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "status",
					In:   "query",
				}: params.Status,
				{
					Name: "bundleId",
					In:   "query",
				}: params.BundleId,
				{
					Name: "bundleType",
					In:   "query",
				}: params.BundleType,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetUpgradesParams
			Response = GetUpgradesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetUpgradesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetUpgrades(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetUpgrades(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetUpgradesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetUsersRequest handles getUsers operation.
//
// Get a list of all users.
//
// GET /v1/users
func (s *Server) handleGetUsersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetUsersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetUsers",
			OperationSummary: "Retrieve a list of users from SDDC Manager",
			OperationID:      "getUsers",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetUsersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetUsers(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetUsers(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetUsersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetValidationOfDnsConfigurationRequest handles getValidationOfDnsConfiguration operation.
//
// Retrieve the results of a DNS configuration validation by its ID.
//
// GET /v1/system/dns-configuration/validations/{id}
func (s *Server) handleGetValidationOfDnsConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetValidationOfDnsConfiguration",
			ID:   "getValidationOfDnsConfiguration",
		}
	)
	params, err := decodeGetValidationOfDnsConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetValidationOfDnsConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetValidationOfDnsConfiguration",
			OperationSummary: "Retrieve the results of a DNS configuration validation by its ID",
			OperationID:      "getValidationOfDnsConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetValidationOfDnsConfigurationParams
			Response = GetValidationOfDnsConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetValidationOfDnsConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetValidationOfDnsConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetValidationOfDnsConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetValidationOfDnsConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetValidationOfNtpConfigurationRequest handles getValidationOfNtpConfiguration operation.
//
// Retrieve the results of a NTP configuration  validation by its ID.
//
// GET /v1/system/ntp-configuration/validations/{id}
func (s *Server) handleGetValidationOfNtpConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetValidationOfNtpConfiguration",
			ID:   "getValidationOfNtpConfiguration",
		}
	)
	params, err := decodeGetValidationOfNtpConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetValidationOfNtpConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetValidationOfNtpConfiguration",
			OperationSummary: "Retrieve the results of a NTP configuration  validation by its ID",
			OperationID:      "getValidationOfNtpConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetValidationOfNtpConfigurationParams
			Response = GetValidationOfNtpConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetValidationOfNtpConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetValidationOfNtpConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetValidationOfNtpConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetValidationOfNtpConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetValidationResultRequest handles getValidationResult operation.
//
// GET /v1/nsxt-clusters/ip-address-pools/validations/{id}
func (s *Server) handleGetValidationResultRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetValidationResult",
			ID:   "getValidationResult",
		}
	)
	params, err := decodeGetValidationResultParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Validation
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetValidationResult",
			OperationSummary: "",
			OperationID:      "getValidationResult",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetValidationResultParams
			Response = *Validation
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetValidationResultParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetValidationResult(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetValidationResult(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetValidationResultResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetValidationsOfDNSConfigurationRequest handles getValidationsOfDNSConfiguration operation.
//
// Retrieve a list of DNS configuation validations.
//
// GET /v1/system/dns-configuration/validations
func (s *Server) handleGetValidationsOfDNSConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetValidationsOfDNSConfiguration",
			ID:   "getValidationsOfDNSConfiguration",
		}
	)
	params, err := decodeGetValidationsOfDNSConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetValidationsOfDNSConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetValidationsOfDNSConfiguration",
			OperationSummary: "Retrieve a list of DNS configuation validations",
			OperationID:      "getValidationsOfDNSConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "executionStatus",
					In:   "query",
				}: params.ExecutionStatus,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetValidationsOfDNSConfigurationParams
			Response = GetValidationsOfDNSConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetValidationsOfDNSConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetValidationsOfDNSConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetValidationsOfDNSConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetValidationsOfDNSConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetValidationsOfNtpConfigurationRequest handles getValidationsOfNtpConfiguration operation.
//
// Retrieve a list of NTP configuation validations.
//
// GET /v1/system/ntp-configuration/validations
func (s *Server) handleGetValidationsOfNtpConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetValidationsOfNtpConfiguration",
			ID:   "getValidationsOfNtpConfiguration",
		}
	)
	params, err := decodeGetValidationsOfNtpConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetValidationsOfNtpConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetValidationsOfNtpConfiguration",
			OperationSummary: "Retrieve a list of NTP configuation validations",
			OperationID:      "getValidationsOfNtpConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "executionStatus",
					In:   "query",
				}: params.ExecutionStatus,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetValidationsOfNtpConfigurationParams
			Response = GetValidationsOfNtpConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetValidationsOfNtpConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetValidationsOfNtpConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetValidationsOfNtpConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetValidationsOfNtpConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVasaProviderRequest handles getVasaProvider operation.
//
// Get a VASA Provider.
//
// GET /v1/vasa-providers/{id}
func (s *Server) handleGetVasaProviderRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVasaProvider",
			ID:   "getVasaProvider",
		}
	)
	params, err := decodeGetVasaProviderParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVasaProviderRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVasaProvider",
			OperationSummary: "Get a VASA Provider",
			OperationID:      "getVasaProvider",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVasaProviderParams
			Response = GetVasaProviderRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVasaProviderParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVasaProvider(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVasaProvider(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVasaProviderResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVasaProviderStorageContainersRequest handles getVasaProviderStorageContainers operation.
//
// Get the storage containers of a VASA Provider.
//
// GET /v1/vasa-providers/{id}/storage-containers
func (s *Server) handleGetVasaProviderStorageContainersRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVasaProviderStorageContainers",
			ID:   "getVasaProviderStorageContainers",
		}
	)
	params, err := decodeGetVasaProviderStorageContainersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVasaProviderStorageContainersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVasaProviderStorageContainers",
			OperationSummary: "Get the storage containers of a VASA Provider",
			OperationID:      "getVasaProviderStorageContainers",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "protocolType",
					In:   "query",
				}: params.ProtocolType,
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVasaProviderStorageContainersParams
			Response = GetVasaProviderStorageContainersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVasaProviderStorageContainersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVasaProviderStorageContainers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVasaProviderStorageContainers(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVasaProviderStorageContainersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVasaProviderUserRequest handles getVasaProviderUser operation.
//
// Get the users of a VASA Provider.
//
// GET /v1/vasa-providers/{id}/users
func (s *Server) handleGetVasaProviderUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVasaProviderUser",
			ID:   "getVasaProviderUser",
		}
	)
	params, err := decodeGetVasaProviderUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVasaProviderUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVasaProviderUser",
			OperationSummary: "Get the users of a VASA Provider",
			OperationID:      "getVasaProviderUser",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVasaProviderUserParams
			Response = GetVasaProviderUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVasaProviderUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVasaProviderUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVasaProviderUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVasaProviderUserResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVasaProviderValidationRequest handles getVasaProviderValidation operation.
//
// Get the status of the validation of the VASA Provider.
//
// GET /v1/vasa-providers/validations/{id}
func (s *Server) handleGetVasaProviderValidationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVasaProviderValidation",
			ID:   "getVasaProviderValidation",
		}
	)
	params, err := decodeGetVasaProviderValidationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVasaProviderValidationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVasaProviderValidation",
			OperationSummary: "Get the status of the validation of the VASA Provider",
			OperationID:      "getVasaProviderValidation",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVasaProviderValidationParams
			Response = GetVasaProviderValidationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVasaProviderValidationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVasaProviderValidation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVasaProviderValidation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVasaProviderValidationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVasaProvidersRequest handles getVasaProviders operation.
//
// Get the VASA Providers.
//
// GET /v1/vasa-providers
func (s *Server) handleGetVasaProvidersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetVasaProvidersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVasaProviders",
			OperationSummary: "Get the VASA Providers",
			OperationID:      "getVasaProviders",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetVasaProvidersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVasaProviders(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVasaProviders(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVasaProvidersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVcenterRequest handles getVcenter operation.
//
// Retrieve a vCenter Server by its ID.
//
// GET /v1/vcenters/{id}
func (s *Server) handleGetVcenterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVcenter",
			ID:   "getVcenter",
		}
	)
	params, err := decodeGetVcenterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVcenterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVcenter",
			OperationSummary: "Retrieve a vCenter Server by its ID",
			OperationID:      "getVcenter",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVcenterParams
			Response = GetVcenterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVcenterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVcenter(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVcenter(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVcenterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVcentersRequest handles getVcenters operation.
//
// Retrieve a list of vCenter Servers.
//
// GET /v1/vcenters
func (s *Server) handleGetVcentersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVcenters",
			ID:   "getVcenters",
		}
	)
	params, err := decodeGetVcentersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVcentersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVcenters",
			OperationSummary: "Retrieve a list of vCenter Servers",
			OperationID:      "getVcenters",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "query",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVcentersParams
			Response = GetVcentersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVcentersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVcenters(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVcenters(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVcentersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVcfServiceRequest handles getVcfService operation.
//
// Retrieve an SDDC Manager service by its ID.
//
// GET /v1/vcf-services/{id}
func (s *Server) handleGetVcfServiceRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVcfService",
			ID:   "getVcfService",
		}
	)
	params, err := decodeGetVcfServiceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVcfServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVcfService",
			OperationSummary: "Retrieve an SDDC Manager service by its ID",
			OperationID:      "getVcfService",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVcfServiceParams
			Response = GetVcfServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVcfServiceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVcfService(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVcfService(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVcfServiceResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVcfServicesRequest handles getVcfServices operation.
//
// Retrieve a list of SDDC Manager services.
//
// GET /v1/vcf-services
func (s *Server) handleGetVcfServicesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetVcfServicesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVcfServices",
			OperationSummary: "Retrieve a list of SDDC Manager services",
			OperationID:      "getVcfServices",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetVcfServicesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVcfServices(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVcfServices(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVcfServicesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVdsesRequest handles getVdses operation.
//
// Get the list of VDSes of a cluster.
//
// GET /v1/clusters/{clusterId}/vdses
func (s *Server) handleGetVdsesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVdses",
			ID:   "getVdses",
		}
	)
	params, err := decodeGetVdsesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVdsesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVdses",
			OperationSummary: "Get the list of VDSes of a cluster.",
			OperationID:      "getVdses",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "clusterId",
					In:   "path",
				}: params.ClusterId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVdsesParams
			Response = GetVdsesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVdsesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVdses(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVdses(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVdsesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVersionAliasConfigurationRequest handles getVersionAliasConfiguration operation.
//
// Get the Version Alias Configuration.
//
// GET /v1/system/settings/version-aliases
func (s *Server) handleGetVersionAliasConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetVersionAliasConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVersionAliasConfiguration",
			OperationSummary: "Retrieve Version Alias Configuration",
			OperationID:      "getVersionAliasConfiguration",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetVersionAliasConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVersionAliasConfiguration(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVersionAliasConfiguration(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVersionAliasConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVrasRequest handles getVras operation.
//
// Retrieve a list of VMware Aria Automation instances.
//
// GET /v1/vras
func (s *Server) handleGetVrasRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response *PageOfVra
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVras",
			OperationSummary: "Retrieve a list of VMware Aria Automation instances",
			OperationID:      "getVras",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *PageOfVra
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVras(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVras(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVrasResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVrliIntegratedDomainsRequest handles getVrliIntegratedDomains operation.
//
// Retrieve a list of VMware Aria Operations for Logs integration status for domains.
//
// GET /v1/vrli/domains
func (s *Server) handleGetVrliIntegratedDomainsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response *PageOfDomainIntegration
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVrliIntegratedDomains",
			OperationSummary: "Retrieve a list of VMware Aria Operations for Logs integration status for domains",
			OperationID:      "getVrliIntegratedDomains",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *PageOfDomainIntegration
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVrliIntegratedDomains(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVrliIntegratedDomains(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVrliIntegratedDomainsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVrlisRequest handles getVrlis operation.
//
// Retrieve a list of VMware Aria Operations for Logs instances.
//
// GET /v1/vrlis
func (s *Server) handleGetVrlisRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response *PageOfVrli
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVrlis",
			OperationSummary: "Retrieve a list of VMware Aria Operations for Logs instances",
			OperationID:      "getVrlis",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *PageOfVrli
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVrlis(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVrlis(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVrlisResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVropsIntegratedDomainsRequest handles getVropsIntegratedDomains operation.
//
// Retrieves the existing  domains and their connection status with Aria Operations.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /v1/vrops/domains
func (s *Server) handleGetVropsIntegratedDomainsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response *PageOfDomainIntegration
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVropsIntegratedDomains",
			OperationSummary: "Retrieve a list of VMware Aria Operations integration status for domains",
			OperationID:      "getVropsIntegratedDomains",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *PageOfDomainIntegration
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVropsIntegratedDomains(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVropsIntegratedDomains(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVropsIntegratedDomainsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVropsesRequest handles getVropses operation.
//
// Retrieve a list of VMware Aria Operations instances.
//
// GET /v1/vropses
func (s *Server) handleGetVropsesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response *PageOfVrops
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVropses",
			OperationSummary: "Retrieve a list of VMware Aria Operations instances",
			OperationID:      "getVropses",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *PageOfVrops
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVropses(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVropses(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVropsesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVrslcmRequest handles getVrslcm operation.
//
// Gets the complete information about the existing VMware Aria Suite Lifecycle instance.
//
// GET /v1/vrslcm
func (s *Server) handleGetVrslcmRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetVrslcmRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVrslcm",
			OperationSummary: "Retrieve information about VMware Aria Suite Lifecycle",
			OperationID:      "getVrslcm",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetVrslcmRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVrslcm(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVrslcm(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVrslcmResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVrslcmStatusRequest handles getVrslcmStatus operation.
//
// Get status on the VMware Aria Suite Lifecycle product and availability of different actions.
//
// GET /v1/vrslcm/status
func (s *Server) handleGetVrslcmStatusRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetVrslcmStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVrslcmStatus",
			OperationSummary: "Retrieve information about VMware Aria Suite Lifecycle actual status",
			OperationID:      "getVrslcmStatus",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetVrslcmStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVrslcmStatus(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVrslcmStatus(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVrslcmStatusResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVrslcmValidationRequest handles getVrslcmValidation operation.
//
// Gets the status of given VMware Aria Suite Lifecycle validation workflow by given validation id.
//
// GET /v1/vrslcms/validations/{id}
func (s *Server) handleGetVrslcmValidationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVrslcmValidation",
			ID:   "getVrslcmValidation",
		}
	)
	params, err := decodeGetVrslcmValidationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVrslcmValidationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVrslcmValidation",
			OperationSummary: "Retrieve the results of a VMware Aria Suite Lifecycle validation by its ID",
			OperationID:      "getVrslcmValidation",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVrslcmValidationParams
			Response = GetVrslcmValidationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVrslcmValidationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVrslcmValidation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVrslcmValidation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVrslcmValidationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVrslcmsRequest handles getVrslcms operation.
//
// Get all existing VMware Aria Suite Lifecycle instances.
//
// GET /v1/vrslcms
func (s *Server) handleGetVrslcmsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response *PageOfVrslcm
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVrslcms",
			OperationSummary: "Get all existing VMware Aria Suite Lifecycle instances",
			OperationID:      "getVrslcms",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *PageOfVrslcm
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVrslcms(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVrslcms(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVrslcmsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVsanHclAttributesRequest handles getVsanHclAttributes operation.
//
// Attributes of vSAN HCL data such as timestamp of last update.
//
// GET /v1/vsan-hcl/attributes
func (s *Server) handleGetVsanHclAttributesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetVsanHclAttributesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVsanHclAttributes",
			OperationSummary: "Get vSAN HCL attributes",
			OperationID:      "getVsanHclAttributes",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetVsanHclAttributesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVsanHclAttributes(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVsanHclAttributes(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVsanHclAttributesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVsanHclConfigurationRequest handles getVsanHclConfiguration operation.
//
// Get vSAN HCL configuration.
//
// GET /v1/vsan-hcl/configuration
func (s *Server) handleGetVsanHclConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response GetVsanHclConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVsanHclConfiguration",
			OperationSummary: "Get vSAN HCL configuration",
			OperationID:      "getVsanHclConfiguration",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetVsanHclConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVsanHclConfiguration(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVsanHclConfiguration(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVsanHclConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVsanHealthCheckByDomainRequest handles getVsanHealthCheckByDomain operation.
//
// Get vSAN health check status for all cluster on the domain.
//
// GET /v1/domains/{domainId}/health-checks
func (s *Server) handleGetVsanHealthCheckByDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVsanHealthCheckByDomain",
			ID:   "getVsanHealthCheckByDomain",
		}
	)
	params, err := decodeGetVsanHealthCheckByDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVsanHealthCheckByDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVsanHealthCheckByDomain",
			OperationSummary: "Retrieve vSAN Health Check status for a domain by its ID",
			OperationID:      "getVsanHealthCheckByDomain",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "status",
					In:   "query",
				}: params.Status,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVsanHealthCheckByDomainParams
			Response = GetVsanHealthCheckByDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVsanHealthCheckByDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVsanHealthCheckByDomain(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVsanHealthCheckByDomain(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVsanHealthCheckByDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVsanHealthCheckByQueryIDRequest handles getVsanHealthCheckByQueryID operation.
//
// Get vSAN health check status for a given Query Id.
//
// GET /v1/domains/{domainId}/health-checks/queries/{queryId}
func (s *Server) handleGetVsanHealthCheckByQueryIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVsanHealthCheckByQueryID",
			ID:   "getVsanHealthCheckByQueryID",
		}
	)
	params, err := decodeGetVsanHealthCheckByQueryIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVsanHealthCheckByQueryIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVsanHealthCheckByQueryID",
			OperationSummary: "Retrieve vSAN Health Check status for a domain and query ID",
			OperationID:      "getVsanHealthCheckByQueryID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "queryId",
					In:   "path",
				}: params.QueryId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVsanHealthCheckByQueryIDParams
			Response = GetVsanHealthCheckByQueryIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVsanHealthCheckByQueryIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVsanHealthCheckByQueryID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVsanHealthCheckByQueryID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVsanHealthCheckByQueryIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVsanHealthCheckByTaskIDRequest handles getVsanHealthCheckByTaskID operation.
//
// Get vSAN health check update task status for a given task Id.
//
// GET /v1/domains/{domainId}/health-checks/tasks/{taskId}
func (s *Server) handleGetVsanHealthCheckByTaskIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVsanHealthCheckByTaskID",
			ID:   "getVsanHealthCheckByTaskID",
		}
	)
	params, err := decodeGetVsanHealthCheckByTaskIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVsanHealthCheckByTaskIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVsanHealthCheckByTaskID",
			OperationSummary: "Retrieve a vSAN Health Check by task ID",
			OperationID:      "getVsanHealthCheckByTaskID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVsanHealthCheckByTaskIDParams
			Response = GetVsanHealthCheckByTaskIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVsanHealthCheckByTaskIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVsanHealthCheckByTaskID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVsanHealthCheckByTaskID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVsanHealthCheckByTaskIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWsasRequest handles getWsas operation.
//
// Retrieve a list of Workspace ONE Access instances.
//
// GET /v1/wsas
func (s *Server) handleGetWsasRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response *PageOfWsa
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWsas",
			OperationSummary: "Retrieve a list of Workspace ONE Access instances",
			OperationID:      "getWsas",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *PageOfWsa
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWsas(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWsas(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWsasResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleImportVdsToInventoryRequest handles importVdsToInventory operation.
//
// Import Vds to inventory for the given cluster.
//
// POST /v1/clusters/{clusterId}/vdses
func (s *Server) handleImportVdsToInventoryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ImportVdsToInventory",
			ID:   "importVdsToInventory",
		}
	)
	params, err := decodeImportVdsToInventoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeImportVdsToInventoryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ImportVdsToInventoryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ImportVdsToInventory",
			OperationSummary: "Import Vds to inventory for the given cluster",
			OperationID:      "importVdsToInventory",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "clusterId",
					In:   "path",
				}: params.ClusterId,
			},
			Raw: r,
		}

		type (
			Request  = *ImportVdsSpec
			Params   = ImportVdsToInventoryParams
			Response = ImportVdsToInventoryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackImportVdsToInventoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ImportVdsToInventory(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ImportVdsToInventory(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeImportVdsToInventoryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleInvalidateRefreshTokenRequest handles invalidateRefreshToken operation.
//
// Invalidate the provided refresh token.
//
// DELETE /v1/tokens/refresh-token
func (s *Server) handleInvalidateRefreshTokenRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "InvalidateRefreshToken",
			ID:   "invalidateRefreshToken",
		}
	)
	request, close, err := s.decodeInvalidateRefreshTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *InvalidateRefreshTokenNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "InvalidateRefreshToken",
			OperationSummary: "Invalidate Refresh Token",
			OperationID:      "invalidateRefreshToken",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = string
			Params   = struct{}
			Response = *InvalidateRefreshTokenNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.InvalidateRefreshToken(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.InvalidateRefreshToken(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInvalidateRefreshTokenResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePerformDomainIsolationPrecheckRequest handles performDomainIsolationPrecheck operation.
//
// Perform Domain Isolation Prechecks.
//
// POST /v1/domains/{domainId}/isolation-prechecks
func (s *Server) handlePerformDomainIsolationPrecheckRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PerformDomainIsolationPrecheck",
			ID:   "performDomainIsolationPrecheck",
		}
	)
	params, err := decodePerformDomainIsolationPrecheckParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePerformDomainIsolationPrecheckRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PerformDomainIsolationPrecheckRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PerformDomainIsolationPrecheck",
			OperationSummary: "Perform Domain Isolation Prechecks",
			OperationID:      "performDomainIsolationPrecheck",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = *IsolationSpec
			Params   = PerformDomainIsolationPrecheckParams
			Response = PerformDomainIsolationPrecheckRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPerformDomainIsolationPrecheckParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PerformDomainIsolationPrecheck(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PerformDomainIsolationPrecheck(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePerformDomainIsolationPrecheckResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePerformUpgradeRequest handles performUpgrade operation.
//
// Schedule/Trigger Upgrade of a Resource. Ex: Resource can be DOMAIN, CLUSTER, UNMANAGED_HOST etc.
// Performing upgrades are supported on VMware Cloud Foundation 3.5 BOM resources and above. Supports
// scheduling/triggering of only 'parallel' upgrades and only Resource 'cluster' that are managed
// using both vSphere Lifecycle Manager Baselines and vSphere Lifecycle Manager Images in the same
// request.
//
// POST /v1/upgrades
func (s *Server) handlePerformUpgradeRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PerformUpgrade",
			ID:   "performUpgrade",
		}
	)
	request, close, err := s.decodePerformUpgradeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PerformUpgradeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PerformUpgrade",
			OperationSummary: "Start an upgrade operation",
			OperationID:      "performUpgrade",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *UpgradeSpec
			Params   = struct{}
			Response = PerformUpgradeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PerformUpgrade(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.PerformUpgrade(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePerformUpgradeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostClusterQueryRequest handles postClusterQuery operation.
//
// Post a cluster query.
//
// POST /v1/domains/{domainId}/clusters/{clusterName}/queries
func (s *Server) handlePostClusterQueryRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostClusterQuery",
			ID:   "postClusterQuery",
		}
	)
	params, err := decodePostClusterQueryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePostClusterQueryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PostClusterQueryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostClusterQuery",
			OperationSummary: "Post a cluster query",
			OperationID:      "postClusterQuery",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
				{
					Name: "clusterName",
					In:   "path",
				}: params.ClusterName,
			},
			Raw: r,
		}

		type (
			Request  = *ClusterCriterion
			Params   = PostClusterQueryParams
			Response = PostClusterQueryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPostClusterQueryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostClusterQuery(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostClusterQuery(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostClusterQueryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostClustersQueryRequest handles postClustersQuery operation.
//
// Post clusters query.
//
// POST /v1/domains/{domainId}/clusters/queries
func (s *Server) handlePostClustersQueryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostClustersQuery",
			ID:   "postClustersQuery",
		}
	)
	params, err := decodePostClustersQueryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePostClustersQueryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PostClustersQueryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostClustersQuery",
			OperationSummary: "Post clusters query",
			OperationID:      "postClustersQuery",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = *ClusterCriterion
			Params   = PostClustersQueryParams
			Response = PostClustersQueryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPostClustersQueryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostClustersQuery(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostClustersQuery(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostClustersQueryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostDatastoreQueryRequest handles postDatastoreQuery operation.
//
// Post a datastore query.
//
// POST /v1/domains/{domainId}/datastores/queries
func (s *Server) handlePostDatastoreQueryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostDatastoreQuery",
			ID:   "postDatastoreQuery",
		}
	)
	params, err := decodePostDatastoreQueryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePostDatastoreQueryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PostDatastoreQueryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostDatastoreQuery",
			OperationSummary: "Post a datastore query",
			OperationID:      "postDatastoreQuery",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = *DatastoreCriterion
			Params   = PostDatastoreQueryParams
			Response = PostDatastoreQueryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPostDatastoreQueryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostDatastoreQuery(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostDatastoreQuery(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostDatastoreQueryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostDatastoreQuery1Request handles postDatastoreQuery_1 operation.
//
// Post a datastore query.
//
// POST /v1/clusters/{id}/datastores/queries
func (s *Server) handlePostDatastoreQuery1Request(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostDatastoreQuery1",
			ID:   "postDatastoreQuery_1",
		}
	)
	params, err := decodePostDatastoreQuery1Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePostDatastoreQuery1Request(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PostDatastoreQuery1Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostDatastoreQuery1",
			OperationSummary: "Post a datastore query",
			OperationID:      "postDatastoreQuery_1",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *DatastoreCriterion
			Params   = PostDatastoreQuery1Params
			Response = PostDatastoreQuery1Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPostDatastoreQuery1Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostDatastoreQuery1(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostDatastoreQuery1(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostDatastoreQuery1Response(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostHostQueryRequest handles postHostQuery operation.
//
// Post a host query.
//
// POST /v1/clusters/{id}/hosts/queries
func (s *Server) handlePostHostQueryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostHostQuery",
			ID:   "postHostQuery",
		}
	)
	params, err := decodePostHostQueryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePostHostQueryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PostHostQueryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostHostQuery",
			OperationSummary: "Post a host query",
			OperationID:      "postHostQuery",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *HostCriterion
			Params   = PostHostQueryParams
			Response = PostHostQueryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPostHostQueryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostHostQuery(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostHostQuery(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostHostQueryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostHostsPrechecks1Request handles postHostsPrechecks_1 operation.
//
// Post host(s) prechecks.
//
// POST /v1/hosts/prechecks
func (s *Server) handlePostHostsPrechecks1Request(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostHostsPrechecks1",
			ID:   "postHostsPrechecks_1",
		}
	)
	request, close, err := s.decodePostHostsPrechecks1Request(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PostHostsPrechecks1Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostHostsPrechecks1",
			OperationSummary: "",
			OperationID:      "postHostsPrechecks_1",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = PostHostsPrechecks1Req
			Params   = struct{}
			Response = PostHostsPrechecks1Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostHostsPrechecks1(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostHostsPrechecks1(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostHostsPrechecks1Response(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostQueryRequest handles postQuery operation.
//
// Post a query.
//
// POST /v1/hosts/queries
func (s *Server) handlePostQueryRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostQuery",
			ID:   "postQuery",
		}
	)
	request, close, err := s.decodePostQueryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PostQueryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostQuery",
			OperationSummary: "",
			OperationID:      "postQuery",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *HostCriterion
			Params   = struct{}
			Response = PostQueryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostQuery(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostQuery(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostQueryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleQueryCheckSetsRequest handles queryCheckSets operation.
//
// Query for check-sets for the given resources.
//
// POST /v1/system/check-sets/queries
func (s *Server) handleQueryCheckSetsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "QueryCheckSets",
			ID:   "queryCheckSets",
		}
	)
	request, close, err := s.decodeQueryCheckSetsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response QueryCheckSetsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "QueryCheckSets",
			OperationSummary: "Query for check-sets for the given resources",
			OperationID:      "queryCheckSets",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *CheckSetQueryInput
			Params   = struct{}
			Response = QueryCheckSetsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.QueryCheckSets(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.QueryCheckSets(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeQueryCheckSetsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReconcileConfigsRequest handles reconcileConfigs operation.
//
// For selective reconciliation, provide a config spec.
//
// POST /v1/config-drift-reconciliations
func (s *Server) handleReconcileConfigsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReconcileConfigs",
			ID:   "reconcileConfigs",
		}
	)
	request, close, err := s.decodeReconcileConfigsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReconcileConfigsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReconcileConfigs",
			OperationSummary: "Reconcile configs",
			OperationID:      "reconcileConfigs",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *ConfigDriftApplySpec
			Params   = struct{}
			Response = ReconcileConfigsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReconcileConfigs(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReconcileConfigs(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReconcileConfigsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRefreshAccessTokenRequest handles refreshAccessToken operation.
//
// Refresh the access token associated with the given refresh token.
//
// PATCH /v1/tokens/access-token/refresh
func (s *Server) handleRefreshAccessTokenRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RefreshAccessToken",
			ID:   "refreshAccessToken",
		}
	)
	request, close, err := s.decodeRefreshAccessTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RefreshAccessTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RefreshAccessToken",
			OperationSummary: "Refresh Access Token",
			OperationID:      "refreshAccessToken",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = string
			Params   = struct{}
			Response = RefreshAccessTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RefreshAccessToken(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.RefreshAccessToken(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRefreshAccessTokenResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRemoveCertificateAuthorityRequest handles removeCertificateAuthority operation.
//
// Deletes CA configuration file.
//
// DELETE /v1/certificate-authorities/{id}
func (s *Server) handleRemoveCertificateAuthorityRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RemoveCertificateAuthority",
			ID:   "removeCertificateAuthority",
		}
	)
	params, err := decodeRemoveCertificateAuthorityParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response RemoveCertificateAuthorityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RemoveCertificateAuthority",
			OperationSummary: "Remove the configuration of a Certificate Authority",
			OperationID:      "removeCertificateAuthority",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RemoveCertificateAuthorityParams
			Response = RemoveCertificateAuthorityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRemoveCertificateAuthorityParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RemoveCertificateAuthority(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RemoveCertificateAuthority(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRemoveCertificateAuthorityResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRemoveDatastoreFromClusterRequest handles removeDatastoreFromCluster operation.
//
// Unmount a datastore from a cluster.
//
// DELETE /v1/clusters/{id}/datastores/{datastoreId}
func (s *Server) handleRemoveDatastoreFromClusterRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RemoveDatastoreFromCluster",
			ID:   "removeDatastoreFromCluster",
		}
	)
	params, err := decodeRemoveDatastoreFromClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response RemoveDatastoreFromClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RemoveDatastoreFromCluster",
			OperationSummary: "Unmount a datastore from a cluster",
			OperationID:      "removeDatastoreFromCluster",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "datastoreId",
					In:   "path",
				}: params.DatastoreId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RemoveDatastoreFromClusterParams
			Response = RemoveDatastoreFromClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRemoveDatastoreFromClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RemoveDatastoreFromCluster(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RemoveDatastoreFromCluster(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRemoveDatastoreFromClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRemoveLicenseKeyRequest handles removeLicenseKey operation.
//
// Remove a license key.
//
// DELETE /v1/license-keys/{key}
func (s *Server) handleRemoveLicenseKeyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RemoveLicenseKey",
			ID:   "removeLicenseKey",
		}
	)
	params, err := decodeRemoveLicenseKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response RemoveLicenseKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RemoveLicenseKey",
			OperationSummary: "Remove a license key",
			OperationID:      "removeLicenseKey",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "key",
					In:   "path",
				}: params.Key,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RemoveLicenseKeyParams
			Response = RemoveLicenseKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRemoveLicenseKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RemoveLicenseKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RemoveLicenseKey(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRemoveLicenseKeyResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRemoveTagsFromClusterRequest handles removeTagsFromCluster operation.
//
// Remove tags from a cluster.
//
// DELETE /v1/clusters/{id}/tags
func (s *Server) handleRemoveTagsFromClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RemoveTagsFromCluster",
			ID:   "removeTagsFromCluster",
		}
	)
	params, err := decodeRemoveTagsFromClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeRemoveTagsFromClusterRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RemoveTagsFromClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RemoveTagsFromCluster",
			OperationSummary: "Remove tags from a cluster",
			OperationID:      "removeTagsFromCluster",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *TagsSpec
			Params   = RemoveTagsFromClusterParams
			Response = RemoveTagsFromClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRemoveTagsFromClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RemoveTagsFromCluster(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RemoveTagsFromCluster(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRemoveTagsFromClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRemoveTagsFromDomainRequest handles removeTagsFromDomain operation.
//
// Remove Tags From Domain.
//
// DELETE /v1/domains/{id}/tags
func (s *Server) handleRemoveTagsFromDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RemoveTagsFromDomain",
			ID:   "removeTagsFromDomain",
		}
	)
	params, err := decodeRemoveTagsFromDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeRemoveTagsFromDomainRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RemoveTagsFromDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RemoveTagsFromDomain",
			OperationSummary: "remove Tags From Domain",
			OperationID:      "removeTagsFromDomain",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *TagsSpec
			Params   = RemoveTagsFromDomainParams
			Response = RemoveTagsFromDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRemoveTagsFromDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RemoveTagsFromDomain(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RemoveTagsFromDomain(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRemoveTagsFromDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRemoveTagsFromHostRequest handles removeTagsFromHost operation.
//
// Remove Tags From Host.
//
// DELETE /v1/hosts/{id}/tags
func (s *Server) handleRemoveTagsFromHostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RemoveTagsFromHost",
			ID:   "removeTagsFromHost",
		}
	)
	params, err := decodeRemoveTagsFromHostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeRemoveTagsFromHostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RemoveTagsFromHostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RemoveTagsFromHost",
			OperationSummary: "",
			OperationID:      "removeTagsFromHost",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *TagsSpec
			Params   = RemoveTagsFromHostParams
			Response = RemoveTagsFromHostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRemoveTagsFromHostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RemoveTagsFromHost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RemoveTagsFromHost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRemoveTagsFromHostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRemoveUserRequest handles removeUser operation.
//
// Delete the user by the ID, if it exists.
//
// DELETE /v1/users/{id}
func (s *Server) handleRemoveUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RemoveUser",
			ID:   "removeUser",
		}
	)
	params, err := decodeRemoveUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response RemoveUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RemoveUser",
			OperationSummary: "Remove access for a user in SDDC Manager",
			OperationID:      "removeUser",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RemoveUserParams
			Response = RemoveUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRemoveUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RemoveUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RemoveUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRemoveUserResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRemoveVasaProviderRequest handles removeVasaProvider operation.
//
// Delete a VASA Provider.
//
// DELETE /v1/vasa-providers/{id}
func (s *Server) handleRemoveVasaProviderRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RemoveVasaProvider",
			ID:   "removeVasaProvider",
		}
	)
	params, err := decodeRemoveVasaProviderParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response RemoveVasaProviderRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RemoveVasaProvider",
			OperationSummary: "Delete a VASA Provider",
			OperationID:      "removeVasaProvider",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RemoveVasaProviderParams
			Response = RemoveVasaProviderRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRemoveVasaProviderParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RemoveVasaProvider(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RemoveVasaProvider(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRemoveVasaProviderResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRemoveVasaProviderStorageContainerRequest handles removeVasaProviderStorageContainer operation.
//
// Delete a storage container of a VASA Provider.
//
// DELETE /v1/vasa-providers/{id}/storage-containers/{storageContainerId}
func (s *Server) handleRemoveVasaProviderStorageContainerRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RemoveVasaProviderStorageContainer",
			ID:   "removeVasaProviderStorageContainer",
		}
	)
	params, err := decodeRemoveVasaProviderStorageContainerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response RemoveVasaProviderStorageContainerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RemoveVasaProviderStorageContainer",
			OperationSummary: "Delete a storage container of a VASA Provider",
			OperationID:      "removeVasaProviderStorageContainer",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "storageContainerId",
					In:   "path",
				}: params.StorageContainerId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RemoveVasaProviderStorageContainerParams
			Response = RemoveVasaProviderStorageContainerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRemoveVasaProviderStorageContainerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RemoveVasaProviderStorageContainer(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RemoveVasaProviderStorageContainer(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRemoveVasaProviderStorageContainerResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRenameCustomIsoByIdRequest handles renameCustomIsoById operation.
//
// Rename the Custom ISO corresponding to the ID.
//
// PATCH /v1/custom-isos/{custom_iso_id}
func (s *Server) handleRenameCustomIsoByIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RenameCustomIsoById",
			ID:   "renameCustomIsoById",
		}
	)
	params, err := decodeRenameCustomIsoByIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeRenameCustomIsoByIdRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RenameCustomIsoByIdRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RenameCustomIsoById",
			OperationSummary: "Rename the Custom ISO corresponding to the ID",
			OperationID:      "renameCustomIsoById",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "custom_iso_id",
					In:   "path",
				}: params.CustomIsoID,
			},
			Raw: r,
		}

		type (
			Request  = *CustomIsoRenameSpec
			Params   = RenameCustomIsoByIdParams
			Response = RenameCustomIsoByIdRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRenameCustomIsoByIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RenameCustomIsoById(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RenameCustomIsoById(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRenameCustomIsoByIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRenamePersonalityByIdRequest handles renamePersonalityById operation.
//
// Rename personality with the ID passed in the URL.
//
// PATCH /v1/personalities/{personalityId}
func (s *Server) handleRenamePersonalityByIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RenamePersonalityById",
			ID:   "renamePersonalityById",
		}
	)
	params, err := decodeRenamePersonalityByIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeRenamePersonalityByIdRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RenamePersonalityByIdRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RenamePersonalityById",
			OperationSummary: "Rename personality based on ID",
			OperationID:      "renamePersonalityById",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "personalityId",
					In:   "path",
				}: params.PersonalityId,
			},
			Raw: r,
		}

		type (
			Request  = *Personality
			Params   = RenamePersonalityByIdParams
			Response = RenamePersonalityByIdRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRenamePersonalityByIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RenamePersonalityById(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RenamePersonalityById(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRenamePersonalityByIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReplaceCertificatesRequest handles replaceCertificates operation.
//
// Replace certificate(s) for the selected resource(s) in a domain.
//
// PATCH /v1/domains/{id}/certificates
func (s *Server) handleReplaceCertificatesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReplaceCertificates",
			ID:   "replaceCertificates",
		}
	)
	params, err := decodeReplaceCertificatesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReplaceCertificatesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReplaceCertificatesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReplaceCertificates",
			OperationSummary: "Replace certificate(s) for the selected resource(s) in a domain",
			OperationID:      "replaceCertificates",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *CertificateOperationSpec
			Params   = ReplaceCertificatesParams
			Response = ReplaceCertificatesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReplaceCertificatesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReplaceCertificates(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReplaceCertificates(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReplaceCertificatesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReplaceResourceCertificatesRequest handles replaceResourceCertificates operation.
//
// Replace resource certificates.
//
// PUT /v1/domains/{id}/resource-certificates
func (s *Server) handleReplaceResourceCertificatesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReplaceResourceCertificates",
			ID:   "replaceResourceCertificates",
		}
	)
	params, err := decodeReplaceResourceCertificatesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReplaceResourceCertificatesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReplaceResourceCertificatesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReplaceResourceCertificates",
			OperationSummary: "Replace the certificate(s) for selected resources of a domain",
			OperationID:      "replaceResourceCertificates",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = []ResourceCertificateSpec
			Params   = ReplaceResourceCertificatesParams
			Response = ReplaceResourceCertificatesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReplaceResourceCertificatesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReplaceResourceCertificates(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReplaceResourceCertificates(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReplaceResourceCertificatesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRetryComplianceAuditTaskRequest handles retryComplianceAuditTask operation.
//
// Retry compliance audit task.
//
// PATCH /v1/domains/{id}/compliance-audits/tasks/{taskId}
func (s *Server) handleRetryComplianceAuditTaskRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RetryComplianceAuditTask",
			ID:   "retryComplianceAuditTask",
		}
	)
	params, err := decodeRetryComplianceAuditTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response RetryComplianceAuditTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RetryComplianceAuditTask",
			OperationSummary: "Retry compliance audit task",
			OperationID:      "retryComplianceAuditTask",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RetryComplianceAuditTaskParams
			Response = RetryComplianceAuditTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRetryComplianceAuditTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RetryComplianceAuditTask(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RetryComplianceAuditTask(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRetryComplianceAuditTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRetryCredentialsTaskRequest handles retryCredentialsTask operation.
//
// Retry a failed credentials task for a given ID.
//
// PATCH /v1/credentials/tasks/{id}
func (s *Server) handleRetryCredentialsTaskRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RetryCredentialsTask",
			ID:   "retryCredentialsTask",
		}
	)
	params, err := decodeRetryCredentialsTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeRetryCredentialsTaskRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RetryCredentialsTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RetryCredentialsTask",
			OperationSummary: "Retry a failed credentials task for a given ID",
			OperationID:      "retryCredentialsTask",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *CredentialsUpdateSpec
			Params   = RetryCredentialsTaskParams
			Response = RetryCredentialsTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRetryCredentialsTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RetryCredentialsTask(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RetryCredentialsTask(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRetryCredentialsTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRetrySddcRequest handles retrySddc operation.
//
// Retry failed SDDC creation.
//
// PATCH /v1/sddcs/{id}
func (s *Server) handleRetrySddcRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RetrySddc",
			ID:   "retrySddc",
		}
	)
	params, err := decodeRetrySddcParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeRetrySddcRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RetrySddcRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RetrySddc",
			OperationSummary: "Retry failed SDDC creation",
			OperationID:      "retrySddc",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = OptSddcSpec
			Params   = RetrySddcParams
			Response = RetrySddcRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRetrySddcParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RetrySddc(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RetrySddc(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRetrySddcResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRetryTaskRequest handles retryTask operation.
//
// Retry a failed Task by ID, if it exists.
//
// PATCH /v1/tasks/{id}
func (s *Server) handleRetryTaskRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RetryTask",
			ID:   "retryTask",
		}
	)
	params, err := decodeRetryTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response RetryTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RetryTask",
			OperationSummary: "Retry a Task",
			OperationID:      "retryTask",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RetryTaskParams
			Response = RetryTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRetryTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RetryTask(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RetryTask(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRetryTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRollbackVrslcmRequest handles rollbackVrslcm operation.
//
// Triggers the VMware Aria Suite Lifecycle rollback operation and returns an URL in the headers to
// track the operation status.
//
// DELETE /v1/vrslcm
func (s *Server) handleRollbackVrslcmRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response RollbackVrslcmRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RollbackVrslcm",
			OperationSummary: "Remove VMware Aria Suite Lifecycle after an unsuccessful deployment",
			OperationID:      "rollbackVrslcm",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = RollbackVrslcmRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RollbackVrslcm(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.RollbackVrslcm(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRollbackVrslcmResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSetBackupConfigurationRequest handles setBackupConfiguration operation.
//
// Configure the backup configuration for SDDC Manager and NSX Manager.
//
// PUT /v1/system/backup-configuration
func (s *Server) handleSetBackupConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SetBackupConfiguration",
			ID:   "setBackupConfiguration",
		}
	)
	request, close, err := s.decodeSetBackupConfigurationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SetBackupConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SetBackupConfiguration",
			OperationSummary: "Configure the backup configuration for SDDC Manager and NSX Manager",
			OperationID:      "setBackupConfiguration",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *BackupConfigurationSpec
			Params   = struct{}
			Response = SetBackupConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SetBackupConfiguration(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SetBackupConfiguration(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSetBackupConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSetCeipStatusRequest handles setCeipStatus operation.
//
// Opt-in or Opt-out of CEIP.
//
// PATCH /v1/system/ceip
func (s *Server) handleSetCeipStatusRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SetCeipStatus",
			ID:   "setCeipStatus",
		}
	)
	request, close, err := s.decodeSetCeipStatusRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SetCeipStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SetCeipStatus",
			OperationSummary: "Configure CEIP to Opt-In or Opt-Out",
			OperationID:      "setCeipStatus",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = SetCeipStatusReq
			Params   = struct{}
			Response = SetCeipStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SetCeipStatus(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SetCeipStatus(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSetCeipStatusResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSetLicenseKeyForResourceRequest handles setLicenseKeyForResource operation.
//
// Update a license key for a resource.
//
// PUT /v1/resources/licensing-infos
func (s *Server) handleSetLicenseKeyForResourceRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SetLicenseKeyForResource",
			ID:   "setLicenseKeyForResource",
		}
	)
	request, close, err := s.decodeSetLicenseKeyForResourceRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SetLicenseKeyForResourceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SetLicenseKeyForResource",
			OperationSummary: "Update a license key for a resource",
			OperationID:      "setLicenseKeyForResource",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *LicensingSpec
			Params   = struct{}
			Response = SetLicenseKeyForResourceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SetLicenseKeyForResource(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SetLicenseKeyForResource(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSetLicenseKeyForResourceResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStartBackupRequest handles startBackup operation.
//
// Start a backup operation.
//
// POST /v1/backups/tasks
func (s *Server) handleStartBackupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "StartBackup",
			ID:   "startBackup",
		}
	)
	request, close, err := s.decodeStartBackupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response StartBackupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "StartBackup",
			OperationSummary: "Start a backup operation",
			OperationID:      "startBackup",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *BackupSpec
			Params   = struct{}
			Response = StartBackupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.StartBackup(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.StartBackup(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeStartBackupResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStartBringupRequest handles startBringup operation.
//
// Deploy a management domain.
//
// POST /v1/sddcs
func (s *Server) handleStartBringupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "StartBringup",
			ID:   "startBringup",
		}
	)
	request, close, err := s.decodeStartBringupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response StartBringupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "StartBringup",
			OperationSummary: "Deploy a management domain",
			OperationID:      "startBringup",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *SddcSpec
			Params   = struct{}
			Response = StartBringupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.StartBringup(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.StartBringup(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeStartBringupResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStartBringupSpecConversionRequest handles startBringupSpecConversion operation.
//
// SDDC specification incorporates all the client inputs regarding VMW component parameters
// constituting the SDDC: NTP, DNS spec, ESXi, VC, VSAN, NSX spec et al.
//
// POST /v1/system/sddc-spec-converter
func (s *Server) handleStartBringupSpecConversionRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "StartBringupSpecConversion",
			ID:   "startBringupSpecConversion",
		}
	)
	params, err := decodeStartBringupSpecConversionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeStartBringupSpecConversionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response StartBringupSpecConversionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "StartBringupSpecConversion",
			OperationSummary: "Convert SDDC specification Json/Excel File",
			OperationID:      "startBringupSpecConversion",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "design",
					In:   "query",
				}: params.Design,
			},
			Raw: r,
		}

		type (
			Request  = OptStartBringupSpecConversionReq
			Params   = StartBringupSpecConversionParams
			Response = StartBringupSpecConversionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackStartBringupSpecConversionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.StartBringupSpecConversion(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.StartBringupSpecConversion(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeStartBringupSpecConversionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStartBundleDownloadByIDRequest handles startBundleDownloadByID operation.
//
// Update a Bundle for scheduling/triggering download. Only one download can triggered for a Bundle.
//
// PATCH /v1/bundles/{id}
func (s *Server) handleStartBundleDownloadByIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "StartBundleDownloadByID",
			ID:   "startBundleDownloadByID",
		}
	)
	params, err := decodeStartBundleDownloadByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeStartBundleDownloadByIDRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response StartBundleDownloadByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "StartBundleDownloadByID",
			OperationSummary: "Start immediate download or schedule download of a bundle by ID",
			OperationID:      "startBundleDownloadByID",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *BundleUpdateSpec
			Params   = StartBundleDownloadByIDParams
			Response = StartBundleDownloadByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackStartBundleDownloadByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.StartBundleDownloadByID(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.StartBundleDownloadByID(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeStartBundleDownloadByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStartHealthCheckRequest handles startHealthCheck operation.
//
// Start a Health Check operation using SoS.
//
// POST /v1/system/health-summary
func (s *Server) handleStartHealthCheckRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "StartHealthCheck",
			ID:   "startHealthCheck",
		}
	)
	request, close, err := s.decodeStartHealthCheckRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response StartHealthCheckRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "StartHealthCheck",
			OperationSummary: "Start a Health Check operation using SoS",
			OperationID:      "startHealthCheck",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *HealthSummarySpec
			Params   = struct{}
			Response = StartHealthCheckRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.StartHealthCheck(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.StartHealthCheck(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeStartHealthCheckResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStartNsxCriteriaQueryRequest handles startNsxCriteriaQuery operation.
//
// Start a query with NSX Criteria.
//
// POST /v1/nsxt-clusters/queries
func (s *Server) handleStartNsxCriteriaQueryRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "StartNsxCriteriaQuery",
			ID:   "startNsxCriteriaQuery",
		}
	)
	request, close, err := s.decodeStartNsxCriteriaQueryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response StartNsxCriteriaQueryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "StartNsxCriteriaQuery",
			OperationSummary: "Start a query with NSX Criteria",
			OperationID:      "startNsxCriteriaQuery",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *NsxTCriterion
			Params   = struct{}
			Response = StartNsxCriteriaQueryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.StartNsxCriteriaQuery(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.StartNsxCriteriaQuery(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeStartNsxCriteriaQueryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStartPrecheckRequest handles startPrecheck operation.
//
// Perform precheck of resource(ex: Domain, Cluster). If only resource is specified, all
// resources/software components under it are included. If resource(Domain, Cluster etc) and specific
// resources/software components are provided, only those are included in precheck. As this API is
// deprecated, please use the new LCM Prechecks API - /v1/system/check-sets/queries and
// /v1/system/check-sets.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /v1/system/prechecks
func (s *Server) handleStartPrecheckRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "StartPrecheck",
			ID:   "startPrecheck",
		}
	)
	request, close, err := s.decodeStartPrecheckRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response StartPrecheckRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "StartPrecheck",
			OperationSummary: "Start a system precheck",
			OperationID:      "startPrecheck",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *PrecheckSpec
			Params   = struct{}
			Response = StartPrecheckRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.StartPrecheck(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.StartPrecheck(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeStartPrecheckResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStartRestoreRequest handles startRestore operation.
//
// Start a restore operation.
//
// POST /v1/restores/tasks
func (s *Server) handleStartRestoreRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "StartRestore",
			ID:   "startRestore",
		}
	)
	request, close, err := s.decodeStartRestoreRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response StartRestoreRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "StartRestore",
			OperationSummary: "Start a restore operation",
			OperationID:      "startRestore",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *RestoreSpec
			Params   = struct{}
			Response = StartRestoreRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.StartRestore(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.StartRestore(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeStartRestoreResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStartSupportBundleRequest handles startSupportBundle operation.
//
// Start a Support Bundle operation using SoS.
//
// POST /v1/system/support-bundles
func (s *Server) handleStartSupportBundleRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "StartSupportBundle",
			ID:   "startSupportBundle",
		}
	)
	request, close, err := s.decodeStartSupportBundleRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response StartSupportBundleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "StartSupportBundle",
			OperationSummary: "Start a Support Bundle operation using SoS",
			OperationID:      "startSupportBundle",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *SupportBundleSpec
			Params   = struct{}
			Response = StartSupportBundleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.StartSupportBundle(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.StartSupportBundle(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeStartSupportBundleResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleStartUpgradePrecheckRequest handles startUpgradePrecheck operation.
//
// Perform Upgrade Prechecks.
//
// POST /v1/upgrades/{upgradeId}/prechecks
func (s *Server) handleStartUpgradePrecheckRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "StartUpgradePrecheck",
			ID:   "startUpgradePrecheck",
		}
	)
	params, err := decodeStartUpgradePrecheckParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response StartUpgradePrecheckRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "StartUpgradePrecheck",
			OperationSummary: "Start an upgrade precheck operation",
			OperationID:      "startUpgradePrecheck",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "upgradeId",
					In:   "path",
				}: params.UpgradeId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = StartUpgradePrecheckParams
			Response = StartUpgradePrecheckRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackStartUpgradePrecheckParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.StartUpgradePrecheck(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.StartUpgradePrecheck(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeStartUpgradePrecheckResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTriggerCheckRunRequest handles triggerCheckRun operation.
//
// Trigger a run of the selected checks.
//
// POST /v1/system/check-sets
func (s *Server) handleTriggerCheckRunRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TriggerCheckRun",
			ID:   "triggerCheckRun",
		}
	)
	request, close, err := s.decodeTriggerCheckRunRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TriggerCheckRunRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "TriggerCheckRun",
			OperationSummary: "Trigger a run of the selected checks",
			OperationID:      "triggerCheckRun",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *CheckSetRunInput
			Params   = struct{}
			Response = TriggerCheckRunRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TriggerCheckRun(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.TriggerCheckRun(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTriggerCheckRunResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTriggerPartialRetryOfCheckRunRequest handles triggerPartialRetryOfCheckRun operation.
//
// Trigger partial retry of a completed check run.
//
// PATCH /v1/system/check-sets/{runId}
func (s *Server) handleTriggerPartialRetryOfCheckRunRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TriggerPartialRetryOfCheckRun",
			ID:   "triggerPartialRetryOfCheckRun",
		}
	)
	params, err := decodeTriggerPartialRetryOfCheckRunParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTriggerPartialRetryOfCheckRunRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TriggerPartialRetryOfCheckRunRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "TriggerPartialRetryOfCheckRun",
			OperationSummary: "Trigger partial retry of a completed check run",
			OperationID:      "triggerPartialRetryOfCheckRun",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "runId",
					In:   "path",
				}: params.RunId,
			},
			Raw: r,
		}

		type (
			Request  = *AssessmentPartialRetryInput
			Params   = TriggerPartialRetryOfCheckRunParams
			Response = TriggerPartialRetryOfCheckRunRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTriggerPartialRetryOfCheckRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TriggerPartialRetryOfCheckRun(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TriggerPartialRetryOfCheckRun(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTriggerPartialRetryOfCheckRunResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateBackupConfigurationRequest handles updateBackupConfiguration operation.
//
// Update the backup configuration for SDDC Manager and NSX Manager.
//
// PATCH /v1/system/backup-configuration
func (s *Server) handleUpdateBackupConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateBackupConfiguration",
			ID:   "updateBackupConfiguration",
		}
	)
	request, close, err := s.decodeUpdateBackupConfigurationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateBackupConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateBackupConfiguration",
			OperationSummary: "Update the backup configuration for SDDC Manager and NSX Manager",
			OperationID:      "updateBackupConfiguration",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *BackupConfigurationSpec
			Params   = struct{}
			Response = UpdateBackupConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateBackupConfiguration(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateBackupConfiguration(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateBackupConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateBundleCompatibilitySetsRequest handles updateBundleCompatibilitySets operation.
//
// Update software compatibility sets for Bundles.
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /v1/bundles/
func (s *Server) handleUpdateBundleCompatibilitySetsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateBundleCompatibilitySets",
			ID:   "updateBundleCompatibilitySets",
		}
	)
	request, close, err := s.decodeUpdateBundleCompatibilitySetsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateBundleCompatibilitySetsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateBundleCompatibilitySets",
			OperationSummary: "Update the software compatability set for all bundles",
			OperationID:      "updateBundleCompatibilitySets",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *BundleUpdateSpec
			Params   = struct{}
			Response = UpdateBundleCompatibilitySetsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateBundleCompatibilitySets(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateBundleCompatibilitySets(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateBundleCompatibilitySetsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateClusterRequest handles updateCluster operation.
//
// Update a Cluster by adding or removing Hosts, Stretching a standard vSAN cluster, Unstretching a
// stretched cluster or by marking for deletion.
//
// PATCH /v1/clusters/{id}
func (s *Server) handleUpdateClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateCluster",
			ID:   "updateCluster",
		}
	)
	params, err := decodeUpdateClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateClusterRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateCluster",
			OperationSummary: "Update a Cluster by adding or removing Hosts, Stretching a standard vSAN cluster, Unstretching a stretched cluster or by marking for deletion",
			OperationID:      "updateCluster",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *ClusterUpdateSpec
			Params   = UpdateClusterParams
			Response = UpdateClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateCluster(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateCluster(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateDepotSettingsRequest handles updateDepotSettings operation.
//
// Update depot settings. Depot settings can be updated with VMware Depot account.
//
// PUT /v1/system/settings/depot
func (s *Server) handleUpdateDepotSettingsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateDepotSettings",
			ID:   "updateDepotSettings",
		}
	)
	request, close, err := s.decodeUpdateDepotSettingsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateDepotSettingsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateDepotSettings",
			OperationSummary: "Configure the depot credentials",
			OperationID:      "updateDepotSettings",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *DepotSettings
			Params   = struct{}
			Response = UpdateDepotSettingsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateDepotSettings(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateDepotSettings(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateDepotSettingsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateDomainRequest handles updateDomain operation.
//
// Update a Domain.
//
// PATCH /v1/domains/{id}
func (s *Server) handleUpdateDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateDomain",
			ID:   "updateDomain",
		}
	)
	params, err := decodeUpdateDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateDomainRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateDomain",
			OperationSummary: "Update a Domain",
			OperationID:      "updateDomain",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *DomainUpdateSpec
			Params   = UpdateDomainParams
			Response = UpdateDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateDomain(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateDomain(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateEdgeClusterRequest handles updateEdgeCluster operation.
//
// Expand or shrink an NSX Edge Cluster.
//
// PATCH /v1/edge-clusters/{id}
func (s *Server) handleUpdateEdgeClusterRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateEdgeCluster",
			ID:   "updateEdgeCluster",
		}
	)
	params, err := decodeUpdateEdgeClusterParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateEdgeClusterRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateEdgeClusterRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateEdgeCluster",
			OperationSummary: "Expand or shrink an NSX Edge Cluster",
			OperationID:      "updateEdgeCluster",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *EdgeClusterUpdateSpec
			Params   = UpdateEdgeClusterParams
			Response = UpdateEdgeClusterRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateEdgeClusterParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateEdgeCluster(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateEdgeCluster(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateEdgeClusterResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateLicenseKeyRequest handles updateLicenseKey operation.
//
// Update the license key.
//
// PATCH /v1/license-keys/{key}
func (s *Server) handleUpdateLicenseKeyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateLicenseKey",
			ID:   "updateLicenseKey",
		}
	)
	params, err := decodeUpdateLicenseKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateLicenseKeyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateLicenseKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateLicenseKey",
			OperationSummary: "Update the license key",
			OperationID:      "updateLicenseKey",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "key",
					In:   "path",
				}: params.Key,
			},
			Raw: r,
		}

		type (
			Request  = *LicenseKeyUpdateSpec
			Params   = UpdateLicenseKeyParams
			Response = UpdateLicenseKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateLicenseKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateLicenseKey(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateLicenseKey(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateLicenseKeyResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateLocalUserPasswordRequest handles updateLocalUserPassword operation.
//
// Update the password for local account only if the old password is correct, or if user configures
// the local account for the first time.
//
// PATCH /v1/users/local/admin
func (s *Server) handleUpdateLocalUserPasswordRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateLocalUserPassword",
			ID:   "updateLocalUserPassword",
		}
	)
	request, close, err := s.decodeUpdateLocalUserPasswordRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateLocalUserPasswordRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateLocalUserPassword",
			OperationSummary: "Update password for local account",
			OperationID:      "updateLocalUserPassword",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *LocalAccountPasswordInfo
			Params   = struct{}
			Response = UpdateLocalUserPasswordRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateLocalUserPassword(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateLocalUserPassword(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateLocalUserPasswordResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateNetworkPoolRequest handles updateNetworkPool operation.
//
// Update a Network Pool by ID, if it exists.
//
// PATCH /v1/network-pools/{id}
func (s *Server) handleUpdateNetworkPoolRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateNetworkPool",
			ID:   "updateNetworkPool",
		}
	)
	params, err := decodeUpdateNetworkPoolParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateNetworkPoolRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateNetworkPoolRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateNetworkPool",
			OperationSummary: "Update Network Pool",
			OperationID:      "updateNetworkPool",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *NetworkPoolUpdateSpec
			Params   = UpdateNetworkPoolParams
			Response = UpdateNetworkPoolRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateNetworkPoolParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateNetworkPool(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateNetworkPool(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateNetworkPoolResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateOrRotatePasswordsRequest handles updateOrRotatePasswords operation.
//
// Update passwords for given list of resources by supplying new passwords or rotate the passwords
// using system generated passwords.
//
// PATCH /v1/credentials
func (s *Server) handleUpdateOrRotatePasswordsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateOrRotatePasswords",
			ID:   "updateOrRotatePasswords",
		}
	)
	request, close, err := s.decodeUpdateOrRotatePasswordsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateOrRotatePasswordsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateOrRotatePasswords",
			OperationSummary: "Update or rotate passwords for a list of resources",
			OperationID:      "updateOrRotatePasswords",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *CredentialsUpdateSpec
			Params   = struct{}
			Response = UpdateOrRotatePasswordsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateOrRotatePasswords(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateOrRotatePasswords(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateOrRotatePasswordsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateReleaseByDomainIDRequest handles updateReleaseByDomainID operation.
//
// Update last selected upgrade version for the domain.
//
// PATCH /v1/releases/domains/{domainId}
func (s *Server) handleUpdateReleaseByDomainIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateReleaseByDomainID",
			ID:   "updateReleaseByDomainID",
		}
	)
	params, err := decodeUpdateReleaseByDomainIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateReleaseByDomainIDRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateReleaseByDomainIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateReleaseByDomainID",
			OperationSummary: "Modify the target upgrade release for a domain by its ID",
			OperationID:      "updateReleaseByDomainID",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = OptDomainRelease
			Params   = UpdateReleaseByDomainIDParams
			Response = UpdateReleaseByDomainIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateReleaseByDomainIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateReleaseByDomainID(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateReleaseByDomainID(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateReleaseByDomainIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateResourcesFunctionalitiesRequest handles updateResourcesFunctionalities operation.
//
// Update Resources Functionalities.
//
// PATCH /v1/resource-functionalities
func (s *Server) handleUpdateResourcesFunctionalitiesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateResourcesFunctionalities",
			ID:   "updateResourcesFunctionalities",
		}
	)
	request, close, err := s.decodeUpdateResourcesFunctionalitiesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateResourcesFunctionalitiesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateResourcesFunctionalities",
			OperationSummary: "Update Resources Functionalities",
			OperationID:      "updateResourcesFunctionalities",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *ResourceFunctionalitiesUpdateSpec
			Params   = struct{}
			Response = UpdateResourcesFunctionalitiesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateResourcesFunctionalities(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateResourcesFunctionalities(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateResourcesFunctionalitiesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateResourcesFunctionalities1Request handles updateResourcesFunctionalities_1 operation.
//
// Update Resources Functionalities Is Allowed Global Configuration.
//
// PATCH /v1/resource-functionalities/global
func (s *Server) handleUpdateResourcesFunctionalities1Request(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateResourcesFunctionalities1",
			ID:   "updateResourcesFunctionalities_1",
		}
	)
	request, close, err := s.decodeUpdateResourcesFunctionalities1Request(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateResourcesFunctionalities1Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateResourcesFunctionalities1",
			OperationSummary: "Update Resources Functionalities Is Allowed Global Configuration",
			OperationID:      "updateResourcesFunctionalities_1",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *ResourceFunctionalitiesGlobalUpdateSpec
			Params   = struct{}
			Response = UpdateResourcesFunctionalities1Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateResourcesFunctionalities1(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateResourcesFunctionalities1(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateResourcesFunctionalities1Response(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateSystemConfigurationRequest handles updateSystemConfiguration operation.
//
// Updates paramters of the system configuration.
//
// PATCH /v1/system
func (s *Server) handleUpdateSystemConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateSystemConfiguration",
			ID:   "updateSystemConfiguration",
		}
	)
	request, close, err := s.decodeUpdateSystemConfigurationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateSystemConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateSystemConfiguration",
			OperationSummary: "Updates paramters of the system configuration",
			OperationID:      "updateSystemConfiguration",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *SystemUpdateSpec
			Params   = struct{}
			Response = UpdateSystemConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateSystemConfiguration(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateSystemConfiguration(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateSystemConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateUpgradeScheduleRequest handles updateUpgradeSchedule operation.
//
// Commit/Reschedule an existing upgrade. It moves the upgrade from DRAFT state to SCHEDULED state
// and/or changes the upgrade scheduled date/time.
//
// PATCH /v1/upgrades/{upgradeId}
func (s *Server) handleUpdateUpgradeScheduleRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateUpgradeSchedule",
			ID:   "updateUpgradeSchedule",
		}
	)
	params, err := decodeUpdateUpgradeScheduleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateUpgradeScheduleRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateUpgradeScheduleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateUpgradeSchedule",
			OperationSummary: "Change a DRAFT upgrade to a SCHEDULED state",
			OperationID:      "updateUpgradeSchedule",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "upgradeId",
					In:   "path",
				}: params.UpgradeId,
			},
			Raw: r,
		}

		type (
			Request  = *UpgradeCommitSpec
			Params   = UpdateUpgradeScheduleParams
			Response = UpdateUpgradeScheduleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateUpgradeScheduleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateUpgradeSchedule(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateUpgradeSchedule(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateUpgradeScheduleResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateVasaProviderRequest handles updateVasaProvider operation.
//
// Update a VASA Provider.
//
// PATCH /v1/vasa-providers/{id}
func (s *Server) handleUpdateVasaProviderRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateVasaProvider",
			ID:   "updateVasaProvider",
		}
	)
	params, err := decodeUpdateVasaProviderParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateVasaProviderRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateVasaProviderRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateVasaProvider",
			OperationSummary: "Update a VASA Provider",
			OperationID:      "updateVasaProvider",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *VasaProviderUpdateSpec
			Params   = UpdateVasaProviderParams
			Response = UpdateVasaProviderRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateVasaProviderParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateVasaProvider(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateVasaProvider(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateVasaProviderResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateVasaProviderStorageContainerRequest handles updateVasaProviderStorageContainer operation.
//
// Update the storage container of a VASA Provider.
//
// PATCH /v1/vasa-providers/{id}/storage-containers/{storageContainerId}
func (s *Server) handleUpdateVasaProviderStorageContainerRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateVasaProviderStorageContainer",
			ID:   "updateVasaProviderStorageContainer",
		}
	)
	params, err := decodeUpdateVasaProviderStorageContainerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateVasaProviderStorageContainerRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateVasaProviderStorageContainerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateVasaProviderStorageContainer",
			OperationSummary: "Update the storage container of a VASA Provider",
			OperationID:      "updateVasaProviderStorageContainer",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "storageContainerId",
					In:   "path",
				}: params.StorageContainerId,
			},
			Raw: r,
		}

		type (
			Request  = *StorageContainerUpdateSpec
			Params   = UpdateVasaProviderStorageContainerParams
			Response = UpdateVasaProviderStorageContainerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateVasaProviderStorageContainerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateVasaProviderStorageContainer(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateVasaProviderStorageContainer(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateVasaProviderStorageContainerResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateVasaProviderUserRequest handles updateVasaProviderUser operation.
//
// Update the user of a VASA Provider.
//
// PATCH /v1/vasa-providers/{id}/users/{userId}
func (s *Server) handleUpdateVasaProviderUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateVasaProviderUser",
			ID:   "updateVasaProviderUser",
		}
	)
	params, err := decodeUpdateVasaProviderUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateVasaProviderUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateVasaProviderUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateVasaProviderUser",
			OperationSummary: "Update the user of a VASA Provider",
			OperationID:      "updateVasaProviderUser",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
			},
			Raw: r,
		}

		type (
			Request  = *VasaUserUpdateSpec
			Params   = UpdateVasaProviderUserParams
			Response = UpdateVasaProviderUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateVasaProviderUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateVasaProviderUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateVasaProviderUser(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateVasaProviderUserResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateVersionAliasConfigurationRequest handles updateVersionAliasConfiguration operation.
//
// Update Version Alias Configuration.
//
// PUT /v1/system/settings/version-aliases/{bundleComponentType}/{version}
func (s *Server) handleUpdateVersionAliasConfigurationRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateVersionAliasConfiguration",
			ID:   "updateVersionAliasConfiguration",
		}
	)
	params, err := decodeUpdateVersionAliasConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateVersionAliasConfigurationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateVersionAliasConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateVersionAliasConfiguration",
			OperationSummary: "Update the Version Alias Configuration by component type",
			OperationID:      "updateVersionAliasConfiguration",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "bundleComponentType",
					In:   "path",
				}: params.BundleComponentType,
				{
					Name: "version",
					In:   "path",
				}: params.Version,
			},
			Raw: r,
		}

		type (
			Request  = *AliasSpec
			Params   = UpdateVersionAliasConfigurationParams
			Response = UpdateVersionAliasConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateVersionAliasConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateVersionAliasConfiguration(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateVersionAliasConfiguration(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateVersionAliasConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateVersionAliasConfigurationsRequest handles updateVersionAliasConfigurations operation.
//
// Update Version Alias Configurations.
//
// PUT /v1/system/settings/version-aliases
func (s *Server) handleUpdateVersionAliasConfigurationsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateVersionAliasConfigurations",
			ID:   "updateVersionAliasConfigurations",
		}
	)
	request, close, err := s.decodeUpdateVersionAliasConfigurationsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateVersionAliasConfigurationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateVersionAliasConfigurations",
			OperationSummary: "Update Version Alias Configurations",
			OperationID:      "updateVersionAliasConfigurations",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *VersionAliasesForBundleComponentTypeSpec
			Params   = struct{}
			Response = UpdateVersionAliasConfigurationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateVersionAliasConfigurations(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateVersionAliasConfigurations(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateVersionAliasConfigurationsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateVrslcmVersionByIdInInventoryRequest handles updateVrslcmVersionByIdInInventory operation.
//
// Updates VMware Aria Suite Lifecycle version.
//
// PUT /v1/vrslcms/{id}
func (s *Server) handleUpdateVrslcmVersionByIdInInventoryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateVrslcmVersionByIdInInventory",
			ID:   "updateVrslcmVersionByIdInInventory",
		}
	)
	params, err := decodeUpdateVrslcmVersionByIdInInventoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateVrslcmVersionByIdInInventoryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateVrslcmVersionByIdInInventoryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateVrslcmVersionByIdInInventory",
			OperationSummary: "Update the version of VMware Aria Suite Lifecycle based on its ID",
			OperationID:      "updateVrslcmVersionByIdInInventory",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *Vrslcm
			Params   = UpdateVrslcmVersionByIdInInventoryParams
			Response = UpdateVrslcmVersionByIdInInventoryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateVrslcmVersionByIdInInventoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateVrslcmVersionByIdInInventory(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateVrslcmVersionByIdInInventory(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateVrslcmVersionByIdInInventoryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateVrslcmVersionInInventoryRequest handles updateVrslcmVersionInInventory operation.
//
// Updates VMware Aria Suite Lifecycle version in VCF inventory.
//
// PUT /v1/vrslcm
func (s *Server) handleUpdateVrslcmVersionInInventoryRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateVrslcmVersionInInventory",
			ID:   "updateVrslcmVersionInInventory",
		}
	)
	request, close, err := s.decodeUpdateVrslcmVersionInInventoryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateVrslcmVersionInInventoryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateVrslcmVersionInInventory",
			OperationSummary: "Update the version of VMware Aria Suite Lifecycle",
			OperationID:      "updateVrslcmVersionInInventory",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *Vrslcm
			Params   = struct{}
			Response = UpdateVrslcmVersionInInventoryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateVrslcmVersionInInventory(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateVrslcmVersionInInventory(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateVrslcmVersionInInventoryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateVsanHclConfigurationRequest handles updateVsanHclConfiguration operation.
//
// Update vSAN HCL configuration.
//
// PATCH /v1/vsan-hcl/configuration
func (s *Server) handleUpdateVsanHclConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateVsanHclConfiguration",
			ID:   "updateVsanHclConfiguration",
		}
	)
	request, close, err := s.decodeUpdateVsanHclConfigurationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateVsanHclConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateVsanHclConfiguration",
			OperationSummary: "Update vSAN HCL configuration",
			OperationID:      "updateVsanHclConfiguration",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *VsanHclConfiguration
			Params   = struct{}
			Response = UpdateVsanHclConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateVsanHclConfiguration(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateVsanHclConfiguration(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateVsanHclConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateVsanHealthCheckByDomainRequest handles updateVsanHealthCheckByDomain operation.
//
// Update vSAN health check status for domain.
//
// PATCH /v1/domains/{domainId}/health-checks
func (s *Server) handleUpdateVsanHealthCheckByDomainRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UpdateVsanHealthCheckByDomain",
			ID:   "updateVsanHealthCheckByDomain",
		}
	)
	params, err := decodeUpdateVsanHealthCheckByDomainParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateVsanHealthCheckByDomainRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateVsanHealthCheckByDomainRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UpdateVsanHealthCheckByDomain",
			OperationSummary: "Update the vSAN Health Check status for a domain",
			OperationID:      "updateVsanHealthCheckByDomain",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = []HealthCheckSpec
			Params   = UpdateVsanHealthCheckByDomainParams
			Response = UpdateVsanHealthCheckByDomainRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateVsanHealthCheckByDomainParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateVsanHealthCheckByDomain(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateVsanHealthCheckByDomain(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateVsanHealthCheckByDomainResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUploadBundleRequest handles uploadBundle operation.
//
// Upload Bundle to SDDC Manager. Used when you do not have internet connectivity for downloading
// bundles from VMWare/VxRail to SDDC Manager. The Bundles are manually downloaded from Depot using
// Bundle Transfer utility.
//
// POST /v1/bundles
func (s *Server) handleUploadBundleRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UploadBundle",
			ID:   "uploadBundle",
		}
	)
	request, close, err := s.decodeUploadBundleRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UploadBundleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UploadBundle",
			OperationSummary: "Upload a bundle to SDDC Manager",
			OperationID:      "uploadBundle",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *BundleUploadSpec
			Params   = struct{}
			Response = UploadBundleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UploadBundle(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UploadBundle(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUploadBundleResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUploadCertificatesRequest handles uploadCertificates operation.
//
// Upload certificates to the certificate store.
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /v1/domains/{id}/certificates/uploads
func (s *Server) handleUploadCertificatesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UploadCertificates",
			ID:   "uploadCertificates",
		}
	)
	params, err := decodeUploadCertificatesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUploadCertificatesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UploadCertificatesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UploadCertificates",
			OperationSummary: "Import certificate(s) to the certificate store for a domain",
			OperationID:      "uploadCertificates",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = OptUploadCertificatesReq
			Params   = UploadCertificatesParams
			Response = UploadCertificatesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUploadCertificatesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UploadCertificates(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UploadCertificates(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUploadCertificatesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUploadCustomIsoRequest handles uploadCustomIso operation.
//
// Upload Custom ISO to SDDC Manager.
//
// POST /v1/custom-isos/file
func (s *Server) handleUploadCustomIsoRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UploadCustomIso",
			ID:   "uploadCustomIso",
		}
	)
	params, err := decodeUploadCustomIsoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUploadCustomIsoRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UploadCustomIsoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UploadCustomIso",
			OperationSummary: "Upload a Custom ISO",
			OperationID:      "uploadCustomIso",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "query",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = OptUploadCustomIsoReq
			Params   = UploadCustomIsoParams
			Response = UploadCustomIsoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUploadCustomIsoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UploadCustomIso(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UploadCustomIso(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUploadCustomIsoResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUploadPersonalityRequest handles uploadPersonality operation.
//
// Upload Personality to SDDC Manager.
//
// POST /v1/personalities
func (s *Server) handleUploadPersonalityRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UploadPersonality",
			ID:   "uploadPersonality",
		}
	)
	request, close, err := s.decodeUploadPersonalityRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UploadPersonalityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UploadPersonality",
			OperationSummary: "Upload a Personality",
			OperationID:      "uploadPersonality",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *PersonalityUploadSpec
			Params   = struct{}
			Response = UploadPersonalityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UploadPersonality(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UploadPersonality(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUploadPersonalityResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUploadPersonalityFilesRequest handles uploadPersonalityFiles operation.
//
// Upload personality files to SDDC Manager.
//
// PUT /v1/personalities/files
func (s *Server) handleUploadPersonalityFilesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UploadPersonalityFiles",
			ID:   "uploadPersonalityFiles",
		}
	)
	request, close, err := s.decodeUploadPersonalityFilesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UploadPersonalityFilesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UploadPersonalityFiles",
			OperationSummary: "Upload personality files to SDDC Manager",
			OperationID:      "uploadPersonalityFiles",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = OptUploadPersonalityFilesReq
			Params   = struct{}
			Response = UploadPersonalityFilesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UploadPersonalityFiles(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UploadPersonalityFiles(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUploadPersonalityFilesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUploadProductVersionCatalogRequest handles uploadProductVersionCatalog operation.
//
// Upload product version catalog. Make sure product version is a valid one.
//
// POST /v1/product-version-catalog
func (s *Server) handleUploadProductVersionCatalogRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UploadProductVersionCatalog",
			ID:   "uploadProductVersionCatalog",
		}
	)
	request, close, err := s.decodeUploadProductVersionCatalogRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UploadProductVersionCatalogRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "UploadProductVersionCatalog",
			OperationSummary: "Upload product version catalog",
			OperationID:      "uploadProductVersionCatalog",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *ProductVersionCatalog
			Params   = struct{}
			Response = UploadProductVersionCatalogRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UploadProductVersionCatalog(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UploadProductVersionCatalog(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUploadProductVersionCatalogResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateALBClusterCreationSpecRequest handles validateALBClusterCreationSpec operation.
//
// Perform validiation of the NsxAlbControllerClusterSpec specification.
//
// POST /v1/nsx-alb-clusters/validations
func (s *Server) handleValidateALBClusterCreationSpecRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateALBClusterCreationSpec",
			ID:   "validateALBClusterCreationSpec",
		}
	)
	params, err := decodeValidateALBClusterCreationSpecParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeValidateALBClusterCreationSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateALBClusterCreationSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateALBClusterCreationSpec",
			OperationSummary: "Perform validiation of the NsxAlbControllerClusterSpec specification",
			OperationID:      "validateALBClusterCreationSpec",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "skipCompatibilityCheck",
					In:   "query",
				}: params.SkipCompatibilityCheck,
			},
			Raw: r,
		}

		type (
			Request  = *NsxAlbControllerClusterSpec
			Params   = ValidateALBClusterCreationSpecParams
			Response = ValidateALBClusterCreationSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackValidateALBClusterCreationSpecParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateALBClusterCreationSpec(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateALBClusterCreationSpec(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateALBClusterCreationSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateAvnSpecRequest handles validateAvnSpec operation.
//
// Returns Validation report.
//
// POST /v1/avns/validations
func (s *Server) handleValidateAvnSpecRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateAvnSpec",
			ID:   "validateAvnSpec",
		}
	)
	request, close, err := s.decodeValidateAvnSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateAvnSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateAvnSpec",
			OperationSummary: "Perform validation of the AvnsCreationSpec specification",
			OperationID:      "validateAvnSpec",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *AvnsCreationSpec
			Params   = struct{}
			Response = ValidateAvnSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateAvnSpec(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateAvnSpec(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateAvnSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateBackupConfigurationsOperationsRequest handles validateBackupConfigurationsOperations operation.
//
// Validation API for backup configuration for SDDC Manager and NSX Manager.
//
// POST /v1/system/backup-configuration/validations
func (s *Server) handleValidateBackupConfigurationsOperationsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateBackupConfigurationsOperations",
			ID:   "validateBackupConfigurationsOperations",
		}
	)
	request, close, err := s.decodeValidateBackupConfigurationsOperationsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateBackupConfigurationsOperationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateBackupConfigurationsOperations",
			OperationSummary: "Validation API for backup configuration for SDDC Manager and NSX Manager",
			OperationID:      "validateBackupConfigurationsOperations",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *BackupConfigurationSpec
			Params   = struct{}
			Response = ValidateBackupConfigurationsOperationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateBackupConfigurationsOperations(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateBackupConfigurationsOperations(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateBackupConfigurationsOperationsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateBringupSpecRequest handles validateBringupSpec operation.
//
// SDDC specification incorporates all the client inputs regarding VMW component parameters
// constituting the SDDC: NTP, DNS spec, ESXi, VC, VSAN, NSX spec et al.
//
// POST /v1/sddcs/validations
func (s *Server) handleValidateBringupSpecRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateBringupSpec",
			ID:   "validateBringupSpec",
		}
	)
	params, err := decodeValidateBringupSpecParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeValidateBringupSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateBringupSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateBringupSpec",
			OperationSummary: "Perform validation of the SddcSpec specification",
			OperationID:      "validateBringupSpec",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "redo",
					In:   "query",
				}: params.Redo,
				{
					Name: "name",
					In:   "query",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = *SddcSpec
			Params   = ValidateBringupSpecParams
			Response = ValidateBringupSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackValidateBringupSpecParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateBringupSpec(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateBringupSpec(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateBringupSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateClusterCreationSpecRequest handles validateClusterCreationSpec operation.
//
// Perform validation of the ClusterCreationSpec specification.
//
// POST /v1/clusters/validations
func (s *Server) handleValidateClusterCreationSpecRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateClusterCreationSpec",
			ID:   "validateClusterCreationSpec",
		}
	)
	params, err := decodeValidateClusterCreationSpecParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeValidateClusterCreationSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateClusterCreationSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateClusterCreationSpec",
			OperationSummary: "Perform validation of the ClusterCreationSpec specification",
			OperationID:      "validateClusterCreationSpec",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "hostsOnly",
					In:   "query",
				}: params.HostsOnly,
				{
					Name: "skipHostSwitchValidation",
					In:   "query",
				}: params.SkipHostSwitchValidation,
			},
			Raw: r,
		}

		type (
			Request  = *ClusterCreationSpec
			Params   = ValidateClusterCreationSpecParams
			Response = ValidateClusterCreationSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackValidateClusterCreationSpecParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateClusterCreationSpec(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateClusterCreationSpec(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateClusterCreationSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateClusterUpdateSpecRequest handles validateClusterUpdateSpec operation.
//
// Perform validation of the ClusterUpdateSpec specification.
//
// POST /v1/clusters/{id}/validations
func (s *Server) handleValidateClusterUpdateSpecRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateClusterUpdateSpec",
			ID:   "validateClusterUpdateSpec",
		}
	)
	params, err := decodeValidateClusterUpdateSpecParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeValidateClusterUpdateSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateClusterUpdateSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateClusterUpdateSpec",
			OperationSummary: "Perform validation of the ClusterUpdateSpec specification",
			OperationID:      "validateClusterUpdateSpec",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "useAsyncValidation",
					In:   "query",
				}: params.UseAsyncValidation,
			},
			Raw: r,
		}

		type (
			Request  = *ClusterUpdateSpec
			Params   = ValidateClusterUpdateSpecParams
			Response = ValidateClusterUpdateSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackValidateClusterUpdateSpecParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateClusterUpdateSpec(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateClusterUpdateSpec(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateClusterUpdateSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateCommissionHostsRequest handles validateCommissionHosts operation.
//
// Validate the input specification to commission the Hosts.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /v1/hosts/validations/commissions
func (s *Server) handleValidateCommissionHostsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateCommissionHosts",
			ID:   "validateCommissionHosts",
		}
	)
	request, close, err := s.decodeValidateCommissionHostsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateCommissionHostsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateCommissionHosts",
			OperationSummary: "Validate the input specification to commission the Hosts",
			OperationID:      "validateCommissionHosts",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []HostCommissionSpec
			Params   = struct{}
			Response = ValidateCommissionHostsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateCommissionHosts(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateCommissionHosts(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateCommissionHostsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateDnsConfigurationRequest handles validateDnsConfiguration operation.
//
// Perform validation of the DnsConfiguration specification.
//
// POST /v1/system/dns-configuration/validations
func (s *Server) handleValidateDnsConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateDnsConfiguration",
			ID:   "validateDnsConfiguration",
		}
	)
	request, close, err := s.decodeValidateDnsConfigurationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateDnsConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateDnsConfiguration",
			OperationSummary: "Perform validation of the DnsConfiguration specification",
			OperationID:      "validateDnsConfiguration",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *DnsConfiguration
			Params   = struct{}
			Response = ValidateDnsConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateDnsConfiguration(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateDnsConfiguration(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateDnsConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateDomainCreationSpecRequest handles validateDomainCreationSpec operation.
//
// Perform validation of the DomainCreationSpec specification.
//
// POST /v1/domains/validations
func (s *Server) handleValidateDomainCreationSpecRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateDomainCreationSpec",
			ID:   "validateDomainCreationSpec",
		}
	)
	params, err := decodeValidateDomainCreationSpecParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeValidateDomainCreationSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateDomainCreationSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateDomainCreationSpec",
			OperationSummary: "Perform validation of the DomainCreationSpec specification",
			OperationID:      "validateDomainCreationSpec",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "hostsOnly",
					In:   "query",
				}: params.HostsOnly,
				{
					Name: "skipHostSwitchValidation",
					In:   "query",
				}: params.SkipHostSwitchValidation,
			},
			Raw: r,
		}

		type (
			Request  = *DomainCreationSpec
			Params   = ValidateDomainCreationSpecParams
			Response = ValidateDomainCreationSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackValidateDomainCreationSpecParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateDomainCreationSpec(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateDomainCreationSpec(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateDomainCreationSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateDomainUpdateSpecRequest handles validateDomainUpdateSpec operation.
//
// Perform validation of the DomainUpdateSpec specification.
//
// POST /v1/domains/{id}/validations
func (s *Server) handleValidateDomainUpdateSpecRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateDomainUpdateSpec",
			ID:   "validateDomainUpdateSpec",
		}
	)
	params, err := decodeValidateDomainUpdateSpecParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeValidateDomainUpdateSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateDomainUpdateSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateDomainUpdateSpec",
			OperationSummary: "Perform validation of the DomainUpdateSpec specification",
			OperationID:      "validateDomainUpdateSpec",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *DomainUpdateSpec
			Params   = ValidateDomainUpdateSpecParams
			Response = ValidateDomainUpdateSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackValidateDomainUpdateSpecParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateDomainUpdateSpec(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateDomainUpdateSpec(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateDomainUpdateSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateEdgeClusterCreationSpecRequest handles validateEdgeClusterCreationSpec operation.
//
// Perform validiation of the EdgeClusterCreationSpec specification.
//
// POST /v1/edge-clusters/validations
func (s *Server) handleValidateEdgeClusterCreationSpecRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateEdgeClusterCreationSpec",
			ID:   "validateEdgeClusterCreationSpec",
		}
	)
	request, close, err := s.decodeValidateEdgeClusterCreationSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateEdgeClusterCreationSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateEdgeClusterCreationSpec",
			OperationSummary: "Perform validiation of the EdgeClusterCreationSpec specification",
			OperationID:      "validateEdgeClusterCreationSpec",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *EdgeClusterCreationSpec
			Params   = struct{}
			Response = ValidateEdgeClusterCreationSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateEdgeClusterCreationSpec(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateEdgeClusterCreationSpec(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateEdgeClusterCreationSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateEdgeClusterUpdateSpecRequest handles validateEdgeClusterUpdateSpec operation.
//
// Perform validation of the EdgeClusterUpdateSpec specification.
//
// POST /v1/edge-clusters/{id}/validations
func (s *Server) handleValidateEdgeClusterUpdateSpecRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateEdgeClusterUpdateSpec",
			ID:   "validateEdgeClusterUpdateSpec",
		}
	)
	params, err := decodeValidateEdgeClusterUpdateSpecParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeValidateEdgeClusterUpdateSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateEdgeClusterUpdateSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateEdgeClusterUpdateSpec",
			OperationSummary: "Perform validation of the EdgeClusterUpdateSpec specification",
			OperationID:      "validateEdgeClusterUpdateSpec",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *EdgeClusterUpdateSpec
			Params   = ValidateEdgeClusterUpdateSpecParams
			Response = ValidateEdgeClusterUpdateSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackValidateEdgeClusterUpdateSpecParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateEdgeClusterUpdateSpec(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateEdgeClusterUpdateSpec(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateEdgeClusterUpdateSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateHostCommissionSpecRequest handles validateHostCommissionSpec operation.
//
// Perform validation of the  HostCommissionSpec specification.
//
// POST /v1/hosts/validations
func (s *Server) handleValidateHostCommissionSpecRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateHostCommissionSpec",
			ID:   "validateHostCommissionSpec",
		}
	)
	request, close, err := s.decodeValidateHostCommissionSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateHostCommissionSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateHostCommissionSpec",
			OperationSummary: "Perform validation of the  HostCommissionSpec specification",
			OperationID:      "validateHostCommissionSpec",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []HostCommissionSpec
			Params   = struct{}
			Response = ValidateHostCommissionSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateHostCommissionSpec(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateHostCommissionSpec(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateHostCommissionSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateIpPoolRequest handles validateIpPool operation.
//
// POST /v1/nsxt-clusters/ip-address-pools/validations
func (s *Server) handleValidateIpPoolRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateIpPool",
			ID:   "validateIpPool",
		}
	)
	request, close, err := s.decodeValidateIpPoolRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Validation
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateIpPool",
			OperationSummary: "",
			OperationID:      "validateIpPool",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *NsxtIpAddressPoolValidationSpec
			Params   = struct{}
			Response = *Validation
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateIpPool(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateIpPool(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateIpPoolResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateNsxALBCompatibilityRequest handles validateNsxALBCompatibility operation.
//
// Validate NSX ALB compatibility version.
//
// POST /v1/nsx-alb-clusters/validations/version
func (s *Server) handleValidateNsxALBCompatibilityRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateNsxALBCompatibility",
			ID:   "validateNsxALBCompatibility",
		}
	)
	request, close, err := s.decodeValidateNsxALBCompatibilityRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateNsxALBCompatibilityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateNsxALBCompatibility",
			OperationSummary: "Validate NSX ALB compatibility version",
			OperationID:      "validateNsxALBCompatibility",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *NsxAlbVersionValidationSpec
			Params   = struct{}
			Response = ValidateNsxALBCompatibilityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateNsxALBCompatibility(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateNsxALBCompatibility(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateNsxALBCompatibilityResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateNtpConfigurationRequest handles validateNtpConfiguration operation.
//
// Perform validation of the NtpConfiguration specification.
//
// POST /v1/system/ntp-configuration/validations
func (s *Server) handleValidateNtpConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateNtpConfiguration",
			ID:   "validateNtpConfiguration",
		}
	)
	request, close, err := s.decodeValidateNtpConfigurationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateNtpConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateNtpConfiguration",
			OperationSummary: "Perform validation of the NtpConfiguration specification",
			OperationID:      "validateNtpConfiguration",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *NtpConfiguration
			Params   = struct{}
			Response = ValidateNtpConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateNtpConfiguration(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateNtpConfiguration(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateNtpConfigurationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateReleaseByDomainIDRequest handles validateReleaseByDomainID operation.
//
// Validate the target selected upgrade release BOM or custom BOM for a domain by its ID.
//
// POST /v1/releases/domains/{domainId}/validations
func (s *Server) handleValidateReleaseByDomainIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateReleaseByDomainID",
			ID:   "validateReleaseByDomainID",
		}
	)
	params, err := decodeValidateReleaseByDomainIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeValidateReleaseByDomainIDRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateReleaseByDomainIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateReleaseByDomainID",
			OperationSummary: "Validate the target selected upgrade version for the domain",
			OperationID:      "validateReleaseByDomainID",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "domainId",
					In:   "path",
				}: params.DomainId,
			},
			Raw: r,
		}

		type (
			Request  = *DomainRelease
			Params   = ValidateReleaseByDomainIDParams
			Response = ValidateReleaseByDomainIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackValidateReleaseByDomainIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateReleaseByDomainID(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateReleaseByDomainID(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateReleaseByDomainIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateResourceCertificatesRequest handles validateResourceCertificates operation.
//
// Validate resource certificates.
//
// PUT /v1/domains/{id}/resource-certificates/validations
func (s *Server) handleValidateResourceCertificatesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateResourceCertificates",
			ID:   "validateResourceCertificates",
		}
	)
	params, err := decodeValidateResourceCertificatesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeValidateResourceCertificatesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateResourceCertificatesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateResourceCertificates",
			OperationSummary: "Perform validation of the ResourceCertificateSpec specification",
			OperationID:      "validateResourceCertificates",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = []ResourceCertificateSpec
			Params   = ValidateResourceCertificatesParams
			Response = ValidateResourceCertificatesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackValidateResourceCertificatesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateResourceCertificates(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateResourceCertificates(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateResourceCertificatesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateVasaProviderSpecRequest handles validateVasaProviderSpec operation.
//
// Validate VasaProvider input specification.
//
// POST /v1/vasa-providers/validations
func (s *Server) handleValidateVasaProviderSpecRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateVasaProviderSpec",
			ID:   "validateVasaProviderSpec",
		}
	)
	request, close, err := s.decodeValidateVasaProviderSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateVasaProviderSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateVasaProviderSpec",
			OperationSummary: "Validate VasaProvider input specification",
			OperationID:      "validateVasaProviderSpec",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *VasaProvider
			Params   = struct{}
			Response = ValidateVasaProviderSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateVasaProviderSpec(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateVasaProviderSpec(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateVasaProviderSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateVrslcmRequest handles validateVrslcm operation.
//
// Triggers VMware Aria Suite Lifecycle deployment specification validation workflow.
//
// POST /v1/vrslcms/validations
func (s *Server) handleValidateVrslcmRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateVrslcm",
			ID:   "validateVrslcm",
		}
	)
	request, close, err := s.decodeValidateVrslcmRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateVrslcmRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateVrslcm",
			OperationSummary: "Perform validation of the VrslcmDeploymentSpec specification",
			OperationID:      "validateVrslcm",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *VrslcmDeploymentSpec
			Params   = struct{}
			Response = ValidateVrslcmRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateVrslcm(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateVrslcm(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateVrslcmResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateVsanRemoteDatastoreMountSpecRequest handles validateVsanRemoteDatastoreMountSpec operation.
//
// Perform validation of the DatastoreMountSpec specification.
//
// POST /v1/clusters/{clusterId}/datastores/validations
func (s *Server) handleValidateVsanRemoteDatastoreMountSpecRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateVsanRemoteDatastoreMountSpec",
			ID:   "validateVsanRemoteDatastoreMountSpec",
		}
	)
	params, err := decodeValidateVsanRemoteDatastoreMountSpecParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeValidateVsanRemoteDatastoreMountSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateVsanRemoteDatastoreMountSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateVsanRemoteDatastoreMountSpec",
			OperationSummary: "Perform validation of the DatastoreMountSpec specification",
			OperationID:      "validateVsanRemoteDatastoreMountSpec",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "clusterId",
					In:   "path",
				}: params.ClusterId,
			},
			Raw: r,
		}

		type (
			Request  = *DatastoreMountSpec
			Params   = ValidateVsanRemoteDatastoreMountSpecParams
			Response = ValidateVsanRemoteDatastoreMountSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackValidateVsanRemoteDatastoreMountSpecParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateVsanRemoteDatastoreMountSpec(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateVsanRemoteDatastoreMountSpec(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateVsanRemoteDatastoreMountSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleValidateVsanRemoteDatastoreSpecRequest handles validateVsanRemoteDatastoreSpec operation.
//
// Perform validation of the DatastoreMountSpec specification.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /v1/clusters/{clusterId}/datastores/validation
func (s *Server) handleValidateVsanRemoteDatastoreSpecRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ValidateVsanRemoteDatastoreSpec",
			ID:   "validateVsanRemoteDatastoreSpec",
		}
	)
	params, err := decodeValidateVsanRemoteDatastoreSpecParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeValidateVsanRemoteDatastoreSpecRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ValidateVsanRemoteDatastoreSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ValidateVsanRemoteDatastoreSpec",
			OperationSummary: "Perform validation of the DatastoreMountSpec specification",
			OperationID:      "validateVsanRemoteDatastoreSpec",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "clusterId",
					In:   "path",
				}: params.ClusterId,
			},
			Raw: r,
		}

		type (
			Request  = *DatastoreMountSpec
			Params   = ValidateVsanRemoteDatastoreSpecParams
			Response = ValidateVsanRemoteDatastoreSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackValidateVsanRemoteDatastoreSpecParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ValidateVsanRemoteDatastoreSpec(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ValidateVsanRemoteDatastoreSpec(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeValidateVsanRemoteDatastoreSpecResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
