// Code generated by ogen, DO NOT EDIT.

package vcf

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ALBControllerNodeFormFactor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ALBControllerNodeFormFactor) encodeFields(e *jx.Encoder) {
	{
		if s.Disk.Set {
			e.FieldStart("disk")
			s.Disk.Encode(e)
		}
	}
	{
		if s.Memory.Set {
			e.FieldStart("memory")
			s.Memory.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Vcpu.Set {
			e.FieldStart("vcpu")
			s.Vcpu.Encode(e)
		}
	}
}

var jsonFieldsNameOfALBControllerNodeFormFactor = [4]string{
	0: "disk",
	1: "memory",
	2: "type",
	3: "vcpu",
}

// Decode decodes ALBControllerNodeFormFactor from json.
func (s *ALBControllerNodeFormFactor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ALBControllerNodeFormFactor to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "disk":
			if err := func() error {
				s.Disk.Reset()
				if err := s.Disk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk\"")
			}
		case "memory":
			if err := func() error {
				s.Memory.Reset()
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "vcpu":
			if err := func() error {
				s.Vcpu.Reset()
				if err := s.Vcpu.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcpu\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ALBControllerNodeFormFactor")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ALBControllerNodeFormFactor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ALBControllerNodeFormFactor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ALBControllerNodeFormFactors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ALBControllerNodeFormFactors) encodeFields(e *jx.Encoder) {
	{
		if s.FormFactors != nil {
			e.FieldStart("formFactors")
			e.ArrStart()
			for _, elem := range s.FormFactors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfALBControllerNodeFormFactors = [1]string{
	0: "formFactors",
}

// Decode decodes ALBControllerNodeFormFactors from json.
func (s *ALBControllerNodeFormFactors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ALBControllerNodeFormFactors to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "formFactors":
			if err := func() error {
				s.FormFactors = make([]ALBControllerNodeFormFactor, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ALBControllerNodeFormFactor
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FormFactors = append(s.FormFactors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"formFactors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ALBControllerNodeFormFactors")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ALBControllerNodeFormFactors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ALBControllerNodeFormFactors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddDatastoreToClusterBadRequest as json.
func (s *AddDatastoreToClusterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddDatastoreToClusterBadRequest from json.
func (s *AddDatastoreToClusterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDatastoreToClusterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddDatastoreToClusterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddDatastoreToClusterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDatastoreToClusterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddDatastoreToClusterInternalServerError as json.
func (s *AddDatastoreToClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddDatastoreToClusterInternalServerError from json.
func (s *AddDatastoreToClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDatastoreToClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddDatastoreToClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddDatastoreToClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDatastoreToClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddDatastoreToClusterNotFound as json.
func (s *AddDatastoreToClusterNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddDatastoreToClusterNotFound from json.
func (s *AddDatastoreToClusterNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDatastoreToClusterNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddDatastoreToClusterNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddDatastoreToClusterNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDatastoreToClusterNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddIpPoolToNetworkOfNetworkPoolBadRequest as json.
func (s *AddIpPoolToNetworkOfNetworkPoolBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddIpPoolToNetworkOfNetworkPoolBadRequest from json.
func (s *AddIpPoolToNetworkOfNetworkPoolBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddIpPoolToNetworkOfNetworkPoolBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddIpPoolToNetworkOfNetworkPoolBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddIpPoolToNetworkOfNetworkPoolBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddIpPoolToNetworkOfNetworkPoolBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddIpPoolToNetworkOfNetworkPoolInternalServerError as json.
func (s *AddIpPoolToNetworkOfNetworkPoolInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddIpPoolToNetworkOfNetworkPoolInternalServerError from json.
func (s *AddIpPoolToNetworkOfNetworkPoolInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddIpPoolToNetworkOfNetworkPoolInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddIpPoolToNetworkOfNetworkPoolInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddIpPoolToNetworkOfNetworkPoolInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddIpPoolToNetworkOfNetworkPoolInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddIpPoolToNetworkOfNetworkPoolNotFound as json.
func (s *AddIpPoolToNetworkOfNetworkPoolNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddIpPoolToNetworkOfNetworkPoolNotFound from json.
func (s *AddIpPoolToNetworkOfNetworkPoolNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddIpPoolToNetworkOfNetworkPoolNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddIpPoolToNetworkOfNetworkPoolNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddIpPoolToNetworkOfNetworkPoolNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddIpPoolToNetworkOfNetworkPoolNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddOnInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddOnInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("vendor")
		e.Str(s.Vendor)
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("displayName")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.DisplayVersion.Set {
			e.FieldStart("displayVersion")
			s.DisplayVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddOnInfo = [5]string{
	0: "version",
	1: "name",
	2: "vendor",
	3: "displayName",
	4: "displayVersion",
}

// Decode decodes AddOnInfo from json.
func (s *AddOnInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddOnInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "vendor":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Vendor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vendor\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "displayVersion":
			if err := func() error {
				s.DisplayVersion.Reset()
				if err := s.DisplayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddOnInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddOnInfo) {
					name = jsonFieldsNameOfAddOnInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddOnInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddOnInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddUsersBadRequest as json.
func (s *AddUsersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddUsersBadRequest from json.
func (s *AddUsersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUsersBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddUsersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUsersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUsersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddUsersInternalServerError as json.
func (s *AddUsersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddUsersInternalServerError from json.
func (s *AddUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUsersInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddUsersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddUsersUnauthorized as json.
func (s *AddUsersUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddUsersUnauthorized from json.
func (s *AddUsersUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUsersUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddUsersUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUsersUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUsersUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddVasaProviderBadRequest as json.
func (s *AddVasaProviderBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddVasaProviderBadRequest from json.
func (s *AddVasaProviderBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddVasaProviderBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddVasaProviderBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddVasaProviderBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddVasaProviderBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddVasaProviderInternalServerError as json.
func (s *AddVasaProviderInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddVasaProviderInternalServerError from json.
func (s *AddVasaProviderInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddVasaProviderInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddVasaProviderInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddVasaProviderInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddVasaProviderInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddVasaProviderStorageContainerBadRequest as json.
func (s *AddVasaProviderStorageContainerBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddVasaProviderStorageContainerBadRequest from json.
func (s *AddVasaProviderStorageContainerBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddVasaProviderStorageContainerBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddVasaProviderStorageContainerBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddVasaProviderStorageContainerBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddVasaProviderStorageContainerBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddVasaProviderStorageContainerInternalServerError as json.
func (s *AddVasaProviderStorageContainerInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddVasaProviderStorageContainerInternalServerError from json.
func (s *AddVasaProviderStorageContainerInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddVasaProviderStorageContainerInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddVasaProviderStorageContainerInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddVasaProviderStorageContainerInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddVasaProviderStorageContainerInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddVasaProviderStorageContainerNotFound as json.
func (s *AddVasaProviderStorageContainerNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddVasaProviderStorageContainerNotFound from json.
func (s *AddVasaProviderStorageContainerNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddVasaProviderStorageContainerNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddVasaProviderStorageContainerNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddVasaProviderStorageContainerNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddVasaProviderStorageContainerNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddVasaProviderUserBadRequest as json.
func (s *AddVasaProviderUserBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddVasaProviderUserBadRequest from json.
func (s *AddVasaProviderUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddVasaProviderUserBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddVasaProviderUserBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddVasaProviderUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddVasaProviderUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddVasaProviderUserInternalServerError as json.
func (s *AddVasaProviderUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddVasaProviderUserInternalServerError from json.
func (s *AddVasaProviderUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddVasaProviderUserInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddVasaProviderUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddVasaProviderUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddVasaProviderUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddVasaProviderUserNotFound as json.
func (s *AddVasaProviderUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddVasaProviderUserNotFound from json.
func (s *AddVasaProviderUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddVasaProviderUserNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddVasaProviderUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddVasaProviderUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddVasaProviderUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AdvancedOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AdvancedOptions) encodeFields(e *jx.Encoder) {
	{
		if s.EvcMode.Set {
			e.FieldStart("evcMode")
			s.EvcMode.Encode(e)
		}
	}
	{
		if s.HighAvailability.Set {
			e.FieldStart("highAvailability")
			s.HighAvailability.Encode(e)
		}
	}
}

var jsonFieldsNameOfAdvancedOptions = [2]string{
	0: "evcMode",
	1: "highAvailability",
}

// Decode decodes AdvancedOptions from json.
func (s *AdvancedOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdvancedOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evcMode":
			if err := func() error {
				s.EvcMode.Reset()
				if err := s.EvcMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evcMode\"")
			}
		case "highAvailability":
			if err := func() error {
				s.HighAvailability.Reset()
				if err := s.HighAvailability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highAvailability\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AdvancedOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdvancedOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdvancedOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AliasSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AliasSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("aliases")
		e.ArrStart()
		for _, elem := range s.Aliases {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.ForceUpdate.Set {
			e.FieldStart("forceUpdate")
			s.ForceUpdate.Encode(e)
		}
	}
}

var jsonFieldsNameOfAliasSpec = [2]string{
	0: "aliases",
	1: "forceUpdate",
}

// Decode decodes AliasSpec from json.
func (s *AliasSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AliasSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "aliases":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Aliases = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Aliases = append(s.Aliases, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aliases\"")
			}
		case "forceUpdate":
			if err := func() error {
				s.ForceUpdate.Reset()
				if err := s.ForceUpdate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forceUpdate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AliasSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAliasSpec) {
					name = jsonFieldsNameOfAliasSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AliasSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AliasSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlternativeApplicableSddcManagerVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlternativeApplicableSddcManagerVersion) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfAlternativeApplicableSddcManagerVersion = [1]string{
	0: "version",
}

// Decode decodes AlternativeApplicableSddcManagerVersion from json.
func (s *AlternativeApplicableSddcManagerVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlternativeApplicableSddcManagerVersion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlternativeApplicableSddcManagerVersion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlternativeApplicableSddcManagerVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlternativeApplicableSddcManagerVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Applicability) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Applicability) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("versionApplicability")
		e.ArrStart()
		for _, elem := range s.VersionApplicability {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("skuType")
		e.Str(s.SkuType)
	}
}

var jsonFieldsNameOfApplicability = [2]string{
	0: "versionApplicability",
	1: "skuType",
}

// Decode decodes Applicability from json.
func (s *Applicability) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Applicability to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "versionApplicability":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.VersionApplicability = make([]VersionApplicability, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VersionApplicability
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VersionApplicability = append(s.VersionApplicability, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versionApplicability\"")
			}
		case "skuType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SkuType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skuType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Applicability")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplicability) {
					name = jsonFieldsNameOfApplicability[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Applicability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Applicability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Artifact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Artifact) encodeFields(e *jx.Encoder) {
	{
		if s.Bundles != nil {
			e.FieldStart("bundles")
			e.ArrStart()
			for _, elem := range s.Bundles {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfArtifact = [1]string{
	0: "bundles",
}

// Decode decodes Artifact from json.
func (s *Artifact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Artifact to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bundles":
			if err := func() error {
				s.Bundles = make([]BundleInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BundleInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Bundles = append(s.Bundles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Artifact")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Artifact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Artifact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssessmentMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssessmentMetadata) encodeFields(e *jx.Encoder) {
	{
		if s.TargetVersion.Set {
			e.FieldStart("targetVersion")
			s.TargetVersion.Encode(e)
		}
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAssessmentMetadata = [2]string{
	0: "targetVersion",
	1: "resources",
}

// Decode decodes AssessmentMetadata from json.
func (s *AssessmentMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssessmentMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "targetVersion":
			if err := func() error {
				s.TargetVersion.Reset()
				if err := s.TargetVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetVersion\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]AssessmentResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssessmentResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssessmentMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssessmentMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssessmentMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssessmentOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssessmentOutput) encodeFields(e *jx.Encoder) {
	{
		if s.PhysicalPresentedData.Set {
			e.FieldStart("physicalPresentedData")
			s.PhysicalPresentedData.Encode(e)
		}
	}
	{
		if s.PresentedArtifactsMap.Set {
			e.FieldStart("presentedArtifactsMap")
			s.PresentedArtifactsMap.Encode(e)
		}
	}
	{
		if s.ValidationResult.Set {
			e.FieldStart("validationResult")
			s.ValidationResult.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.InputValidationErrors != nil {
			e.FieldStart("inputValidationErrors")
			e.ArrStart()
			for _, elem := range s.InputValidationErrors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DiscoveryProgress.Set {
			e.FieldStart("discoveryProgress")
			s.DiscoveryProgress.Encode(e)
		}
	}
	{
		if s.RelatedAssessmentId.Set {
			e.FieldStart("relatedAssessmentId")
			s.RelatedAssessmentId.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.CompletionTimestamp.Set {
			e.FieldStart("completionTimestamp")
			s.CompletionTimestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssessmentOutput = [9]string{
	0: "physicalPresentedData",
	1: "presentedArtifactsMap",
	2: "validationResult",
	3: "status",
	4: "inputValidationErrors",
	5: "discoveryProgress",
	6: "relatedAssessmentId",
	7: "timestamp",
	8: "completionTimestamp",
}

// Decode decodes AssessmentOutput from json.
func (s *AssessmentOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssessmentOutput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "physicalPresentedData":
			if err := func() error {
				s.PhysicalPresentedData.Reset()
				if err := s.PhysicalPresentedData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalPresentedData\"")
			}
		case "presentedArtifactsMap":
			if err := func() error {
				s.PresentedArtifactsMap.Reset()
				if err := s.PresentedArtifactsMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"presentedArtifactsMap\"")
			}
		case "validationResult":
			if err := func() error {
				s.ValidationResult.Reset()
				if err := s.ValidationResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validationResult\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "inputValidationErrors":
			if err := func() error {
				s.InputValidationErrors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InputValidationErrors = append(s.InputValidationErrors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inputValidationErrors\"")
			}
		case "discoveryProgress":
			if err := func() error {
				s.DiscoveryProgress.Reset()
				if err := s.DiscoveryProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discoveryProgress\"")
			}
		case "relatedAssessmentId":
			if err := func() error {
				s.RelatedAssessmentId.Reset()
				if err := s.RelatedAssessmentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relatedAssessmentId\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "completionTimestamp":
			if err := func() error {
				s.CompletionTimestamp.Reset()
				if err := s.CompletionTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTimestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssessmentOutput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssessmentOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssessmentOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AssessmentOutputPresentedArtifactsMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AssessmentOutputPresentedArtifactsMap) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes AssessmentOutputPresentedArtifactsMap from json.
func (s *AssessmentOutputPresentedArtifactsMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssessmentOutputPresentedArtifactsMap to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem AssessmentOutputPresentedArtifactsMapItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssessmentOutputPresentedArtifactsMap")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssessmentOutputPresentedArtifactsMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssessmentOutputPresentedArtifactsMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssessmentOutputPresentedArtifactsMapItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssessmentOutputPresentedArtifactsMapItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAssessmentOutputPresentedArtifactsMapItem = [0]string{}

// Decode decodes AssessmentOutputPresentedArtifactsMapItem from json.
func (s *AssessmentOutputPresentedArtifactsMapItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssessmentOutputPresentedArtifactsMapItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AssessmentOutputPresentedArtifactsMapItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssessmentOutputPresentedArtifactsMapItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssessmentOutputPresentedArtifactsMapItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssessmentOutputStatus as json.
func (s AssessmentOutputStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssessmentOutputStatus from json.
func (s *AssessmentOutputStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssessmentOutputStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssessmentOutputStatus(v) {
	case AssessmentOutputStatusINPROGRESS:
		*s = AssessmentOutputStatusINPROGRESS
	case AssessmentOutputStatusCOMPLETEDWITHSUCCESS:
		*s = AssessmentOutputStatusCOMPLETEDWITHSUCCESS
	case AssessmentOutputStatusCOMPLETEDWITHFAILURE:
		*s = AssessmentOutputStatusCOMPLETEDWITHFAILURE
	default:
		*s = AssessmentOutputStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssessmentOutputStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssessmentOutputStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssessmentPartialRetryInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssessmentPartialRetryInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("errorIds")
		e.ArrStart()
		for _, elem := range s.ErrorIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Options.Set {
			e.FieldStart("options")
			s.Options.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssessmentPartialRetryInput = [2]string{
	0: "errorIds",
	1: "options",
}

// Decode decodes AssessmentPartialRetryInput from json.
func (s *AssessmentPartialRetryInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssessmentPartialRetryInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "errorIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ErrorIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ErrorIds = append(s.ErrorIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorIds\"")
			}
		case "options":
			if err := func() error {
				s.Options.Reset()
				if err := s.Options.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssessmentPartialRetryInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssessmentPartialRetryInput) {
					name = jsonFieldsNameOfAssessmentPartialRetryInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssessmentPartialRetryInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssessmentPartialRetryInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AssessmentPartialRetryInputOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AssessmentPartialRetryInputOptions) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes AssessmentPartialRetryInputOptions from json.
func (s *AssessmentPartialRetryInputOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssessmentPartialRetryInputOptions to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssessmentPartialRetryInputOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssessmentPartialRetryInputOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssessmentPartialRetryInputOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssessmentResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssessmentResource) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.DomainId.Set {
			e.FieldStart("domainId")
			s.DomainId.Encode(e)
		}
	}
	{
		if s.TargetVersion.Set {
			e.FieldStart("targetVersion")
			s.TargetVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssessmentResource = [5]string{
	0: "type",
	1: "id",
	2: "name",
	3: "domainId",
	4: "targetVersion",
}

// Decode decodes AssessmentResource from json.
func (s *AssessmentResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssessmentResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "domainId":
			if err := func() error {
				s.DomainId.Reset()
				if err := s.DomainId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainId\"")
			}
		case "targetVersion":
			if err := func() error {
				s.TargetVersion.Reset()
				if err := s.TargetVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssessmentResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssessmentResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssessmentResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssessmentTaskInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssessmentTaskInfo) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.CompletionTimestamp.Set {
			e.FieldStart("completionTimestamp")
			s.CompletionTimestamp.Encode(e)
		}
	}
	{
		if s.DomainInputs != nil {
			e.FieldStart("domainInputs")
			e.ArrStart()
			for _, elem := range s.DomainInputs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssessmentTaskInfo = [6]string{
	0: "id",
	1: "state",
	2: "timestamp",
	3: "completionTimestamp",
	4: "domainInputs",
	5: "metadata",
}

// Decode decodes AssessmentTaskInfo from json.
func (s *AssessmentTaskInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssessmentTaskInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "completionTimestamp":
			if err := func() error {
				s.CompletionTimestamp.Reset()
				if err := s.CompletionTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTimestamp\"")
			}
		case "domainInputs":
			if err := func() error {
				s.DomainInputs = make([]DomainInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DomainInputs = append(s.DomainInputs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainInputs\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssessmentTaskInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssessmentTaskInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssessmentTaskInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssignTagsToClusterBadRequest as json.
func (s *AssignTagsToClusterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AssignTagsToClusterBadRequest from json.
func (s *AssignTagsToClusterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssignTagsToClusterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AssignTagsToClusterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssignTagsToClusterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssignTagsToClusterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssignTagsToClusterInternalServerError as json.
func (s *AssignTagsToClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AssignTagsToClusterInternalServerError from json.
func (s *AssignTagsToClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssignTagsToClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AssignTagsToClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssignTagsToClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssignTagsToClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssignTagsToDomainBadRequest as json.
func (s *AssignTagsToDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AssignTagsToDomainBadRequest from json.
func (s *AssignTagsToDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssignTagsToDomainBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AssignTagsToDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssignTagsToDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssignTagsToDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssignTagsToDomainInternalServerError as json.
func (s *AssignTagsToDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AssignTagsToDomainInternalServerError from json.
func (s *AssignTagsToDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssignTagsToDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AssignTagsToDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssignTagsToDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssignTagsToDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssignTagsToHostBadRequest as json.
func (s *AssignTagsToHostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AssignTagsToHostBadRequest from json.
func (s *AssignTagsToHostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssignTagsToHostBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AssignTagsToHostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssignTagsToHostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssignTagsToHostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssignTagsToHostInternalServerError as json.
func (s *AssignTagsToHostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes AssignTagsToHostInternalServerError from json.
func (s *AssignTagsToHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssignTagsToHostInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AssignTagsToHostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssignTagsToHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssignTagsToHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssociatedTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssociatedTask) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("taskId")
		e.Str(s.TaskId)
	}
	{
		if s.SubTaskId.Set {
			e.FieldStart("subTaskId")
			s.SubTaskId.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssociatedTask = [2]string{
	0: "taskId",
	1: "subTaskId",
}

// Decode decodes AssociatedTask from json.
func (s *AssociatedTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssociatedTask to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "taskId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TaskId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskId\"")
			}
		case "subTaskId":
			if err := func() error {
				s.SubTaskId.Reset()
				if err := s.SubTaskId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subTaskId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssociatedTask")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssociatedTask) {
					name = jsonFieldsNameOfAssociatedTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssociatedTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssociatedTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthenticatedResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthenticatedResource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceId")
		e.Str(s.ResourceId)
	}
	{
		e.FieldStart("resourceName")
		e.Str(s.ResourceName)
	}
	{
		e.FieldStart("resourceIp")
		e.Str(s.ResourceIp)
	}
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		e.FieldStart("domainNames")
		e.ArrStart()
		for _, elem := range s.DomainNames {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.DomainName.Set {
			e.FieldStart("domainName")
			s.DomainName.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthenticatedResource = [6]string{
	0: "resourceId",
	1: "resourceName",
	2: "resourceIp",
	3: "resourceType",
	4: "domainNames",
	5: "domainName",
}

// Decode decodes AuthenticatedResource from json.
func (s *AuthenticatedResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticatedResource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ResourceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		case "resourceIp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ResourceIp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceIp\"")
			}
		case "resourceType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "domainNames":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.DomainNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DomainNames = append(s.DomainNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainNames\"")
			}
		case "domainName":
			if err := func() error {
				s.DomainName.Reset()
				if err := s.DomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticatedResource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthenticatedResource) {
					name = jsonFieldsNameOfAuthenticatedResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthenticatedResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticatedResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutoRotateCredentialPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutoRotateCredentialPolicy) encodeFields(e *jx.Encoder) {
	{
		if s.FrequencyInDays.Set {
			e.FieldStart("frequencyInDays")
			s.FrequencyInDays.Encode(e)
		}
	}
	{
		e.FieldStart("nextSchedule")
		e.Str(s.NextSchedule)
	}
}

var jsonFieldsNameOfAutoRotateCredentialPolicy = [2]string{
	0: "frequencyInDays",
	1: "nextSchedule",
}

// Decode decodes AutoRotateCredentialPolicy from json.
func (s *AutoRotateCredentialPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutoRotateCredentialPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "frequencyInDays":
			if err := func() error {
				s.FrequencyInDays.Reset()
				if err := s.FrequencyInDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequencyInDays\"")
			}
		case "nextSchedule":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NextSchedule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextSchedule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutoRotateCredentialPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutoRotateCredentialPolicy) {
					name = jsonFieldsNameOfAutoRotateCredentialPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutoRotateCredentialPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutoRotateCredentialPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutoRotateCredentialPolicyInputSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutoRotateCredentialPolicyInputSpec) encodeFields(e *jx.Encoder) {
	{
		if s.FrequencyInDays.Set {
			e.FieldStart("frequencyInDays")
			s.FrequencyInDays.Encode(e)
		}
	}
	{
		e.FieldStart("enableAutoRotatePolicy")
		e.Bool(s.EnableAutoRotatePolicy)
	}
}

var jsonFieldsNameOfAutoRotateCredentialPolicyInputSpec = [2]string{
	0: "frequencyInDays",
	1: "enableAutoRotatePolicy",
}

// Decode decodes AutoRotateCredentialPolicyInputSpec from json.
func (s *AutoRotateCredentialPolicyInputSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutoRotateCredentialPolicyInputSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "frequencyInDays":
			if err := func() error {
				s.FrequencyInDays.Reset()
				if err := s.FrequencyInDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequencyInDays\"")
			}
		case "enableAutoRotatePolicy":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.EnableAutoRotatePolicy = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enableAutoRotatePolicy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutoRotateCredentialPolicyInputSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutoRotateCredentialPolicyInputSpec) {
					name = jsonFieldsNameOfAutoRotateCredentialPolicyInputSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutoRotateCredentialPolicyInputSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutoRotateCredentialPolicyInputSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Avn) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Avn) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("regionType")
		e.Str(s.RegionType)
	}
	{
		e.FieldStart("subnet")
		e.Str(s.Subnet)
	}
	{
		e.FieldStart("subnetMask")
		e.Str(s.SubnetMask)
	}
	{
		e.FieldStart("gateway")
		e.Str(s.Gateway)
	}
	{
		e.FieldStart("mtu")
		e.Int32(s.Mtu)
	}
	{
		if s.VlanId.Set {
			e.FieldStart("vlanId")
			s.VlanId.Encode(e)
		}
	}
	{
		if s.PortGroupName.Set {
			e.FieldStart("portGroupName")
			s.PortGroupName.Encode(e)
		}
	}
	{
		if s.DomainName.Set {
			e.FieldStart("domainName")
			s.DomainName.Encode(e)
		}
	}
	{
		if s.RouterName.Set {
			e.FieldStart("routerName")
			s.RouterName.Encode(e)
		}
	}
}

var jsonFieldsNameOfAvn = [11]string{
	0:  "id",
	1:  "name",
	2:  "regionType",
	3:  "subnet",
	4:  "subnetMask",
	5:  "gateway",
	6:  "mtu",
	7:  "vlanId",
	8:  "portGroupName",
	9:  "domainName",
	10: "routerName",
}

// Decode decodes Avn from json.
func (s *Avn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Avn to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "regionType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RegionType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regionType\"")
			}
		case "subnet":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Subnet = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subnet\"")
			}
		case "subnetMask":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubnetMask = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subnetMask\"")
			}
		case "gateway":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Gateway = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		case "mtu":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Mtu = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mtu\"")
			}
		case "vlanId":
			if err := func() error {
				s.VlanId.Reset()
				if err := s.VlanId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlanId\"")
			}
		case "portGroupName":
			if err := func() error {
				s.PortGroupName.Reset()
				if err := s.PortGroupName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portGroupName\"")
			}
		case "domainName":
			if err := func() error {
				s.DomainName.Reset()
				if err := s.DomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainName\"")
			}
		case "routerName":
			if err := func() error {
				s.RouterName.Reset()
				if err := s.RouterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"routerName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Avn")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAvn) {
					name = jsonFieldsNameOfAvn[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Avn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Avn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AvnsCreationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AvnsCreationSpec) encodeFields(e *jx.Encoder) {
	{
		if s.EdgeClusterId.Set {
			e.FieldStart("edgeClusterId")
			s.EdgeClusterId.Encode(e)
		}
	}
	{
		e.FieldStart("avns")
		e.ArrStart()
		for _, elem := range s.Avns {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAvnsCreationSpec = [2]string{
	0: "edgeClusterId",
	1: "avns",
}

// Decode decodes AvnsCreationSpec from json.
func (s *AvnsCreationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvnsCreationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "edgeClusterId":
			if err := func() error {
				s.EdgeClusterId.Reset()
				if err := s.EdgeClusterId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeClusterId\"")
			}
		case "avns":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Avns = make([]Avn, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Avn
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Avns = append(s.Avns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avns\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AvnsCreationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAvnsCreationSpec) {
					name = jsonFieldsNameOfAvnsCreationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AvnsCreationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvnsCreationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackupConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackupConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.Encryption.Set {
			e.FieldStart("encryption")
			s.Encryption.Encode(e)
		}
	}
	{
		if s.BackupLocations != nil {
			e.FieldStart("backupLocations")
			e.ArrStart()
			for _, elem := range s.BackupLocations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BackupSchedules != nil {
			e.FieldStart("backupSchedules")
			e.ArrStart()
			for _, elem := range s.BackupSchedules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsConfigured.Set {
			e.FieldStart("isConfigured")
			s.IsConfigured.Encode(e)
		}
	}
}

var jsonFieldsNameOfBackupConfiguration = [4]string{
	0: "encryption",
	1: "backupLocations",
	2: "backupSchedules",
	3: "isConfigured",
}

// Decode decodes BackupConfiguration from json.
func (s *BackupConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackupConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encryption":
			if err := func() error {
				s.Encryption.Reset()
				if err := s.Encryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryption\"")
			}
		case "backupLocations":
			if err := func() error {
				s.BackupLocations = make([]BackupLocation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BackupLocation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BackupLocations = append(s.BackupLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupLocations\"")
			}
		case "backupSchedules":
			if err := func() error {
				s.BackupSchedules = make([]BackupSchedule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BackupSchedule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BackupSchedules = append(s.BackupSchedules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupSchedules\"")
			}
		case "isConfigured":
			if err := func() error {
				s.IsConfigured.Reset()
				if err := s.IsConfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConfigured\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackupConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackupConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackupConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackupConfigurationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackupConfigurationSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Encryption.Set {
			e.FieldStart("encryption")
			s.Encryption.Encode(e)
		}
	}
	{
		if s.BackupLocations != nil {
			e.FieldStart("backupLocations")
			e.ArrStart()
			for _, elem := range s.BackupLocations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BackupSchedules != nil {
			e.FieldStart("backupSchedules")
			e.ArrStart()
			for _, elem := range s.BackupSchedules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBackupConfigurationSpec = [3]string{
	0: "encryption",
	1: "backupLocations",
	2: "backupSchedules",
}

// Decode decodes BackupConfigurationSpec from json.
func (s *BackupConfigurationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackupConfigurationSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encryption":
			if err := func() error {
				s.Encryption.Reset()
				if err := s.Encryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryption\"")
			}
		case "backupLocations":
			if err := func() error {
				s.BackupLocations = make([]BackupLocation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BackupLocation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BackupLocations = append(s.BackupLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupLocations\"")
			}
		case "backupSchedules":
			if err := func() error {
				s.BackupSchedules = make([]BackupSchedule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BackupSchedule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BackupSchedules = append(s.BackupSchedules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupSchedules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackupConfigurationSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackupConfigurationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackupConfigurationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackupLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackupLocation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("server")
		e.Str(s.Server)
	}
	{
		e.FieldStart("port")
		e.Int32(s.Port)
	}
	{
		e.FieldStart("protocol")
		e.Str(s.Protocol)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		e.FieldStart("directoryPath")
		e.Str(s.DirectoryPath)
	}
	{
		if s.SshFingerprint.Set {
			e.FieldStart("sshFingerprint")
			s.SshFingerprint.Encode(e)
		}
	}
}

var jsonFieldsNameOfBackupLocation = [7]string{
	0: "server",
	1: "port",
	2: "protocol",
	3: "username",
	4: "password",
	5: "directoryPath",
	6: "sshFingerprint",
}

// Decode decodes BackupLocation from json.
func (s *BackupLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackupLocation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "server":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Server = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Protocol = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "directoryPath":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DirectoryPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"directoryPath\"")
			}
		case "sshFingerprint":
			if err := func() error {
				s.SshFingerprint.Reset()
				if err := s.SshFingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sshFingerprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackupLocation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackupLocation) {
					name = jsonFieldsNameOfBackupLocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackupLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackupLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackupResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackupResource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
}

var jsonFieldsNameOfBackupResource = [1]string{
	0: "resourceType",
}

// Decode decodes BackupResource from json.
func (s *BackupResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackupResource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackupResource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackupResource) {
					name = jsonFieldsNameOfBackupResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackupResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackupResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackupRetentionPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackupRetentionPolicy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("numberOfMostRecentBackups")
		e.Int32(s.NumberOfMostRecentBackups)
	}
	{
		if s.NumberOfDaysOfHourlyBackups.Set {
			e.FieldStart("numberOfDaysOfHourlyBackups")
			s.NumberOfDaysOfHourlyBackups.Encode(e)
		}
	}
	{
		if s.NumberOfDaysOfDailyBackups.Set {
			e.FieldStart("numberOfDaysOfDailyBackups")
			s.NumberOfDaysOfDailyBackups.Encode(e)
		}
	}
}

var jsonFieldsNameOfBackupRetentionPolicy = [3]string{
	0: "numberOfMostRecentBackups",
	1: "numberOfDaysOfHourlyBackups",
	2: "numberOfDaysOfDailyBackups",
}

// Decode decodes BackupRetentionPolicy from json.
func (s *BackupRetentionPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackupRetentionPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "numberOfMostRecentBackups":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.NumberOfMostRecentBackups = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfMostRecentBackups\"")
			}
		case "numberOfDaysOfHourlyBackups":
			if err := func() error {
				s.NumberOfDaysOfHourlyBackups.Reset()
				if err := s.NumberOfDaysOfHourlyBackups.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfDaysOfHourlyBackups\"")
			}
		case "numberOfDaysOfDailyBackups":
			if err := func() error {
				s.NumberOfDaysOfDailyBackups.Reset()
				if err := s.NumberOfDaysOfDailyBackups.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfDaysOfDailyBackups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackupRetentionPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackupRetentionPolicy) {
					name = jsonFieldsNameOfBackupRetentionPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackupRetentionPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackupRetentionPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackupSchedule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackupSchedule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		if s.TakeScheduledBackups.Set {
			e.FieldStart("takeScheduledBackups")
			s.TakeScheduledBackups.Encode(e)
		}
	}
	{
		e.FieldStart("frequency")
		e.Str(s.Frequency)
	}
	{
		if s.DaysOfWeek != nil {
			e.FieldStart("daysOfWeek")
			e.ArrStart()
			for _, elem := range s.DaysOfWeek {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HourOfDay.Set {
			e.FieldStart("hourOfDay")
			s.HourOfDay.Encode(e)
		}
	}
	{
		if s.MinuteOfHour.Set {
			e.FieldStart("minuteOfHour")
			s.MinuteOfHour.Encode(e)
		}
	}
	{
		if s.TakeBackupOnStateChange.Set {
			e.FieldStart("takeBackupOnStateChange")
			s.TakeBackupOnStateChange.Encode(e)
		}
	}
	{
		if s.RetentionPolicy.Set {
			e.FieldStart("retentionPolicy")
			s.RetentionPolicy.Encode(e)
		}
	}
}

var jsonFieldsNameOfBackupSchedule = [8]string{
	0: "resourceType",
	1: "takeScheduledBackups",
	2: "frequency",
	3: "daysOfWeek",
	4: "hourOfDay",
	5: "minuteOfHour",
	6: "takeBackupOnStateChange",
	7: "retentionPolicy",
}

// Decode decodes BackupSchedule from json.
func (s *BackupSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackupSchedule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "takeScheduledBackups":
			if err := func() error {
				s.TakeScheduledBackups.Reset()
				if err := s.TakeScheduledBackups.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takeScheduledBackups\"")
			}
		case "frequency":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Frequency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency\"")
			}
		case "daysOfWeek":
			if err := func() error {
				s.DaysOfWeek = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DaysOfWeek = append(s.DaysOfWeek, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysOfWeek\"")
			}
		case "hourOfDay":
			if err := func() error {
				s.HourOfDay.Reset()
				if err := s.HourOfDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hourOfDay\"")
			}
		case "minuteOfHour":
			if err := func() error {
				s.MinuteOfHour.Reset()
				if err := s.MinuteOfHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minuteOfHour\"")
			}
		case "takeBackupOnStateChange":
			if err := func() error {
				s.TakeBackupOnStateChange.Reset()
				if err := s.TakeBackupOnStateChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takeBackupOnStateChange\"")
			}
		case "retentionPolicy":
			if err := func() error {
				s.RetentionPolicy.Reset()
				if err := s.RetentionPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retentionPolicy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackupSchedule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackupSchedule) {
					name = jsonFieldsNameOfBackupSchedule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackupSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackupSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackupSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackupSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("elements")
		e.ArrStart()
		for _, elem := range s.Elements {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBackupSpec = [1]string{
	0: "elements",
}

// Decode decodes BackupSpec from json.
func (s *BackupSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackupSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Elements = make([]BackupResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BackupResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackupSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBackupSpec) {
					name = jsonFieldsNameOfBackupSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackupSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackupSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BackupTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BackupTask) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBackupTask = [5]string{
	0: "id",
	1: "name",
	2: "status",
	3: "resources",
	4: "errors",
}

// Decode decodes BackupTask from json.
func (s *BackupTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BackupTask to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]Resource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Resource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BackupTask")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BackupTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BackupTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BaseAlias) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BaseAlias) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("aliases")
		e.ArrStart()
		for _, elem := range s.Aliases {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBaseAlias = [2]string{
	0: "version",
	1: "aliases",
}

// Decode decodes BaseAlias from json.
func (s *BaseAlias) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseAlias to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "aliases":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Aliases = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Aliases = append(s.Aliases, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aliases\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseAlias")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBaseAlias) {
					name = jsonFieldsNameOfBaseAlias[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BaseAlias) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BaseAlias) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BaseCredential) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BaseCredential) encodeFields(e *jx.Encoder) {
	{
		if s.CredentialType.Set {
			e.FieldStart("credentialType")
			s.CredentialType.Encode(e)
		}
	}
	{
		if s.AccountType.Set {
			e.FieldStart("accountType")
			s.AccountType.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfBaseCredential = [4]string{
	0: "credentialType",
	1: "accountType",
	2: "username",
	3: "password",
}

// Decode decodes BaseCredential from json.
func (s *BaseCredential) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseCredential to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "credentialType":
			if err := func() error {
				s.CredentialType.Reset()
				if err := s.CredentialType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentialType\"")
			}
		case "accountType":
			if err := func() error {
				s.AccountType.Reset()
				if err := s.AccountType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountType\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseCredential")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBaseCredential) {
					name = jsonFieldsNameOfBaseCredential[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BaseCredential) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BaseCredential) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BaseImageDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BaseImageDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("displayName")
		e.Str(s.DisplayName)
	}
	{
		e.FieldStart("displayVersion")
		e.Str(s.DisplayVersion)
	}
	{
		if s.ReleaseDate.Set {
			e.FieldStart("releaseDate")
			s.ReleaseDate.Encode(e)
		}
	}
	{
		if s.ReleaseTimestamp.Set {
			e.FieldStart("releaseTimestamp")
			s.ReleaseTimestamp.Encode(e)
		}
	}
	{
		if s.QuickPatchCompatibleVersions != nil {
			e.FieldStart("quickPatchCompatibleVersions")
			e.ArrStart()
			for _, elem := range s.QuickPatchCompatibleVersions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBaseImageDetails = [5]string{
	0: "displayName",
	1: "displayVersion",
	2: "releaseDate",
	3: "releaseTimestamp",
	4: "quickPatchCompatibleVersions",
}

// Decode decodes BaseImageDetails from json.
func (s *BaseImageDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseImageDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "displayName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "displayVersion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DisplayVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayVersion\"")
			}
		case "releaseDate":
			if err := func() error {
				s.ReleaseDate.Reset()
				if err := s.ReleaseDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releaseDate\"")
			}
		case "releaseTimestamp":
			if err := func() error {
				s.ReleaseTimestamp.Reset()
				if err := s.ReleaseTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releaseTimestamp\"")
			}
		case "quickPatchCompatibleVersions":
			if err := func() error {
				s.QuickPatchCompatibleVersions = make([]Version, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Version
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.QuickPatchCompatibleVersions = append(s.QuickPatchCompatibleVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quickPatchCompatibleVersions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseImageDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBaseImageDetails) {
					name = jsonFieldsNameOfBaseImageDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BaseImageDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BaseImageDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BaseImageInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BaseImageInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfBaseImageInfo = [2]string{
	0: "version",
	1: "details",
}

// Decode decodes BaseImageInfo from json.
func (s *BaseImageInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseImageInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseImageInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBaseImageInfo) {
					name = jsonFieldsNameOfBaseImageInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BaseImageInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BaseImageInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BasicAuthDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BasicAuthDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
}

var jsonFieldsNameOfBasicAuthDetails = [2]string{
	0: "status",
	1: "username",
}

// Decode decodes BasicAuthDetails from json.
func (s *BasicAuthDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BasicAuthDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BasicAuthDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBasicAuthDetails) {
					name = jsonFieldsNameOfBasicAuthDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BasicAuthDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BasicAuthDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BgpPeerSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BgpPeerSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ip")
		e.Str(s.IP)
	}
	{
		e.FieldStart("asn")
		e.Int64(s.Asn)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfBgpPeerSpec = [3]string{
	0: "ip",
	1: "asn",
	2: "password",
}

// Decode decodes BgpPeerSpec from json.
func (s *BgpPeerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BgpPeerSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ip":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IP = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		case "asn":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Asn = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asn\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BgpPeerSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBgpPeerSpec) {
					name = jsonFieldsNameOfBgpPeerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BgpPeerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BgpPeerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Bundle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Bundle) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		if s.Vendor.Set {
			e.FieldStart("vendor")
			s.Vendor.Encode(e)
		}
	}
	{
		if s.ReleasedDate.Set {
			e.FieldStart("releasedDate")
			s.ReleasedDate.Encode(e)
		}
	}
	{
		if s.IsCumulative.Set {
			e.FieldStart("isCumulative")
			s.IsCumulative.Encode(e)
		}
	}
	{
		if s.IsCompliant.Set {
			e.FieldStart("isCompliant")
			s.IsCompliant.Encode(e)
		}
	}
	{
		if s.SizeMB.Set {
			e.FieldStart("sizeMB")
			s.SizeMB.Encode(e)
		}
	}
	{
		e.FieldStart("downloadStatus")
		e.Str(s.DownloadStatus)
	}
	{
		if s.Components != nil {
			e.FieldStart("components")
			e.ArrStart()
			for _, elem := range s.Components {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ApplicabilityStatus.Set {
			e.FieldStart("applicabilityStatus")
			s.ApplicabilityStatus.Encode(e)
		}
	}
	{
		if s.ApplicabilityOrder.Set {
			e.FieldStart("applicabilityOrder")
			s.ApplicabilityOrder.Encode(e)
		}
	}
	{
		if s.IsPartiallyUpgraded.Set {
			e.FieldStart("isPartiallyUpgraded")
			s.IsPartiallyUpgraded.Encode(e)
		}
	}
}

var jsonFieldsNameOfBundle = [15]string{
	0:  "id",
	1:  "type",
	2:  "description",
	3:  "version",
	4:  "severity",
	5:  "vendor",
	6:  "releasedDate",
	7:  "isCumulative",
	8:  "isCompliant",
	9:  "sizeMB",
	10: "downloadStatus",
	11: "components",
	12: "applicabilityStatus",
	13: "applicabilityOrder",
	14: "isPartiallyUpgraded",
}

// Decode decodes Bundle from json.
func (s *Bundle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Bundle to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "vendor":
			if err := func() error {
				s.Vendor.Reset()
				if err := s.Vendor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vendor\"")
			}
		case "releasedDate":
			if err := func() error {
				s.ReleasedDate.Reset()
				if err := s.ReleasedDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releasedDate\"")
			}
		case "isCumulative":
			if err := func() error {
				s.IsCumulative.Reset()
				if err := s.IsCumulative.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isCumulative\"")
			}
		case "isCompliant":
			if err := func() error {
				s.IsCompliant.Reset()
				if err := s.IsCompliant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isCompliant\"")
			}
		case "sizeMB":
			if err := func() error {
				s.SizeMB.Reset()
				if err := s.SizeMB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sizeMB\"")
			}
		case "downloadStatus":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DownloadStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloadStatus\"")
			}
		case "components":
			if err := func() error {
				s.Components = make([]BundleComponent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BundleComponent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Components = append(s.Components, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"components\"")
			}
		case "applicabilityStatus":
			if err := func() error {
				s.ApplicabilityStatus.Reset()
				if err := s.ApplicabilityStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applicabilityStatus\"")
			}
		case "applicabilityOrder":
			if err := func() error {
				s.ApplicabilityOrder.Reset()
				if err := s.ApplicabilityOrder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applicabilityOrder\"")
			}
		case "isPartiallyUpgraded":
			if err := func() error {
				s.IsPartiallyUpgraded.Reset()
				if err := s.IsPartiallyUpgraded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isPartiallyUpgraded\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Bundle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000010,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBundle) {
					name = jsonFieldsNameOfBundle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Bundle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Bundle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BundleComponent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BundleComponent) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Vendor.Set {
			e.FieldStart("vendor")
			s.Vendor.Encode(e)
		}
	}
	{
		if s.ReleasedDate.Set {
			e.FieldStart("releasedDate")
			s.ReleasedDate.Encode(e)
		}
	}
	{
		if s.ToVersion.Set {
			e.FieldStart("toVersion")
			s.ToVersion.Encode(e)
		}
	}
	{
		if s.FromVersion.Set {
			e.FieldStart("fromVersion")
			s.FromVersion.Encode(e)
		}
	}
	{
		e.FieldStart("imageType")
		e.Str(s.ImageType)
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfBundleComponent = [8]string{
	0: "description",
	1: "vendor",
	2: "releasedDate",
	3: "toVersion",
	4: "fromVersion",
	5: "imageType",
	6: "id",
	7: "type",
}

// Decode decodes BundleComponent from json.
func (s *BundleComponent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BundleComponent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "vendor":
			if err := func() error {
				s.Vendor.Reset()
				if err := s.Vendor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vendor\"")
			}
		case "releasedDate":
			if err := func() error {
				s.ReleasedDate.Reset()
				if err := s.ReleasedDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releasedDate\"")
			}
		case "toVersion":
			if err := func() error {
				s.ToVersion.Reset()
				if err := s.ToVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"toVersion\"")
			}
		case "fromVersion":
			if err := func() error {
				s.FromVersion.Reset()
				if err := s.FromVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fromVersion\"")
			}
		case "imageType":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ImageType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageType\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BundleComponent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBundleComponent) {
					name = jsonFieldsNameOfBundleComponent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BundleComponent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BundleComponent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BundleDownloadSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BundleDownloadSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ScheduledTimestamp.Set {
			e.FieldStart("scheduledTimestamp")
			s.ScheduledTimestamp.Encode(e)
		}
	}
	{
		if s.DownloadNow.Set {
			e.FieldStart("downloadNow")
			s.DownloadNow.Encode(e)
		}
	}
	{
		if s.CancelNow.Set {
			e.FieldStart("cancelNow")
			s.CancelNow.Encode(e)
		}
	}
}

var jsonFieldsNameOfBundleDownloadSpec = [3]string{
	0: "scheduledTimestamp",
	1: "downloadNow",
	2: "cancelNow",
}

// Decode decodes BundleDownloadSpec from json.
func (s *BundleDownloadSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BundleDownloadSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scheduledTimestamp":
			if err := func() error {
				s.ScheduledTimestamp.Reset()
				if err := s.ScheduledTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduledTimestamp\"")
			}
		case "downloadNow":
			if err := func() error {
				s.DownloadNow.Reset()
				if err := s.DownloadNow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloadNow\"")
			}
		case "cancelNow":
			if err := func() error {
				s.CancelNow.Reset()
				if err := s.CancelNow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancelNow\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BundleDownloadSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BundleDownloadSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BundleDownloadSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BundleInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BundleInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfBundleInfo = [3]string{
	0: "id",
	1: "type",
	2: "name",
}

// Decode decodes BundleInfo from json.
func (s *BundleInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BundleInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BundleInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBundleInfo) {
					name = jsonFieldsNameOfBundleInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BundleInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BundleInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BundleUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BundleUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		if s.BundleDownloadSpec.Set {
			e.FieldStart("bundleDownloadSpec")
			s.BundleDownloadSpec.Encode(e)
		}
	}
	{
		if s.CompatibilitySetsFilePath.Set {
			e.FieldStart("compatibilitySetsFilePath")
			s.CompatibilitySetsFilePath.Encode(e)
		}
	}
}

var jsonFieldsNameOfBundleUpdateSpec = [2]string{
	0: "bundleDownloadSpec",
	1: "compatibilitySetsFilePath",
}

// Decode decodes BundleUpdateSpec from json.
func (s *BundleUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BundleUpdateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bundleDownloadSpec":
			if err := func() error {
				s.BundleDownloadSpec.Reset()
				if err := s.BundleDownloadSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleDownloadSpec\"")
			}
		case "compatibilitySetsFilePath":
			if err := func() error {
				s.CompatibilitySetsFilePath.Reset()
				if err := s.CompatibilitySetsFilePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compatibilitySetsFilePath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BundleUpdateSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BundleUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BundleUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BundleUploadSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BundleUploadSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bundleFilePath")
		e.Str(s.BundleFilePath)
	}
	{
		e.FieldStart("manifestFilePath")
		e.Str(s.ManifestFilePath)
	}
	{
		if s.SignatureFilePath.Set {
			e.FieldStart("signatureFilePath")
			s.SignatureFilePath.Encode(e)
		}
	}
	{
		if s.CompatibilitySetsFilePath.Set {
			e.FieldStart("compatibilitySetsFilePath")
			s.CompatibilitySetsFilePath.Encode(e)
		}
	}
	{
		if s.PartnerExtensionSpec.Set {
			e.FieldStart("partnerExtensionSpec")
			s.PartnerExtensionSpec.Encode(e)
		}
	}
}

var jsonFieldsNameOfBundleUploadSpec = [5]string{
	0: "bundleFilePath",
	1: "manifestFilePath",
	2: "signatureFilePath",
	3: "compatibilitySetsFilePath",
	4: "partnerExtensionSpec",
}

// Decode decodes BundleUploadSpec from json.
func (s *BundleUploadSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BundleUploadSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bundleFilePath":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BundleFilePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleFilePath\"")
			}
		case "manifestFilePath":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ManifestFilePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"manifestFilePath\"")
			}
		case "signatureFilePath":
			if err := func() error {
				s.SignatureFilePath.Reset()
				if err := s.SignatureFilePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signatureFilePath\"")
			}
		case "compatibilitySetsFilePath":
			if err := func() error {
				s.CompatibilitySetsFilePath.Reset()
				if err := s.CompatibilitySetsFilePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compatibilitySetsFilePath\"")
			}
		case "partnerExtensionSpec":
			if err := func() error {
				s.PartnerExtensionSpec.Reset()
				if err := s.PartnerExtensionSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partnerExtensionSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BundleUploadSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBundleUploadSpec) {
					name = jsonFieldsNameOfBundleUploadSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BundleUploadSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BundleUploadSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CPU) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CPU) encodeFields(e *jx.Encoder) {
	{
		if s.FrequencyMHz.Set {
			e.FieldStart("frequencyMHz")
			s.FrequencyMHz.Encode(e)
		}
	}
	{
		if s.UsedFrequencyMHz.Set {
			e.FieldStart("usedFrequencyMHz")
			s.UsedFrequencyMHz.Encode(e)
		}
	}
	{
		if s.Cores.Set {
			e.FieldStart("cores")
			s.Cores.Encode(e)
		}
	}
	{
		if s.CpuCores != nil {
			e.FieldStart("cpuCores")
			e.ArrStart()
			for _, elem := range s.CpuCores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCPU = [4]string{
	0: "frequencyMHz",
	1: "usedFrequencyMHz",
	2: "cores",
	3: "cpuCores",
}

// Decode decodes CPU from json.
func (s *CPU) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CPU to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "frequencyMHz":
			if err := func() error {
				s.FrequencyMHz.Reset()
				if err := s.FrequencyMHz.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequencyMHz\"")
			}
		case "usedFrequencyMHz":
			if err := func() error {
				s.UsedFrequencyMHz.Reset()
				if err := s.UsedFrequencyMHz.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedFrequencyMHz\"")
			}
		case "cores":
			if err := func() error {
				s.Cores.Reset()
				if err := s.Cores.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cores\"")
			}
		case "cpuCores":
			if err := func() error {
				s.CpuCores = make([]CpuCore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CpuCore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CpuCores = append(s.CpuCores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CPU")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CPU) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CPU) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CancelCredentialsTaskBadRequest as json.
func (s *CancelCredentialsTaskBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CancelCredentialsTaskBadRequest from json.
func (s *CancelCredentialsTaskBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CancelCredentialsTaskBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CancelCredentialsTaskBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CancelCredentialsTaskBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CancelCredentialsTaskBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CancelCredentialsTaskInternalServerError as json.
func (s *CancelCredentialsTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CancelCredentialsTaskInternalServerError from json.
func (s *CancelCredentialsTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CancelCredentialsTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CancelCredentialsTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CancelCredentialsTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CancelCredentialsTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CancelTaskConflict as json.
func (s *CancelTaskConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CancelTaskConflict from json.
func (s *CancelTaskConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CancelTaskConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CancelTaskConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CancelTaskConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CancelTaskConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CancelTaskInternalServerError as json.
func (s *CancelTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CancelTaskInternalServerError from json.
func (s *CancelTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CancelTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CancelTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CancelTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CancelTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CancelTaskNotFound as json.
func (s *CancelTaskNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CancelTaskNotFound from json.
func (s *CancelTaskNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CancelTaskNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CancelTaskNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CancelTaskNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CancelTaskNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Capacity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Capacity) encodeFields(e *jx.Encoder) {
	{
		if s.CPU.Set {
			e.FieldStart("cpu")
			s.CPU.Encode(e)
		}
	}
	{
		if s.Memory.Set {
			e.FieldStart("memory")
			s.Memory.Encode(e)
		}
	}
	{
		if s.Storage.Set {
			e.FieldStart("storage")
			s.Storage.Encode(e)
		}
	}
}

var jsonFieldsNameOfCapacity = [3]string{
	0: "cpu",
	1: "memory",
	2: "storage",
}

// Decode decodes Capacity from json.
func (s *Capacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Capacity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpu":
			if err := func() error {
				s.CPU.Reset()
				if err := s.CPU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu\"")
			}
		case "memory":
			if err := func() error {
				s.Memory.Reset()
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		case "storage":
			if err := func() error {
				s.Storage.Reset()
				if err := s.Storage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Capacity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Capacity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Capacity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Ceip) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Ceip) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		if s.InstanceId.Set {
			e.FieldStart("instanceId")
			s.InstanceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfCeip = [2]string{
	0: "status",
	1: "instanceId",
}

// Decode decodes Ceip from json.
func (s *Ceip) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Ceip to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instanceId":
			if err := func() error {
				s.InstanceId.Reset()
				if err := s.InstanceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instanceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Ceip")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCeip) {
					name = jsonFieldsNameOfCeip[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Ceip) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Ceip) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Certificate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Certificate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isInstalled")
		e.Bool(s.IsInstalled)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("serialNumber")
		e.Str(s.SerialNumber)
	}
	{
		e.FieldStart("issuedTo")
		e.Str(s.IssuedTo)
	}
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		if s.ResourceName.Set {
			e.FieldStart("resourceName")
			s.ResourceName.Encode(e)
		}
	}
	{
		e.FieldStart("issuedBy")
		e.Str(s.IssuedBy)
	}
	{
		e.FieldStart("notBefore")
		e.Str(s.NotBefore)
	}
	{
		e.FieldStart("notAfter")
		e.Str(s.NotAfter)
	}
	{
		e.FieldStart("signatureAlgorithm")
		e.Str(s.SignatureAlgorithm)
	}
	{
		e.FieldStart("subject")
		e.Str(s.Subject)
	}
	{
		e.FieldStart("domain")
		e.Str(s.Domain)
	}
	{
		e.FieldStart("subjectAlternativeName")
		e.ArrStart()
		for _, elem := range s.SubjectAlternativeName {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("publicKey")
		e.Str(s.PublicKey)
	}
	{
		e.FieldStart("publicKeyAlgorithm")
		e.Str(s.PublicKeyAlgorithm)
	}
	{
		e.FieldStart("keySize")
		e.Str(s.KeySize)
	}
	{
		e.FieldStart("thumbprintAlgorithm")
		e.Str(s.ThumbprintAlgorithm)
	}
	{
		e.FieldStart("thumbprint")
		e.Str(s.Thumbprint)
	}
	{
		e.FieldStart("numberOfDaysToExpire")
		e.Int32(s.NumberOfDaysToExpire)
	}
	{
		e.FieldStart("expirationStatus")
		e.Str(s.ExpirationStatus)
	}
	{
		e.FieldStart("pemEncoded")
		e.Str(s.PemEncoded)
	}
	{
		e.FieldStart("getCertificateError")
		e.Str(s.GetCertificateError)
	}
	{
		if s.OperationType.Set {
			e.FieldStart("operationType")
			s.OperationType.Encode(e)
		}
	}
	{
		if s.OperationStatus.Set {
			e.FieldStart("operationStatus")
			s.OperationStatus.Encode(e)
		}
	}
	{
		if s.OperationMessage.Set {
			e.FieldStart("operationMessage")
			s.OperationMessage.Encode(e)
		}
	}
	{
		if s.CaChain != nil {
			e.FieldStart("caChain")
			e.ArrStart()
			for _, elem := range s.CaChain {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCertificate = [26]string{
	0:  "isInstalled",
	1:  "version",
	2:  "serialNumber",
	3:  "issuedTo",
	4:  "resourceType",
	5:  "resourceName",
	6:  "issuedBy",
	7:  "notBefore",
	8:  "notAfter",
	9:  "signatureAlgorithm",
	10: "subject",
	11: "domain",
	12: "subjectAlternativeName",
	13: "publicKey",
	14: "publicKeyAlgorithm",
	15: "keySize",
	16: "thumbprintAlgorithm",
	17: "thumbprint",
	18: "numberOfDaysToExpire",
	19: "expirationStatus",
	20: "pemEncoded",
	21: "getCertificateError",
	22: "operationType",
	23: "operationStatus",
	24: "operationMessage",
	25: "caChain",
}

// Decode decodes Certificate from json.
func (s *Certificate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Certificate to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isInstalled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsInstalled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isInstalled\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "serialNumber":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SerialNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serialNumber\"")
			}
		case "issuedTo":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.IssuedTo = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuedTo\"")
			}
		case "resourceType":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "resourceName":
			if err := func() error {
				s.ResourceName.Reset()
				if err := s.ResourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		case "issuedBy":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IssuedBy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuedBy\"")
			}
		case "notBefore":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NotBefore = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notBefore\"")
			}
		case "notAfter":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NotAfter = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notAfter\"")
			}
		case "signatureAlgorithm":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SignatureAlgorithm = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signatureAlgorithm\"")
			}
		case "subject":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Subject = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subject\"")
			}
		case "domain":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Domain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "subjectAlternativeName":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.SubjectAlternativeName = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SubjectAlternativeName = append(s.SubjectAlternativeName, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjectAlternativeName\"")
			}
		case "publicKey":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PublicKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicKey\"")
			}
		case "publicKeyAlgorithm":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.PublicKeyAlgorithm = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicKeyAlgorithm\"")
			}
		case "keySize":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.KeySize = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keySize\"")
			}
		case "thumbprintAlgorithm":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ThumbprintAlgorithm = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbprintAlgorithm\"")
			}
		case "thumbprint":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Thumbprint = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbprint\"")
			}
		case "numberOfDaysToExpire":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.NumberOfDaysToExpire = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfDaysToExpire\"")
			}
		case "expirationStatus":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ExpirationStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationStatus\"")
			}
		case "pemEncoded":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PemEncoded = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pemEncoded\"")
			}
		case "getCertificateError":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.GetCertificateError = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"getCertificateError\"")
			}
		case "operationType":
			if err := func() error {
				s.OperationType.Reset()
				if err := s.OperationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationType\"")
			}
		case "operationStatus":
			if err := func() error {
				s.OperationStatus.Reset()
				if err := s.OperationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationStatus\"")
			}
		case "operationMessage":
			if err := func() error {
				s.OperationMessage.Reset()
				if err := s.OperationMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationMessage\"")
			}
		case "caChain":
			if err := func() error {
				s.CaChain = make([]Certificate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Certificate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CaChain = append(s.CaChain, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caChain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Certificate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11011111,
		0b11111111,
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificate) {
					name = jsonFieldsNameOfCertificate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Certificate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Certificate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateAuthority) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateAuthority) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.ServerUrl.Set {
			e.FieldStart("serverUrl")
			s.ServerUrl.Encode(e)
		}
	}
	{
		if s.TemplateName.Set {
			e.FieldStart("templateName")
			s.TemplateName.Encode(e)
		}
	}
	{
		if s.CommonName.Set {
			e.FieldStart("commonName")
			s.CommonName.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.Locality.Set {
			e.FieldStart("locality")
			s.Locality.Encode(e)
		}
	}
	{
		if s.Organization.Set {
			e.FieldStart("organization")
			s.Organization.Encode(e)
		}
	}
	{
		if s.OrganizationUnit.Set {
			e.FieldStart("organizationUnit")
			s.OrganizationUnit.Encode(e)
		}
	}
}

var jsonFieldsNameOfCertificateAuthority = [10]string{
	0: "id",
	1: "username",
	2: "serverUrl",
	3: "templateName",
	4: "commonName",
	5: "country",
	6: "state",
	7: "locality",
	8: "organization",
	9: "organizationUnit",
}

// Decode decodes CertificateAuthority from json.
func (s *CertificateAuthority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateAuthority to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "serverUrl":
			if err := func() error {
				s.ServerUrl.Reset()
				if err := s.ServerUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverUrl\"")
			}
		case "templateName":
			if err := func() error {
				s.TemplateName.Reset()
				if err := s.TemplateName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateName\"")
			}
		case "commonName":
			if err := func() error {
				s.CommonName.Reset()
				if err := s.CommonName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commonName\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "locality":
			if err := func() error {
				s.Locality.Reset()
				if err := s.Locality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locality\"")
			}
		case "organization":
			if err := func() error {
				s.Organization.Reset()
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "organizationUnit":
			if err := func() error {
				s.OrganizationUnit.Reset()
				if err := s.OrganizationUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizationUnit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateAuthority")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificateAuthority) {
					name = jsonFieldsNameOfCertificateAuthority[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateAuthority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateAuthority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateAuthorityCreationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateAuthorityCreationSpec) encodeFields(e *jx.Encoder) {
	{
		if s.OpenSSLCertificateAuthoritySpec.Set {
			e.FieldStart("openSSLCertificateAuthoritySpec")
			s.OpenSSLCertificateAuthoritySpec.Encode(e)
		}
	}
	{
		if s.MicrosoftCertificateAuthoritySpec.Set {
			e.FieldStart("microsoftCertificateAuthoritySpec")
			s.MicrosoftCertificateAuthoritySpec.Encode(e)
		}
	}
}

var jsonFieldsNameOfCertificateAuthorityCreationSpec = [2]string{
	0: "openSSLCertificateAuthoritySpec",
	1: "microsoftCertificateAuthoritySpec",
}

// Decode decodes CertificateAuthorityCreationSpec from json.
func (s *CertificateAuthorityCreationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateAuthorityCreationSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "openSSLCertificateAuthoritySpec":
			if err := func() error {
				s.OpenSSLCertificateAuthoritySpec.Reset()
				if err := s.OpenSSLCertificateAuthoritySpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openSSLCertificateAuthoritySpec\"")
			}
		case "microsoftCertificateAuthoritySpec":
			if err := func() error {
				s.MicrosoftCertificateAuthoritySpec.Reset()
				if err := s.MicrosoftCertificateAuthoritySpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"microsoftCertificateAuthoritySpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateAuthorityCreationSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateAuthorityCreationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateAuthorityCreationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateOperationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateOperationSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("operationType")
		e.Str(s.OperationType)
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCertificateOperationSpec = [2]string{
	0: "operationType",
	1: "resources",
}

// Decode decodes CertificateOperationSpec from json.
func (s *CertificateOperationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateOperationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operationType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OperationType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationType\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]Resource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Resource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateOperationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificateOperationSpec) {
					name = jsonFieldsNameOfCertificateOperationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateOperationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateOperationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateValidation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateValidation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceId")
		e.Str(s.ResourceId)
	}
	{
		e.FieldStart("resourceFqdn")
		e.Str(s.ResourceFqdn)
	}
	{
		e.FieldStart("startTimestamp")
		e.Str(s.StartTimestamp)
	}
	{
		if s.EndTimestamp.Set {
			e.FieldStart("endTimestamp")
			s.EndTimestamp.Encode(e)
		}
	}
	{
		e.FieldStart("validationStatus")
		e.Str(s.ValidationStatus)
	}
	{
		if s.ValidationMessage.Set {
			e.FieldStart("validationMessage")
			s.ValidationMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfCertificateValidation = [6]string{
	0: "resourceId",
	1: "resourceFqdn",
	2: "startTimestamp",
	3: "endTimestamp",
	4: "validationStatus",
	5: "validationMessage",
}

// Decode decodes CertificateValidation from json.
func (s *CertificateValidation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateValidation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceFqdn":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ResourceFqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceFqdn\"")
			}
		case "startTimestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StartTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTimestamp\"")
			}
		case "endTimestamp":
			if err := func() error {
				s.EndTimestamp.Reset()
				if err := s.EndTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTimestamp\"")
			}
		case "validationStatus":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ValidationStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validationStatus\"")
			}
		case "validationMessage":
			if err := func() error {
				s.ValidationMessage.Reset()
				if err := s.ValidationMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validationMessage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateValidation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificateValidation) {
					name = jsonFieldsNameOfCertificateValidation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateValidation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateValidation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateValidationTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateValidationTask) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("validationId")
		e.Str(s.ValidationId)
	}
	{
		if s.StartTimestamp.Set {
			e.FieldStart("startTimestamp")
			s.StartTimestamp.Encode(e)
		}
	}
	{
		if s.EndTimestamp.Set {
			e.FieldStart("endTimestamp")
			s.EndTimestamp.Encode(e)
		}
	}
	{
		e.FieldStart("completed")
		e.Bool(s.Completed)
	}
	{
		e.FieldStart("validations")
		e.ArrStart()
		for _, elem := range s.Validations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCertificateValidationTask = [5]string{
	0: "validationId",
	1: "startTimestamp",
	2: "endTimestamp",
	3: "completed",
	4: "validations",
}

// Decode decodes CertificateValidationTask from json.
func (s *CertificateValidationTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateValidationTask to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "validationId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ValidationId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validationId\"")
			}
		case "startTimestamp":
			if err := func() error {
				s.StartTimestamp.Reset()
				if err := s.StartTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTimestamp\"")
			}
		case "endTimestamp":
			if err := func() error {
				s.EndTimestamp.Reset()
				if err := s.EndTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTimestamp\"")
			}
		case "completed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Completed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed\"")
			}
		case "validations":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Validations = make([]CertificateValidation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CertificateValidation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Validations = append(s.Validations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateValidationTask")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificateValidationTask) {
					name = jsonFieldsNameOfCertificateValidationTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateValidationTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateValidationTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificatesGenerationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificatesGenerationSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("caType")
		e.Str(s.CaType)
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCertificatesGenerationSpec = [2]string{
	0: "caType",
	1: "resources",
}

// Decode decodes CertificatesGenerationSpec from json.
func (s *CertificatesGenerationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificatesGenerationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "caType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CaType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caType\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]Resource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Resource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificatesGenerationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCertificatesGenerationSpec) {
					name = jsonFieldsNameOfCertificatesGenerationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificatesGenerationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificatesGenerationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSetCandidates) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSetCandidates) encodeFields(e *jx.Encoder) {
	{
		if s.CheckSetId.Set {
			e.FieldStart("checkSetId")
			s.CheckSetId.Encode(e)
		}
	}
	{
		if s.CheckSetName.Set {
			e.FieldStart("checkSetName")
			s.CheckSetName.Encode(e)
		}
	}
	{
		if s.CheckSetType.Set {
			e.FieldStart("checkSetType")
			s.CheckSetType.Encode(e)
		}
	}
}

var jsonFieldsNameOfCheckSetCandidates = [3]string{
	0: "checkSetId",
	1: "checkSetName",
	2: "checkSetType",
}

// Decode decodes CheckSetCandidates from json.
func (s *CheckSetCandidates) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSetCandidates to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "checkSetId":
			if err := func() error {
				s.CheckSetId.Reset()
				if err := s.CheckSetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkSetId\"")
			}
		case "checkSetName":
			if err := func() error {
				s.CheckSetName.Reset()
				if err := s.CheckSetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkSetName\"")
			}
		case "checkSetType":
			if err := func() error {
				s.CheckSetType.Reset()
				if err := s.CheckSetType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkSetType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSetCandidates")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSetCandidates) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSetCandidates) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSetQueryDomainResources) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSetQueryDomainResources) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("domainId")
		e.Str(s.DomainId)
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCheckSetQueryDomainResources = [2]string{
	0: "domainId",
	1: "resources",
}

// Decode decodes CheckSetQueryDomainResources from json.
func (s *CheckSetQueryDomainResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSetQueryDomainResources to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DomainId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainId\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]CheckSetQueryResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckSetQueryResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSetQueryDomainResources")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSetQueryDomainResources) {
					name = jsonFieldsNameOfCheckSetQueryDomainResources[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSetQueryDomainResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSetQueryDomainResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSetQueryInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSetQueryInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("checkSetType")
		e.Str(s.CheckSetType)
	}
	{
		e.FieldStart("domains")
		e.ArrStart()
		for _, elem := range s.Domains {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCheckSetQueryInput = [2]string{
	0: "checkSetType",
	1: "domains",
}

// Decode decodes CheckSetQueryInput from json.
func (s *CheckSetQueryInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSetQueryInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "checkSetType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CheckSetType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkSetType\"")
			}
		case "domains":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Domains = make([]CheckSetQueryDomainResources, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckSetQueryDomainResources
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSetQueryInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSetQueryInput) {
					name = jsonFieldsNameOfCheckSetQueryInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSetQueryInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSetQueryInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSetQueryResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSetQueryResource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		if s.ResourceId.Set {
			e.FieldStart("resourceId")
			s.ResourceId.Encode(e)
		}
	}
	{
		if s.ResourceTargetVersion.Set {
			e.FieldStart("resourceTargetVersion")
			s.ResourceTargetVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfCheckSetQueryResource = [3]string{
	0: "resourceType",
	1: "resourceId",
	2: "resourceTargetVersion",
}

// Decode decodes CheckSetQueryResource from json.
func (s *CheckSetQueryResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSetQueryResource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "resourceId":
			if err := func() error {
				s.ResourceId.Reset()
				if err := s.ResourceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceTargetVersion":
			if err := func() error {
				s.ResourceTargetVersion.Reset()
				if err := s.ResourceTargetVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceTargetVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSetQueryResource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSetQueryResource) {
					name = jsonFieldsNameOfCheckSetQueryResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSetQueryResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSetQueryResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSetQueryResourceResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSetQueryResourceResult) encodeFields(e *jx.Encoder) {
	{
		if s.ResourceName.Set {
			e.FieldStart("resourceName")
			s.ResourceName.Encode(e)
		}
	}
	{
		if s.ResourceId.Set {
			e.FieldStart("resourceId")
			s.ResourceId.Encode(e)
		}
	}
	{
		if s.ResourceType.Set {
			e.FieldStart("resourceType")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.ResourceVersion.Set {
			e.FieldStart("resourceVersion")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.CheckSets != nil {
			e.FieldStart("checkSets")
			e.ArrStart()
			for _, elem := range s.CheckSets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExtraContext.Set {
			e.FieldStart("extraContext")
			s.ExtraContext.Encode(e)
		}
	}
}

var jsonFieldsNameOfCheckSetQueryResourceResult = [7]string{
	0: "resourceName",
	1: "resourceId",
	2: "resourceType",
	3: "resourceVersion",
	4: "domain",
	5: "checkSets",
	6: "extraContext",
}

// Decode decodes CheckSetQueryResourceResult from json.
func (s *CheckSetQueryResourceResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSetQueryResourceResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceName":
			if err := func() error {
				s.ResourceName.Reset()
				if err := s.ResourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		case "resourceId":
			if err := func() error {
				s.ResourceId.Reset()
				if err := s.ResourceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "resourceVersion":
			if err := func() error {
				s.ResourceVersion.Reset()
				if err := s.ResourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceVersion\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "checkSets":
			if err := func() error {
				s.CheckSets = make([]CheckSetCandidates, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckSetCandidates
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CheckSets = append(s.CheckSets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkSets\"")
			}
		case "extraContext":
			if err := func() error {
				s.ExtraContext.Reset()
				if err := s.ExtraContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extraContext\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSetQueryResourceResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSetQueryResourceResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSetQueryResourceResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CheckSetQueryResourceResultExtraContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CheckSetQueryResourceResultExtraContext) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes CheckSetQueryResourceResultExtraContext from json.
func (s *CheckSetQueryResourceResultExtraContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSetQueryResourceResultExtraContext to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem CheckSetQueryResourceResultExtraContextItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSetQueryResourceResultExtraContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CheckSetQueryResourceResultExtraContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSetQueryResourceResultExtraContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSetQueryResourceResultExtraContextItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSetQueryResourceResultExtraContextItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCheckSetQueryResourceResultExtraContextItem = [0]string{}

// Decode decodes CheckSetQueryResourceResultExtraContextItem from json.
func (s *CheckSetQueryResourceResultExtraContextItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSetQueryResourceResultExtraContextItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CheckSetQueryResourceResultExtraContextItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSetQueryResourceResultExtraContextItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSetQueryResourceResultExtraContextItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSetQueryResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSetQueryResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("queryId")
		e.Str(s.QueryId)
	}
	{
		e.FieldStart("resources")
		e.ArrStart()
		for _, elem := range s.Resources {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCheckSetQueryResult = [2]string{
	0: "queryId",
	1: "resources",
}

// Decode decodes CheckSetQueryResult from json.
func (s *CheckSetQueryResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSetQueryResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queryId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.QueryId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryId\"")
			}
		case "resources":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Resources = make([]CheckSetQueryResourceResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckSetQueryResourceResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSetQueryResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSetQueryResult) {
					name = jsonFieldsNameOfCheckSetQueryResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSetQueryResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSetQueryResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSetResourceSelection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSetResourceSelection) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceName")
		e.Str(s.ResourceName)
	}
	{
		e.FieldStart("resourceId")
		e.Str(s.ResourceId)
	}
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("checkSets")
		e.ArrStart()
		for _, elem := range s.CheckSets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCheckSetResourceSelection = [5]string{
	0: "resourceName",
	1: "resourceId",
	2: "resourceType",
	3: "domain",
	4: "checkSets",
}

// Decode decodes CheckSetResourceSelection from json.
func (s *CheckSetResourceSelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSetResourceSelection to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		case "resourceId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ResourceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "checkSets":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.CheckSets = make([]SelectedCheckSetCandidate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SelectedCheckSetCandidate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CheckSets = append(s.CheckSets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkSets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSetResourceSelection")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSetResourceSelection) {
					name = jsonFieldsNameOfCheckSetResourceSelection[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSetResourceSelection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSetResourceSelection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSetRunInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSetRunInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("queryId")
		e.Str(s.QueryId)
	}
	{
		e.FieldStart("resources")
		e.ArrStart()
		for _, elem := range s.Resources {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCheckSetRunInput = [2]string{
	0: "queryId",
	1: "resources",
}

// Decode decodes CheckSetRunInput from json.
func (s *CheckSetRunInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSetRunInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queryId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.QueryId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryId\"")
			}
		case "resources":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Resources = make([]CheckSetResourceSelection, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckSetResourceSelection
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSetRunInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSetRunInput) {
					name = jsonFieldsNameOfCheckSetRunInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSetRunInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSetRunInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Classification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Classification) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
}

var jsonFieldsNameOfClassification = [4]string{
	0: "type",
	1: "value",
	2: "description",
	3: "source",
}

// Decode decodes Classification from json.
func (s *Classification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Classification to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Classification")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Classification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Classification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClassificationSource as json.
func (s ClassificationSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ClassificationSource from json.
func (s *ClassificationSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClassificationSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ClassificationSource(v) {
	case ClassificationSourceCLASSIFIER:
		*s = ClassificationSourceCLASSIFIER
	case ClassificationSourceUSERINPUT:
		*s = ClassificationSourceUSERINPUT
	case ClassificationSourceINHERITED:
		*s = ClassificationSourceINHERITED
	default:
		*s = ClassificationSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClassificationSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClassificationSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Cluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Cluster) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.HciMeshData.Set {
			e.FieldStart("hciMeshData")
			s.HciMeshData.Encode(e)
		}
	}
	{
		if s.PrimaryDatastoreName.Set {
			e.FieldStart("primaryDatastoreName")
			s.PrimaryDatastoreName.Encode(e)
		}
	}
	{
		if s.PrimaryDatastoreType.Set {
			e.FieldStart("primaryDatastoreType")
			s.PrimaryDatastoreType.Encode(e)
		}
	}
	{
		if s.Hosts != nil {
			e.FieldStart("hosts")
			e.ArrStart()
			for _, elem := range s.Hosts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsStretched.Set {
			e.FieldStart("isStretched")
			s.IsStretched.Encode(e)
		}
	}
	{
		if s.IsDefault.Set {
			e.FieldStart("isDefault")
			s.IsDefault.Encode(e)
		}
	}
	{
		if s.FailuresToTolerate.Set {
			e.FieldStart("failuresToTolerate")
			s.FailuresToTolerate.Encode(e)
		}
	}
	{
		if s.VdsSpecs != nil {
			e.FieldStart("vdsSpecs")
			e.ArrStart()
			for _, elem := range s.VdsSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsImageBased.Set {
			e.FieldStart("isImageBased")
			s.IsImageBased.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			e.FieldStart("capacity")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Vcenter.Set {
			e.FieldStart("vcenter")
			s.Vcenter.Encode(e)
		}
	}
	{
		if s.ManagedObjectReferenceId.Set {
			e.FieldStart("managedObjectReferenceId")
			s.ManagedObjectReferenceId.Encode(e)
		}
	}
	{
		if s.VsanClusterMode.Set {
			e.FieldStart("vsanClusterMode")
			s.VsanClusterMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfCluster = [18]string{
	0:  "id",
	1:  "domain",
	2:  "name",
	3:  "status",
	4:  "hciMeshData",
	5:  "primaryDatastoreName",
	6:  "primaryDatastoreType",
	7:  "hosts",
	8:  "isStretched",
	9:  "isDefault",
	10: "failuresToTolerate",
	11: "vdsSpecs",
	12: "tags",
	13: "isImageBased",
	14: "capacity",
	15: "vcenter",
	16: "managedObjectReferenceId",
	17: "vsanClusterMode",
}

// Decode decodes Cluster from json.
func (s *Cluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Cluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "hciMeshData":
			if err := func() error {
				s.HciMeshData.Reset()
				if err := s.HciMeshData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hciMeshData\"")
			}
		case "primaryDatastoreName":
			if err := func() error {
				s.PrimaryDatastoreName.Reset()
				if err := s.PrimaryDatastoreName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryDatastoreName\"")
			}
		case "primaryDatastoreType":
			if err := func() error {
				s.PrimaryDatastoreType.Reset()
				if err := s.PrimaryDatastoreType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryDatastoreType\"")
			}
		case "hosts":
			if err := func() error {
				s.Hosts = make([]HostReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		case "isStretched":
			if err := func() error {
				s.IsStretched.Reset()
				if err := s.IsStretched.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isStretched\"")
			}
		case "isDefault":
			if err := func() error {
				s.IsDefault.Reset()
				if err := s.IsDefault.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDefault\"")
			}
		case "failuresToTolerate":
			if err := func() error {
				s.FailuresToTolerate.Reset()
				if err := s.FailuresToTolerate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failuresToTolerate\"")
			}
		case "vdsSpecs":
			if err := func() error {
				s.VdsSpecs = make([]VdsSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VdsSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VdsSpecs = append(s.VdsSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsSpecs\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "isImageBased":
			if err := func() error {
				s.IsImageBased.Reset()
				if err := s.IsImageBased.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isImageBased\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "vcenter":
			if err := func() error {
				s.Vcenter.Reset()
				if err := s.Vcenter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcenter\"")
			}
		case "managedObjectReferenceId":
			if err := func() error {
				s.ManagedObjectReferenceId.Reset()
				if err := s.ManagedObjectReferenceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"managedObjectReferenceId\"")
			}
		case "vsanClusterMode":
			if err := func() error {
				s.VsanClusterMode.Reset()
				if err := s.VsanClusterMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanClusterMode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Cluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Cluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Cluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterCompactionSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterCompactionSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hosts")
		e.ArrStart()
		for _, elem := range s.Hosts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Force.Set {
			e.FieldStart("force")
			s.Force.Encode(e)
		}
	}
	{
		if s.ForceByPassingSafeMinSize.Set {
			e.FieldStart("forceByPassingSafeMinSize")
			s.ForceByPassingSafeMinSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfClusterCompactionSpec = [3]string{
	0: "hosts",
	1: "force",
	2: "forceByPassingSafeMinSize",
}

// Decode decodes ClusterCompactionSpec from json.
func (s *ClusterCompactionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterCompactionSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hosts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Hosts = make([]HostReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		case "forceByPassingSafeMinSize":
			if err := func() error {
				s.ForceByPassingSafeMinSize.Reset()
				if err := s.ForceByPassingSafeMinSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forceByPassingSafeMinSize\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterCompactionSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterCompactionSpec) {
					name = jsonFieldsNameOfClusterCompactionSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterCompactionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterCompactionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterCreationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterCreationSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("domainId")
		e.Str(s.DomainId)
	}
	{
		e.FieldStart("computeSpec")
		s.ComputeSpec.Encode(e)
	}
	{
		if s.DeployWithoutLicenseKeys.Set {
			e.FieldStart("deployWithoutLicenseKeys")
			s.DeployWithoutLicenseKeys.Encode(e)
		}
	}
}

var jsonFieldsNameOfClusterCreationSpec = [3]string{
	0: "domainId",
	1: "computeSpec",
	2: "deployWithoutLicenseKeys",
}

// Decode decodes ClusterCreationSpec from json.
func (s *ClusterCreationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterCreationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DomainId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainId\"")
			}
		case "computeSpec":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ComputeSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"computeSpec\"")
			}
		case "deployWithoutLicenseKeys":
			if err := func() error {
				s.DeployWithoutLicenseKeys.Reset()
				if err := s.DeployWithoutLicenseKeys.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployWithoutLicenseKeys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterCreationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterCreationSpec) {
					name = jsonFieldsNameOfClusterCreationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterCreationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterCreationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterCriterion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterCriterion) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Arguments.Set {
			e.FieldStart("arguments")
			s.Arguments.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfClusterCriterion = [3]string{
	0: "name",
	1: "arguments",
	2: "description",
}

// Decode decodes ClusterCriterion from json.
func (s *ClusterCriterion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterCriterion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments.Reset()
				if err := s.Arguments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterCriterion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterCriterion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterCriterion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ClusterCriterionArguments) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ClusterCriterionArguments) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ClusterCriterionArguments from json.
func (s *ClusterCriterionArguments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterCriterionArguments to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterCriterionArguments")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClusterCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterExpansionNetworkProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterExpansionNetworkProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("nsxtHostSwitchConfigs")
		e.ArrStart()
		for _, elem := range s.NsxtHostSwitchConfigs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfClusterExpansionNetworkProfile = [3]string{
	0: "name",
	1: "description",
	2: "nsxtHostSwitchConfigs",
}

// Decode decodes ClusterExpansionNetworkProfile from json.
func (s *ClusterExpansionNetworkProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterExpansionNetworkProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "nsxtHostSwitchConfigs":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.NsxtHostSwitchConfigs = make([]NsxtHostSwitchConfig, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtHostSwitchConfig
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxtHostSwitchConfigs = append(s.NsxtHostSwitchConfigs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtHostSwitchConfigs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterExpansionNetworkProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterExpansionNetworkProfile) {
					name = jsonFieldsNameOfClusterExpansionNetworkProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterExpansionNetworkProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterExpansionNetworkProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterExpansionNetworkSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterExpansionNetworkSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nsxClusterSpec")
		s.NsxClusterSpec.Encode(e)
	}
	{
		e.FieldStart("networkProfiles")
		e.ArrStart()
		for _, elem := range s.NetworkProfiles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfClusterExpansionNetworkSpec = [2]string{
	0: "nsxClusterSpec",
	1: "networkProfiles",
}

// Decode decodes ClusterExpansionNetworkSpec from json.
func (s *ClusterExpansionNetworkSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterExpansionNetworkSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nsxClusterSpec":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.NsxClusterSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxClusterSpec\"")
			}
		case "networkProfiles":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.NetworkProfiles = make([]ClusterExpansionNetworkProfile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClusterExpansionNetworkProfile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NetworkProfiles = append(s.NetworkProfiles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkProfiles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterExpansionNetworkSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterExpansionNetworkSpec) {
					name = jsonFieldsNameOfClusterExpansionNetworkSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterExpansionNetworkSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterExpansionNetworkSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterExpansionNsxSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterExpansionNsxSpec) encodeFields(e *jx.Encoder) {
	{
		if s.IpAddressPoolsSpec != nil {
			e.FieldStart("ipAddressPoolsSpec")
			e.ArrStart()
			for _, elem := range s.IpAddressPoolsSpec {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("uplinkProfiles")
		e.ArrStart()
		for _, elem := range s.UplinkProfiles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfClusterExpansionNsxSpec = [2]string{
	0: "ipAddressPoolsSpec",
	1: "uplinkProfiles",
}

// Decode decodes ClusterExpansionNsxSpec from json.
func (s *ClusterExpansionNsxSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterExpansionNsxSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddressPoolsSpec":
			if err := func() error {
				s.IpAddressPoolsSpec = make([]IpAddressPoolSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IpAddressPoolSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IpAddressPoolsSpec = append(s.IpAddressPoolsSpec, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPoolsSpec\"")
			}
		case "uplinkProfiles":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.UplinkProfiles = make([]UplinkProfile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UplinkProfile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UplinkProfiles = append(s.UplinkProfiles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplinkProfiles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterExpansionNsxSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterExpansionNsxSpec) {
					name = jsonFieldsNameOfClusterExpansionNsxSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterExpansionNsxSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterExpansionNsxSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterExpansionSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterExpansionSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hostSpecs")
		e.ArrStart()
		for _, elem := range s.HostSpecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.NetworkSpec.Set {
			e.FieldStart("networkSpec")
			s.NetworkSpec.Encode(e)
		}
	}
	{
		if s.VsanNetworkSpecs != nil {
			e.FieldStart("vsanNetworkSpecs")
			e.ArrStart()
			for _, elem := range s.VsanNetworkSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.WitnessSpec.Set {
			e.FieldStart("witnessSpec")
			s.WitnessSpec.Encode(e)
		}
	}
	{
		if s.WitnessTrafficSharedWithVsanTraffic.Set {
			e.FieldStart("witnessTrafficSharedWithVsanTraffic")
			s.WitnessTrafficSharedWithVsanTraffic.Encode(e)
		}
	}
	{
		if s.DeployWithoutLicenseKeys.Set {
			e.FieldStart("deployWithoutLicenseKeys")
			s.DeployWithoutLicenseKeys.Encode(e)
		}
	}
	{
		if s.InterRackExpansion.Set {
			e.FieldStart("interRackExpansion")
			s.InterRackExpansion.Encode(e)
		}
	}
	{
		if s.ForceHostAdditionInPresenceofDeadHosts.Set {
			e.FieldStart("forceHostAdditionInPresenceofDeadHosts")
			s.ForceHostAdditionInPresenceofDeadHosts.Encode(e)
		}
	}
	{
		if s.SkipThumbprintValidation.Set {
			e.FieldStart("skipThumbprintValidation")
			s.SkipThumbprintValidation.Encode(e)
		}
	}
}

var jsonFieldsNameOfClusterExpansionSpec = [9]string{
	0: "hostSpecs",
	1: "networkSpec",
	2: "vsanNetworkSpecs",
	3: "witnessSpec",
	4: "witnessTrafficSharedWithVsanTraffic",
	5: "deployWithoutLicenseKeys",
	6: "interRackExpansion",
	7: "forceHostAdditionInPresenceofDeadHosts",
	8: "skipThumbprintValidation",
}

// Decode decodes ClusterExpansionSpec from json.
func (s *ClusterExpansionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterExpansionSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostSpecs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.HostSpecs = make([]HostSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HostSpecs = append(s.HostSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostSpecs\"")
			}
		case "networkSpec":
			if err := func() error {
				s.NetworkSpec.Reset()
				if err := s.NetworkSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkSpec\"")
			}
		case "vsanNetworkSpecs":
			if err := func() error {
				s.VsanNetworkSpecs = make([]VSANNetworkSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VSANNetworkSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VsanNetworkSpecs = append(s.VsanNetworkSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanNetworkSpecs\"")
			}
		case "witnessSpec":
			if err := func() error {
				s.WitnessSpec.Reset()
				if err := s.WitnessSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"witnessSpec\"")
			}
		case "witnessTrafficSharedWithVsanTraffic":
			if err := func() error {
				s.WitnessTrafficSharedWithVsanTraffic.Reset()
				if err := s.WitnessTrafficSharedWithVsanTraffic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"witnessTrafficSharedWithVsanTraffic\"")
			}
		case "deployWithoutLicenseKeys":
			if err := func() error {
				s.DeployWithoutLicenseKeys.Reset()
				if err := s.DeployWithoutLicenseKeys.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployWithoutLicenseKeys\"")
			}
		case "interRackExpansion":
			if err := func() error {
				s.InterRackExpansion.Reset()
				if err := s.InterRackExpansion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interRackExpansion\"")
			}
		case "forceHostAdditionInPresenceofDeadHosts":
			if err := func() error {
				s.ForceHostAdditionInPresenceofDeadHosts.Reset()
				if err := s.ForceHostAdditionInPresenceofDeadHosts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forceHostAdditionInPresenceofDeadHosts\"")
			}
		case "skipThumbprintValidation":
			if err := func() error {
				s.SkipThumbprintValidation.Reset()
				if err := s.SkipThumbprintValidation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skipThumbprintValidation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterExpansionSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterExpansionSpec) {
					name = jsonFieldsNameOfClusterExpansionSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterExpansionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterExpansionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterNetworkConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterNetworkConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.HostDetails != nil {
			e.FieldStart("hostDetails")
			e.ArrStart()
			for _, elem := range s.HostDetails {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VdsConfigurations != nil {
			e.FieldStart("vdsConfigurations")
			e.ArrStart()
			for _, elem := range s.VdsConfigurations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NonVcfCreatedVds != nil {
			e.FieldStart("nonVcfCreatedVds")
			e.ArrStart()
			for _, elem := range s.NonVcfCreatedVds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IpAddressPools != nil {
			e.FieldStart("ipAddressPools")
			e.ArrStart()
			for _, elem := range s.IpAddressPools {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.UplinkProfiles != nil {
			e.FieldStart("uplinkProfiles")
			e.ArrStart()
			for _, elem := range s.UplinkProfiles {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NetworkProfiles != nil {
			e.FieldStart("networkProfiles")
			e.ArrStart()
			for _, elem := range s.NetworkProfiles {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfClusterNetworkConfiguration = [6]string{
	0: "hostDetails",
	1: "vdsConfigurations",
	2: "nonVcfCreatedVds",
	3: "ipAddressPools",
	4: "uplinkProfiles",
	5: "networkProfiles",
}

// Decode decodes ClusterNetworkConfiguration from json.
func (s *ClusterNetworkConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterNetworkConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostDetails":
			if err := func() error {
				s.HostDetails = make([]HostDetail, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostDetail
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HostDetails = append(s.HostDetails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostDetails\"")
			}
		case "vdsConfigurations":
			if err := func() error {
				s.VdsConfigurations = make([]VdsConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VdsConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VdsConfigurations = append(s.VdsConfigurations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsConfigurations\"")
			}
		case "nonVcfCreatedVds":
			if err := func() error {
				s.NonVcfCreatedVds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NonVcfCreatedVds = append(s.NonVcfCreatedVds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nonVcfCreatedVds\"")
			}
		case "ipAddressPools":
			if err := func() error {
				s.IpAddressPools = make([]NsxtIpAddressPool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtIpAddressPool
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IpAddressPools = append(s.IpAddressPools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPools\"")
			}
		case "uplinkProfiles":
			if err := func() error {
				s.UplinkProfiles = make([]UplinkProfile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UplinkProfile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UplinkProfiles = append(s.UplinkProfiles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplinkProfiles\"")
			}
		case "networkProfiles":
			if err := func() error {
				s.NetworkProfiles = make([]NetworkProfileConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NetworkProfileConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NetworkProfiles = append(s.NetworkProfiles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkProfiles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterNetworkConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterNetworkConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterNetworkConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterNetworkConfigurationCriterion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterNetworkConfigurationCriterion) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Arguments.Set {
			e.FieldStart("arguments")
			s.Arguments.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfClusterNetworkConfigurationCriterion = [3]string{
	0: "name",
	1: "arguments",
	2: "description",
}

// Decode decodes ClusterNetworkConfigurationCriterion from json.
func (s *ClusterNetworkConfigurationCriterion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterNetworkConfigurationCriterion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments.Reset()
				if err := s.Arguments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterNetworkConfigurationCriterion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterNetworkConfigurationCriterion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterNetworkConfigurationCriterion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ClusterNetworkConfigurationCriterionArguments) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ClusterNetworkConfigurationCriterionArguments) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ClusterNetworkConfigurationCriterionArguments from json.
func (s *ClusterNetworkConfigurationCriterionArguments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterNetworkConfigurationCriterionArguments to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterNetworkConfigurationCriterionArguments")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClusterNetworkConfigurationCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterNetworkConfigurationCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterNetworkConfigurationQueryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterNetworkConfigurationQueryResponse) encodeFields(e *jx.Encoder) {
	{
		if s.QueryInfo.Set {
			e.FieldStart("queryInfo")
			s.QueryInfo.Encode(e)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfClusterNetworkConfigurationQueryResponse = [2]string{
	0: "queryInfo",
	1: "result",
}

// Decode decodes ClusterNetworkConfigurationQueryResponse from json.
func (s *ClusterNetworkConfigurationQueryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterNetworkConfigurationQueryResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queryInfo":
			if err := func() error {
				s.QueryInfo.Reset()
				if err := s.QueryInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryInfo\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterNetworkConfigurationQueryResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterNetworkConfigurationQueryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterNetworkConfigurationQueryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterQueryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterQueryResponse) encodeFields(e *jx.Encoder) {
	{
		if s.QueryInfo.Set {
			e.FieldStart("queryInfo")
			s.QueryInfo.Encode(e)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfClusterQueryResponse = [2]string{
	0: "queryInfo",
	1: "result",
}

// Decode decodes ClusterQueryResponse from json.
func (s *ClusterQueryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterQueryResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queryInfo":
			if err := func() error {
				s.QueryInfo.Reset()
				if err := s.QueryInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryInfo\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterQueryResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterQueryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterQueryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfClusterReference = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes ClusterReference from json.
func (s *ClusterReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterReference) {
					name = jsonFieldsNameOfClusterReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ClusterImageId.Set {
			e.FieldStart("clusterImageId")
			s.ClusterImageId.Encode(e)
		}
	}
	{
		if s.VxRailDetails.Set {
			e.FieldStart("vxRailDetails")
			s.VxRailDetails.Encode(e)
		}
	}
	{
		e.FieldStart("hostSpecs")
		e.ArrStart()
		for _, elem := range s.HostSpecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("datastoreSpec")
		s.DatastoreSpec.Encode(e)
	}
	{
		e.FieldStart("networkSpec")
		s.NetworkSpec.Encode(e)
	}
	{
		if s.AdvancedOptions.Set {
			e.FieldStart("advancedOptions")
			s.AdvancedOptions.Encode(e)
		}
	}
	{
		if s.SkipThumbprintValidation.Set {
			e.FieldStart("skipThumbprintValidation")
			s.SkipThumbprintValidation.Encode(e)
		}
	}
}

var jsonFieldsNameOfClusterSpec = [8]string{
	0: "name",
	1: "clusterImageId",
	2: "vxRailDetails",
	3: "hostSpecs",
	4: "datastoreSpec",
	5: "networkSpec",
	6: "advancedOptions",
	7: "skipThumbprintValidation",
}

// Decode decodes ClusterSpec from json.
func (s *ClusterSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "clusterImageId":
			if err := func() error {
				s.ClusterImageId.Reset()
				if err := s.ClusterImageId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterImageId\"")
			}
		case "vxRailDetails":
			if err := func() error {
				s.VxRailDetails.Reset()
				if err := s.VxRailDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vxRailDetails\"")
			}
		case "hostSpecs":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.HostSpecs = make([]HostSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HostSpecs = append(s.HostSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostSpecs\"")
			}
		case "datastoreSpec":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DatastoreSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datastoreSpec\"")
			}
		case "networkSpec":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.NetworkSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkSpec\"")
			}
		case "advancedOptions":
			if err := func() error {
				s.AdvancedOptions.Reset()
				if err := s.AdvancedOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"advancedOptions\"")
			}
		case "skipThumbprintValidation":
			if err := func() error {
				s.SkipThumbprintValidation.Reset()
				if err := s.SkipThumbprintValidation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skipThumbprintValidation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterSpec) {
					name = jsonFieldsNameOfClusterSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterStretchNetworkSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterStretchNetworkSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nsxClusterSpec")
		s.NsxClusterSpec.Encode(e)
	}
	{
		e.FieldStart("networkProfiles")
		e.ArrStart()
		for _, elem := range s.NetworkProfiles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfClusterStretchNetworkSpec = [2]string{
	0: "nsxClusterSpec",
	1: "networkProfiles",
}

// Decode decodes ClusterStretchNetworkSpec from json.
func (s *ClusterStretchNetworkSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterStretchNetworkSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nsxClusterSpec":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.NsxClusterSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxClusterSpec\"")
			}
		case "networkProfiles":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.NetworkProfiles = make([]StretchClusterNetworkProfile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StretchClusterNetworkProfile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NetworkProfiles = append(s.NetworkProfiles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkProfiles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterStretchNetworkSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterStretchNetworkSpec) {
					name = jsonFieldsNameOfClusterStretchNetworkSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterStretchNetworkSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterStretchNetworkSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterStretchSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterStretchSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hostSpecs")
		e.ArrStart()
		for _, elem := range s.HostSpecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("witnessSpec")
		s.WitnessSpec.Encode(e)
	}
	{
		if s.WitnessTrafficSharedWithVsanTraffic.Set {
			e.FieldStart("witnessTrafficSharedWithVsanTraffic")
			s.WitnessTrafficSharedWithVsanTraffic.Encode(e)
		}
	}
	{
		if s.VsanNetworkSpecs != nil {
			e.FieldStart("vsanNetworkSpecs")
			e.ArrStart()
			for _, elem := range s.VsanNetworkSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SecondaryAzOverlayVlanId.Set {
			e.FieldStart("secondaryAzOverlayVlanId")
			s.SecondaryAzOverlayVlanId.Encode(e)
		}
	}
	{
		if s.NetworkSpec.Set {
			e.FieldStart("networkSpec")
			s.NetworkSpec.Encode(e)
		}
	}
	{
		if s.IsEdgeClusterConfiguredForMultiAZ.Set {
			e.FieldStart("isEdgeClusterConfiguredForMultiAZ")
			s.IsEdgeClusterConfiguredForMultiAZ.Encode(e)
		}
	}
	{
		if s.DeployWithoutLicenseKeys.Set {
			e.FieldStart("deployWithoutLicenseKeys")
			s.DeployWithoutLicenseKeys.Encode(e)
		}
	}
}

var jsonFieldsNameOfClusterStretchSpec = [8]string{
	0: "hostSpecs",
	1: "witnessSpec",
	2: "witnessTrafficSharedWithVsanTraffic",
	3: "vsanNetworkSpecs",
	4: "secondaryAzOverlayVlanId",
	5: "networkSpec",
	6: "isEdgeClusterConfiguredForMultiAZ",
	7: "deployWithoutLicenseKeys",
}

// Decode decodes ClusterStretchSpec from json.
func (s *ClusterStretchSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterStretchSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostSpecs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.HostSpecs = make([]HostSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HostSpecs = append(s.HostSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostSpecs\"")
			}
		case "witnessSpec":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.WitnessSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"witnessSpec\"")
			}
		case "witnessTrafficSharedWithVsanTraffic":
			if err := func() error {
				s.WitnessTrafficSharedWithVsanTraffic.Reset()
				if err := s.WitnessTrafficSharedWithVsanTraffic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"witnessTrafficSharedWithVsanTraffic\"")
			}
		case "vsanNetworkSpecs":
			if err := func() error {
				s.VsanNetworkSpecs = make([]VSANNetworkSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VSANNetworkSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VsanNetworkSpecs = append(s.VsanNetworkSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanNetworkSpecs\"")
			}
		case "secondaryAzOverlayVlanId":
			if err := func() error {
				s.SecondaryAzOverlayVlanId.Reset()
				if err := s.SecondaryAzOverlayVlanId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secondaryAzOverlayVlanId\"")
			}
		case "networkSpec":
			if err := func() error {
				s.NetworkSpec.Reset()
				if err := s.NetworkSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkSpec\"")
			}
		case "isEdgeClusterConfiguredForMultiAZ":
			if err := func() error {
				s.IsEdgeClusterConfiguredForMultiAZ.Reset()
				if err := s.IsEdgeClusterConfiguredForMultiAZ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEdgeClusterConfiguredForMultiAZ\"")
			}
		case "deployWithoutLicenseKeys":
			if err := func() error {
				s.DeployWithoutLicenseKeys.Reset()
				if err := s.DeployWithoutLicenseKeys.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployWithoutLicenseKeys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterStretchSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterStretchSpec) {
					name = jsonFieldsNameOfClusterStretchSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterStretchSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterStretchSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterUnstretchSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterUnstretchSpec) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfClusterUnstretchSpec = [0]string{}

// Decode decodes ClusterUnstretchSpec from json.
func (s *ClusterUnstretchSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterUnstretchSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ClusterUnstretchSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterUnstretchSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterUnstretchSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ClusterExpansionSpec.Set {
			e.FieldStart("clusterExpansionSpec")
			s.ClusterExpansionSpec.Encode(e)
		}
	}
	{
		if s.ClusterCompactionSpec.Set {
			e.FieldStart("clusterCompactionSpec")
			s.ClusterCompactionSpec.Encode(e)
		}
	}
	{
		if s.ClusterStretchSpec.Set {
			e.FieldStart("clusterStretchSpec")
			s.ClusterStretchSpec.Encode(e)
		}
	}
	{
		if s.ClusterUnstretchSpec != nil {
			e.FieldStart("clusterUnstretchSpec")
			s.ClusterUnstretchSpec.Encode(e)
		}
	}
	{
		if s.MarkForDeletion.Set {
			e.FieldStart("markForDeletion")
			s.MarkForDeletion.Encode(e)
		}
	}
	{
		if s.PrepareForStretch.Set {
			e.FieldStart("prepareForStretch")
			s.PrepareForStretch.Encode(e)
		}
	}
}

var jsonFieldsNameOfClusterUpdateSpec = [7]string{
	0: "name",
	1: "clusterExpansionSpec",
	2: "clusterCompactionSpec",
	3: "clusterStretchSpec",
	4: "clusterUnstretchSpec",
	5: "markForDeletion",
	6: "prepareForStretch",
}

// Decode decodes ClusterUpdateSpec from json.
func (s *ClusterUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterUpdateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "clusterExpansionSpec":
			if err := func() error {
				s.ClusterExpansionSpec.Reset()
				if err := s.ClusterExpansionSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterExpansionSpec\"")
			}
		case "clusterCompactionSpec":
			if err := func() error {
				s.ClusterCompactionSpec.Reset()
				if err := s.ClusterCompactionSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterCompactionSpec\"")
			}
		case "clusterStretchSpec":
			if err := func() error {
				s.ClusterStretchSpec.Reset()
				if err := s.ClusterStretchSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterStretchSpec\"")
			}
		case "clusterUnstretchSpec":
			if err := func() error {
				s.ClusterUnstretchSpec = nil
				var elem ClusterUnstretchSpec
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ClusterUnstretchSpec = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterUnstretchSpec\"")
			}
		case "markForDeletion":
			if err := func() error {
				s.MarkForDeletion.Reset()
				if err := s.MarkForDeletion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"markForDeletion\"")
			}
		case "prepareForStretch":
			if err := func() error {
				s.PrepareForStretch.Reset()
				if err := s.PrepareForStretch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prepareForStretch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterUpdateSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CommissionHostsInternalServerErrorApplicationJSON as json.
func (s CommissionHostsInternalServerErrorApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CommissionHostsInternalServerErrorApplicationJSON from json.
func (s *CommissionHostsInternalServerErrorApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommissionHostsInternalServerErrorApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CommissionHostsInternalServerErrorApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CommissionHostsInternalServerErrorApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommissionHostsInternalServerErrorApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompatibilityMatrix) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompatibilityMatrix) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("compatibilityMatrixMetadata")
		s.CompatibilityMatrixMetadata.Encode(e)
	}
	{
		e.FieldStart("compatibilityMatrixSource")
		e.Str(s.CompatibilityMatrixSource)
	}
	{
		e.FieldStart("compatibilityMatrixContent")
		e.Str(s.CompatibilityMatrixContent)
	}
}

var jsonFieldsNameOfCompatibilityMatrix = [3]string{
	0: "compatibilityMatrixMetadata",
	1: "compatibilityMatrixSource",
	2: "compatibilityMatrixContent",
}

// Decode decodes CompatibilityMatrix from json.
func (s *CompatibilityMatrix) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompatibilityMatrix to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "compatibilityMatrixMetadata":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CompatibilityMatrixMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compatibilityMatrixMetadata\"")
			}
		case "compatibilityMatrixSource":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CompatibilityMatrixSource = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compatibilityMatrixSource\"")
			}
		case "compatibilityMatrixContent":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CompatibilityMatrixContent = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compatibilityMatrixContent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompatibilityMatrix")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompatibilityMatrix) {
					name = jsonFieldsNameOfCompatibilityMatrix[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompatibilityMatrix) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompatibilityMatrix) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompatibilityMatrixMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompatibilityMatrixMetadata) encodeFields(e *jx.Encoder) {
	{
		if s.IsStale.Set {
			e.FieldStart("isStale")
			s.IsStale.Encode(e)
		}
	}
	{
		if s.IsMissing.Set {
			e.FieldStart("isMissing")
			s.IsMissing.Encode(e)
		}
	}
	{
		if s.LastModifiedDate.Set {
			e.FieldStart("lastModifiedDate")
			s.LastModifiedDate.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("errorMessage")
			s.ErrorMessage.Encode(e)
		}
	}
	{
		if s.WarningMessage.Set {
			e.FieldStart("warningMessage")
			s.WarningMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompatibilityMatrixMetadata = [6]string{
	0: "isStale",
	1: "isMissing",
	2: "lastModifiedDate",
	3: "message",
	4: "errorMessage",
	5: "warningMessage",
}

// Decode decodes CompatibilityMatrixMetadata from json.
func (s *CompatibilityMatrixMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompatibilityMatrixMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isStale":
			if err := func() error {
				s.IsStale.Reset()
				if err := s.IsStale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isStale\"")
			}
		case "isMissing":
			if err := func() error {
				s.IsMissing.Reset()
				if err := s.IsMissing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isMissing\"")
			}
		case "lastModifiedDate":
			if err := func() error {
				s.LastModifiedDate.Reset()
				if err := s.LastModifiedDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModifiedDate\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorMessage":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorMessage\"")
			}
		case "warningMessage":
			if err := func() error {
				s.WarningMessage.Reset()
				if err := s.WarningMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warningMessage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompatibilityMatrixMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompatibilityMatrixMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompatibilityMatrixMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComplianceAudit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComplianceAudit) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreationTimestamp.Set {
			e.FieldStart("creationTimestamp")
			s.CreationTimestamp.Encode(e)
		}
	}
	{
		if s.CompletionTimestamp.Set {
			e.FieldStart("completionTimestamp")
			s.CompletionTimestamp.Encode(e)
		}
	}
	{
		if s.StandardType.Set {
			e.FieldStart("standardType")
			s.StandardType.Encode(e)
		}
	}
	{
		if s.StandardVersion.Set {
			e.FieldStart("standardVersion")
			s.StandardVersion.Encode(e)
		}
	}
	{
		if s.DomainId.Set {
			e.FieldStart("domainId")
			s.DomainId.Encode(e)
		}
	}
	{
		if s.ConfigurationEvaluationStatus.Set {
			e.FieldStart("configurationEvaluationStatus")
			s.ConfigurationEvaluationStatus.Encode(e)
		}
	}
	{
		if s.ConfigurationEvaluationStatusDetails.Set {
			e.FieldStart("configurationEvaluationStatusDetails")
			s.ConfigurationEvaluationStatusDetails.Encode(e)
		}
	}
	{
		if s.CompliantStatus.Set {
			e.FieldStart("compliantStatus")
			s.CompliantStatus.Encode(e)
		}
	}
	{
		if s.TotalConfigurationsEvaluated.Set {
			e.FieldStart("totalConfigurationsEvaluated")
			s.TotalConfigurationsEvaluated.Encode(e)
		}
	}
	{
		if s.NumberOfNonCompliantConfigurations.Set {
			e.FieldStart("numberOfNonCompliantConfigurations")
			s.NumberOfNonCompliantConfigurations.Encode(e)
		}
	}
	{
		if s.NumberOfSkippedConfigurations.Set {
			e.FieldStart("numberOfSkippedConfigurations")
			s.NumberOfSkippedConfigurations.Encode(e)
		}
	}
	{
		if s.NumberOfAuditItems.Set {
			e.FieldStart("numberOfAuditItems")
			s.NumberOfAuditItems.Encode(e)
		}
	}
	{
		if s.AuditItems != nil {
			e.FieldStart("auditItems")
			e.ArrStart()
			for _, elem := range s.AuditItems {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfComplianceAudit = [14]string{
	0:  "id",
	1:  "creationTimestamp",
	2:  "completionTimestamp",
	3:  "standardType",
	4:  "standardVersion",
	5:  "domainId",
	6:  "configurationEvaluationStatus",
	7:  "configurationEvaluationStatusDetails",
	8:  "compliantStatus",
	9:  "totalConfigurationsEvaluated",
	10: "numberOfNonCompliantConfigurations",
	11: "numberOfSkippedConfigurations",
	12: "numberOfAuditItems",
	13: "auditItems",
}

// Decode decodes ComplianceAudit from json.
func (s *ComplianceAudit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceAudit to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "creationTimestamp":
			if err := func() error {
				s.CreationTimestamp.Reset()
				if err := s.CreationTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "completionTimestamp":
			if err := func() error {
				s.CompletionTimestamp.Reset()
				if err := s.CompletionTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTimestamp\"")
			}
		case "standardType":
			if err := func() error {
				s.StandardType.Reset()
				if err := s.StandardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standardType\"")
			}
		case "standardVersion":
			if err := func() error {
				s.StandardVersion.Reset()
				if err := s.StandardVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standardVersion\"")
			}
		case "domainId":
			if err := func() error {
				s.DomainId.Reset()
				if err := s.DomainId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainId\"")
			}
		case "configurationEvaluationStatus":
			if err := func() error {
				s.ConfigurationEvaluationStatus.Reset()
				if err := s.ConfigurationEvaluationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configurationEvaluationStatus\"")
			}
		case "configurationEvaluationStatusDetails":
			if err := func() error {
				s.ConfigurationEvaluationStatusDetails.Reset()
				if err := s.ConfigurationEvaluationStatusDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configurationEvaluationStatusDetails\"")
			}
		case "compliantStatus":
			if err := func() error {
				s.CompliantStatus.Reset()
				if err := s.CompliantStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compliantStatus\"")
			}
		case "totalConfigurationsEvaluated":
			if err := func() error {
				s.TotalConfigurationsEvaluated.Reset()
				if err := s.TotalConfigurationsEvaluated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalConfigurationsEvaluated\"")
			}
		case "numberOfNonCompliantConfigurations":
			if err := func() error {
				s.NumberOfNonCompliantConfigurations.Reset()
				if err := s.NumberOfNonCompliantConfigurations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfNonCompliantConfigurations\"")
			}
		case "numberOfSkippedConfigurations":
			if err := func() error {
				s.NumberOfSkippedConfigurations.Reset()
				if err := s.NumberOfSkippedConfigurations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfSkippedConfigurations\"")
			}
		case "numberOfAuditItems":
			if err := func() error {
				s.NumberOfAuditItems.Reset()
				if err := s.NumberOfAuditItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfAuditItems\"")
			}
		case "auditItems":
			if err := func() error {
				s.AuditItems = make([]ComplianceAuditItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ComplianceAuditItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AuditItems = append(s.AuditItems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auditItems\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComplianceAudit")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceAudit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceAudit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComplianceAuditBadRequest as json.
func (s *ComplianceAuditBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ComplianceAuditBadRequest from json.
func (s *ComplianceAuditBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceAuditBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ComplianceAuditBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceAuditBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceAuditBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComplianceAuditInternalServerError as json.
func (s *ComplianceAuditInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ComplianceAuditInternalServerError from json.
func (s *ComplianceAuditInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceAuditInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ComplianceAuditInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceAuditInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceAuditInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComplianceAuditItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComplianceAuditItem) encodeFields(e *jx.Encoder) {
	{
		if s.ResourceType.Set {
			e.FieldStart("resourceType")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.ResourceVersion.Set {
			e.FieldStart("resourceVersion")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.ResourceName.Set {
			e.FieldStart("resourceName")
			s.ResourceName.Encode(e)
		}
	}
	{
		if s.ConfigurationId.Set {
			e.FieldStart("configurationId")
			s.ConfigurationId.Encode(e)
		}
	}
	{
		if s.ConfigurationTitle.Set {
			e.FieldStart("configurationTitle")
			s.ConfigurationTitle.Encode(e)
		}
	}
	{
		if s.IsConfigurationRecommendedByStandard.Set {
			e.FieldStart("isConfigurationRecommendedByStandard")
			s.IsConfigurationRecommendedByStandard.Encode(e)
		}
	}
	{
		if s.CitationReference.Set {
			e.FieldStart("citationReference")
			s.CitationReference.Encode(e)
		}
	}
	{
		if s.RecommendedValue.Set {
			e.FieldStart("recommendedValue")
			s.RecommendedValue.Encode(e)
		}
	}
	{
		if s.ActualValue.Set {
			e.FieldStart("actualValue")
			s.ActualValue.Encode(e)
		}
	}
	{
		if s.ComplianceStatus.Set {
			e.FieldStart("complianceStatus")
			s.ComplianceStatus.Encode(e)
		}
	}
	{
		if s.RemediationStep.Set {
			e.FieldStart("remediationStep")
			s.RemediationStep.Encode(e)
		}
	}
	{
		if s.ComplianceAuditStatus.Set {
			e.FieldStart("complianceAuditStatus")
			s.ComplianceAuditStatus.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("errorMessage")
			s.ErrorMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfComplianceAuditItem = [13]string{
	0:  "resourceType",
	1:  "resourceVersion",
	2:  "resourceName",
	3:  "configurationId",
	4:  "configurationTitle",
	5:  "isConfigurationRecommendedByStandard",
	6:  "citationReference",
	7:  "recommendedValue",
	8:  "actualValue",
	9:  "complianceStatus",
	10: "remediationStep",
	11: "complianceAuditStatus",
	12: "errorMessage",
}

// Decode decodes ComplianceAuditItem from json.
func (s *ComplianceAuditItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceAuditItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "resourceVersion":
			if err := func() error {
				s.ResourceVersion.Reset()
				if err := s.ResourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceVersion\"")
			}
		case "resourceName":
			if err := func() error {
				s.ResourceName.Reset()
				if err := s.ResourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		case "configurationId":
			if err := func() error {
				s.ConfigurationId.Reset()
				if err := s.ConfigurationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configurationId\"")
			}
		case "configurationTitle":
			if err := func() error {
				s.ConfigurationTitle.Reset()
				if err := s.ConfigurationTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configurationTitle\"")
			}
		case "isConfigurationRecommendedByStandard":
			if err := func() error {
				s.IsConfigurationRecommendedByStandard.Reset()
				if err := s.IsConfigurationRecommendedByStandard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConfigurationRecommendedByStandard\"")
			}
		case "citationReference":
			if err := func() error {
				s.CitationReference.Reset()
				if err := s.CitationReference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"citationReference\"")
			}
		case "recommendedValue":
			if err := func() error {
				s.RecommendedValue.Reset()
				if err := s.RecommendedValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recommendedValue\"")
			}
		case "actualValue":
			if err := func() error {
				s.ActualValue.Reset()
				if err := s.ActualValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actualValue\"")
			}
		case "complianceStatus":
			if err := func() error {
				s.ComplianceStatus.Reset()
				if err := s.ComplianceStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"complianceStatus\"")
			}
		case "remediationStep":
			if err := func() error {
				s.RemediationStep.Reset()
				if err := s.RemediationStep.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediationStep\"")
			}
		case "complianceAuditStatus":
			if err := func() error {
				s.ComplianceAuditStatus.Reset()
				if err := s.ComplianceAuditStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"complianceAuditStatus\"")
			}
		case "errorMessage":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorMessage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComplianceAuditItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceAuditItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceAuditItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ComplianceAuditNotFound as json.
func (s *ComplianceAuditNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ComplianceAuditNotFound from json.
func (s *ComplianceAuditNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceAuditNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ComplianceAuditNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceAuditNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceAuditNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComplianceAuditSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComplianceAuditSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("standardType")
		e.Str(s.StandardType)
	}
	{
		e.FieldStart("standardVersion")
		e.Str(s.StandardVersion)
	}
	{
		e.FieldStart("complianceResourcesConfigurationSpec")
		e.ArrStart()
		for _, elem := range s.ComplianceResourcesConfigurationSpec {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfComplianceAuditSpec = [3]string{
	0: "standardType",
	1: "standardVersion",
	2: "complianceResourcesConfigurationSpec",
}

// Decode decodes ComplianceAuditSpec from json.
func (s *ComplianceAuditSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceAuditSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "standardType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.StandardType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standardType\"")
			}
		case "standardVersion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.StandardVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standardVersion\"")
			}
		case "complianceResourcesConfigurationSpec":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.ComplianceResourcesConfigurationSpec = make([]ComplianceResourcesConfigurationSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ComplianceResourcesConfigurationSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ComplianceResourcesConfigurationSpec = append(s.ComplianceResourcesConfigurationSpec, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"complianceResourcesConfigurationSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComplianceAuditSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfComplianceAuditSpec) {
					name = jsonFieldsNameOfComplianceAuditSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceAuditSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceAuditSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComplianceConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComplianceConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.ConfigurationId.Set {
			e.FieldStart("configurationId")
			s.ConfigurationId.Encode(e)
		}
	}
	{
		if s.ConfigurationTitle.Set {
			e.FieldStart("configurationTitle")
			s.ConfigurationTitle.Encode(e)
		}
	}
	{
		if s.ComplianceResourceStandardConfigurationDetails != nil {
			e.FieldStart("complianceResourceStandardConfigurationDetails")
			e.ArrStart()
			for _, elem := range s.ComplianceResourceStandardConfigurationDetails {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfComplianceConfiguration = [3]string{
	0: "configurationId",
	1: "configurationTitle",
	2: "complianceResourceStandardConfigurationDetails",
}

// Decode decodes ComplianceConfiguration from json.
func (s *ComplianceConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configurationId":
			if err := func() error {
				s.ConfigurationId.Reset()
				if err := s.ConfigurationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configurationId\"")
			}
		case "configurationTitle":
			if err := func() error {
				s.ConfigurationTitle.Reset()
				if err := s.ConfigurationTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configurationTitle\"")
			}
		case "complianceResourceStandardConfigurationDetails":
			if err := func() error {
				s.ComplianceResourceStandardConfigurationDetails = make([]ComplianceResourceStandardConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ComplianceResourceStandardConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ComplianceResourceStandardConfigurationDetails = append(s.ComplianceResourceStandardConfigurationDetails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"complianceResourceStandardConfigurationDetails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComplianceConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComplianceResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComplianceResource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		if s.ResourceName.Set {
			e.FieldStart("resourceName")
			s.ResourceName.Encode(e)
		}
	}
}

var jsonFieldsNameOfComplianceResource = [2]string{
	0: "resourceType",
	1: "resourceName",
}

// Decode decodes ComplianceResource from json.
func (s *ComplianceResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceResource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "resourceName":
			if err := func() error {
				s.ResourceName.Reset()
				if err := s.ResourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComplianceResource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfComplianceResource) {
					name = jsonFieldsNameOfComplianceResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComplianceResourceStandardConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComplianceResourceStandardConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.ResourceType.Set {
			e.FieldStart("resourceType")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.ResourceVersion.Set {
			e.FieldStart("resourceVersion")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.StandardConfigurationDetails != nil {
			e.FieldStart("standardConfigurationDetails")
			e.ArrStart()
			for _, elem := range s.StandardConfigurationDetails {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfComplianceResourceStandardConfiguration = [3]string{
	0: "resourceType",
	1: "resourceVersion",
	2: "standardConfigurationDetails",
}

// Decode decodes ComplianceResourceStandardConfiguration from json.
func (s *ComplianceResourceStandardConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceResourceStandardConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "resourceVersion":
			if err := func() error {
				s.ResourceVersion.Reset()
				if err := s.ResourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceVersion\"")
			}
		case "standardConfigurationDetails":
			if err := func() error {
				s.StandardConfigurationDetails = make([]ComplianceStandardConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ComplianceStandardConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.StandardConfigurationDetails = append(s.StandardConfigurationDetails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standardConfigurationDetails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComplianceResourceStandardConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceResourceStandardConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceResourceStandardConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComplianceResourcesConfigurationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComplianceResourcesConfigurationSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ConfigurationId.Set {
			e.FieldStart("configurationId")
			s.ConfigurationId.Encode(e)
		}
	}
	{
		e.FieldStart("resources")
		e.ArrStart()
		for _, elem := range s.Resources {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfComplianceResourcesConfigurationSpec = [2]string{
	0: "configurationId",
	1: "resources",
}

// Decode decodes ComplianceResourcesConfigurationSpec from json.
func (s *ComplianceResourcesConfigurationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceResourcesConfigurationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configurationId":
			if err := func() error {
				s.ConfigurationId.Reset()
				if err := s.ConfigurationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configurationId\"")
			}
		case "resources":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Resources = make([]ComplianceResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ComplianceResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComplianceResourcesConfigurationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfComplianceResourcesConfigurationSpec) {
					name = jsonFieldsNameOfComplianceResourcesConfigurationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceResourcesConfigurationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceResourcesConfigurationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComplianceStandard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComplianceStandard) encodeFields(e *jx.Encoder) {
	{
		if s.StandardType.Set {
			e.FieldStart("standardType")
			s.StandardType.Encode(e)
		}
	}
	{
		if s.StandardVersions != nil {
			e.FieldStart("standardVersions")
			e.ArrStart()
			for _, elem := range s.StandardVersions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfComplianceStandard = [2]string{
	0: "standardType",
	1: "standardVersions",
}

// Decode decodes ComplianceStandard from json.
func (s *ComplianceStandard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceStandard to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "standardType":
			if err := func() error {
				s.StandardType.Reset()
				if err := s.StandardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standardType\"")
			}
		case "standardVersions":
			if err := func() error {
				s.StandardVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StandardVersions = append(s.StandardVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standardVersions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComplianceStandard")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceStandard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceStandard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComplianceStandardConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComplianceStandardConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.StandardType.Set {
			e.FieldStart("standardType")
			s.StandardType.Encode(e)
		}
	}
	{
		if s.StandardVersion.Set {
			e.FieldStart("standardVersion")
			s.StandardVersion.Encode(e)
		}
	}
	{
		if s.IsRecommendedByStandard.Set {
			e.FieldStart("isRecommendedByStandard")
			s.IsRecommendedByStandard.Encode(e)
		}
	}
	{
		if s.IsAuditAutomated.Set {
			e.FieldStart("isAuditAutomated")
			s.IsAuditAutomated.Encode(e)
		}
	}
	{
		if s.CitationReference.Set {
			e.FieldStart("citationReference")
			s.CitationReference.Encode(e)
		}
	}
	{
		if s.AuditProcedure.Set {
			e.FieldStart("auditProcedure")
			s.AuditProcedure.Encode(e)
		}
	}
	{
		if s.RecommendedValue.Set {
			e.FieldStart("recommendedValue")
			s.RecommendedValue.Encode(e)
		}
	}
	{
		if s.RemediationProcedure.Set {
			e.FieldStart("remediationProcedure")
			s.RemediationProcedure.Encode(e)
		}
	}
}

var jsonFieldsNameOfComplianceStandardConfiguration = [8]string{
	0: "standardType",
	1: "standardVersion",
	2: "isRecommendedByStandard",
	3: "isAuditAutomated",
	4: "citationReference",
	5: "auditProcedure",
	6: "recommendedValue",
	7: "remediationProcedure",
}

// Decode decodes ComplianceStandardConfiguration from json.
func (s *ComplianceStandardConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceStandardConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "standardType":
			if err := func() error {
				s.StandardType.Reset()
				if err := s.StandardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standardType\"")
			}
		case "standardVersion":
			if err := func() error {
				s.StandardVersion.Reset()
				if err := s.StandardVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standardVersion\"")
			}
		case "isRecommendedByStandard":
			if err := func() error {
				s.IsRecommendedByStandard.Reset()
				if err := s.IsRecommendedByStandard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isRecommendedByStandard\"")
			}
		case "isAuditAutomated":
			if err := func() error {
				s.IsAuditAutomated.Reset()
				if err := s.IsAuditAutomated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAuditAutomated\"")
			}
		case "citationReference":
			if err := func() error {
				s.CitationReference.Reset()
				if err := s.CitationReference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"citationReference\"")
			}
		case "auditProcedure":
			if err := func() error {
				s.AuditProcedure.Reset()
				if err := s.AuditProcedure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auditProcedure\"")
			}
		case "recommendedValue":
			if err := func() error {
				s.RecommendedValue.Reset()
				if err := s.RecommendedValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recommendedValue\"")
			}
		case "remediationProcedure":
			if err := func() error {
				s.RemediationProcedure.Reset()
				if err := s.RemediationProcedure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediationProcedure\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComplianceStandardConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceStandardConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceStandardConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComplianceTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComplianceTask) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ComplianceAuditId.Set {
			e.FieldStart("complianceAuditId")
			s.ComplianceAuditId.Encode(e)
		}
	}
}

var jsonFieldsNameOfComplianceTask = [3]string{
	0: "id",
	1: "status",
	2: "complianceAuditId",
}

// Decode decodes ComplianceTask from json.
func (s *ComplianceTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComplianceTask to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "complianceAuditId":
			if err := func() error {
				s.ComplianceAuditId.Reset()
				if err := s.ComplianceAuditId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"complianceAuditId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComplianceTask")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComplianceTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComplianceTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComponentDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComponentDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vendor")
		e.Str(s.Vendor)
	}
	{
		e.FieldStart("displayName")
		e.Str(s.DisplayName)
	}
	{
		if s.DisplayVersion.Set {
			e.FieldStart("displayVersion")
			s.DisplayVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfComponentDetails = [3]string{
	0: "vendor",
	1: "displayName",
	2: "displayVersion",
}

// Decode decodes ComponentDetails from json.
func (s *ComponentDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComponentDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vendor":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Vendor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vendor\"")
			}
		case "displayName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "displayVersion":
			if err := func() error {
				s.DisplayVersion.Reset()
				if err := s.DisplayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComponentDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfComponentDetails) {
					name = jsonFieldsNameOfComponentDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComponentDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComponentDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComponentInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComponentInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("details")
		s.Details.Encode(e)
	}
}

var jsonFieldsNameOfComponentInfo = [2]string{
	0: "version",
	1: "details",
}

// Decode decodes ComponentInfo from json.
func (s *ComponentInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComponentInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComponentInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfComponentInfo) {
					name = jsonFieldsNameOfComponentInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComponentInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComponentInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ComputeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ComputeSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("clusterSpecs")
		e.ArrStart()
		for _, elem := range s.ClusterSpecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.SkipFailedHosts.Set {
			e.FieldStart("skipFailedHosts")
			s.SkipFailedHosts.Encode(e)
		}
	}
}

var jsonFieldsNameOfComputeSpec = [2]string{
	0: "clusterSpecs",
	1: "skipFailedHosts",
}

// Decode decodes ComputeSpec from json.
func (s *ComputeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ComputeSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusterSpecs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ClusterSpecs = make([]ClusterSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClusterSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ClusterSpecs = append(s.ClusterSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterSpecs\"")
			}
		case "skipFailedHosts":
			if err := func() error {
				s.SkipFailedHosts.Reset()
				if err := s.SkipFailedHosts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skipFailedHosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ComputeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfComputeSpec) {
					name = jsonFieldsNameOfComputeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ComputeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ComputeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigDriftApplySpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigDriftApplySpec) encodeFields(e *jx.Encoder) {
	{
		if s.ReconciliationForResources != nil {
			e.FieldStart("reconciliationForResources")
			e.ArrStart()
			for _, elem := range s.ReconciliationForResources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfConfigDriftApplySpec = [1]string{
	0: "reconciliationForResources",
}

// Decode decodes ConfigDriftApplySpec from json.
func (s *ConfigDriftApplySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigDriftApplySpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reconciliationForResources":
			if err := func() error {
				s.ReconciliationForResources = make([]ReconciliationForResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReconciliationForResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ReconciliationForResources = append(s.ReconciliationForResources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reconciliationForResources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigDriftApplySpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigDriftApplySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigDriftApplySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigDriftSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigDriftSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ResourceType.Set {
			e.FieldStart("resourceType")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Applicability.Set {
			e.FieldStart("applicability")
			s.Applicability.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigDriftSpec = [6]string{
	0: "id",
	1: "name",
	2: "description",
	3: "resourceType",
	4: "type",
	5: "applicability",
}

// Decode decodes ConfigDriftSpec from json.
func (s *ConfigDriftSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigDriftSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "applicability":
			if err := func() error {
				s.Applicability.Reset()
				if err := s.Applicability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applicability\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigDriftSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigDriftSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigDriftSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigureCertificateAuthorityBadRequest as json.
func (s *ConfigureCertificateAuthorityBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ConfigureCertificateAuthorityBadRequest from json.
func (s *ConfigureCertificateAuthorityBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigureCertificateAuthorityBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConfigureCertificateAuthorityBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigureCertificateAuthorityBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigureCertificateAuthorityBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigureCertificateAuthorityInternalServerError as json.
func (s *ConfigureCertificateAuthorityInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ConfigureCertificateAuthorityInternalServerError from json.
func (s *ConfigureCertificateAuthorityInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigureCertificateAuthorityInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConfigureCertificateAuthorityInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigureCertificateAuthorityInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigureCertificateAuthorityInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigureCertificateAuthorityNotFound as json.
func (s *ConfigureCertificateAuthorityNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ConfigureCertificateAuthorityNotFound from json.
func (s *ConfigureCertificateAuthorityNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigureCertificateAuthorityNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConfigureCertificateAuthorityNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigureCertificateAuthorityNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigureCertificateAuthorityNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigureDnsBadRequest as json.
func (s *ConfigureDnsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ConfigureDnsBadRequest from json.
func (s *ConfigureDnsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigureDnsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConfigureDnsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigureDnsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigureDnsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigureDnsInternalServerError as json.
func (s *ConfigureDnsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ConfigureDnsInternalServerError from json.
func (s *ConfigureDnsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigureDnsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConfigureDnsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigureDnsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigureDnsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigureNtpBadRequest as json.
func (s *ConfigureNtpBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ConfigureNtpBadRequest from json.
func (s *ConfigureNtpBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigureNtpBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConfigureNtpBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigureNtpBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigureNtpBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigureNtpInternalServerError as json.
func (s *ConfigureNtpInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ConfigureNtpInternalServerError from json.
func (s *ConfigureNtpInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigureNtpInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConfigureNtpInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigureNtpInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigureNtpInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConnectVropsWithDomainBadRequest as json.
func (s *ConnectVropsWithDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ConnectVropsWithDomainBadRequest from json.
func (s *ConnectVropsWithDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectVropsWithDomainBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConnectVropsWithDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectVropsWithDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectVropsWithDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConnectVropsWithDomainInternalServerError as json.
func (s *ConnectVropsWithDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ConnectVropsWithDomainInternalServerError from json.
func (s *ConnectVropsWithDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectVropsWithDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConnectVropsWithDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectVropsWithDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectVropsWithDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CpuCore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CpuCore) encodeFields(e *jx.Encoder) {
	{
		if s.FrequencyMHz.Set {
			e.FieldStart("frequencyMHz")
			s.FrequencyMHz.Encode(e)
		}
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Manufacturer.Set {
			e.FieldStart("manufacturer")
			s.Manufacturer.Encode(e)
		}
	}
}

var jsonFieldsNameOfCpuCore = [3]string{
	0: "frequencyMHz",
	1: "model",
	2: "manufacturer",
}

// Decode decodes CpuCore from json.
func (s *CpuCore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CpuCore to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "frequencyMHz":
			if err := func() error {
				s.FrequencyMHz.Reset()
				if err := s.FrequencyMHz.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequencyMHz\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "manufacturer":
			if err := func() error {
				s.Manufacturer.Reset()
				if err := s.Manufacturer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"manufacturer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CpuCore")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CpuCore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CpuCore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CpuInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CpuInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Used.Set {
			e.FieldStart("used")
			s.Used.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.NumberOfCores.Set {
			e.FieldStart("numberOfCores")
			s.NumberOfCores.Encode(e)
		}
	}
	{
		if s.NumberOfCPUPackages.Set {
			e.FieldStart("numberOfCPUPackages")
			s.NumberOfCPUPackages.Encode(e)
		}
	}
}

var jsonFieldsNameOfCpuInfo = [4]string{
	0: "used",
	1: "total",
	2: "numberOfCores",
	3: "numberOfCPUPackages",
}

// Decode decodes CpuInfo from json.
func (s *CpuInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CpuInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "used":
			if err := func() error {
				s.Used.Reset()
				if err := s.Used.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "numberOfCores":
			if err := func() error {
				s.NumberOfCores.Reset()
				if err := s.NumberOfCores.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfCores\"")
			}
		case "numberOfCPUPackages":
			if err := func() error {
				s.NumberOfCPUPackages.Reset()
				if err := s.NumberOfCPUPackages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfCPUPackages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CpuInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CpuInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CpuInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAvnsBadRequest as json.
func (s *CreateAvnsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAvnsBadRequest from json.
func (s *CreateAvnsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAvnsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAvnsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAvnsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAvnsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAvnsInternalServerError as json.
func (s *CreateAvnsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAvnsInternalServerError from json.
func (s *CreateAvnsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAvnsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAvnsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAvnsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAvnsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCertificateAuthorityBadRequest as json.
func (s *CreateCertificateAuthorityBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateCertificateAuthorityBadRequest from json.
func (s *CreateCertificateAuthorityBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCertificateAuthorityBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateCertificateAuthorityBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCertificateAuthorityBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCertificateAuthorityBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCertificateAuthorityInternalServerError as json.
func (s *CreateCertificateAuthorityInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateCertificateAuthorityInternalServerError from json.
func (s *CreateCertificateAuthorityInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCertificateAuthorityInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateCertificateAuthorityInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCertificateAuthorityInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCertificateAuthorityInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateClusterBadRequest as json.
func (s *CreateClusterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateClusterBadRequest from json.
func (s *CreateClusterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateClusterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateClusterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateClusterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateClusterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateClusterInternalServerError as json.
func (s *CreateClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateClusterInternalServerError from json.
func (s *CreateClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDomainBadRequest as json.
func (s *CreateDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateDomainBadRequest from json.
func (s *CreateDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDomainBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDomainInternalServerError as json.
func (s *CreateDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateDomainInternalServerError from json.
func (s *CreateDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateEdgeClusterBadRequest as json.
func (s *CreateEdgeClusterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateEdgeClusterBadRequest from json.
func (s *CreateEdgeClusterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEdgeClusterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateEdgeClusterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateEdgeClusterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEdgeClusterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateEdgeClusterInternalServerError as json.
func (s *CreateEdgeClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateEdgeClusterInternalServerError from json.
func (s *CreateEdgeClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateEdgeClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateEdgeClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateEdgeClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateEdgeClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateNetworkPoolBadRequest as json.
func (s *CreateNetworkPoolBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateNetworkPoolBadRequest from json.
func (s *CreateNetworkPoolBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNetworkPoolBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateNetworkPoolBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNetworkPoolBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNetworkPoolBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateNetworkPoolInternalServerError as json.
func (s *CreateNetworkPoolInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateNetworkPoolInternalServerError from json.
func (s *CreateNetworkPoolInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNetworkPoolInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateNetworkPoolInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNetworkPoolInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNetworkPoolInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateResourceWarningBadRequest as json.
func (s *CreateResourceWarningBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateResourceWarningBadRequest from json.
func (s *CreateResourceWarningBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateResourceWarningBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateResourceWarningBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateResourceWarningBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateResourceWarningBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateResourceWarningInternalServerError as json.
func (s *CreateResourceWarningInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateResourceWarningInternalServerError from json.
func (s *CreateResourceWarningInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateResourceWarningInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateResourceWarningInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateResourceWarningInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateResourceWarningInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTokenBadRequest as json.
func (s *CreateTokenBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTokenBadRequest from json.
func (s *CreateTokenBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTokenBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTokenBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTokenBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTokenBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTokenCreated as json.
func (s *CreateTokenCreated) Encode(e *jx.Encoder) {
	unwrapped := (*TokenPair)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTokenCreated from json.
func (s *CreateTokenCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTokenCreated to nil")
	}
	var unwrapped TokenPair
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTokenCreated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTokenCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTokenCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTokenInternalServerError as json.
func (s *CreateTokenInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTokenInternalServerError from json.
func (s *CreateTokenInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTokenInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTokenInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTokenInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTokenInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTokenOK as json.
func (s *CreateTokenOK) Encode(e *jx.Encoder) {
	unwrapped := (*TokenPair)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTokenOK from json.
func (s *CreateTokenOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTokenOK to nil")
	}
	var unwrapped TokenPair
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTokenOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTokenOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTokenOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTokenUnauthorized as json.
func (s *CreateTokenUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTokenUnauthorized from json.
func (s *CreateTokenUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTokenUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTokenUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTokenUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTokenUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Credential) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Credential) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("credentialType")
		e.Str(s.CredentialType)
	}
	{
		e.FieldStart("accountType")
		e.Str(s.AccountType)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		e.FieldStart("creationTimestamp")
		e.Str(s.CreationTimestamp)
	}
	{
		e.FieldStart("modificationTimestamp")
		e.Str(s.ModificationTimestamp)
	}
	{
		if s.Expiry.Set {
			e.FieldStart("expiry")
			s.Expiry.Encode(e)
		}
	}
	{
		e.FieldStart("resource")
		s.Resource.Encode(e)
	}
	{
		if s.AutoRotatePolicy.Set {
			e.FieldStart("autoRotatePolicy")
			s.AutoRotatePolicy.Encode(e)
		}
	}
}

var jsonFieldsNameOfCredential = [10]string{
	0: "id",
	1: "credentialType",
	2: "accountType",
	3: "username",
	4: "password",
	5: "creationTimestamp",
	6: "modificationTimestamp",
	7: "expiry",
	8: "resource",
	9: "autoRotatePolicy",
}

// Decode decodes Credential from json.
func (s *Credential) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Credential to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "credentialType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CredentialType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentialType\"")
			}
		case "accountType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AccountType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountType\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "creationTimestamp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreationTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "modificationTimestamp":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ModificationTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modificationTimestamp\"")
			}
		case "expiry":
			if err := func() error {
				s.Expiry.Reset()
				if err := s.Expiry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiry\"")
			}
		case "resource":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "autoRotatePolicy":
			if err := func() error {
				s.AutoRotatePolicy.Reset()
				if err := s.AutoRotatePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoRotatePolicy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Credential")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01101111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCredential) {
					name = jsonFieldsNameOfCredential[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Credential) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Credential) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CredentialExpirationCheck) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CredentialExpirationCheck) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			e.FieldStart("resource")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Expiry.Set {
			e.FieldStart("expiry")
			s.Expiry.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreationTimestamp.Set {
			e.FieldStart("creationTimestamp")
			s.CreationTimestamp.Encode(e)
		}
	}
	{
		if s.CompletionTimestamp.Set {
			e.FieldStart("completionTimestamp")
			s.CompletionTimestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfCredentialExpirationCheck = [7]string{
	0: "id",
	1: "username",
	2: "resource",
	3: "expiry",
	4: "errors",
	5: "creationTimestamp",
	6: "completionTimestamp",
}

// Decode decodes CredentialExpirationCheck from json.
func (s *CredentialExpirationCheck) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CredentialExpirationCheck to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "expiry":
			if err := func() error {
				s.Expiry.Reset()
				if err := s.Expiry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiry\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		case "creationTimestamp":
			if err := func() error {
				s.CreationTimestamp.Reset()
				if err := s.CreationTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "completionTimestamp":
			if err := func() error {
				s.CompletionTimestamp.Reset()
				if err := s.CompletionTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTimestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CredentialExpirationCheck")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CredentialExpirationCheck) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CredentialExpirationCheck) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CredentialsExpiration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CredentialsExpiration) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreationTimestamp.Set {
			e.FieldStart("creationTimestamp")
			s.CreationTimestamp.Encode(e)
		}
	}
	{
		if s.CompletionTimestamp.Set {
			e.FieldStart("completionTimestamp")
			s.CompletionTimestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfCredentialsExpiration = [5]string{
	0: "id",
	1: "status",
	2: "elements",
	3: "creationTimestamp",
	4: "completionTimestamp",
}

// Decode decodes CredentialsExpiration from json.
func (s *CredentialsExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CredentialsExpiration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "elements":
			if err := func() error {
				s.Elements = make([]CredentialExpirationCheck, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CredentialExpirationCheck
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "creationTimestamp":
			if err := func() error {
				s.CreationTimestamp.Reset()
				if err := s.CreationTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "completionTimestamp":
			if err := func() error {
				s.CompletionTimestamp.Reset()
				if err := s.CompletionTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTimestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CredentialsExpiration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCredentialsExpiration) {
					name = jsonFieldsNameOfCredentialsExpiration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CredentialsExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CredentialsExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CredentialsExpirationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CredentialsExpirationSpec) encodeFields(e *jx.Encoder) {
	{
		if s.DomainName.Set {
			e.FieldStart("domainName")
			s.DomainName.Encode(e)
		}
	}
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		if s.CredentialIds != nil {
			e.FieldStart("credentialIds")
			e.ArrStart()
			for _, elem := range s.CredentialIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCredentialsExpirationSpec = [3]string{
	0: "domainName",
	1: "resourceType",
	2: "credentialIds",
}

// Decode decodes CredentialsExpirationSpec from json.
func (s *CredentialsExpirationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CredentialsExpirationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainName":
			if err := func() error {
				s.DomainName.Reset()
				if err := s.DomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainName\"")
			}
		case "resourceType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "credentialIds":
			if err := func() error {
				s.CredentialIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CredentialIds = append(s.CredentialIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentialIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CredentialsExpirationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCredentialsExpirationSpec) {
					name = jsonFieldsNameOfCredentialsExpirationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CredentialsExpirationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CredentialsExpirationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CredentialsSubTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CredentialsSubTask) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ResourceName.Set {
			e.FieldStart("resourceName")
			s.ResourceName.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("creationTimestamp")
		e.Str(s.CreationTimestamp)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		if s.DependentSubTasks != nil {
			e.FieldStart("dependentSubTasks")
			e.ArrStart()
			for _, elem := range s.DependentSubTasks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OldPassword.Set {
			e.FieldStart("oldPassword")
			s.OldPassword.Encode(e)
		}
	}
	{
		if s.NewPassword.Set {
			e.FieldStart("newPassword")
			s.NewPassword.Encode(e)
		}
	}
	{
		if s.EntityType.Set {
			e.FieldStart("entityType")
			s.EntityType.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.CredentialType.Set {
			e.FieldStart("credentialType")
			s.CredentialType.Encode(e)
		}
	}
}

var jsonFieldsNameOfCredentialsSubTask = [13]string{
	0:  "id",
	1:  "resourceName",
	2:  "name",
	3:  "description",
	4:  "creationTimestamp",
	5:  "status",
	6:  "dependentSubTasks",
	7:  "errors",
	8:  "oldPassword",
	9:  "newPassword",
	10: "entityType",
	11: "username",
	12: "credentialType",
}

// Decode decodes CredentialsSubTask from json.
func (s *CredentialsSubTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CredentialsSubTask to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "resourceName":
			if err := func() error {
				s.ResourceName.Reset()
				if err := s.ResourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "creationTimestamp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CreationTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "dependentSubTasks":
			if err := func() error {
				s.DependentSubTasks = make([]CredentialsSubTask, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CredentialsSubTask
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DependentSubTasks = append(s.DependentSubTasks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependentSubTasks\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		case "oldPassword":
			if err := func() error {
				s.OldPassword.Reset()
				if err := s.OldPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oldPassword\"")
			}
		case "newPassword":
			if err := func() error {
				s.NewPassword.Reset()
				if err := s.NewPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"newPassword\"")
			}
		case "entityType":
			if err := func() error {
				s.EntityType.Reset()
				if err := s.EntityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityType\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "credentialType":
			if err := func() error {
				s.CredentialType.Reset()
				if err := s.CredentialType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentialType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CredentialsSubTask")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCredentialsSubTask) {
					name = jsonFieldsNameOfCredentialsSubTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CredentialsSubTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CredentialsSubTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CredentialsTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CredentialsTask) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("creationTimestamp")
		e.Str(s.CreationTimestamp)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		if s.SubTasks != nil {
			e.FieldStart("subTasks")
			e.ArrStart()
			for _, elem := range s.SubTasks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsAutoRotate.Set {
			e.FieldStart("isAutoRotate")
			s.IsAutoRotate.Encode(e)
		}
	}
}

var jsonFieldsNameOfCredentialsTask = [8]string{
	0: "id",
	1: "name",
	2: "type",
	3: "creationTimestamp",
	4: "status",
	5: "subTasks",
	6: "errors",
	7: "isAutoRotate",
}

// Decode decodes CredentialsTask from json.
func (s *CredentialsTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CredentialsTask to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "creationTimestamp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CreationTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "subTasks":
			if err := func() error {
				s.SubTasks = make([]CredentialsSubTask, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CredentialsSubTask
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SubTasks = append(s.SubTasks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subTasks\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		case "isAutoRotate":
			if err := func() error {
				s.IsAutoRotate.Reset()
				if err := s.IsAutoRotate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAutoRotate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CredentialsTask")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCredentialsTask) {
					name = jsonFieldsNameOfCredentialsTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CredentialsTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CredentialsTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CredentialsUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CredentialsUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("operationType")
		e.Str(s.OperationType)
	}
	{
		e.FieldStart("elements")
		e.ArrStart()
		for _, elem := range s.Elements {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.AutoRotatePolicy.Set {
			e.FieldStart("autoRotatePolicy")
			s.AutoRotatePolicy.Encode(e)
		}
	}
}

var jsonFieldsNameOfCredentialsUpdateSpec = [3]string{
	0: "operationType",
	1: "elements",
	2: "autoRotatePolicy",
}

// Decode decodes CredentialsUpdateSpec from json.
func (s *CredentialsUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CredentialsUpdateSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operationType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OperationType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationType\"")
			}
		case "elements":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Elements = make([]ResourceCredentials, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourceCredentials
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "autoRotatePolicy":
			if err := func() error {
				s.AutoRotatePolicy.Reset()
				if err := s.AutoRotatePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoRotatePolicy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CredentialsUpdateSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCredentialsUpdateSpec) {
					name = jsonFieldsNameOfCredentialsUpdateSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CredentialsUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CredentialsUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Csr) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Csr) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("csrEncodedContent")
		e.Str(s.CsrEncodedContent)
	}
	{
		e.FieldStart("resource")
		s.Resource.Encode(e)
	}
	{
		e.FieldStart("csrDecodedContent")
		e.Str(s.CsrDecodedContent)
	}
}

var jsonFieldsNameOfCsr = [3]string{
	0: "csrEncodedContent",
	1: "resource",
	2: "csrDecodedContent",
}

// Decode decodes Csr from json.
func (s *Csr) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Csr to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "csrEncodedContent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CsrEncodedContent = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"csrEncodedContent\"")
			}
		case "resource":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "csrDecodedContent":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CsrDecodedContent = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"csrDecodedContent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Csr")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCsr) {
					name = jsonFieldsNameOfCsr[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Csr) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Csr) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CsrGenerationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CsrGenerationSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("country")
		e.Str(s.Country)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("locality")
		e.Str(s.Locality)
	}
	{
		e.FieldStart("organization")
		e.Str(s.Organization)
	}
	{
		e.FieldStart("organizationUnit")
		e.Str(s.OrganizationUnit)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		e.FieldStart("keySize")
		e.Str(s.KeySize)
	}
	{
		e.FieldStart("keyAlgorithm")
		e.Str(s.KeyAlgorithm)
	}
}

var jsonFieldsNameOfCsrGenerationSpec = [8]string{
	0: "country",
	1: "state",
	2: "locality",
	3: "organization",
	4: "organizationUnit",
	5: "email",
	6: "keySize",
	7: "keyAlgorithm",
}

// Decode decodes CsrGenerationSpec from json.
func (s *CsrGenerationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CsrGenerationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "country":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Country = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "locality":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Locality = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locality\"")
			}
		case "organization":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Organization = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "organizationUnit":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.OrganizationUnit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizationUnit\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "keySize":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.KeySize = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keySize\"")
			}
		case "keyAlgorithm":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.KeyAlgorithm = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyAlgorithm\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CsrGenerationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCsrGenerationSpec) {
					name = jsonFieldsNameOfCsrGenerationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CsrGenerationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CsrGenerationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CsrsGenerationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CsrsGenerationSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("csrGenerationSpec")
		s.CsrGenerationSpec.Encode(e)
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCsrsGenerationSpec = [2]string{
	0: "csrGenerationSpec",
	1: "resources",
}

// Decode decodes CsrsGenerationSpec from json.
func (s *CsrsGenerationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CsrsGenerationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "csrGenerationSpec":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CsrGenerationSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"csrGenerationSpec\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]Resource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Resource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CsrsGenerationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCsrsGenerationSpec) {
					name = jsonFieldsNameOfCsrsGenerationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CsrsGenerationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CsrsGenerationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CustomISOSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CustomISOSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfCustomISOSpec = [1]string{
	0: "id",
}

// Decode decodes CustomISOSpec from json.
func (s *CustomISOSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomISOSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CustomISOSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCustomISOSpec) {
					name = jsonFieldsNameOfCustomISOSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CustomISOSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomISOSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CustomIso) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CustomIso) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Vendor.Set {
			e.FieldStart("vendor")
			s.Vendor.Encode(e)
		}
	}
	{
		if s.UploadedTimestamp.Set {
			e.FieldStart("uploadedTimestamp")
			s.UploadedTimestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfCustomIso = [5]string{
	0: "id",
	1: "name",
	2: "version",
	3: "vendor",
	4: "uploadedTimestamp",
}

// Decode decodes CustomIso from json.
func (s *CustomIso) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomIso to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "vendor":
			if err := func() error {
				s.Vendor.Reset()
				if err := s.Vendor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vendor\"")
			}
		case "uploadedTimestamp":
			if err := func() error {
				s.UploadedTimestamp.Reset()
				if err := s.UploadedTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadedTimestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CustomIso")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCustomIso) {
					name = jsonFieldsNameOfCustomIso[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CustomIso) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomIso) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CustomIsoRenameSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CustomIsoRenameSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfCustomIsoRenameSpec = [1]string{
	0: "name",
}

// Decode decodes CustomIsoRenameSpec from json.
func (s *CustomIsoRenameSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomIsoRenameSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CustomIsoRenameSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCustomIsoRenameSpec) {
					name = jsonFieldsNameOfCustomIsoRenameSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CustomIsoRenameSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomIsoRenameSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataMetric) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataMetric) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Unit.Set {
			e.FieldStart("unit")
			s.Unit.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataMetric = [2]string{
	0: "value",
	1: "unit",
}

// Decode decodes DataMetric from json.
func (s *DataMetric) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataMetric to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "unit":
			if err := func() error {
				s.Unit.Reset()
				if err := s.Unit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataMetric")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataMetric) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataMetric) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataMetricUnit as json.
func (s DataMetricUnit) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DataMetricUnit from json.
func (s *DataMetricUnit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataMetricUnit to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DataMetricUnit(v) {
	case DataMetricUnitB:
		*s = DataMetricUnitB
	case DataMetricUnitKB:
		*s = DataMetricUnitKB
	case DataMetricUnitMB:
		*s = DataMetricUnitMB
	case DataMetricUnitGB:
		*s = DataMetricUnitGB
	case DataMetricUnitTB:
		*s = DataMetricUnitTB
	case DataMetricUnitPB:
		*s = DataMetricUnitPB
	default:
		*s = DataMetricUnit(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataMetricUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataMetricUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Datastore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Datastore) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.VcInstanceUuid.Set {
			e.FieldStart("vcInstanceUuid")
			s.VcInstanceUuid.Encode(e)
		}
	}
	{
		if s.VcDatacenterName.Set {
			e.FieldStart("vcDatacenterName")
			s.VcDatacenterName.Encode(e)
		}
	}
	{
		if s.DatastoreType.Set {
			e.FieldStart("datastoreType")
			s.DatastoreType.Encode(e)
		}
	}
	{
		if s.TotalCapacityGB.Set {
			e.FieldStart("totalCapacityGB")
			s.TotalCapacityGB.Encode(e)
		}
	}
	{
		if s.FreeCapacityGB.Set {
			e.FieldStart("freeCapacityGB")
			s.FreeCapacityGB.Encode(e)
		}
	}
	{
		if s.VmCount.Set {
			e.FieldStart("vmCount")
			s.VmCount.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatastore = [10]string{
	0: "id",
	1: "name",
	2: "url",
	3: "vcInstanceUuid",
	4: "vcDatacenterName",
	5: "datastoreType",
	6: "totalCapacityGB",
	7: "freeCapacityGB",
	8: "vmCount",
	9: "tags",
}

// Decode decodes Datastore from json.
func (s *Datastore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Datastore to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "vcInstanceUuid":
			if err := func() error {
				s.VcInstanceUuid.Reset()
				if err := s.VcInstanceUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcInstanceUuid\"")
			}
		case "vcDatacenterName":
			if err := func() error {
				s.VcDatacenterName.Reset()
				if err := s.VcDatacenterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcDatacenterName\"")
			}
		case "datastoreType":
			if err := func() error {
				s.DatastoreType.Reset()
				if err := s.DatastoreType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datastoreType\"")
			}
		case "totalCapacityGB":
			if err := func() error {
				s.TotalCapacityGB.Reset()
				if err := s.TotalCapacityGB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalCapacityGB\"")
			}
		case "freeCapacityGB":
			if err := func() error {
				s.FreeCapacityGB.Reset()
				if err := s.FreeCapacityGB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"freeCapacityGB\"")
			}
		case "vmCount":
			if err := func() error {
				s.VmCount.Reset()
				if err := s.VmCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmCount\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Datastore")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Datastore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Datastore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatastoreCriterion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatastoreCriterion) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Arguments.Set {
			e.FieldStart("arguments")
			s.Arguments.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatastoreCriterion = [3]string{
	0: "name",
	1: "arguments",
	2: "description",
}

// Decode decodes DatastoreCriterion from json.
func (s *DatastoreCriterion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatastoreCriterion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments.Reset()
				if err := s.Arguments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatastoreCriterion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatastoreCriterion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatastoreCriterion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatastoreCriterionArguments) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatastoreCriterionArguments) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatastoreCriterionArguments from json.
func (s *DatastoreCriterionArguments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatastoreCriterionArguments to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatastoreCriterionArguments")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatastoreCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatastoreCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatastoreMountSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatastoreMountSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("datastoreSpec")
		s.DatastoreSpec.Encode(e)
	}
}

var jsonFieldsNameOfDatastoreMountSpec = [1]string{
	0: "datastoreSpec",
}

// Decode decodes DatastoreMountSpec from json.
func (s *DatastoreMountSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatastoreMountSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "datastoreSpec":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DatastoreSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datastoreSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatastoreMountSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatastoreMountSpec) {
					name = jsonFieldsNameOfDatastoreMountSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatastoreMountSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatastoreMountSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatastoreQueryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatastoreQueryResponse) encodeFields(e *jx.Encoder) {
	{
		if s.QueryInfo.Set {
			e.FieldStart("queryInfo")
			s.QueryInfo.Encode(e)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatastoreQueryResponse = [2]string{
	0: "queryInfo",
	1: "result",
}

// Decode decodes DatastoreQueryResponse from json.
func (s *DatastoreQueryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatastoreQueryResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queryInfo":
			if err := func() error {
				s.QueryInfo.Reset()
				if err := s.QueryInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryInfo\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatastoreQueryResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatastoreQueryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatastoreQueryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatastoreSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatastoreSpec) encodeFields(e *jx.Encoder) {
	{
		if s.VsanDatastoreSpec.Set {
			e.FieldStart("vsanDatastoreSpec")
			s.VsanDatastoreSpec.Encode(e)
		}
	}
	{
		if s.NfsDatastoreSpecs != nil {
			e.FieldStart("nfsDatastoreSpecs")
			e.ArrStart()
			for _, elem := range s.NfsDatastoreSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VmfsDatastoreSpec.Set {
			e.FieldStart("vmfsDatastoreSpec")
			s.VmfsDatastoreSpec.Encode(e)
		}
	}
	{
		if s.VvolDatastoreSpecs != nil {
			e.FieldStart("vvolDatastoreSpecs")
			e.ArrStart()
			for _, elem := range s.VvolDatastoreSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VsanRemoteDatastoreClusterSpec.Set {
			e.FieldStart("vsanRemoteDatastoreClusterSpec")
			s.VsanRemoteDatastoreClusterSpec.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatastoreSpec = [5]string{
	0: "vsanDatastoreSpec",
	1: "nfsDatastoreSpecs",
	2: "vmfsDatastoreSpec",
	3: "vvolDatastoreSpecs",
	4: "vsanRemoteDatastoreClusterSpec",
}

// Decode decodes DatastoreSpec from json.
func (s *DatastoreSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatastoreSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vsanDatastoreSpec":
			if err := func() error {
				s.VsanDatastoreSpec.Reset()
				if err := s.VsanDatastoreSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanDatastoreSpec\"")
			}
		case "nfsDatastoreSpecs":
			if err := func() error {
				s.NfsDatastoreSpecs = make([]NfsDatastoreSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NfsDatastoreSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NfsDatastoreSpecs = append(s.NfsDatastoreSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nfsDatastoreSpecs\"")
			}
		case "vmfsDatastoreSpec":
			if err := func() error {
				s.VmfsDatastoreSpec.Reset()
				if err := s.VmfsDatastoreSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmfsDatastoreSpec\"")
			}
		case "vvolDatastoreSpecs":
			if err := func() error {
				s.VvolDatastoreSpecs = make([]VvolDatastoreSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VvolDatastoreSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VvolDatastoreSpecs = append(s.VvolDatastoreSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vvolDatastoreSpecs\"")
			}
		case "vsanRemoteDatastoreClusterSpec":
			if err := func() error {
				s.VsanRemoteDatastoreClusterSpec.Reset()
				if err := s.VsanRemoteDatastoreClusterSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanRemoteDatastoreClusterSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatastoreSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatastoreSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatastoreSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DecommissionHostsAccepted as json.
func (s *DecommissionHostsAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*Task)(s)

	unwrapped.Encode(e)
}

// Decode decodes DecommissionHostsAccepted from json.
func (s *DecommissionHostsAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DecommissionHostsAccepted to nil")
	}
	var unwrapped Task
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DecommissionHostsAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DecommissionHostsAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DecommissionHostsAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DecommissionHostsInternalServerError as json.
func (s *DecommissionHostsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Task)(s)

	unwrapped.Encode(e)
}

// Decode decodes DecommissionHostsInternalServerError from json.
func (s *DecommissionHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DecommissionHostsInternalServerError to nil")
	}
	var unwrapped Task
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DecommissionHostsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DecommissionHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DecommissionHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteALBClusterInternalServerError as json.
func (s *DeleteALBClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteALBClusterInternalServerError from json.
func (s *DeleteALBClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteALBClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteALBClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteALBClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteALBClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteALBClusterNotFound as json.
func (s *DeleteALBClusterNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteALBClusterNotFound from json.
func (s *DeleteALBClusterNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteALBClusterNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteALBClusterNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteALBClusterNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteALBClusterNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteAliasVersionsBySoftwareTypeAndBaseVersionBadRequest as json.
func (s *DeleteAliasVersionsBySoftwareTypeAndBaseVersionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteAliasVersionsBySoftwareTypeAndBaseVersionBadRequest from json.
func (s *DeleteAliasVersionsBySoftwareTypeAndBaseVersionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAliasVersionsBySoftwareTypeAndBaseVersionBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteAliasVersionsBySoftwareTypeAndBaseVersionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAliasVersionsBySoftwareTypeAndBaseVersionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAliasVersionsBySoftwareTypeAndBaseVersionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteAliasVersionsBySoftwareTypeAndBaseVersionInternalServerError as json.
func (s *DeleteAliasVersionsBySoftwareTypeAndBaseVersionInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteAliasVersionsBySoftwareTypeAndBaseVersionInternalServerError from json.
func (s *DeleteAliasVersionsBySoftwareTypeAndBaseVersionInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAliasVersionsBySoftwareTypeAndBaseVersionInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteAliasVersionsBySoftwareTypeAndBaseVersionInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAliasVersionsBySoftwareTypeAndBaseVersionInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAliasVersionsBySoftwareTypeAndBaseVersionInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteBundleBadRequest as json.
func (s *DeleteBundleBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteBundleBadRequest from json.
func (s *DeleteBundleBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteBundleBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteBundleBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteBundleBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteBundleBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteBundleConflict as json.
func (s *DeleteBundleConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteBundleConflict from json.
func (s *DeleteBundleConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteBundleConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteBundleConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteBundleConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteBundleConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteBundleInternalServerError as json.
func (s *DeleteBundleInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteBundleInternalServerError from json.
func (s *DeleteBundleInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteBundleInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteBundleInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteBundleInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteBundleInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteClusterBadRequest as json.
func (s *DeleteClusterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteClusterBadRequest from json.
func (s *DeleteClusterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteClusterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteClusterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteClusterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteClusterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteClusterInternalServerError as json.
func (s *DeleteClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteClusterInternalServerError from json.
func (s *DeleteClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteClusterNotFound as json.
func (s *DeleteClusterNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteClusterNotFound from json.
func (s *DeleteClusterNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteClusterNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteClusterNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteClusterNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteClusterNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCustomIsoByIdBadRequest as json.
func (s *DeleteCustomIsoByIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCustomIsoByIdBadRequest from json.
func (s *DeleteCustomIsoByIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCustomIsoByIdBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCustomIsoByIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCustomIsoByIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCustomIsoByIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCustomIsoByIdInternalServerError as json.
func (s *DeleteCustomIsoByIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCustomIsoByIdInternalServerError from json.
func (s *DeleteCustomIsoByIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCustomIsoByIdInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCustomIsoByIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCustomIsoByIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCustomIsoByIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCustomIsoByIdNotFound as json.
func (s *DeleteCustomIsoByIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCustomIsoByIdNotFound from json.
func (s *DeleteCustomIsoByIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCustomIsoByIdNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCustomIsoByIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCustomIsoByIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCustomIsoByIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteDepotSettingsBadRequest as json.
func (s *DeleteDepotSettingsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteDepotSettingsBadRequest from json.
func (s *DeleteDepotSettingsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDepotSettingsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteDepotSettingsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDepotSettingsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDepotSettingsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteDepotSettingsInternalServerError as json.
func (s *DeleteDepotSettingsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteDepotSettingsInternalServerError from json.
func (s *DeleteDepotSettingsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDepotSettingsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteDepotSettingsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDepotSettingsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDepotSettingsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteDomainBadRequest as json.
func (s *DeleteDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteDomainBadRequest from json.
func (s *DeleteDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDomainBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteDomainInternalServerError as json.
func (s *DeleteDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteDomainInternalServerError from json.
func (s *DeleteDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteDomainNotFound as json.
func (s *DeleteDomainNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteDomainNotFound from json.
func (s *DeleteDomainNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDomainNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteDomainNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDomainNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDomainNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteIpPoolFromNetworkOfNetworkPoolBadRequest as json.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteIpPoolFromNetworkOfNetworkPoolBadRequest from json.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteIpPoolFromNetworkOfNetworkPoolBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteIpPoolFromNetworkOfNetworkPoolBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteIpPoolFromNetworkOfNetworkPoolInternalServerError as json.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteIpPoolFromNetworkOfNetworkPoolInternalServerError from json.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteIpPoolFromNetworkOfNetworkPoolInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteIpPoolFromNetworkOfNetworkPoolInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteIpPoolFromNetworkOfNetworkPoolNotFound as json.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteIpPoolFromNetworkOfNetworkPoolNotFound from json.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteIpPoolFromNetworkOfNetworkPoolNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteIpPoolFromNetworkOfNetworkPoolNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteIpPoolFromNetworkOfNetworkPoolNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteNetworkPoolBadRequest as json.
func (s *DeleteNetworkPoolBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteNetworkPoolBadRequest from json.
func (s *DeleteNetworkPoolBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteNetworkPoolBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteNetworkPoolBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteNetworkPoolBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteNetworkPoolBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteNetworkPoolInternalServerError as json.
func (s *DeleteNetworkPoolInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteNetworkPoolInternalServerError from json.
func (s *DeleteNetworkPoolInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteNetworkPoolInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteNetworkPoolInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteNetworkPoolInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteNetworkPoolInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteNetworkPoolNotFound as json.
func (s *DeleteNetworkPoolNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteNetworkPoolNotFound from json.
func (s *DeleteNetworkPoolNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteNetworkPoolNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteNetworkPoolNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteNetworkPoolNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteNetworkPoolNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeletePersonalityInternalServerError as json.
func (s *DeletePersonalityInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeletePersonalityInternalServerError from json.
func (s *DeletePersonalityInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeletePersonalityInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeletePersonalityInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeletePersonalityInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeletePersonalityInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeletePersonalityNotFound as json.
func (s *DeletePersonalityNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeletePersonalityNotFound from json.
func (s *DeletePersonalityNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeletePersonalityNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeletePersonalityNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeletePersonalityNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeletePersonalityNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteVersionAliasBySoftwareTypeBadRequest as json.
func (s *DeleteVersionAliasBySoftwareTypeBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteVersionAliasBySoftwareTypeBadRequest from json.
func (s *DeleteVersionAliasBySoftwareTypeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVersionAliasBySoftwareTypeBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteVersionAliasBySoftwareTypeBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVersionAliasBySoftwareTypeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVersionAliasBySoftwareTypeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteVersionAliasBySoftwareTypeInternalServerError as json.
func (s *DeleteVersionAliasBySoftwareTypeInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteVersionAliasBySoftwareTypeInternalServerError from json.
func (s *DeleteVersionAliasBySoftwareTypeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVersionAliasBySoftwareTypeInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteVersionAliasBySoftwareTypeInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVersionAliasBySoftwareTypeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVersionAliasBySoftwareTypeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeployVrslcmBadRequest as json.
func (s *DeployVrslcmBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeployVrslcmBadRequest from json.
func (s *DeployVrslcmBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployVrslcmBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeployVrslcmBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeployVrslcmBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployVrslcmBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeployVrslcmInternalServerError as json.
func (s *DeployVrslcmInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeployVrslcmInternalServerError from json.
func (s *DeployVrslcmInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployVrslcmInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeployVrslcmInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeployVrslcmInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployVrslcmInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeployVrslcmMethodNotAllowed as json.
func (s *DeployVrslcmMethodNotAllowed) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeployVrslcmMethodNotAllowed from json.
func (s *DeployVrslcmMethodNotAllowed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployVrslcmMethodNotAllowed to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeployVrslcmMethodNotAllowed(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeployVrslcmMethodNotAllowed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployVrslcmMethodNotAllowed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DepotAccount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DepotAccount) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfDepotAccount = [4]string{
	0: "username",
	1: "password",
	2: "status",
	3: "message",
}

// Decode decodes DepotAccount from json.
func (s *DepotAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepotAccount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DepotAccount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDepotAccount) {
					name = jsonFieldsNameOfDepotAccount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DepotAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepotAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DepotConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DepotConfiguration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isOfflineDepot")
		e.Bool(s.IsOfflineDepot)
	}
	{
		e.FieldStart("hostname")
		e.Str(s.Hostname)
	}
	{
		e.FieldStart("port")
		e.Int32(s.Port)
	}
}

var jsonFieldsNameOfDepotConfiguration = [3]string{
	0: "isOfflineDepot",
	1: "hostname",
	2: "port",
}

// Decode decodes DepotConfiguration from json.
func (s *DepotConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepotConfiguration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isOfflineDepot":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsOfflineDepot = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOfflineDepot\"")
			}
		case "hostname":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Hostname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DepotConfiguration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDepotConfiguration) {
					name = jsonFieldsNameOfDepotConfiguration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DepotConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepotConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DepotSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DepotSettings) encodeFields(e *jx.Encoder) {
	{
		if s.VmwareAccount.Set {
			e.FieldStart("vmwareAccount")
			s.VmwareAccount.Encode(e)
		}
	}
	{
		if s.DellEmcSupportAccount.Set {
			e.FieldStart("dellEmcSupportAccount")
			s.DellEmcSupportAccount.Encode(e)
		}
	}
	{
		if s.OfflineAccount.Set {
			e.FieldStart("offlineAccount")
			s.OfflineAccount.Encode(e)
		}
	}
	{
		if s.DepotConfiguration.Set {
			e.FieldStart("depotConfiguration")
			s.DepotConfiguration.Encode(e)
		}
	}
}

var jsonFieldsNameOfDepotSettings = [4]string{
	0: "vmwareAccount",
	1: "dellEmcSupportAccount",
	2: "offlineAccount",
	3: "depotConfiguration",
}

// Decode decodes DepotSettings from json.
func (s *DepotSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepotSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vmwareAccount":
			if err := func() error {
				s.VmwareAccount.Reset()
				if err := s.VmwareAccount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmwareAccount\"")
			}
		case "dellEmcSupportAccount":
			if err := func() error {
				s.DellEmcSupportAccount.Reset()
				if err := s.DellEmcSupportAccount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dellEmcSupportAccount\"")
			}
		case "offlineAccount":
			if err := func() error {
				s.OfflineAccount.Reset()
				if err := s.OfflineAccount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offlineAccount\"")
			}
		case "depotConfiguration":
			if err := func() error {
				s.DepotConfiguration.Reset()
				if err := s.DepotConfiguration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depotConfiguration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DepotSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DepotSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepotSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Details) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Details) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfDetails = [2]string{
	0: "type",
	1: "message",
}

// Decode decodes Details from json.
func (s *Details) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Details to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Details")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDetails) {
					name = jsonFieldsNameOfDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Details) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Details) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableLocalAccountInternalServerError as json.
func (s *DisableLocalAccountInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DisableLocalAccountInternalServerError from json.
func (s *DisableLocalAccountInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableLocalAccountInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DisableLocalAccountInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableLocalAccountInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableLocalAccountInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableLocalAccountUnauthorized as json.
func (s *DisableLocalAccountUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DisableLocalAccountUnauthorized from json.
func (s *DisableLocalAccountUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableLocalAccountUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DisableLocalAccountUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableLocalAccountUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableLocalAccountUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DiscoveryProgress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DiscoveryProgress) encodeFields(e *jx.Encoder) {
	{
		if s.ProgressMessages != nil {
			e.FieldStart("progressMessages")
			e.ArrStart()
			for _, elem := range s.ProgressMessages {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PercentageComplete.Set {
			e.FieldStart("percentageComplete")
			s.PercentageComplete.Encode(e)
		}
	}
}

var jsonFieldsNameOfDiscoveryProgress = [2]string{
	0: "progressMessages",
	1: "percentageComplete",
}

// Decode decodes DiscoveryProgress from json.
func (s *DiscoveryProgress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DiscoveryProgress to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "progressMessages":
			if err := func() error {
				s.ProgressMessages = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ProgressMessages = append(s.ProgressMessages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progressMessages\"")
			}
		case "percentageComplete":
			if err := func() error {
				s.PercentageComplete.Reset()
				if err := s.PercentageComplete.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"percentageComplete\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DiscoveryProgress")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DiscoveryProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DiscoveryProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Disk) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Disk) encodeFields(e *jx.Encoder) {
	{
		if s.CapacityMB.Set {
			e.FieldStart("capacityMB")
			s.CapacityMB.Encode(e)
		}
	}
	{
		if s.DiskType.Set {
			e.FieldStart("diskType")
			s.DiskType.Encode(e)
		}
	}
	{
		if s.Manufacturer.Set {
			e.FieldStart("manufacturer")
			s.Manufacturer.Encode(e)
		}
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
}

var jsonFieldsNameOfDisk = [4]string{
	0: "capacityMB",
	1: "diskType",
	2: "manufacturer",
	3: "model",
}

// Decode decodes Disk from json.
func (s *Disk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Disk to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "capacityMB":
			if err := func() error {
				s.CapacityMB.Reset()
				if err := s.CapacityMB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacityMB\"")
			}
		case "diskType":
			if err := func() error {
				s.DiskType.Reset()
				if err := s.DiskType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskType\"")
			}
		case "manufacturer":
			if err := func() error {
				s.Manufacturer.Reset()
				if err := s.Manufacturer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"manufacturer\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Disk")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Disk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Disk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DnsConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DnsConfiguration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dnsServers")
		e.ArrStart()
		for _, elem := range s.DnsServers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDnsConfiguration = [1]string{
	0: "dnsServers",
}

// Decode decodes DnsConfiguration from json.
func (s *DnsConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DnsConfiguration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dnsServers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.DnsServers = make([]DnsServer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DnsServer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DnsServers = append(s.DnsServers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dnsServers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DnsConfiguration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDnsConfiguration) {
					name = jsonFieldsNameOfDnsConfiguration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DnsConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DnsConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DnsServer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DnsServer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ipAddress")
		e.Str(s.IpAddress)
	}
	{
		e.FieldStart("isPrimary")
		e.Bool(s.IsPrimary)
	}
}

var jsonFieldsNameOfDnsServer = [2]string{
	0: "ipAddress",
	1: "isPrimary",
}

// Decode decodes DnsServer from json.
func (s *DnsServer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DnsServer to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IpAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "isPrimary":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsPrimary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isPrimary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DnsServer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDnsServer) {
					name = jsonFieldsNameOfDnsServer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DnsServer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DnsServer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DnsSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DnsSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subdomain")
		e.Str(s.Subdomain)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.Nameserver.Set {
			e.FieldStart("nameserver")
			s.Nameserver.Encode(e)
		}
	}
	{
		if s.SecondaryNameserver.Set {
			e.FieldStart("secondaryNameserver")
			s.SecondaryNameserver.Encode(e)
		}
	}
	{
		if s.Nameservers != nil {
			e.FieldStart("nameservers")
			e.ArrStart()
			for _, elem := range s.Nameservers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDnsSpec = [5]string{
	0: "subdomain",
	1: "domain",
	2: "nameserver",
	3: "secondaryNameserver",
	4: "nameservers",
}

// Decode decodes DnsSpec from json.
func (s *DnsSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DnsSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subdomain":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Subdomain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subdomain\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "nameserver":
			if err := func() error {
				s.Nameserver.Reset()
				if err := s.Nameserver.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameserver\"")
			}
		case "secondaryNameserver":
			if err := func() error {
				s.SecondaryNameserver.Reset()
				if err := s.SecondaryNameserver.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secondaryNameserver\"")
			}
		case "nameservers":
			if err := func() error {
				s.Nameservers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Nameservers = append(s.Nameservers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameservers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DnsSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDnsSpec) {
					name = jsonFieldsNameOfDnsSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DnsSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DnsSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Domain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Domain) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.OrgName.Set {
			e.FieldStart("orgName")
			s.OrgName.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.UpgradeState.Set {
			e.FieldStart("upgradeState")
			s.UpgradeState.Encode(e)
		}
	}
	{
		if s.UpgradeStatus.Set {
			e.FieldStart("upgradeStatus")
			s.UpgradeStatus.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.VraIntegrationStatus.Set {
			e.FieldStart("vraIntegrationStatus")
			s.VraIntegrationStatus.Encode(e)
		}
	}
	{
		if s.VropsIntegrationStatus.Set {
			e.FieldStart("vropsIntegrationStatus")
			s.VropsIntegrationStatus.Encode(e)
		}
	}
	{
		if s.VrliIntegrationStatus.Set {
			e.FieldStart("vrliIntegrationStatus")
			s.VrliIntegrationStatus.Encode(e)
		}
	}
	{
		if s.Owners != nil {
			e.FieldStart("owners")
			e.ArrStart()
			for _, elem := range s.Owners {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Vcenters != nil {
			e.FieldStart("vcenters")
			e.ArrStart()
			for _, elem := range s.Vcenters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SsoId.Set {
			e.FieldStart("ssoId")
			s.SsoId.Encode(e)
		}
	}
	{
		if s.SsoName.Set {
			e.FieldStart("ssoName")
			s.SsoName.Encode(e)
		}
	}
	{
		if s.IsManagementSsoDomain.Set {
			e.FieldStart("isManagementSsoDomain")
			s.IsManagementSsoDomain.Encode(e)
		}
	}
	{
		if s.Clusters != nil {
			e.FieldStart("clusters")
			e.ArrStart()
			for _, elem := range s.Clusters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NsxtCluster.Set {
			e.FieldStart("nsxtCluster")
			s.NsxtCluster.Encode(e)
		}
	}
	{
		if s.LicensingInfo.Set {
			e.FieldStart("licensingInfo")
			s.LicensingInfo.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			e.FieldStart("capacity")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ElmStatus.Set {
			e.FieldStart("elmStatus")
			s.ElmStatus.Encode(e)
		}
	}
	{
		if s.LifecycleManagementMode.Set {
			e.FieldStart("lifecycleManagementMode")
			s.LifecycleManagementMode.Encode(e)
		}
	}
	{
		if s.IsNetworkSeparationEnabled.Set {
			e.FieldStart("isNetworkSeparationEnabled")
			s.IsNetworkSeparationEnabled.Encode(e)
		}
	}
	{
		if s.IsSecurityEnabled.Set {
			e.FieldStart("isSecurityEnabled")
			s.IsSecurityEnabled.Encode(e)
		}
	}
	{
		if s.IsPrimaryDomainForNsx.Set {
			e.FieldStart("isPrimaryDomainForNsx")
			s.IsPrimaryDomainForNsx.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomain = [25]string{
	0:  "id",
	1:  "name",
	2:  "orgName",
	3:  "status",
	4:  "upgradeState",
	5:  "upgradeStatus",
	6:  "type",
	7:  "vraIntegrationStatus",
	8:  "vropsIntegrationStatus",
	9:  "vrliIntegrationStatus",
	10: "owners",
	11: "vcenters",
	12: "ssoId",
	13: "ssoName",
	14: "isManagementSsoDomain",
	15: "clusters",
	16: "nsxtCluster",
	17: "licensingInfo",
	18: "capacity",
	19: "tags",
	20: "elmStatus",
	21: "lifecycleManagementMode",
	22: "isNetworkSeparationEnabled",
	23: "isSecurityEnabled",
	24: "isPrimaryDomainForNsx",
}

// Decode decodes Domain from json.
func (s *Domain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Domain to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "orgName":
			if err := func() error {
				s.OrgName.Reset()
				if err := s.OrgName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orgName\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "upgradeState":
			if err := func() error {
				s.UpgradeState.Reset()
				if err := s.UpgradeState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upgradeState\"")
			}
		case "upgradeStatus":
			if err := func() error {
				s.UpgradeStatus.Reset()
				if err := s.UpgradeStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upgradeStatus\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "vraIntegrationStatus":
			if err := func() error {
				s.VraIntegrationStatus.Reset()
				if err := s.VraIntegrationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vraIntegrationStatus\"")
			}
		case "vropsIntegrationStatus":
			if err := func() error {
				s.VropsIntegrationStatus.Reset()
				if err := s.VropsIntegrationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vropsIntegrationStatus\"")
			}
		case "vrliIntegrationStatus":
			if err := func() error {
				s.VrliIntegrationStatus.Reset()
				if err := s.VrliIntegrationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vrliIntegrationStatus\"")
			}
		case "owners":
			if err := func() error {
				s.Owners = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Owners = append(s.Owners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owners\"")
			}
		case "vcenters":
			if err := func() error {
				s.Vcenters = make([]VcenterReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VcenterReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Vcenters = append(s.Vcenters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcenters\"")
			}
		case "ssoId":
			if err := func() error {
				s.SsoId.Reset()
				if err := s.SsoId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssoId\"")
			}
		case "ssoName":
			if err := func() error {
				s.SsoName.Reset()
				if err := s.SsoName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssoName\"")
			}
		case "isManagementSsoDomain":
			if err := func() error {
				s.IsManagementSsoDomain.Reset()
				if err := s.IsManagementSsoDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isManagementSsoDomain\"")
			}
		case "clusters":
			if err := func() error {
				s.Clusters = make([]ClusterReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClusterReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Clusters = append(s.Clusters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusters\"")
			}
		case "nsxtCluster":
			if err := func() error {
				s.NsxtCluster.Reset()
				if err := s.NsxtCluster.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtCluster\"")
			}
		case "licensingInfo":
			if err := func() error {
				s.LicensingInfo.Reset()
				if err := s.LicensingInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licensingInfo\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "elmStatus":
			if err := func() error {
				s.ElmStatus.Reset()
				if err := s.ElmStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elmStatus\"")
			}
		case "lifecycleManagementMode":
			if err := func() error {
				s.LifecycleManagementMode.Reset()
				if err := s.LifecycleManagementMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifecycleManagementMode\"")
			}
		case "isNetworkSeparationEnabled":
			if err := func() error {
				s.IsNetworkSeparationEnabled.Reset()
				if err := s.IsNetworkSeparationEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNetworkSeparationEnabled\"")
			}
		case "isSecurityEnabled":
			if err := func() error {
				s.IsSecurityEnabled.Reset()
				if err := s.IsSecurityEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSecurityEnabled\"")
			}
		case "isPrimaryDomainForNsx":
			if err := func() error {
				s.IsPrimaryDomainForNsx.Reset()
				if err := s.IsPrimaryDomainForNsx.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isPrimaryDomainForNsx\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Domain")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Domain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Domain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainCreateValidationBadRequest as json.
func (s *DomainCreateValidationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DomainCreateValidationBadRequest from json.
func (s *DomainCreateValidationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainCreateValidationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DomainCreateValidationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainCreateValidationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainCreateValidationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainCreateValidationNotFound as json.
func (s *DomainCreateValidationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DomainCreateValidationNotFound from json.
func (s *DomainCreateValidationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainCreateValidationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DomainCreateValidationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainCreateValidationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainCreateValidationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainCreationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainCreationSpec) encodeFields(e *jx.Encoder) {
	{
		if s.DomainName.Set {
			e.FieldStart("domainName")
			s.DomainName.Encode(e)
		}
	}
	{
		if s.OrgName.Set {
			e.FieldStart("orgName")
			s.OrgName.Encode(e)
		}
	}
	{
		e.FieldStart("vcenterSpec")
		s.VcenterSpec.Encode(e)
	}
	{
		e.FieldStart("computeSpec")
		s.ComputeSpec.Encode(e)
	}
	{
		if s.NsxTSpec.Set {
			e.FieldStart("nsxTSpec")
			s.NsxTSpec.Encode(e)
		}
	}
	{
		if s.SsoDomainSpec.Set {
			e.FieldStart("ssoDomainSpec")
			s.SsoDomainSpec.Encode(e)
		}
	}
	{
		if s.SecuritySpec.Set {
			e.FieldStart("securitySpec")
			s.SecuritySpec.Encode(e)
		}
	}
	{
		if s.DeployWithoutLicenseKeys.Set {
			e.FieldStart("deployWithoutLicenseKeys")
			s.DeployWithoutLicenseKeys.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainCreationSpec = [8]string{
	0: "domainName",
	1: "orgName",
	2: "vcenterSpec",
	3: "computeSpec",
	4: "nsxTSpec",
	5: "ssoDomainSpec",
	6: "securitySpec",
	7: "deployWithoutLicenseKeys",
}

// Decode decodes DomainCreationSpec from json.
func (s *DomainCreationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainCreationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainName":
			if err := func() error {
				s.DomainName.Reset()
				if err := s.DomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainName\"")
			}
		case "orgName":
			if err := func() error {
				s.OrgName.Reset()
				if err := s.OrgName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orgName\"")
			}
		case "vcenterSpec":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.VcenterSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcenterSpec\"")
			}
		case "computeSpec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ComputeSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"computeSpec\"")
			}
		case "nsxTSpec":
			if err := func() error {
				s.NsxTSpec.Reset()
				if err := s.NsxTSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxTSpec\"")
			}
		case "ssoDomainSpec":
			if err := func() error {
				s.SsoDomainSpec.Reset()
				if err := s.SsoDomainSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssoDomainSpec\"")
			}
		case "securitySpec":
			if err := func() error {
				s.SecuritySpec.Reset()
				if err := s.SecuritySpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securitySpec\"")
			}
		case "deployWithoutLicenseKeys":
			if err := func() error {
				s.DeployWithoutLicenseKeys.Reset()
				if err := s.DeployWithoutLicenseKeys.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployWithoutLicenseKeys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainCreationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainCreationSpec) {
					name = jsonFieldsNameOfDomainCreationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainCreationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainCreationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainFutureRelease) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainFutureRelease) encodeFields(e *jx.Encoder) {
	{
		if s.ReasonNotApplicable.Set {
			e.FieldStart("reasonNotApplicable")
			s.ReasonNotApplicable.Encode(e)
		}
	}
	{
		if s.ReasonsNotApplicable != nil {
			e.FieldStart("reasonsNotApplicable")
			e.ArrStart()
			for _, elem := range s.ReasonsNotApplicable {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Warnings != nil {
			e.FieldStart("warnings")
			e.ArrStart()
			for _, elem := range s.Warnings {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AlternativeApplicableSddcManagerVersions != nil {
			e.FieldStart("alternativeApplicableSddcManagerVersions")
			e.ArrStart()
			for _, elem := range s.AlternativeApplicableSddcManagerVersions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ApplicabilityStatus.Set {
			e.FieldStart("applicabilityStatus")
			s.ApplicabilityStatus.Encode(e)
		}
	}
	{
		e.FieldStart("product")
		e.Str(s.Product)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("minCompatibleVcfVersion")
		e.Str(s.MinCompatibleVcfVersion)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("releaseDate")
		e.Str(s.ReleaseDate)
	}
	{
		e.FieldStart("bom")
		e.ArrStart()
		for _, elem := range s.Bom {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.IsApplicable.Set {
			e.FieldStart("isApplicable")
			s.IsApplicable.Encode(e)
		}
	}
	{
		if s.NotApplicableReason.Set {
			e.FieldStart("notApplicableReason")
			s.NotApplicableReason.Encode(e)
		}
	}
	{
		if s.Sku != nil {
			e.FieldStart("sku")
			e.ArrStart()
			for _, elem := range s.Sku {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Updates != nil {
			e.FieldStart("updates")
			e.ArrStart()
			for _, elem := range s.Updates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PatchBundles != nil {
			e.FieldStart("patchBundles")
			e.ArrStart()
			for _, elem := range s.PatchBundles {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Eol.Set {
			e.FieldStart("eol")
			s.Eol.Encode(e)
		}
	}
	{
		if s.UpgradeOrder.Set {
			e.FieldStart("upgradeOrder")
			s.UpgradeOrder.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainFutureRelease = [18]string{
	0:  "reasonNotApplicable",
	1:  "reasonsNotApplicable",
	2:  "warnings",
	3:  "alternativeApplicableSddcManagerVersions",
	4:  "applicabilityStatus",
	5:  "product",
	6:  "version",
	7:  "minCompatibleVcfVersion",
	8:  "description",
	9:  "releaseDate",
	10: "bom",
	11: "isApplicable",
	12: "notApplicableReason",
	13: "sku",
	14: "updates",
	15: "patchBundles",
	16: "eol",
	17: "upgradeOrder",
}

// Decode decodes DomainFutureRelease from json.
func (s *DomainFutureRelease) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainFutureRelease to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reasonNotApplicable":
			if err := func() error {
				s.ReasonNotApplicable.Reset()
				if err := s.ReasonNotApplicable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reasonNotApplicable\"")
			}
		case "reasonsNotApplicable":
			if err := func() error {
				s.ReasonsNotApplicable = make([]MessagePack, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessagePack
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ReasonsNotApplicable = append(s.ReasonsNotApplicable, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reasonsNotApplicable\"")
			}
		case "warnings":
			if err := func() error {
				s.Warnings = make([]MessagePack, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MessagePack
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Warnings = append(s.Warnings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warnings\"")
			}
		case "alternativeApplicableSddcManagerVersions":
			if err := func() error {
				s.AlternativeApplicableSddcManagerVersions = make([]AlternativeApplicableSddcManagerVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlternativeApplicableSddcManagerVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AlternativeApplicableSddcManagerVersions = append(s.AlternativeApplicableSddcManagerVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alternativeApplicableSddcManagerVersions\"")
			}
		case "applicabilityStatus":
			if err := func() error {
				s.ApplicabilityStatus.Reset()
				if err := s.ApplicabilityStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applicabilityStatus\"")
			}
		case "product":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Product = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "minCompatibleVcfVersion":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MinCompatibleVcfVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minCompatibleVcfVersion\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "releaseDate":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ReleaseDate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releaseDate\"")
			}
		case "bom":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Bom = make([]ProductVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProductVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Bom = append(s.Bom, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bom\"")
			}
		case "isApplicable":
			if err := func() error {
				s.IsApplicable.Reset()
				if err := s.IsApplicable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isApplicable\"")
			}
		case "notApplicableReason":
			if err := func() error {
				s.NotApplicableReason.Reset()
				if err := s.NotApplicableReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notApplicableReason\"")
			}
		case "sku":
			if err := func() error {
				s.Sku = make([]SkuBomDetails, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SkuBomDetails
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sku = append(s.Sku, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sku\"")
			}
		case "updates":
			if err := func() error {
				s.Updates = make([]ReleaseUpdate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReleaseUpdate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Updates = append(s.Updates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updates\"")
			}
		case "patchBundles":
			if err := func() error {
				s.PatchBundles = make([]PatchBundle, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PatchBundle
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PatchBundles = append(s.PatchBundles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patchBundles\"")
			}
		case "eol":
			if err := func() error {
				s.Eol.Reset()
				if err := s.Eol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eol\"")
			}
		case "upgradeOrder":
			if err := func() error {
				s.UpgradeOrder.Reset()
				if err := s.UpgradeOrder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upgradeOrder\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainFutureRelease")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11100000,
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainFutureRelease) {
					name = jsonFieldsNameOfDomainFutureRelease[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainFutureRelease) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainFutureRelease) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainInfo) encodeFields(e *jx.Encoder) {
	{
		if s.DomainName.Set {
			e.FieldStart("domainName")
			s.DomainName.Encode(e)
		}
	}
	{
		if s.DomainType.Set {
			e.FieldStart("domainType")
			s.DomainType.Encode(e)
		}
	}
	{
		if s.DomainId.Set {
			e.FieldStart("domainId")
			s.DomainId.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainInfo = [3]string{
	0: "domainName",
	1: "domainType",
	2: "domainId",
}

// Decode decodes DomainInfo from json.
func (s *DomainInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainName":
			if err := func() error {
				s.DomainName.Reset()
				if err := s.DomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainName\"")
			}
		case "domainType":
			if err := func() error {
				s.DomainType.Reset()
				if err := s.DomainType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainType\"")
			}
		case "domainId":
			if err := func() error {
				s.DomainId.Reset()
				if err := s.DomainId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainInfoDomainType as json.
func (s DomainInfoDomainType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DomainInfoDomainType from json.
func (s *DomainInfoDomainType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainInfoDomainType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DomainInfoDomainType(v) {
	case DomainInfoDomainTypeMANAGEMENT:
		*s = DomainInfoDomainTypeMANAGEMENT
	case DomainInfoDomainTypeVI:
		*s = DomainInfoDomainTypeVI
	default:
		*s = DomainInfoDomainType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainInfoDomainType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainInfoDomainType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainIntegration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainIntegration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("domainId")
		e.Str(s.DomainId)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfDomainIntegration = [2]string{
	0: "domainId",
	1: "status",
}

// Decode decodes DomainIntegration from json.
func (s *DomainIntegration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIntegration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DomainId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainIntegration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainIntegration) {
					name = jsonFieldsNameOfDomainIntegration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainIntegration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIntegration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainIntegrationStatus as json.
func (s DomainIntegrationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DomainIntegrationStatus from json.
func (s *DomainIntegrationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIntegrationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DomainIntegrationStatus(v) {
	case DomainIntegrationStatusENABLED:
		*s = DomainIntegrationStatusENABLED
	case DomainIntegrationStatusDISABLED:
		*s = DomainIntegrationStatusDISABLED
	default:
		*s = DomainIntegrationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainIntegrationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIntegrationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainReference = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes DomainReference from json.
func (s *DomainReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainReference) {
					name = jsonFieldsNameOfDomainReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainRelease) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainRelease) encodeFields(e *jx.Encoder) {
	{
		if s.TargetVersion.Set {
			e.FieldStart("targetVersion")
			s.TargetVersion.Encode(e)
		}
	}
	{
		if s.TargetVxRailVersion.Set {
			e.FieldStart("targetVxRailVersion")
			s.TargetVxRailVersion.Encode(e)
		}
	}
	{
		if s.TargetSddcManagerVersion.Set {
			e.FieldStart("targetSddcManagerVersion")
			s.TargetSddcManagerVersion.Encode(e)
		}
	}
	{
		if s.Patches != nil {
			e.FieldStart("patches")
			e.ArrStart()
			for _, elem := range s.Patches {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDomainRelease = [4]string{
	0: "targetVersion",
	1: "targetVxRailVersion",
	2: "targetSddcManagerVersion",
	3: "patches",
}

// Decode decodes DomainRelease from json.
func (s *DomainRelease) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainRelease to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "targetVersion":
			if err := func() error {
				s.TargetVersion.Reset()
				if err := s.TargetVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetVersion\"")
			}
		case "targetVxRailVersion":
			if err := func() error {
				s.TargetVxRailVersion.Reset()
				if err := s.TargetVxRailVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetVxRailVersion\"")
			}
		case "targetSddcManagerVersion":
			if err := func() error {
				s.TargetSddcManagerVersion.Reset()
				if err := s.TargetSddcManagerVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetSddcManagerVersion\"")
			}
		case "patches":
			if err := func() error {
				s.Patches = make([]TargetProductVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TargetProductVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Patches = append(s.Patches, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainRelease")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainRelease) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainRelease) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainReleaseView) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainReleaseView) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("domainId")
		e.Str(s.DomainId)
	}
	{
		e.FieldStart("targetVersion")
		e.Str(s.TargetVersion)
	}
	{
		if s.TargetVxRailVersion.Set {
			e.FieldStart("targetVxRailVersion")
			s.TargetVxRailVersion.Encode(e)
		}
	}
	{
		if s.TargetSddcManagerVersion.Set {
			e.FieldStart("targetSddcManagerVersion")
			s.TargetSddcManagerVersion.Encode(e)
		}
	}
	{
		if s.Patches != nil {
			e.FieldStart("patches")
			e.ArrStart()
			for _, elem := range s.Patches {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsCustomizedBom.Set {
			e.FieldStart("isCustomizedBom")
			s.IsCustomizedBom.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainReleaseView = [6]string{
	0: "domainId",
	1: "targetVersion",
	2: "targetVxRailVersion",
	3: "targetSddcManagerVersion",
	4: "patches",
	5: "isCustomizedBom",
}

// Decode decodes DomainReleaseView from json.
func (s *DomainReleaseView) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainReleaseView to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DomainId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainId\"")
			}
		case "targetVersion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TargetVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetVersion\"")
			}
		case "targetVxRailVersion":
			if err := func() error {
				s.TargetVxRailVersion.Reset()
				if err := s.TargetVxRailVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetVxRailVersion\"")
			}
		case "targetSddcManagerVersion":
			if err := func() error {
				s.TargetSddcManagerVersion.Reset()
				if err := s.TargetSddcManagerVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetSddcManagerVersion\"")
			}
		case "patches":
			if err := func() error {
				s.Patches = make([]TargetProductVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TargetProductVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Patches = append(s.Patches, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patches\"")
			}
		case "isCustomizedBom":
			if err := func() error {
				s.IsCustomizedBom.Reset()
				if err := s.IsCustomizedBom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isCustomizedBom\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainReleaseView")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainReleaseView) {
					name = jsonFieldsNameOfDomainReleaseView[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainReleaseView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainReleaseView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ClusterSpec.Set {
			e.FieldStart("clusterSpec")
			s.ClusterSpec.Encode(e)
		}
	}
	{
		if s.NsxTSpec.Set {
			e.FieldStart("nsxTSpec")
			s.NsxTSpec.Encode(e)
		}
	}
	{
		if s.MarkForDeletion.Set {
			e.FieldStart("markForDeletion")
			s.MarkForDeletion.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.IsolationSpec.Set {
			e.FieldStart("isolationSpec")
			s.IsolationSpec.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainUpdateSpec = [5]string{
	0: "clusterSpec",
	1: "nsxTSpec",
	2: "markForDeletion",
	3: "name",
	4: "isolationSpec",
}

// Decode decodes DomainUpdateSpec from json.
func (s *DomainUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainUpdateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusterSpec":
			if err := func() error {
				s.ClusterSpec.Reset()
				if err := s.ClusterSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterSpec\"")
			}
		case "nsxTSpec":
			if err := func() error {
				s.NsxTSpec.Reset()
				if err := s.NsxTSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxTSpec\"")
			}
		case "markForDeletion":
			if err := func() error {
				s.MarkForDeletion.Reset()
				if err := s.MarkForDeletion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"markForDeletion\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "isolationSpec":
			if err := func() error {
				s.IsolationSpec.Reset()
				if err := s.IsolationSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isolationSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainUpdateSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Domains) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Domains) encodeFields(e *jx.Encoder) {
	{
		if s.DomainName.Set {
			e.FieldStart("domainName")
			s.DomainName.Encode(e)
		}
	}
	{
		if s.ClusterNames != nil {
			e.FieldStart("clusterNames")
			e.ArrStart()
			for _, elem := range s.ClusterNames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDomains = [2]string{
	0: "domainName",
	1: "clusterNames",
}

// Decode decodes Domains from json.
func (s *Domains) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Domains to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainName":
			if err := func() error {
				s.DomainName.Reset()
				if err := s.DomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainName\"")
			}
		case "clusterNames":
			if err := func() error {
				s.ClusterNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ClusterNames = append(s.ClusterNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterNames\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Domains")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Domains) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Domains) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DownloadCSRInternalServerError as json.
func (s *DownloadCSRInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DownloadCSRInternalServerError from json.
func (s *DownloadCSRInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DownloadCSRInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DownloadCSRInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DownloadCSRInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DownloadCSRInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DownloadCSRNotFound as json.
func (s *DownloadCSRNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DownloadCSRNotFound from json.
func (s *DownloadCSRNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DownloadCSRNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DownloadCSRNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DownloadCSRNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DownloadCSRNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DownloadCSROKApplicationJSON as json.
func (s DownloadCSROKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []byte(s)

	e.Base64(unwrapped)
}

// Decode decodes DownloadCSROKApplicationJSON from json.
func (s *DownloadCSROKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DownloadCSROKApplicationJSON to nil")
	}
	var unwrapped []byte
	if err := func() error {
		v, err := d.Base64()
		unwrapped = []byte(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DownloadCSROKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DownloadCSROKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DownloadCSROKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DownloadVsanHclBadRequest as json.
func (s *DownloadVsanHclBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DownloadVsanHclBadRequest from json.
func (s *DownloadVsanHclBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DownloadVsanHclBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DownloadVsanHclBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DownloadVsanHclBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DownloadVsanHclBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DownloadVsanHclInternalServerError as json.
func (s *DownloadVsanHclInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes DownloadVsanHclInternalServerError from json.
func (s *DownloadVsanHclInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DownloadVsanHclInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DownloadVsanHclInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DownloadVsanHclInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DownloadVsanHclInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DvsSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DvsSpec) encodeFields(e *jx.Encoder) {
	{
		if s.DvsName.Set {
			e.FieldStart("dvsName")
			s.DvsName.Encode(e)
		}
	}
	{
		if s.Vmnics != nil {
			e.FieldStart("vmnics")
			e.ArrStart()
			for _, elem := range s.Vmnics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Networks != nil {
			e.FieldStart("networks")
			e.ArrStart()
			for _, elem := range s.Networks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NiocSpecs != nil {
			e.FieldStart("niocSpecs")
			e.ArrStart()
			for _, elem := range s.NiocSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Mtu.Set {
			e.FieldStart("mtu")
			s.Mtu.Encode(e)
		}
	}
	{
		if s.IsUsedByNsxt.Set {
			e.FieldStart("isUsedByNsxt")
			s.IsUsedByNsxt.Encode(e)
		}
	}
	{
		if s.NsxtSwitchConfig.Set {
			e.FieldStart("nsxtSwitchConfig")
			s.NsxtSwitchConfig.Encode(e)
		}
	}
	{
		if s.VmnicsToUplinks != nil {
			e.FieldStart("vmnicsToUplinks")
			e.ArrStart()
			for _, elem := range s.VmnicsToUplinks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NsxTeamings != nil {
			e.FieldStart("nsxTeamings")
			e.ArrStart()
			for _, elem := range s.NsxTeamings {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDvsSpec = [9]string{
	0: "dvsName",
	1: "vmnics",
	2: "networks",
	3: "niocSpecs",
	4: "mtu",
	5: "isUsedByNsxt",
	6: "nsxtSwitchConfig",
	7: "vmnicsToUplinks",
	8: "nsxTeamings",
}

// Decode decodes DvsSpec from json.
func (s *DvsSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DvsSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dvsName":
			if err := func() error {
				s.DvsName.Reset()
				if err := s.DvsName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dvsName\"")
			}
		case "vmnics":
			if err := func() error {
				s.Vmnics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Vmnics = append(s.Vmnics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmnics\"")
			}
		case "networks":
			if err := func() error {
				s.Networks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Networks = append(s.Networks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networks\"")
			}
		case "niocSpecs":
			if err := func() error {
				s.NiocSpecs = make([]NiocSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NiocSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NiocSpecs = append(s.NiocSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"niocSpecs\"")
			}
		case "mtu":
			if err := func() error {
				s.Mtu.Reset()
				if err := s.Mtu.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mtu\"")
			}
		case "isUsedByNsxt":
			if err := func() error {
				s.IsUsedByNsxt.Reset()
				if err := s.IsUsedByNsxt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isUsedByNsxt\"")
			}
		case "nsxtSwitchConfig":
			if err := func() error {
				s.NsxtSwitchConfig.Reset()
				if err := s.NsxtSwitchConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtSwitchConfig\"")
			}
		case "vmnicsToUplinks":
			if err := func() error {
				s.VmnicsToUplinks = make([]VmnicToUplink, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VmnicToUplink
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VmnicsToUplinks = append(s.VmnicsToUplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmnicsToUplinks\"")
			}
		case "nsxTeamings":
			if err := func() error {
				s.NsxTeamings = make([]TeamingSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TeamingSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxTeamings = append(s.NsxTeamings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxTeamings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DvsSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DvsSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DvsSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EdgeCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EdgeCluster) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Clusters != nil {
			e.FieldStart("clusters")
			e.ArrStart()
			for _, elem := range s.Clusters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.NsxtCluster.Set {
			e.FieldStart("nsxtCluster")
			s.NsxtCluster.Encode(e)
		}
	}
	{
		if s.EdgeNodes != nil {
			e.FieldStart("edgeNodes")
			e.ArrStart()
			for _, elem := range s.EdgeNodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsTier0ManagedBySystem.Set {
			e.FieldStart("isTier0ManagedBySystem")
			s.IsTier0ManagedBySystem.Encode(e)
		}
	}
	{
		if s.SkipTepRoutabilityCheck.Set {
			e.FieldStart("skipTepRoutabilityCheck")
			s.SkipTepRoutabilityCheck.Encode(e)
		}
	}
}

var jsonFieldsNameOfEdgeCluster = [8]string{
	0: "id",
	1: "name",
	2: "clusters",
	3: "status",
	4: "nsxtCluster",
	5: "edgeNodes",
	6: "isTier0ManagedBySystem",
	7: "skipTepRoutabilityCheck",
}

// Decode decodes EdgeCluster from json.
func (s *EdgeCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EdgeCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "clusters":
			if err := func() error {
				s.Clusters = make([]ClusterReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClusterReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Clusters = append(s.Clusters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusters\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "nsxtCluster":
			if err := func() error {
				s.NsxtCluster.Reset()
				if err := s.NsxtCluster.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtCluster\"")
			}
		case "edgeNodes":
			if err := func() error {
				s.EdgeNodes = make([]EdgeNodeReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EdgeNodeReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EdgeNodes = append(s.EdgeNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeNodes\"")
			}
		case "isTier0ManagedBySystem":
			if err := func() error {
				s.IsTier0ManagedBySystem.Reset()
				if err := s.IsTier0ManagedBySystem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTier0ManagedBySystem\"")
			}
		case "skipTepRoutabilityCheck":
			if err := func() error {
				s.SkipTepRoutabilityCheck.Reset()
				if err := s.SkipTepRoutabilityCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skipTepRoutabilityCheck\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EdgeCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EdgeCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EdgeCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EdgeClusterCreationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EdgeClusterCreationSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("edgeClusterName")
		e.Str(s.EdgeClusterName)
	}
	{
		e.FieldStart("edgeClusterType")
		e.Str(s.EdgeClusterType)
	}
	{
		e.FieldStart("edgeRootPassword")
		e.Str(s.EdgeRootPassword)
	}
	{
		e.FieldStart("edgeAdminPassword")
		e.Str(s.EdgeAdminPassword)
	}
	{
		e.FieldStart("edgeAuditPassword")
		e.Str(s.EdgeAuditPassword)
	}
	{
		e.FieldStart("edgeFormFactor")
		e.Str(s.EdgeFormFactor)
	}
	{
		if s.Tier0ServicesHighAvailability.Set {
			e.FieldStart("tier0ServicesHighAvailability")
			s.Tier0ServicesHighAvailability.Encode(e)
		}
	}
	{
		e.FieldStart("mtu")
		e.Int32(s.Mtu)
	}
	{
		if s.Asn.Set {
			e.FieldStart("asn")
			s.Asn.Encode(e)
		}
	}
	{
		e.FieldStart("edgeNodeSpecs")
		e.ArrStart()
		for _, elem := range s.EdgeNodeSpecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.NewIpAddressPoolSpecs != nil {
			e.FieldStart("newIpAddressPoolSpecs")
			e.ArrStart()
			for _, elem := range s.NewIpAddressPoolSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Tier0RoutingType.Set {
			e.FieldStart("tier0RoutingType")
			s.Tier0RoutingType.Encode(e)
		}
	}
	{
		if s.Tier0Name.Set {
			e.FieldStart("tier0Name")
			s.Tier0Name.Encode(e)
		}
	}
	{
		if s.Tier1Name.Set {
			e.FieldStart("tier1Name")
			s.Tier1Name.Encode(e)
		}
	}
	{
		if s.Tier1Unhosted.Set {
			e.FieldStart("tier1Unhosted")
			s.Tier1Unhosted.Encode(e)
		}
	}
	{
		e.FieldStart("edgeClusterProfileType")
		e.Str(s.EdgeClusterProfileType)
	}
	{
		e.FieldStart("edgeClusterProfileSpec")
		s.EdgeClusterProfileSpec.Encode(e)
	}
	{
		if s.SkipTepRoutabilityCheck.Set {
			e.FieldStart("skipTepRoutabilityCheck")
			s.SkipTepRoutabilityCheck.Encode(e)
		}
	}
	{
		if s.TransitSubnets != nil {
			e.FieldStart("transitSubnets")
			e.ArrStart()
			for _, elem := range s.TransitSubnets {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.InternalTransitSubnets != nil {
			e.FieldStart("internalTransitSubnets")
			e.ArrStart()
			for _, elem := range s.InternalTransitSubnets {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEdgeClusterCreationSpec = [20]string{
	0:  "edgeClusterName",
	1:  "edgeClusterType",
	2:  "edgeRootPassword",
	3:  "edgeAdminPassword",
	4:  "edgeAuditPassword",
	5:  "edgeFormFactor",
	6:  "tier0ServicesHighAvailability",
	7:  "mtu",
	8:  "asn",
	9:  "edgeNodeSpecs",
	10: "newIpAddressPoolSpecs",
	11: "tier0RoutingType",
	12: "tier0Name",
	13: "tier1Name",
	14: "tier1Unhosted",
	15: "edgeClusterProfileType",
	16: "edgeClusterProfileSpec",
	17: "skipTepRoutabilityCheck",
	18: "transitSubnets",
	19: "internalTransitSubnets",
}

// Decode decodes EdgeClusterCreationSpec from json.
func (s *EdgeClusterCreationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EdgeClusterCreationSpec to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "edgeClusterName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EdgeClusterName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeClusterName\"")
			}
		case "edgeClusterType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EdgeClusterType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeClusterType\"")
			}
		case "edgeRootPassword":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.EdgeRootPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeRootPassword\"")
			}
		case "edgeAdminPassword":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.EdgeAdminPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeAdminPassword\"")
			}
		case "edgeAuditPassword":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.EdgeAuditPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeAuditPassword\"")
			}
		case "edgeFormFactor":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.EdgeFormFactor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeFormFactor\"")
			}
		case "tier0ServicesHighAvailability":
			if err := func() error {
				s.Tier0ServicesHighAvailability.Reset()
				if err := s.Tier0ServicesHighAvailability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier0ServicesHighAvailability\"")
			}
		case "mtu":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Mtu = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mtu\"")
			}
		case "asn":
			if err := func() error {
				s.Asn.Reset()
				if err := s.Asn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asn\"")
			}
		case "edgeNodeSpecs":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.EdgeNodeSpecs = make([]NsxTEdgeNodeSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxTEdgeNodeSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EdgeNodeSpecs = append(s.EdgeNodeSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeNodeSpecs\"")
			}
		case "newIpAddressPoolSpecs":
			if err := func() error {
				s.NewIpAddressPoolSpecs = make([]IpAddressPoolSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IpAddressPoolSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NewIpAddressPoolSpecs = append(s.NewIpAddressPoolSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"newIpAddressPoolSpecs\"")
			}
		case "tier0RoutingType":
			if err := func() error {
				s.Tier0RoutingType.Reset()
				if err := s.Tier0RoutingType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier0RoutingType\"")
			}
		case "tier0Name":
			if err := func() error {
				s.Tier0Name.Reset()
				if err := s.Tier0Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier0Name\"")
			}
		case "tier1Name":
			if err := func() error {
				s.Tier1Name.Reset()
				if err := s.Tier1Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier1Name\"")
			}
		case "tier1Unhosted":
			if err := func() error {
				s.Tier1Unhosted.Reset()
				if err := s.Tier1Unhosted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier1Unhosted\"")
			}
		case "edgeClusterProfileType":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.EdgeClusterProfileType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeClusterProfileType\"")
			}
		case "edgeClusterProfileSpec":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.EdgeClusterProfileSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeClusterProfileSpec\"")
			}
		case "skipTepRoutabilityCheck":
			if err := func() error {
				s.SkipTepRoutabilityCheck.Reset()
				if err := s.SkipTepRoutabilityCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skipTepRoutabilityCheck\"")
			}
		case "transitSubnets":
			if err := func() error {
				s.TransitSubnets = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TransitSubnets = append(s.TransitSubnets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transitSubnets\"")
			}
		case "internalTransitSubnets":
			if err := func() error {
				s.InternalTransitSubnets = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.InternalTransitSubnets = append(s.InternalTransitSubnets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalTransitSubnets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EdgeClusterCreationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b10111111,
		0b10000010,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEdgeClusterCreationSpec) {
					name = jsonFieldsNameOfEdgeClusterCreationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EdgeClusterCreationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EdgeClusterCreationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EdgeClusterExpansionSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EdgeClusterExpansionSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("edgeNodeRootPassword")
		e.Str(s.EdgeNodeRootPassword)
	}
	{
		e.FieldStart("edgeNodeAdminPassword")
		e.Str(s.EdgeNodeAdminPassword)
	}
	{
		e.FieldStart("edgeNodeAuditPassword")
		e.Str(s.EdgeNodeAuditPassword)
	}
	{
		if s.SkipTepRoutabilityCheck.Set {
			e.FieldStart("skipTepRoutabilityCheck")
			s.SkipTepRoutabilityCheck.Encode(e)
		}
	}
	{
		e.FieldStart("edgeNodeSpecs")
		e.ArrStart()
		for _, elem := range s.EdgeNodeSpecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.NewIpAddressPoolSpecs != nil {
			e.FieldStart("newIpAddressPoolSpecs")
			e.ArrStart()
			for _, elem := range s.NewIpAddressPoolSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AdditionalTier1Names != nil {
			e.FieldStart("additionalTier1Names")
			e.ArrStart()
			for _, elem := range s.AdditionalTier1Names {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Tier1Unhosted.Set {
			e.FieldStart("tier1Unhosted")
			s.Tier1Unhosted.Encode(e)
		}
	}
}

var jsonFieldsNameOfEdgeClusterExpansionSpec = [8]string{
	0: "edgeNodeRootPassword",
	1: "edgeNodeAdminPassword",
	2: "edgeNodeAuditPassword",
	3: "skipTepRoutabilityCheck",
	4: "edgeNodeSpecs",
	5: "newIpAddressPoolSpecs",
	6: "additionalTier1Names",
	7: "tier1Unhosted",
}

// Decode decodes EdgeClusterExpansionSpec from json.
func (s *EdgeClusterExpansionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EdgeClusterExpansionSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "edgeNodeRootPassword":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EdgeNodeRootPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeNodeRootPassword\"")
			}
		case "edgeNodeAdminPassword":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EdgeNodeAdminPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeNodeAdminPassword\"")
			}
		case "edgeNodeAuditPassword":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.EdgeNodeAuditPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeNodeAuditPassword\"")
			}
		case "skipTepRoutabilityCheck":
			if err := func() error {
				s.SkipTepRoutabilityCheck.Reset()
				if err := s.SkipTepRoutabilityCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skipTepRoutabilityCheck\"")
			}
		case "edgeNodeSpecs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.EdgeNodeSpecs = make([]NsxTEdgeNodeSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxTEdgeNodeSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EdgeNodeSpecs = append(s.EdgeNodeSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeNodeSpecs\"")
			}
		case "newIpAddressPoolSpecs":
			if err := func() error {
				s.NewIpAddressPoolSpecs = make([]IpAddressPoolSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IpAddressPoolSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NewIpAddressPoolSpecs = append(s.NewIpAddressPoolSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"newIpAddressPoolSpecs\"")
			}
		case "additionalTier1Names":
			if err := func() error {
				s.AdditionalTier1Names = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdditionalTier1Names = append(s.AdditionalTier1Names, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalTier1Names\"")
			}
		case "tier1Unhosted":
			if err := func() error {
				s.Tier1Unhosted.Reset()
				if err := s.Tier1Unhosted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier1Unhosted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EdgeClusterExpansionSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEdgeClusterExpansionSpec) {
					name = jsonFieldsNameOfEdgeClusterExpansionSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EdgeClusterExpansionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EdgeClusterExpansionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EdgeClusterNsxtEntityCriterion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EdgeClusterNsxtEntityCriterion) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Arguments.Set {
			e.FieldStart("arguments")
			s.Arguments.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfEdgeClusterNsxtEntityCriterion = [3]string{
	0: "name",
	1: "arguments",
	2: "description",
}

// Decode decodes EdgeClusterNsxtEntityCriterion from json.
func (s *EdgeClusterNsxtEntityCriterion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EdgeClusterNsxtEntityCriterion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments.Reset()
				if err := s.Arguments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EdgeClusterNsxtEntityCriterion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EdgeClusterNsxtEntityCriterion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EdgeClusterNsxtEntityCriterion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EdgeClusterNsxtEntityCriterionArguments) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EdgeClusterNsxtEntityCriterionArguments) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes EdgeClusterNsxtEntityCriterionArguments from json.
func (s *EdgeClusterNsxtEntityCriterionArguments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EdgeClusterNsxtEntityCriterionArguments to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EdgeClusterNsxtEntityCriterionArguments")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EdgeClusterNsxtEntityCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EdgeClusterNsxtEntityCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EdgeClusterShrinkageSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EdgeClusterShrinkageSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("edgeNodeIds")
		e.ArrStart()
		for _, elem := range s.EdgeNodeIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEdgeClusterShrinkageSpec = [1]string{
	0: "edgeNodeIds",
}

// Decode decodes EdgeClusterShrinkageSpec from json.
func (s *EdgeClusterShrinkageSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EdgeClusterShrinkageSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "edgeNodeIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.EdgeNodeIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.EdgeNodeIds = append(s.EdgeNodeIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeNodeIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EdgeClusterShrinkageSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEdgeClusterShrinkageSpec) {
					name = jsonFieldsNameOfEdgeClusterShrinkageSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EdgeClusterShrinkageSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EdgeClusterShrinkageSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EdgeClusterUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EdgeClusterUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		if s.EdgeClusterExpansionSpec.Set {
			e.FieldStart("edgeClusterExpansionSpec")
			s.EdgeClusterExpansionSpec.Encode(e)
		}
	}
	{
		if s.EdgeClusterShrinkageSpec.Set {
			e.FieldStart("edgeClusterShrinkageSpec")
			s.EdgeClusterShrinkageSpec.Encode(e)
		}
	}
	{
		e.FieldStart("operation")
		e.Str(s.Operation)
	}
}

var jsonFieldsNameOfEdgeClusterUpdateSpec = [3]string{
	0: "edgeClusterExpansionSpec",
	1: "edgeClusterShrinkageSpec",
	2: "operation",
}

// Decode decodes EdgeClusterUpdateSpec from json.
func (s *EdgeClusterUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EdgeClusterUpdateSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "edgeClusterExpansionSpec":
			if err := func() error {
				s.EdgeClusterExpansionSpec.Reset()
				if err := s.EdgeClusterExpansionSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeClusterExpansionSpec\"")
			}
		case "edgeClusterShrinkageSpec":
			if err := func() error {
				s.EdgeClusterShrinkageSpec.Reset()
				if err := s.EdgeClusterShrinkageSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeClusterShrinkageSpec\"")
			}
		case "operation":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Operation = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EdgeClusterUpdateSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEdgeClusterUpdateSpec) {
					name = jsonFieldsNameOfEdgeClusterUpdateSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EdgeClusterUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EdgeClusterUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EdgeNodeReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EdgeNodeReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("hostName")
		e.Str(s.HostName)
	}
}

var jsonFieldsNameOfEdgeNodeReference = [2]string{
	0: "id",
	1: "hostName",
}

// Decode decodes EdgeNodeReference from json.
func (s *EdgeNodeReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EdgeNodeReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "hostName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.HostName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EdgeNodeReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEdgeNodeReference) {
					name = jsonFieldsNameOfEdgeNodeReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EdgeNodeReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EdgeNodeReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EdgeTepIpAddressPoolSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EdgeTepIpAddressPoolSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.NsxId.Set {
			e.FieldStart("nsxId")
			s.NsxId.Encode(e)
		}
	}
}

var jsonFieldsNameOfEdgeTepIpAddressPoolSpec = [2]string{
	0: "name",
	1: "nsxId",
}

// Decode decodes EdgeTepIpAddressPoolSpec from json.
func (s *EdgeTepIpAddressPoolSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EdgeTepIpAddressPoolSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nsxId":
			if err := func() error {
				s.NsxId.Reset()
				if err := s.NsxId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EdgeTepIpAddressPoolSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EdgeTepIpAddressPoolSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EdgeTepIpAddressPoolSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Encryption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Encryption) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("passphrase")
		e.Str(s.Passphrase)
	}
}

var jsonFieldsNameOfEncryption = [1]string{
	0: "passphrase",
}

// Decode decodes Encryption from json.
func (s *Encryption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Encryption to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "passphrase":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Passphrase = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passphrase\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Encryption")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEncryption) {
					name = jsonFieldsNameOfEncryption[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Encryption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Encryption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Endpoint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Endpoint) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfEndpoint = [2]string{
	0: "type",
	1: "url",
}

// Decode decodes Endpoint from json.
func (s *Endpoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Endpoint to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Endpoint")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEndpoint) {
					name = jsonFieldsNameOfEndpoint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Endpoint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Endpoint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityRest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityRest) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Properties.Set {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.ChildEntities != nil {
			e.FieldStart("childEntities")
			e.ArrStart()
			for _, elem := range s.ChildEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.SourceAddress.Set {
			e.FieldStart("sourceAddress")
			s.SourceAddress.Encode(e)
		}
	}
	{
		if s.Classifications != nil {
			e.FieldStart("classifications")
			e.ArrStart()
			for _, elem := range s.Classifications {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEntityRest = [8]string{
	0: "id",
	1: "type",
	2: "name",
	3: "properties",
	4: "childEntities",
	5: "description",
	6: "sourceAddress",
	7: "classifications",
}

// Decode decodes EntityRest from json.
func (s *EntityRest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityRest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "properties":
			if err := func() error {
				s.Properties.Reset()
				if err := s.Properties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "childEntities":
			if err := func() error {
				s.ChildEntities = make([]EntityRest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EntityRest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ChildEntities = append(s.ChildEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"childEntities\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "sourceAddress":
			if err := func() error {
				s.SourceAddress.Reset()
				if err := s.SourceAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceAddress\"")
			}
		case "classifications":
			if err := func() error {
				s.Classifications = make([]Classification, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Classification
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Classifications = append(s.Classifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classifications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityRest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityRest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityRest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EntityRestProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EntityRestProperties) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes EntityRestProperties from json.
func (s *EntityRestProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityRestProperties to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem EntityRestPropertiesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EntityRestProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EntityRestProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityRestProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EntityRestPropertiesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EntityRestPropertiesItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEntityRestPropertiesItem = [0]string{}

// Decode decodes EntityRestPropertiesItem from json.
func (s *EntityRestPropertiesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EntityRestPropertiesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EntityRestPropertiesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EntityRestPropertiesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EntityRestPropertiesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorType.Set {
			e.FieldStart("errorType")
			s.ErrorType.Encode(e)
		}
	}
	{
		if s.Arguments != nil {
			e.FieldStart("arguments")
			e.ArrStart()
			for _, elem := range s.Arguments {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.RemediationMessage.Set {
			e.FieldStart("remediationMessage")
			s.RemediationMessage.Encode(e)
		}
	}
	{
		if s.Causes != nil {
			e.FieldStart("causes")
			e.ArrStart()
			for _, elem := range s.Causes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NestedErrors != nil {
			e.FieldStart("nestedErrors")
			e.ArrStart()
			for _, elem := range s.NestedErrors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReferenceToken.Set {
			e.FieldStart("referenceToken")
			s.ReferenceToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [9]string{
	0: "errorCode",
	1: "errorType",
	2: "arguments",
	3: "context",
	4: "message",
	5: "remediationMessage",
	6: "causes",
	7: "nestedErrors",
	8: "referenceToken",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		case "errorType":
			if err := func() error {
				s.ErrorType.Reset()
				if err := s.ErrorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorType\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Arguments = append(s.Arguments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "remediationMessage":
			if err := func() error {
				s.RemediationMessage.Reset()
				if err := s.RemediationMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediationMessage\"")
			}
		case "causes":
			if err := func() error {
				s.Causes = make([]ErrorCause, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ErrorCause
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Causes = append(s.Causes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"causes\"")
			}
		case "nestedErrors":
			if err := func() error {
				s.NestedErrors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NestedErrors = append(s.NestedErrors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nestedErrors\"")
			}
		case "referenceToken":
			if err := func() error {
				s.ReferenceToken.Reset()
				if err := s.ReferenceToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorCause) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorCause) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorCause = [2]string{
	0: "type",
	1: "message",
}

// Decode decodes ErrorCause from json.
func (s *ErrorCause) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorCause to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorCause")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorCause) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorCause) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ErrorContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ErrorContext) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ErrorContext from json.
func (s *ErrorContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorContext to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.Arguments != nil {
			e.FieldStart("arguments")
			e.ArrStart()
			for _, elem := range s.Arguments {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.RemediationMessage.Set {
			e.FieldStart("remediationMessage")
			s.RemediationMessage.Encode(e)
		}
	}
	{
		if s.Cause != nil {
			e.FieldStart("cause")
			e.ArrStart()
			for _, elem := range s.Cause {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NestedErrors != nil {
			e.FieldStart("nestedErrors")
			e.ArrStart()
			for _, elem := range s.NestedErrors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReferenceToken.Set {
			e.FieldStart("referenceToken")
			s.ReferenceToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorResponse = [8]string{
	0: "errorCode",
	1: "arguments",
	2: "context",
	3: "message",
	4: "remediationMessage",
	5: "cause",
	6: "nestedErrors",
	7: "referenceToken",
}

// Decode decodes ErrorResponse from json.
func (s *ErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Arguments = append(s.Arguments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "remediationMessage":
			if err := func() error {
				s.RemediationMessage.Reset()
				if err := s.RemediationMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediationMessage\"")
			}
		case "cause":
			if err := func() error {
				s.Cause = make([]ErrorCause, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ErrorCause
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Cause = append(s.Cause, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cause\"")
			}
		case "nestedErrors":
			if err := func() error {
				s.NestedErrors = make([]ErrorResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ErrorResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NestedErrors = append(s.NestedErrors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nestedErrors\"")
			}
		case "referenceToken":
			if err := func() error {
				s.ReferenceToken.Reset()
				if err := s.ReferenceToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ErrorResponseContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ErrorResponseContext) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ErrorResponseContext from json.
func (s *ErrorResponseContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorResponseContext to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorResponseContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorResponseContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorResponseContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EsaConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EsaConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		if s.VsanMaxConfig.Set {
			e.FieldStart("vsanMaxConfig")
			s.VsanMaxConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfEsaConfig = [2]string{
	0: "enabled",
	1: "vsanMaxConfig",
}

// Decode decodes EsaConfig from json.
func (s *EsaConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EsaConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "vsanMaxConfig":
			if err := func() error {
				s.VsanMaxConfig.Reset()
				if err := s.VsanMaxConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanMaxConfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EsaConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEsaConfig) {
					name = jsonFieldsNameOfEsaConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EsaConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EsaConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EsxUpgradeFailureAction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EsxUpgradeFailureAction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("retryDelay")
		e.Int64(s.RetryDelay)
	}
	{
		e.FieldStart("retryCount")
		e.Int64(s.RetryCount)
	}
	{
		e.FieldStart("action")
		e.Str(s.Action)
	}
}

var jsonFieldsNameOfEsxUpgradeFailureAction = [3]string{
	0: "retryDelay",
	1: "retryCount",
	2: "action",
}

// Decode decodes EsxUpgradeFailureAction from json.
func (s *EsxUpgradeFailureAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EsxUpgradeFailureAction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "retryDelay":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.RetryDelay = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retryDelay\"")
			}
		case "retryCount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.RetryCount = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retryCount\"")
			}
		case "action":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Action = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EsxUpgradeFailureAction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEsxUpgradeFailureAction) {
					name = jsonFieldsNameOfEsxUpgradeFailureAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EsxUpgradeFailureAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EsxUpgradeFailureAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EsxUpgradeOptionsSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EsxUpgradeOptionsSpec) encodeFields(e *jx.Encoder) {
	{
		if s.EsxUpgradeFailureAction.Set {
			e.FieldStart("esxUpgradeFailureAction")
			s.EsxUpgradeFailureAction.Encode(e)
		}
	}
	{
		if s.EnforceHclValidation.Set {
			e.FieldStart("enforceHclValidation")
			s.EnforceHclValidation.Encode(e)
		}
	}
	{
		if s.EnableQuickPatch.Set {
			e.FieldStart("enableQuickPatch")
			s.EnableQuickPatch.Encode(e)
		}
	}
	{
		if s.EnableQuickboot.Set {
			e.FieldStart("enableQuickboot")
			s.EnableQuickboot.Encode(e)
		}
	}
	{
		if s.EvacuateOfflineVms.Set {
			e.FieldStart("evacuateOfflineVms")
			s.EvacuateOfflineVms.Encode(e)
		}
	}
	{
		if s.DisableHac.Set {
			e.FieldStart("disableHac")
			s.DisableHac.Encode(e)
		}
	}
	{
		if s.DisableDpm.Set {
			e.FieldStart("disableDpm")
			s.DisableDpm.Encode(e)
		}
	}
	{
		if s.PreRemediationPowerAction.Set {
			e.FieldStart("preRemediationPowerAction")
			s.PreRemediationPowerAction.Encode(e)
		}
	}
}

var jsonFieldsNameOfEsxUpgradeOptionsSpec = [8]string{
	0: "esxUpgradeFailureAction",
	1: "enforceHclValidation",
	2: "enableQuickPatch",
	3: "enableQuickboot",
	4: "evacuateOfflineVms",
	5: "disableHac",
	6: "disableDpm",
	7: "preRemediationPowerAction",
}

// Decode decodes EsxUpgradeOptionsSpec from json.
func (s *EsxUpgradeOptionsSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EsxUpgradeOptionsSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "esxUpgradeFailureAction":
			if err := func() error {
				s.EsxUpgradeFailureAction.Reset()
				if err := s.EsxUpgradeFailureAction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"esxUpgradeFailureAction\"")
			}
		case "enforceHclValidation":
			if err := func() error {
				s.EnforceHclValidation.Reset()
				if err := s.EnforceHclValidation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforceHclValidation\"")
			}
		case "enableQuickPatch":
			if err := func() error {
				s.EnableQuickPatch.Reset()
				if err := s.EnableQuickPatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enableQuickPatch\"")
			}
		case "enableQuickboot":
			if err := func() error {
				s.EnableQuickboot.Reset()
				if err := s.EnableQuickboot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enableQuickboot\"")
			}
		case "evacuateOfflineVms":
			if err := func() error {
				s.EvacuateOfflineVms.Reset()
				if err := s.EvacuateOfflineVms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evacuateOfflineVms\"")
			}
		case "disableHac":
			if err := func() error {
				s.DisableHac.Reset()
				if err := s.DisableHac.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disableHac\"")
			}
		case "disableDpm":
			if err := func() error {
				s.DisableDpm.Reset()
				if err := s.DisableDpm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disableDpm\"")
			}
		case "preRemediationPowerAction":
			if err := func() error {
				s.PreRemediationPowerAction.Reset()
				if err := s.PreRemediationPowerAction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preRemediationPowerAction\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EsxUpgradeOptionsSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EsxUpgradeOptionsSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EsxUpgradeOptionsSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExpirationDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExpirationDetails) encodeFields(e *jx.Encoder) {
	{
		if s.ExpiryDate.Set {
			e.FieldStart("expiryDate")
			s.ExpiryDate.Encode(e)
		}
	}
	{
		if s.LastCheckedDate.Set {
			e.FieldStart("lastCheckedDate")
			s.LastCheckedDate.Encode(e)
		}
	}
	{
		if s.ConnectivityStatus.Set {
			e.FieldStart("connectivityStatus")
			s.ConnectivityStatus.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfExpirationDetails = [4]string{
	0: "expiryDate",
	1: "lastCheckedDate",
	2: "connectivityStatus",
	3: "status",
}

// Decode decodes ExpirationDetails from json.
func (s *ExpirationDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExpirationDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expiryDate":
			if err := func() error {
				s.ExpiryDate.Reset()
				if err := s.ExpiryDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiryDate\"")
			}
		case "lastCheckedDate":
			if err := func() error {
				s.LastCheckedDate.Reset()
				if err := s.LastCheckedDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastCheckedDate\"")
			}
		case "connectivityStatus":
			if err := func() error {
				s.ConnectivityStatus.Reset()
				if err := s.ConnectivityStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectivityStatus\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExpirationDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExpirationDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExpirationDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExportBringupDetailReportNoContentApplicationJSON as json.
func (s ExportBringupDetailReportNoContentApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ExportBringupDetailReportNoContentApplicationJSON from json.
func (s *ExportBringupDetailReportNoContentApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExportBringupDetailReportNoContentApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExportBringupDetailReportNoContentApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExportBringupDetailReportNoContentApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExportBringupDetailReportNoContentApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExportBringupDetailReportOKApplicationJSON as json.
func (s ExportBringupDetailReportOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ExportBringupDetailReportOKApplicationJSON from json.
func (s *ExportBringupDetailReportOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExportBringupDetailReportOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExportBringupDetailReportOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExportBringupDetailReportOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExportBringupDetailReportOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExportBringupValidationReportOKApplicationJSON as json.
func (s ExportBringupValidationReportOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ExportBringupValidationReportOKApplicationJSON from json.
func (s *ExportBringupValidationReportOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExportBringupValidationReportOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExportBringupValidationReportOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExportBringupValidationReportOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExportBringupValidationReportOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FcSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FcSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("datastoreName")
		e.Str(s.DatastoreName)
	}
}

var jsonFieldsNameOfFcSpec = [1]string{
	0: "datastoreName",
}

// Decode decodes FcSpec from json.
func (s *FcSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FcSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "datastoreName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatastoreName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datastoreName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FcSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFcSpec) {
					name = jsonFieldsNameOfFcSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FcSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FcSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FederatedIdentityProviderInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FederatedIdentityProviderInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.DirectoryList.Set {
			e.FieldStart("directoryList")
			s.DirectoryList.Encode(e)
		}
	}
	{
		if s.OidcInfo.Set {
			e.FieldStart("oidcInfo")
			s.OidcInfo.Encode(e)
		}
	}
	{
		if s.SyncClientTokenTTL.Set {
			e.FieldStart("syncClientTokenTTL")
			s.SyncClientTokenTTL.Encode(e)
		}
	}
	{
		if s.SyncClientTokenInfo.Set {
			e.FieldStart("syncClientTokenInfo")
			s.SyncClientTokenInfo.Encode(e)
		}
	}
}

var jsonFieldsNameOfFederatedIdentityProviderInfo = [6]string{
	0: "name",
	1: "source",
	2: "directoryList",
	3: "oidcInfo",
	4: "syncClientTokenTTL",
	5: "syncClientTokenInfo",
}

// Decode decodes FederatedIdentityProviderInfo from json.
func (s *FederatedIdentityProviderInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FederatedIdentityProviderInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "directoryList":
			if err := func() error {
				s.DirectoryList.Reset()
				if err := s.DirectoryList.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"directoryList\"")
			}
		case "oidcInfo":
			if err := func() error {
				s.OidcInfo.Reset()
				if err := s.OidcInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidcInfo\"")
			}
		case "syncClientTokenTTL":
			if err := func() error {
				s.SyncClientTokenTTL.Reset()
				if err := s.SyncClientTokenTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"syncClientTokenTTL\"")
			}
		case "syncClientTokenInfo":
			if err := func() error {
				s.SyncClientTokenInfo.Reset()
				if err := s.SyncClientTokenInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"syncClientTokenInfo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FederatedIdentityProviderInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FederatedIdentityProviderInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FederatedIdentityProviderInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Fips) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Fips) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfFips = [1]string{
	0: "enabled",
}

// Decode decodes Fips from json.
func (s *Fips) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Fips to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Fips")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFips) {
					name = jsonFieldsNameOfFips[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Fips) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Fips) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FlexibleProductPatch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FlexibleProductPatch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("productType")
		e.Str(s.ProductType)
	}
	{
		e.FieldStart("versions")
		e.ArrStart()
		for _, elem := range s.Versions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfFlexibleProductPatch = [2]string{
	0: "productType",
	1: "versions",
}

// Decode decodes FlexibleProductPatch from json.
func (s *FlexibleProductPatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FlexibleProductPatch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "productType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ProductType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productType\"")
			}
		case "versions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Versions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FlexibleProductPatch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFlexibleProductPatch) {
					name = jsonFieldsNameOfFlexibleProductPatch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FlexibleProductPatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FlexibleProductPatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FlexibleProductPatches) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FlexibleProductPatches) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("patches")
		e.ArrStart()
		for _, elem := range s.Patches {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfFlexibleProductPatches = [2]string{
	0: "version",
	1: "patches",
}

// Decode decodes FlexibleProductPatches from json.
func (s *FlexibleProductPatches) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FlexibleProductPatches to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "patches":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Patches = make([]FlexibleProductPatch, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FlexibleProductPatch
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Patches = append(s.Patches, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FlexibleProductPatches")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFlexibleProductPatches) {
					name = jsonFieldsNameOfFlexibleProductPatches[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FlexibleProductPatches) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FlexibleProductPatches) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FrequencyMetric) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FrequencyMetric) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Unit.Set {
			e.FieldStart("unit")
			s.Unit.Encode(e)
		}
	}
}

var jsonFieldsNameOfFrequencyMetric = [2]string{
	0: "value",
	1: "unit",
}

// Decode decodes FrequencyMetric from json.
func (s *FrequencyMetric) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FrequencyMetric to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "unit":
			if err := func() error {
				s.Unit.Reset()
				if err := s.Unit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FrequencyMetric")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FrequencyMetric) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FrequencyMetric) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FrequencyMetricUnit as json.
func (s FrequencyMetricUnit) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FrequencyMetricUnit from json.
func (s *FrequencyMetricUnit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FrequencyMetricUnit to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FrequencyMetricUnit(v) {
	case FrequencyMetricUnitHz:
		*s = FrequencyMetricUnitHz
	case FrequencyMetricUnitKHz:
		*s = FrequencyMetricUnitKHz
	case FrequencyMetricUnitMHz:
		*s = FrequencyMetricUnitMHz
	case FrequencyMetricUnitGHz:
		*s = FrequencyMetricUnitGHz
	case FrequencyMetricUnitTHz:
		*s = FrequencyMetricUnitTHz
	default:
		*s = FrequencyMetricUnit(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FrequencyMetricUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FrequencyMetricUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Functionality) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Functionality) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("isAllowed")
		e.Bool(s.IsAllowed)
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("errorMessage")
			s.ErrorMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfFunctionality = [3]string{
	0: "type",
	1: "isAllowed",
	2: "errorMessage",
}

// Decode decodes Functionality from json.
func (s *Functionality) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Functionality to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "isAllowed":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAllowed\"")
			}
		case "errorMessage":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorMessage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Functionality")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFunctionality) {
					name = jsonFieldsNameOfFunctionality[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Functionality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Functionality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateCertificatesBadRequest as json.
func (s *GenerateCertificatesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GenerateCertificatesBadRequest from json.
func (s *GenerateCertificatesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateCertificatesBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GenerateCertificatesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateCertificatesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateCertificatesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateCertificatesConflict as json.
func (s *GenerateCertificatesConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GenerateCertificatesConflict from json.
func (s *GenerateCertificatesConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateCertificatesConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GenerateCertificatesConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateCertificatesConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateCertificatesConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateCertificatesInternalServerError as json.
func (s *GenerateCertificatesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GenerateCertificatesInternalServerError from json.
func (s *GenerateCertificatesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateCertificatesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GenerateCertificatesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateCertificatesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateCertificatesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateCertificatesNotFound as json.
func (s *GenerateCertificatesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GenerateCertificatesNotFound from json.
func (s *GenerateCertificatesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateCertificatesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GenerateCertificatesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateCertificatesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateCertificatesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateSyncClientTokenInternalServerError as json.
func (s *GenerateSyncClientTokenInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GenerateSyncClientTokenInternalServerError from json.
func (s *GenerateSyncClientTokenInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateSyncClientTokenInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GenerateSyncClientTokenInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateSyncClientTokenInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateSyncClientTokenInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateSyncClientTokenNotFound as json.
func (s *GenerateSyncClientTokenNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GenerateSyncClientTokenNotFound from json.
func (s *GenerateSyncClientTokenNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateSyncClientTokenNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GenerateSyncClientTokenNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateSyncClientTokenNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateSyncClientTokenNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GenerateSyncClientTokenUnauthorized as json.
func (s *GenerateSyncClientTokenUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GenerateSyncClientTokenUnauthorized from json.
func (s *GenerateSyncClientTokenUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateSyncClientTokenUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GenerateSyncClientTokenUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateSyncClientTokenUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateSyncClientTokenUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GeneratesCSRsBadRequest as json.
func (s *GeneratesCSRsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GeneratesCSRsBadRequest from json.
func (s *GeneratesCSRsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneratesCSRsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GeneratesCSRsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeneratesCSRsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneratesCSRsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GeneratesCSRsConflict as json.
func (s *GeneratesCSRsConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GeneratesCSRsConflict from json.
func (s *GeneratesCSRsConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneratesCSRsConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GeneratesCSRsConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeneratesCSRsConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneratesCSRsConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GeneratesCSRsInternalServerError as json.
func (s *GeneratesCSRsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GeneratesCSRsInternalServerError from json.
func (s *GeneratesCSRsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneratesCSRsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GeneratesCSRsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeneratesCSRsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneratesCSRsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GeneratesCSRsNotFound as json.
func (s *GeneratesCSRsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GeneratesCSRsNotFound from json.
func (s *GeneratesCSRsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeneratesCSRsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GeneratesCSRsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeneratesCSRsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeneratesCSRsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetALBClusterInternalServerError as json.
func (s *GetALBClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetALBClusterInternalServerError from json.
func (s *GetALBClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetALBClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetALBClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetALBClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetALBClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetALBClusterNotFound as json.
func (s *GetALBClusterNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetALBClusterNotFound from json.
func (s *GetALBClusterNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetALBClusterNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetALBClusterNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetALBClusterNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetALBClusterNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetALBClustersBadRequest as json.
func (s *GetALBClustersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetALBClustersBadRequest from json.
func (s *GetALBClustersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetALBClustersBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetALBClustersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetALBClustersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetALBClustersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetALBClustersInternalServerError as json.
func (s *GetALBClustersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetALBClustersInternalServerError from json.
func (s *GetALBClustersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetALBClustersInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetALBClustersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetALBClustersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetALBClustersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAssignableTagForHostBadRequest as json.
func (s *GetAssignableTagForHostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetAssignableTagForHostBadRequest from json.
func (s *GetAssignableTagForHostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAssignableTagForHostBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAssignableTagForHostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAssignableTagForHostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAssignableTagForHostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAssignableTagForHostInternalServerError as json.
func (s *GetAssignableTagForHostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetAssignableTagForHostInternalServerError from json.
func (s *GetAssignableTagForHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAssignableTagForHostInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAssignableTagForHostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAssignableTagForHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAssignableTagForHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAssignableTagsForDomainBadRequest as json.
func (s *GetAssignableTagsForDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetAssignableTagsForDomainBadRequest from json.
func (s *GetAssignableTagsForDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAssignableTagsForDomainBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAssignableTagsForDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAssignableTagsForDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAssignableTagsForDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAssignableTagsForDomainInternalServerError as json.
func (s *GetAssignableTagsForDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetAssignableTagsForDomainInternalServerError from json.
func (s *GetAssignableTagsForDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAssignableTagsForDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAssignableTagsForDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAssignableTagsForDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAssignableTagsForDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAvnsOKApplicationJSON as json.
func (s GetAvnsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Avn(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetAvnsOKApplicationJSON from json.
func (s *GetAvnsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAvnsOKApplicationJSON to nil")
	}
	var unwrapped []Avn
	if err := func() error {
		unwrapped = make([]Avn, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Avn
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAvnsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAvnsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAvnsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBackupConfigurationBadRequest as json.
func (s *GetBackupConfigurationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBackupConfigurationBadRequest from json.
func (s *GetBackupConfigurationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBackupConfigurationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBackupConfigurationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBackupConfigurationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBackupConfigurationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBackupConfigurationInternalServerError as json.
func (s *GetBackupConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBackupConfigurationInternalServerError from json.
func (s *GetBackupConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBackupConfigurationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBackupConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBackupConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBackupConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBackupLocationBadRequest as json.
func (s *GetBackupLocationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBackupLocationBadRequest from json.
func (s *GetBackupLocationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBackupLocationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBackupLocationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBackupLocationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBackupLocationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBackupLocationInternalServerError as json.
func (s *GetBackupLocationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBackupLocationInternalServerError from json.
func (s *GetBackupLocationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBackupLocationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBackupLocationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBackupLocationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBackupLocationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupAppInfoInternalServerError as json.
func (s *GetBringupAppInfoInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*VcfService)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupAppInfoInternalServerError from json.
func (s *GetBringupAppInfoInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupAppInfoInternalServerError to nil")
	}
	var unwrapped VcfService
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupAppInfoInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupAppInfoInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupAppInfoInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupAppInfoNotFound as json.
func (s *GetBringupAppInfoNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*VcfService)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupAppInfoNotFound from json.
func (s *GetBringupAppInfoNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupAppInfoNotFound to nil")
	}
	var unwrapped VcfService
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupAppInfoNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupAppInfoNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupAppInfoNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupAppInfoNotImplemented as json.
func (s *GetBringupAppInfoNotImplemented) Encode(e *jx.Encoder) {
	unwrapped := (*VcfService)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupAppInfoNotImplemented from json.
func (s *GetBringupAppInfoNotImplemented) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupAppInfoNotImplemented to nil")
	}
	var unwrapped VcfService
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupAppInfoNotImplemented(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupAppInfoNotImplemented) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupAppInfoNotImplemented) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupAppInfoOK as json.
func (s *GetBringupAppInfoOK) Encode(e *jx.Encoder) {
	unwrapped := (*VcfService)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupAppInfoOK from json.
func (s *GetBringupAppInfoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupAppInfoOK to nil")
	}
	var unwrapped VcfService
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupAppInfoOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupAppInfoOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupAppInfoOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupTaskByIDBadRequest as json.
func (s *GetBringupTaskByIDBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupTaskByIDBadRequest from json.
func (s *GetBringupTaskByIDBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupTaskByIDBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupTaskByIDBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupTaskByIDBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupTaskByIDBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupTaskByIDInternalServerError as json.
func (s *GetBringupTaskByIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupTaskByIDInternalServerError from json.
func (s *GetBringupTaskByIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupTaskByIDInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupTaskByIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupTaskByIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupTaskByIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupTaskByIDNotFound as json.
func (s *GetBringupTaskByIDNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupTaskByIDNotFound from json.
func (s *GetBringupTaskByIDNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupTaskByIDNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupTaskByIDNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupTaskByIDNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupTaskByIDNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupValidationBadRequest as json.
func (s *GetBringupValidationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupValidationBadRequest from json.
func (s *GetBringupValidationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupValidationBadRequest to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupValidationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupValidationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupValidationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupValidationInternalServerError as json.
func (s *GetBringupValidationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupValidationInternalServerError from json.
func (s *GetBringupValidationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupValidationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupValidationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupValidationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupValidationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupValidationNotFound as json.
func (s *GetBringupValidationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupValidationNotFound from json.
func (s *GetBringupValidationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupValidationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupValidationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupValidationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupValidationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupValidationNotImplemented as json.
func (s *GetBringupValidationNotImplemented) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupValidationNotImplemented from json.
func (s *GetBringupValidationNotImplemented) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupValidationNotImplemented to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupValidationNotImplemented(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupValidationNotImplemented) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupValidationNotImplemented) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupValidationOK as json.
func (s *GetBringupValidationOK) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupValidationOK from json.
func (s *GetBringupValidationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupValidationOK to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupValidationOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupValidationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupValidationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupValidationsInternalServerError as json.
func (s *GetBringupValidationsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupValidationsInternalServerError from json.
func (s *GetBringupValidationsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupValidationsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupValidationsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupValidationsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupValidationsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupValidationsNotFound as json.
func (s *GetBringupValidationsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupValidationsNotFound from json.
func (s *GetBringupValidationsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupValidationsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupValidationsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupValidationsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupValidationsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBringupValidationsNotImplemented as json.
func (s *GetBringupValidationsNotImplemented) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBringupValidationsNotImplemented from json.
func (s *GetBringupValidationsNotImplemented) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBringupValidationsNotImplemented to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBringupValidationsNotImplemented(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBringupValidationsNotImplemented) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBringupValidationsNotImplemented) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBundleInternalServerError as json.
func (s *GetBundleInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBundleInternalServerError from json.
func (s *GetBundleInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBundleInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBundleInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBundleInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBundleInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBundleNotFound as json.
func (s *GetBundleNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBundleNotFound from json.
func (s *GetBundleNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBundleNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBundleNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBundleNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBundleNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBundlesForSkipUpgradeInternalServerError as json.
func (s *GetBundlesForSkipUpgradeInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBundlesForSkipUpgradeInternalServerError from json.
func (s *GetBundlesForSkipUpgradeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBundlesForSkipUpgradeInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBundlesForSkipUpgradeInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBundlesForSkipUpgradeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBundlesForSkipUpgradeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBundlesForSkipUpgradeNotFound as json.
func (s *GetBundlesForSkipUpgradeNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBundlesForSkipUpgradeNotFound from json.
func (s *GetBundlesForSkipUpgradeNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBundlesForSkipUpgradeNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBundlesForSkipUpgradeNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBundlesForSkipUpgradeNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBundlesForSkipUpgradeNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCSRsInternalServerError as json.
func (s *GetCSRsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCSRsInternalServerError from json.
func (s *GetCSRsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCSRsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCSRsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCSRsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCSRsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCSRsNotFound as json.
func (s *GetCSRsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCSRsNotFound from json.
func (s *GetCSRsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCSRsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCSRsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCSRsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCSRsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCertificateAuthorityByIdInternalServerError as json.
func (s *GetCertificateAuthorityByIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCertificateAuthorityByIdInternalServerError from json.
func (s *GetCertificateAuthorityByIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCertificateAuthorityByIdInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCertificateAuthorityByIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCertificateAuthorityByIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCertificateAuthorityByIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCertificateAuthorityByIdNotFound as json.
func (s *GetCertificateAuthorityByIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCertificateAuthorityByIdNotFound from json.
func (s *GetCertificateAuthorityByIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCertificateAuthorityByIdNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCertificateAuthorityByIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCertificateAuthorityByIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCertificateAuthorityByIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCertificatesByDomainInternalServerError as json.
func (s *GetCertificatesByDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCertificatesByDomainInternalServerError from json.
func (s *GetCertificatesByDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCertificatesByDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCertificatesByDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCertificatesByDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCertificatesByDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCertificatesByDomainNotFound as json.
func (s *GetCertificatesByDomainNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCertificatesByDomainNotFound from json.
func (s *GetCertificatesByDomainNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCertificatesByDomainNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCertificatesByDomainNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCertificatesByDomainNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCertificatesByDomainNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterCreateValidationBadRequest as json.
func (s *GetClusterCreateValidationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterCreateValidationBadRequest from json.
func (s *GetClusterCreateValidationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterCreateValidationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterCreateValidationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterCreateValidationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterCreateValidationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterCreateValidationNotFound as json.
func (s *GetClusterCreateValidationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterCreateValidationNotFound from json.
func (s *GetClusterCreateValidationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterCreateValidationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterCreateValidationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterCreateValidationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterCreateValidationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterDatastoresBadRequest as json.
func (s *GetClusterDatastoresBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterDatastoresBadRequest from json.
func (s *GetClusterDatastoresBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterDatastoresBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterDatastoresBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterDatastoresBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterDatastoresBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterDatastoresInternalServerError as json.
func (s *GetClusterDatastoresInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterDatastoresInternalServerError from json.
func (s *GetClusterDatastoresInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterDatastoresInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterDatastoresInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterDatastoresInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterDatastoresInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterDatastoresNotFound as json.
func (s *GetClusterDatastoresNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterDatastoresNotFound from json.
func (s *GetClusterDatastoresNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterDatastoresNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterDatastoresNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterDatastoresNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterDatastoresNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterDatastoresOKApplicationJSON as json.
func (s GetClusterDatastoresOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Datastore(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetClusterDatastoresOKApplicationJSON from json.
func (s *GetClusterDatastoresOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterDatastoresOKApplicationJSON to nil")
	}
	var unwrapped []Datastore
	if err := func() error {
		unwrapped = make([]Datastore, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Datastore
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterDatastoresOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetClusterDatastoresOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterDatastoresOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterInternalServerError as json.
func (s *GetClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterInternalServerError from json.
func (s *GetClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterNetworkConfigurationBadRequest as json.
func (s *GetClusterNetworkConfigurationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterNetworkConfigurationBadRequest from json.
func (s *GetClusterNetworkConfigurationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterNetworkConfigurationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterNetworkConfigurationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterNetworkConfigurationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterNetworkConfigurationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterNetworkConfigurationInternalServerError as json.
func (s *GetClusterNetworkConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterNetworkConfigurationInternalServerError from json.
func (s *GetClusterNetworkConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterNetworkConfigurationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterNetworkConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterNetworkConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterNetworkConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterNetworkConfigurationQueryResponseBadRequest as json.
func (s *GetClusterNetworkConfigurationQueryResponseBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterNetworkConfigurationQueryResponseBadRequest from json.
func (s *GetClusterNetworkConfigurationQueryResponseBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterNetworkConfigurationQueryResponseBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterNetworkConfigurationQueryResponseBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterNetworkConfigurationQueryResponseBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterNetworkConfigurationQueryResponseBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterNetworkConfigurationQueryResponseInternalServerError as json.
func (s *GetClusterNetworkConfigurationQueryResponseInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterNetworkConfigurationQueryResponseInternalServerError from json.
func (s *GetClusterNetworkConfigurationQueryResponseInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterNetworkConfigurationQueryResponseInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterNetworkConfigurationQueryResponseInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterNetworkConfigurationQueryResponseInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterNetworkConfigurationQueryResponseInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterNotFound as json.
func (s *GetClusterNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterNotFound from json.
func (s *GetClusterNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterQueryResponseBadRequest as json.
func (s *GetClusterQueryResponseBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterQueryResponseBadRequest from json.
func (s *GetClusterQueryResponseBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterQueryResponseBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterQueryResponseBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterQueryResponseBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterQueryResponseBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterQueryResponseInternalServerError as json.
func (s *GetClusterQueryResponseInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterQueryResponseInternalServerError from json.
func (s *GetClusterQueryResponseInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterQueryResponseInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterQueryResponseInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterQueryResponseInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterQueryResponseInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterQueryResponseNotFound as json.
func (s *GetClusterQueryResponseNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterQueryResponseNotFound from json.
func (s *GetClusterQueryResponseNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterQueryResponseNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterQueryResponseNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterQueryResponseNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterQueryResponseNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterTagManagerUrlBadRequest as json.
func (s *GetClusterTagManagerUrlBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterTagManagerUrlBadRequest from json.
func (s *GetClusterTagManagerUrlBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterTagManagerUrlBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterTagManagerUrlBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterTagManagerUrlBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterTagManagerUrlBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterTagManagerUrlInternalServerError as json.
func (s *GetClusterTagManagerUrlInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterTagManagerUrlInternalServerError from json.
func (s *GetClusterTagManagerUrlInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterTagManagerUrlInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterTagManagerUrlInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterTagManagerUrlInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterTagManagerUrlInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterUpdateValidationBadRequest as json.
func (s *GetClusterUpdateValidationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterUpdateValidationBadRequest from json.
func (s *GetClusterUpdateValidationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterUpdateValidationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterUpdateValidationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterUpdateValidationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterUpdateValidationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClusterUpdateValidationNotFound as json.
func (s *GetClusterUpdateValidationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClusterUpdateValidationNotFound from json.
func (s *GetClusterUpdateValidationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClusterUpdateValidationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClusterUpdateValidationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClusterUpdateValidationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClusterUpdateValidationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClustersBadRequest as json.
func (s *GetClustersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClustersBadRequest from json.
func (s *GetClustersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClustersBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClustersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClustersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClustersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClustersInternalServerError as json.
func (s *GetClustersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClustersInternalServerError from json.
func (s *GetClustersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClustersInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClustersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClustersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClustersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClustersQueryResponseBadRequest as json.
func (s *GetClustersQueryResponseBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClustersQueryResponseBadRequest from json.
func (s *GetClustersQueryResponseBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClustersQueryResponseBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClustersQueryResponseBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClustersQueryResponseBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClustersQueryResponseBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClustersQueryResponseInternalServerError as json.
func (s *GetClustersQueryResponseInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClustersQueryResponseInternalServerError from json.
func (s *GetClustersQueryResponseInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClustersQueryResponseInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClustersQueryResponseInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClustersQueryResponseInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClustersQueryResponseInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClustersQueryResponseNotFound as json.
func (s *GetClustersQueryResponseNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClustersQueryResponseNotFound from json.
func (s *GetClustersQueryResponseNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClustersQueryResponseNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClustersQueryResponseNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClustersQueryResponseNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClustersQueryResponseNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCompatibilityMatricesInternalServerError as json.
func (s *GetCompatibilityMatricesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCompatibilityMatricesInternalServerError from json.
func (s *GetCompatibilityMatricesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCompatibilityMatricesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCompatibilityMatricesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCompatibilityMatricesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCompatibilityMatricesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCompatibilityMatricesNotFound as json.
func (s *GetCompatibilityMatricesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCompatibilityMatricesNotFound from json.
func (s *GetCompatibilityMatricesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCompatibilityMatricesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCompatibilityMatricesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCompatibilityMatricesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCompatibilityMatricesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCompatibilityMatrixContentInternalServerError as json.
func (s *GetCompatibilityMatrixContentInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCompatibilityMatrixContentInternalServerError from json.
func (s *GetCompatibilityMatrixContentInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCompatibilityMatrixContentInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCompatibilityMatrixContentInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCompatibilityMatrixContentInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCompatibilityMatrixContentInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCompatibilityMatrixContentNotFound as json.
func (s *GetCompatibilityMatrixContentNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCompatibilityMatrixContentNotFound from json.
func (s *GetCompatibilityMatrixContentNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCompatibilityMatrixContentNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCompatibilityMatrixContentNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCompatibilityMatrixContentNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCompatibilityMatrixContentNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCompatibilityMatrixContentOKApplicationJSON as json.
func (s GetCompatibilityMatrixContentOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes GetCompatibilityMatrixContentOKApplicationJSON from json.
func (s *GetCompatibilityMatrixContentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCompatibilityMatrixContentOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCompatibilityMatrixContentOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetCompatibilityMatrixContentOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCompatibilityMatrixContentOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCompatibilityMatrixInternalServerError as json.
func (s *GetCompatibilityMatrixInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCompatibilityMatrixInternalServerError from json.
func (s *GetCompatibilityMatrixInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCompatibilityMatrixInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCompatibilityMatrixInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCompatibilityMatrixInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCompatibilityMatrixInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCompatibilityMatrixMetadataInternalServerError as json.
func (s *GetCompatibilityMatrixMetadataInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCompatibilityMatrixMetadataInternalServerError from json.
func (s *GetCompatibilityMatrixMetadataInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCompatibilityMatrixMetadataInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCompatibilityMatrixMetadataInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCompatibilityMatrixMetadataInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCompatibilityMatrixMetadataInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCompatibilityMatrixMetadataNotFound as json.
func (s *GetCompatibilityMatrixMetadataNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCompatibilityMatrixMetadataNotFound from json.
func (s *GetCompatibilityMatrixMetadataNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCompatibilityMatrixMetadataNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCompatibilityMatrixMetadataNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCompatibilityMatrixMetadataNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCompatibilityMatrixMetadataNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCompatibilityMatrixNotFound as json.
func (s *GetCompatibilityMatrixNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCompatibilityMatrixNotFound from json.
func (s *GetCompatibilityMatrixNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCompatibilityMatrixNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCompatibilityMatrixNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCompatibilityMatrixNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCompatibilityMatrixNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditForADomainInternalServerError as json.
func (s *GetComplianceAuditForADomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditForADomainInternalServerError from json.
func (s *GetComplianceAuditForADomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditForADomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditForADomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditForADomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditForADomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditForADomainNotFound as json.
func (s *GetComplianceAuditForADomainNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditForADomainNotFound from json.
func (s *GetComplianceAuditForADomainNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditForADomainNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditForADomainNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditForADomainNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditForADomainNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditForADomainUnauthorized as json.
func (s *GetComplianceAuditForADomainUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditForADomainUnauthorized from json.
func (s *GetComplianceAuditForADomainUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditForADomainUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditForADomainUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditForADomainUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditForADomainUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditHistoryForADomainInternalServerError as json.
func (s *GetComplianceAuditHistoryForADomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditHistoryForADomainInternalServerError from json.
func (s *GetComplianceAuditHistoryForADomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditHistoryForADomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditHistoryForADomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditHistoryForADomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditHistoryForADomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditHistoryForADomainNotFound as json.
func (s *GetComplianceAuditHistoryForADomainNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditHistoryForADomainNotFound from json.
func (s *GetComplianceAuditHistoryForADomainNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditHistoryForADomainNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditHistoryForADomainNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditHistoryForADomainNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditHistoryForADomainNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditHistoryForADomainUnauthorized as json.
func (s *GetComplianceAuditHistoryForADomainUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditHistoryForADomainUnauthorized from json.
func (s *GetComplianceAuditHistoryForADomainUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditHistoryForADomainUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditHistoryForADomainUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditHistoryForADomainUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditHistoryForADomainUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditHistoryInternalServerError as json.
func (s *GetComplianceAuditHistoryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditHistoryInternalServerError from json.
func (s *GetComplianceAuditHistoryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditHistoryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditHistoryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditHistoryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditHistoryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditHistoryNotFound as json.
func (s *GetComplianceAuditHistoryNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditHistoryNotFound from json.
func (s *GetComplianceAuditHistoryNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditHistoryNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditHistoryNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditHistoryNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditHistoryNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditHistoryUnauthorized as json.
func (s *GetComplianceAuditHistoryUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditHistoryUnauthorized from json.
func (s *GetComplianceAuditHistoryUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditHistoryUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditHistoryUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditHistoryUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditHistoryUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditInternalServerError as json.
func (s *GetComplianceAuditInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditInternalServerError from json.
func (s *GetComplianceAuditInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditItemsForADomainInternalServerError as json.
func (s *GetComplianceAuditItemsForADomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditItemsForADomainInternalServerError from json.
func (s *GetComplianceAuditItemsForADomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditItemsForADomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditItemsForADomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditItemsForADomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditItemsForADomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditItemsForADomainNotFound as json.
func (s *GetComplianceAuditItemsForADomainNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditItemsForADomainNotFound from json.
func (s *GetComplianceAuditItemsForADomainNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditItemsForADomainNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditItemsForADomainNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditItemsForADomainNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditItemsForADomainNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditItemsForADomainUnauthorized as json.
func (s *GetComplianceAuditItemsForADomainUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditItemsForADomainUnauthorized from json.
func (s *GetComplianceAuditItemsForADomainUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditItemsForADomainUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditItemsForADomainUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditItemsForADomainUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditItemsForADomainUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditItemsInternalServerError as json.
func (s *GetComplianceAuditItemsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditItemsInternalServerError from json.
func (s *GetComplianceAuditItemsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditItemsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditItemsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditItemsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditItemsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditItemsNotFound as json.
func (s *GetComplianceAuditItemsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditItemsNotFound from json.
func (s *GetComplianceAuditItemsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditItemsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditItemsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditItemsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditItemsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditItemsUnauthorized as json.
func (s *GetComplianceAuditItemsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditItemsUnauthorized from json.
func (s *GetComplianceAuditItemsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditItemsUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditItemsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditItemsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditItemsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditNotFound as json.
func (s *GetComplianceAuditNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditNotFound from json.
func (s *GetComplianceAuditNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditTaskInternalServerError as json.
func (s *GetComplianceAuditTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditTaskInternalServerError from json.
func (s *GetComplianceAuditTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditTaskNotFound as json.
func (s *GetComplianceAuditTaskNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditTaskNotFound from json.
func (s *GetComplianceAuditTaskNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditTaskNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditTaskNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditTaskNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditTaskNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditTaskUnauthorized as json.
func (s *GetComplianceAuditTaskUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditTaskUnauthorized from json.
func (s *GetComplianceAuditTaskUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditTaskUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditTaskUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditTaskUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditTaskUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceAuditUnauthorized as json.
func (s *GetComplianceAuditUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceAuditUnauthorized from json.
func (s *GetComplianceAuditUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceAuditUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceAuditUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceAuditUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceAuditUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceConfigurationsBadRequest as json.
func (s *GetComplianceConfigurationsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceConfigurationsBadRequest from json.
func (s *GetComplianceConfigurationsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceConfigurationsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceConfigurationsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceConfigurationsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceConfigurationsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceConfigurationsInternalServerError as json.
func (s *GetComplianceConfigurationsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceConfigurationsInternalServerError from json.
func (s *GetComplianceConfigurationsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceConfigurationsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceConfigurationsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceConfigurationsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceConfigurationsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceConfigurationsUnauthorized as json.
func (s *GetComplianceConfigurationsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceConfigurationsUnauthorized from json.
func (s *GetComplianceConfigurationsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceConfigurationsUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceConfigurationsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceConfigurationsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceConfigurationsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceStandardsInternalServerError as json.
func (s *GetComplianceStandardsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceStandardsInternalServerError from json.
func (s *GetComplianceStandardsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceStandardsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceStandardsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceStandardsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceStandardsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetComplianceStandardsUnauthorized as json.
func (s *GetComplianceStandardsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetComplianceStandardsUnauthorized from json.
func (s *GetComplianceStandardsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetComplianceStandardsUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetComplianceStandardsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetComplianceStandardsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetComplianceStandardsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetConfigsInternalServerError as json.
func (s *GetConfigsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetConfigsInternalServerError from json.
func (s *GetConfigsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetConfigsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetConfigsServiceUnavailable as json.
func (s *GetConfigsServiceUnavailable) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetConfigsServiceUnavailable from json.
func (s *GetConfigsServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigsServiceUnavailable to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetConfigsServiceUnavailable(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigsServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigsServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialBadRequest as json.
func (s *GetCredentialBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialBadRequest from json.
func (s *GetCredentialBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialForbidden as json.
func (s *GetCredentialForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialForbidden from json.
func (s *GetCredentialForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialInternalServerError as json.
func (s *GetCredentialInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialInternalServerError from json.
func (s *GetCredentialInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialNotFound as json.
func (s *GetCredentialNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialNotFound from json.
func (s *GetCredentialNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialTaskByResourceIDBadRequest as json.
func (s *GetCredentialTaskByResourceIDBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialTaskByResourceIDBadRequest from json.
func (s *GetCredentialTaskByResourceIDBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialTaskByResourceIDBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialTaskByResourceIDBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialTaskByResourceIDBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialTaskByResourceIDBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialTaskByResourceIDInternalServerError as json.
func (s *GetCredentialTaskByResourceIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialTaskByResourceIDInternalServerError from json.
func (s *GetCredentialTaskByResourceIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialTaskByResourceIDInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialTaskByResourceIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialTaskByResourceIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialTaskByResourceIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialTaskByResourceIDOKApplicationJSON as json.
func (s GetCredentialTaskByResourceIDOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ResourceCredentials(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetCredentialTaskByResourceIDOKApplicationJSON from json.
func (s *GetCredentialTaskByResourceIDOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialTaskByResourceIDOKApplicationJSON to nil")
	}
	var unwrapped []ResourceCredentials
	if err := func() error {
		unwrapped = make([]ResourceCredentials, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ResourceCredentials
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialTaskByResourceIDOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetCredentialTaskByResourceIDOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialTaskByResourceIDOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialUnauthorized as json.
func (s *GetCredentialUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialUnauthorized from json.
func (s *GetCredentialUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialsBadRequest as json.
func (s *GetCredentialsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialsBadRequest from json.
func (s *GetCredentialsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialsForbidden as json.
func (s *GetCredentialsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialsForbidden from json.
func (s *GetCredentialsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialsForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialsInternalServerError as json.
func (s *GetCredentialsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialsInternalServerError from json.
func (s *GetCredentialsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialsSubTaskBadRequest as json.
func (s *GetCredentialsSubTaskBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialsSubTaskBadRequest from json.
func (s *GetCredentialsSubTaskBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialsSubTaskBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialsSubTaskBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialsSubTaskBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialsSubTaskBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialsSubTaskInternalServerError as json.
func (s *GetCredentialsSubTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialsSubTaskInternalServerError from json.
func (s *GetCredentialsSubTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialsSubTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialsSubTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialsSubTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialsSubTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialsTaskBadRequest as json.
func (s *GetCredentialsTaskBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialsTaskBadRequest from json.
func (s *GetCredentialsTaskBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialsTaskBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialsTaskBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialsTaskBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialsTaskBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialsTaskInternalServerError as json.
func (s *GetCredentialsTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialsTaskInternalServerError from json.
func (s *GetCredentialsTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialsTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialsTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialsTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialsTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialsTasksBadRequest as json.
func (s *GetCredentialsTasksBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialsTasksBadRequest from json.
func (s *GetCredentialsTasksBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialsTasksBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialsTasksBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialsTasksBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialsTasksBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialsTasksInternalServerError as json.
func (s *GetCredentialsTasksInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialsTasksInternalServerError from json.
func (s *GetCredentialsTasksInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialsTasksInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialsTasksInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialsTasksInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialsTasksInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCredentialsUnauthorized as json.
func (s *GetCredentialsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCredentialsUnauthorized from json.
func (s *GetCredentialsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCredentialsUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCredentialsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCredentialsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCredentialsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCustomIsoByIdBadRequest as json.
func (s *GetCustomIsoByIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCustomIsoByIdBadRequest from json.
func (s *GetCustomIsoByIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCustomIsoByIdBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCustomIsoByIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCustomIsoByIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCustomIsoByIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCustomIsoByIdInternalServerError as json.
func (s *GetCustomIsoByIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCustomIsoByIdInternalServerError from json.
func (s *GetCustomIsoByIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCustomIsoByIdInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCustomIsoByIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCustomIsoByIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCustomIsoByIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCustomIsoByIdNotFound as json.
func (s *GetCustomIsoByIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCustomIsoByIdNotFound from json.
func (s *GetCustomIsoByIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCustomIsoByIdNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCustomIsoByIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCustomIsoByIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCustomIsoByIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDatastoreQueryResponse1BadRequest as json.
func (s *GetDatastoreQueryResponse1BadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDatastoreQueryResponse1BadRequest from json.
func (s *GetDatastoreQueryResponse1BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDatastoreQueryResponse1BadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDatastoreQueryResponse1BadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDatastoreQueryResponse1BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDatastoreQueryResponse1BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDatastoreQueryResponse1InternalServerError as json.
func (s *GetDatastoreQueryResponse1InternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDatastoreQueryResponse1InternalServerError from json.
func (s *GetDatastoreQueryResponse1InternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDatastoreQueryResponse1InternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDatastoreQueryResponse1InternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDatastoreQueryResponse1InternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDatastoreQueryResponse1InternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDatastoreQueryResponseBadRequest as json.
func (s *GetDatastoreQueryResponseBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDatastoreQueryResponseBadRequest from json.
func (s *GetDatastoreQueryResponseBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDatastoreQueryResponseBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDatastoreQueryResponseBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDatastoreQueryResponseBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDatastoreQueryResponseBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDatastoreQueryResponseInternalServerError as json.
func (s *GetDatastoreQueryResponseInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDatastoreQueryResponseInternalServerError from json.
func (s *GetDatastoreQueryResponseInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDatastoreQueryResponseInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDatastoreQueryResponseInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDatastoreQueryResponseInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDatastoreQueryResponseInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDatastoreQueryResponseNotFound as json.
func (s *GetDatastoreQueryResponseNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDatastoreQueryResponseNotFound from json.
func (s *GetDatastoreQueryResponseNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDatastoreQueryResponseNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDatastoreQueryResponseNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDatastoreQueryResponseNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDatastoreQueryResponseNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDnsConfigurationBadRequest as json.
func (s *GetDnsConfigurationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDnsConfigurationBadRequest from json.
func (s *GetDnsConfigurationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDnsConfigurationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDnsConfigurationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDnsConfigurationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDnsConfigurationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDnsConfigurationInternalServerError as json.
func (s *GetDnsConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDnsConfigurationInternalServerError from json.
func (s *GetDnsConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDnsConfigurationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDnsConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDnsConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDnsConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainCertificatesInternalServerError as json.
func (s *GetDomainCertificatesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainCertificatesInternalServerError from json.
func (s *GetDomainCertificatesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainCertificatesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainCertificatesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainCertificatesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainCertificatesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainCertificatesNotFound as json.
func (s *GetDomainCertificatesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainCertificatesNotFound from json.
func (s *GetDomainCertificatesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainCertificatesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainCertificatesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainCertificatesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainCertificatesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainEndpointsInternalServerError as json.
func (s *GetDomainEndpointsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainEndpointsInternalServerError from json.
func (s *GetDomainEndpointsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainEndpointsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainEndpointsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainEndpointsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainEndpointsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainEndpointsNotFound as json.
func (s *GetDomainEndpointsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainEndpointsNotFound from json.
func (s *GetDomainEndpointsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainEndpointsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainEndpointsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainEndpointsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainEndpointsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainInternalServerError as json.
func (s *GetDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainInternalServerError from json.
func (s *GetDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainIsolationPrecheckStatusBadRequest as json.
func (s *GetDomainIsolationPrecheckStatusBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainIsolationPrecheckStatusBadRequest from json.
func (s *GetDomainIsolationPrecheckStatusBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainIsolationPrecheckStatusBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainIsolationPrecheckStatusBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainIsolationPrecheckStatusBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainIsolationPrecheckStatusBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainIsolationPrecheckStatusInternalServerError as json.
func (s *GetDomainIsolationPrecheckStatusInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainIsolationPrecheckStatusInternalServerError from json.
func (s *GetDomainIsolationPrecheckStatusInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainIsolationPrecheckStatusInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainIsolationPrecheckStatusInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainIsolationPrecheckStatusInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainIsolationPrecheckStatusInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainNotFound as json.
func (s *GetDomainNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainNotFound from json.
func (s *GetDomainNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainReleaseViewValidationInternalServerError as json.
func (s *GetDomainReleaseViewValidationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainReleaseViewValidationInternalServerError from json.
func (s *GetDomainReleaseViewValidationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainReleaseViewValidationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainReleaseViewValidationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainReleaseViewValidationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainReleaseViewValidationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainReleaseViewValidationNotFound as json.
func (s *GetDomainReleaseViewValidationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainReleaseViewValidationNotFound from json.
func (s *GetDomainReleaseViewValidationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainReleaseViewValidationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainReleaseViewValidationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainReleaseViewValidationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainReleaseViewValidationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainTagManagerUrlBadRequest as json.
func (s *GetDomainTagManagerUrlBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainTagManagerUrlBadRequest from json.
func (s *GetDomainTagManagerUrlBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainTagManagerUrlBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainTagManagerUrlBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainTagManagerUrlBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainTagManagerUrlBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainTagManagerUrlInternalServerError as json.
func (s *GetDomainTagManagerUrlInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainTagManagerUrlInternalServerError from json.
func (s *GetDomainTagManagerUrlInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainTagManagerUrlInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainTagManagerUrlInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainTagManagerUrlInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainTagManagerUrlInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainUpdateValidationBadRequest as json.
func (s *GetDomainUpdateValidationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainUpdateValidationBadRequest from json.
func (s *GetDomainUpdateValidationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainUpdateValidationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainUpdateValidationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainUpdateValidationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainUpdateValidationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainUpdateValidationNotFound as json.
func (s *GetDomainUpdateValidationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainUpdateValidationNotFound from json.
func (s *GetDomainUpdateValidationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainUpdateValidationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainUpdateValidationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainUpdateValidationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainUpdateValidationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainsBadRequest as json.
func (s *GetDomainsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainsBadRequest from json.
func (s *GetDomainsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainsInternalServerError as json.
func (s *GetDomainsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainsInternalServerError from json.
func (s *GetDomainsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEdgeClusterInternalServerError as json.
func (s *GetEdgeClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEdgeClusterInternalServerError from json.
func (s *GetEdgeClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEdgeClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEdgeClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEdgeClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEdgeClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEdgeClusterNotFound as json.
func (s *GetEdgeClusterNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEdgeClusterNotFound from json.
func (s *GetEdgeClusterNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEdgeClusterNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEdgeClusterNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEdgeClusterNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEdgeClusterNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEdgeClusterValidationByIDInternalServerError as json.
func (s *GetEdgeClusterValidationByIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEdgeClusterValidationByIDInternalServerError from json.
func (s *GetEdgeClusterValidationByIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEdgeClusterValidationByIDInternalServerError to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEdgeClusterValidationByIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEdgeClusterValidationByIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEdgeClusterValidationByIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEdgeClusterValidationByIDOK as json.
func (s *GetEdgeClusterValidationByIDOK) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEdgeClusterValidationByIDOK from json.
func (s *GetEdgeClusterValidationByIDOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEdgeClusterValidationByIDOK to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEdgeClusterValidationByIDOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEdgeClusterValidationByIDOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEdgeClusterValidationByIDOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEdgeClustersBadRequest as json.
func (s *GetEdgeClustersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEdgeClustersBadRequest from json.
func (s *GetEdgeClustersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEdgeClustersBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEdgeClustersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEdgeClustersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEdgeClustersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEdgeClustersInternalServerError as json.
func (s *GetEdgeClustersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEdgeClustersInternalServerError from json.
func (s *GetEdgeClustersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEdgeClustersInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEdgeClustersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEdgeClustersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEdgeClustersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetFIPSConfigurationInternalServerError as json.
func (s *GetFIPSConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Fips)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetFIPSConfigurationInternalServerError from json.
func (s *GetFIPSConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFIPSConfigurationInternalServerError to nil")
	}
	var unwrapped Fips
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetFIPSConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetFIPSConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFIPSConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetFIPSConfigurationOK as json.
func (s *GetFIPSConfigurationOK) Encode(e *jx.Encoder) {
	unwrapped := (*Fips)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetFIPSConfigurationOK from json.
func (s *GetFIPSConfigurationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFIPSConfigurationOK to nil")
	}
	var unwrapped Fips
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetFIPSConfigurationOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetFIPSConfigurationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFIPSConfigurationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetFutureReleasesInternalServerError as json.
func (s *GetFutureReleasesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetFutureReleasesInternalServerError from json.
func (s *GetFutureReleasesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFutureReleasesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetFutureReleasesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetFutureReleasesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFutureReleasesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetFutureReleasesNotFound as json.
func (s *GetFutureReleasesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetFutureReleasesNotFound from json.
func (s *GetFutureReleasesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFutureReleasesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetFutureReleasesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetFutureReleasesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFutureReleasesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHealthCheckStatusBadRequest as json.
func (s *GetHealthCheckStatusBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHealthCheckStatusBadRequest from json.
func (s *GetHealthCheckStatusBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHealthCheckStatusBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHealthCheckStatusBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHealthCheckStatusBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHealthCheckStatusBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHealthCheckStatusInternalServerError as json.
func (s *GetHealthCheckStatusInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHealthCheckStatusInternalServerError from json.
func (s *GetHealthCheckStatusInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHealthCheckStatusInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHealthCheckStatusInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHealthCheckStatusInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHealthCheckStatusInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHealthCheckStatusUnauthorized as json.
func (s *GetHealthCheckStatusUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHealthCheckStatusUnauthorized from json.
func (s *GetHealthCheckStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHealthCheckStatusUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHealthCheckStatusUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHealthCheckStatusUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHealthCheckStatusUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHealthCheckTaskBadRequest as json.
func (s *GetHealthCheckTaskBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHealthCheckTaskBadRequest from json.
func (s *GetHealthCheckTaskBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHealthCheckTaskBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHealthCheckTaskBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHealthCheckTaskBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHealthCheckTaskBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHealthCheckTaskInternalServerError as json.
func (s *GetHealthCheckTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHealthCheckTaskInternalServerError from json.
func (s *GetHealthCheckTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHealthCheckTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHealthCheckTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHealthCheckTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHealthCheckTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHealthCheckTaskUnauthorized as json.
func (s *GetHealthCheckTaskUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHealthCheckTaskUnauthorized from json.
func (s *GetHealthCheckTaskUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHealthCheckTaskUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHealthCheckTaskUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHealthCheckTaskUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHealthCheckTaskUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostCommissionValidationByIDAccepted as json.
func (s *GetHostCommissionValidationByIDAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostCommissionValidationByIDAccepted from json.
func (s *GetHostCommissionValidationByIDAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostCommissionValidationByIDAccepted to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostCommissionValidationByIDAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostCommissionValidationByIDAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostCommissionValidationByIDAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostCommissionValidationByIDInternalServerError as json.
func (s *GetHostCommissionValidationByIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostCommissionValidationByIDInternalServerError from json.
func (s *GetHostCommissionValidationByIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostCommissionValidationByIDInternalServerError to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostCommissionValidationByIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostCommissionValidationByIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostCommissionValidationByIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostInternalServerErrorApplicationJSON as json.
func (s GetHostInternalServerErrorApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes GetHostInternalServerErrorApplicationJSON from json.
func (s *GetHostInternalServerErrorApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostInternalServerErrorApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostInternalServerErrorApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetHostInternalServerErrorApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostInternalServerErrorApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostQueryResponse1Accepted as json.
func (s *GetHostQueryResponse1Accepted) Encode(e *jx.Encoder) {
	unwrapped := (*HostQueryResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostQueryResponse1Accepted from json.
func (s *GetHostQueryResponse1Accepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostQueryResponse1Accepted to nil")
	}
	var unwrapped HostQueryResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostQueryResponse1Accepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostQueryResponse1Accepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostQueryResponse1Accepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostQueryResponse1BadRequest as json.
func (s *GetHostQueryResponse1BadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostQueryResponse1BadRequest from json.
func (s *GetHostQueryResponse1BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostQueryResponse1BadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostQueryResponse1BadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostQueryResponse1BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostQueryResponse1BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostQueryResponse1InternalServerError as json.
func (s *GetHostQueryResponse1InternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostQueryResponse1InternalServerError from json.
func (s *GetHostQueryResponse1InternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostQueryResponse1InternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostQueryResponse1InternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostQueryResponse1InternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostQueryResponse1InternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostQueryResponse1NotFound as json.
func (s *GetHostQueryResponse1NotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostQueryResponse1NotFound from json.
func (s *GetHostQueryResponse1NotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostQueryResponse1NotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostQueryResponse1NotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostQueryResponse1NotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostQueryResponse1NotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostQueryResponse1OK as json.
func (s *GetHostQueryResponse1OK) Encode(e *jx.Encoder) {
	unwrapped := (*HostQueryResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostQueryResponse1OK from json.
func (s *GetHostQueryResponse1OK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostQueryResponse1OK to nil")
	}
	var unwrapped HostQueryResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostQueryResponse1OK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostQueryResponse1OK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostQueryResponse1OK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostQueryResponseBadRequest as json.
func (s *GetHostQueryResponseBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostQueryResponseBadRequest from json.
func (s *GetHostQueryResponseBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostQueryResponseBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostQueryResponseBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostQueryResponseBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostQueryResponseBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostQueryResponseInternalServerError as json.
func (s *GetHostQueryResponseInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostQueryResponseInternalServerError from json.
func (s *GetHostQueryResponseInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostQueryResponseInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostQueryResponseInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostQueryResponseInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostQueryResponseInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostQueryResponseNotFound as json.
func (s *GetHostQueryResponseNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostQueryResponseNotFound from json.
func (s *GetHostQueryResponseNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostQueryResponseNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostQueryResponseNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostQueryResponseNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostQueryResponseNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostTagManagerUrlBadRequest as json.
func (s *GetHostTagManagerUrlBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostTagManagerUrlBadRequest from json.
func (s *GetHostTagManagerUrlBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostTagManagerUrlBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostTagManagerUrlBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostTagManagerUrlBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostTagManagerUrlBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostTagManagerUrlInternalServerError as json.
func (s *GetHostTagManagerUrlInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostTagManagerUrlInternalServerError from json.
func (s *GetHostTagManagerUrlInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostTagManagerUrlInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostTagManagerUrlInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostTagManagerUrlInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostTagManagerUrlInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostsBadRequest as json.
func (s *GetHostsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostsBadRequest from json.
func (s *GetHostsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostsInternalServerError as json.
func (s *GetHostsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostsInternalServerError from json.
func (s *GetHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostsPrechecksResponseInternalServerError as json.
func (s *GetHostsPrechecksResponseInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostsPrechecksResponseInternalServerError from json.
func (s *GetHostsPrechecksResponseInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostsPrechecksResponseInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostsPrechecksResponseInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostsPrechecksResponseInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostsPrechecksResponseInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetHostsPrechecksResponseNotFound as json.
func (s *GetHostsPrechecksResponseNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetHostsPrechecksResponseNotFound from json.
func (s *GetHostsPrechecksResponseNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostsPrechecksResponseNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetHostsPrechecksResponseNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHostsPrechecksResponseNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostsPrechecksResponseNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetIdentityPrecheckResultInternalServerError as json.
func (s *GetIdentityPrecheckResultInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetIdentityPrecheckResultInternalServerError from json.
func (s *GetIdentityPrecheckResultInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIdentityPrecheckResultInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetIdentityPrecheckResultInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetIdentityPrecheckResultInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIdentityPrecheckResultInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetIdentityPrecheckResultNotFound as json.
func (s *GetIdentityPrecheckResultNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetIdentityPrecheckResultNotFound from json.
func (s *GetIdentityPrecheckResultNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIdentityPrecheckResultNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetIdentityPrecheckResultNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetIdentityPrecheckResultNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIdentityPrecheckResultNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetIdentityProvidersBadRequest as json.
func (s *GetIdentityProvidersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetIdentityProvidersBadRequest from json.
func (s *GetIdentityProvidersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIdentityProvidersBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetIdentityProvidersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetIdentityProvidersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIdentityProvidersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetIdentityProvidersInternalServerError as json.
func (s *GetIdentityProvidersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetIdentityProvidersInternalServerError from json.
func (s *GetIdentityProvidersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIdentityProvidersInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetIdentityProvidersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetIdentityProvidersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIdentityProvidersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetIdentityProvidersUnauthorized as json.
func (s *GetIdentityProvidersUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetIdentityProvidersUnauthorized from json.
func (s *GetIdentityProvidersUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIdentityProvidersUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetIdentityProvidersUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetIdentityProvidersUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIdentityProvidersUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLastAssessmentRunInfoBadRequest as json.
func (s *GetLastAssessmentRunInfoBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLastAssessmentRunInfoBadRequest from json.
func (s *GetLastAssessmentRunInfoBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLastAssessmentRunInfoBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLastAssessmentRunInfoBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLastAssessmentRunInfoBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLastAssessmentRunInfoBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLastAssessmentRunInfoInternalServerError as json.
func (s *GetLastAssessmentRunInfoInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLastAssessmentRunInfoInternalServerError from json.
func (s *GetLastAssessmentRunInfoInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLastAssessmentRunInfoInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLastAssessmentRunInfoInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLastAssessmentRunInfoInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLastAssessmentRunInfoInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLastAssessmentRunInfoOKApplicationJSON as json.
func (s GetLastAssessmentRunInfoOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []AssessmentTaskInfo(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetLastAssessmentRunInfoOKApplicationJSON from json.
func (s *GetLastAssessmentRunInfoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLastAssessmentRunInfoOKApplicationJSON to nil")
	}
	var unwrapped []AssessmentTaskInfo
	if err := func() error {
		unwrapped = make([]AssessmentTaskInfo, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AssessmentTaskInfo
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLastAssessmentRunInfoOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetLastAssessmentRunInfoOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLastAssessmentRunInfoOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLicenseKeyInternalServerError as json.
func (s *GetLicenseKeyInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLicenseKeyInternalServerError from json.
func (s *GetLicenseKeyInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLicenseKeyInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLicenseKeyInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLicenseKeyInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLicenseKeyInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLicenseKeyNotFound as json.
func (s *GetLicenseKeyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLicenseKeyNotFound from json.
func (s *GetLicenseKeyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLicenseKeyNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLicenseKeyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLicenseKeyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLicenseKeyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLicenseProductTypesOKApplicationJSON as json.
func (s GetLicenseProductTypesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes GetLicenseProductTypesOKApplicationJSON from json.
func (s *GetLicenseProductTypesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLicenseProductTypesOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLicenseProductTypesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetLicenseProductTypesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLicenseProductTypesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLocalAccountBadRequest as json.
func (s *GetLocalAccountBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLocalAccountBadRequest from json.
func (s *GetLocalAccountBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLocalAccountBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLocalAccountBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLocalAccountBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLocalAccountBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLocalAccountInternalServerError as json.
func (s *GetLocalAccountInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLocalAccountInternalServerError from json.
func (s *GetLocalAccountInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLocalAccountInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLocalAccountInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLocalAccountInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLocalAccountInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLocalAccountUnauthorized as json.
func (s *GetLocalAccountUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLocalAccountUnauthorized from json.
func (s *GetLocalAccountUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLocalAccountUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLocalAccountUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLocalAccountUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLocalAccountUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLocalOsUserAccountsOKApplicationJSON as json.
func (s GetLocalOsUserAccountsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LocalOsUserAccount(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetLocalOsUserAccountsOKApplicationJSON from json.
func (s *GetLocalOsUserAccountsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLocalOsUserAccountsOKApplicationJSON to nil")
	}
	var unwrapped []LocalOsUserAccount
	if err := func() error {
		unwrapped = make([]LocalOsUserAccount, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LocalOsUserAccount
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLocalOsUserAccountsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetLocalOsUserAccountsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLocalOsUserAccountsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNetworkOfNetworkPoolInternalServerError as json.
func (s *GetNetworkOfNetworkPoolInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNetworkOfNetworkPoolInternalServerError from json.
func (s *GetNetworkOfNetworkPoolInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNetworkOfNetworkPoolInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNetworkOfNetworkPoolInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNetworkOfNetworkPoolInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNetworkOfNetworkPoolInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNetworkOfNetworkPoolNotFound as json.
func (s *GetNetworkOfNetworkPoolNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNetworkOfNetworkPoolNotFound from json.
func (s *GetNetworkOfNetworkPoolNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNetworkOfNetworkPoolNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNetworkOfNetworkPoolNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNetworkOfNetworkPoolNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNetworkOfNetworkPoolNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNetworkPoolByIDInternalServerError as json.
func (s *GetNetworkPoolByIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNetworkPoolByIDInternalServerError from json.
func (s *GetNetworkPoolByIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNetworkPoolByIDInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNetworkPoolByIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNetworkPoolByIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNetworkPoolByIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNetworkPoolByIDNotFound as json.
func (s *GetNetworkPoolByIDNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNetworkPoolByIDNotFound from json.
func (s *GetNetworkPoolByIDNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNetworkPoolByIDNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNetworkPoolByIDNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNetworkPoolByIDNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNetworkPoolByIDNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNetworkPoolInternalServerError as json.
func (s *GetNetworkPoolInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNetworkPoolInternalServerError from json.
func (s *GetNetworkPoolInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNetworkPoolInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNetworkPoolInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNetworkPoolInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNetworkPoolInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNetworkPoolNotFound as json.
func (s *GetNetworkPoolNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNetworkPoolNotFound from json.
func (s *GetNetworkPoolNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNetworkPoolNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNetworkPoolNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNetworkPoolNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNetworkPoolNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNetworksOfNetworkPoolInternalServerError as json.
func (s *GetNetworksOfNetworkPoolInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNetworksOfNetworkPoolInternalServerError from json.
func (s *GetNetworksOfNetworkPoolInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNetworksOfNetworkPoolInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNetworksOfNetworkPoolInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNetworksOfNetworkPoolInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNetworksOfNetworkPoolInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNetworksOfNetworkPoolNotFound as json.
func (s *GetNetworksOfNetworkPoolNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNetworksOfNetworkPoolNotFound from json.
func (s *GetNetworksOfNetworkPoolNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNetworksOfNetworkPoolNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNetworksOfNetworkPoolNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNetworksOfNetworkPoolNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNetworksOfNetworkPoolNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxClusterInternalServerError as json.
func (s *GetNsxClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxClusterInternalServerError from json.
func (s *GetNsxClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxClusterNotFound as json.
func (s *GetNsxClusterNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxClusterNotFound from json.
func (s *GetNsxClusterNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxClusterNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxClusterNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxClusterNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxClusterNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxClusterQueryResponseAccepted as json.
func (s *GetNsxClusterQueryResponseAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*NsxTQueryResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxClusterQueryResponseAccepted from json.
func (s *GetNsxClusterQueryResponseAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxClusterQueryResponseAccepted to nil")
	}
	var unwrapped NsxTQueryResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxClusterQueryResponseAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxClusterQueryResponseAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxClusterQueryResponseAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxClusterQueryResponseBadRequest as json.
func (s *GetNsxClusterQueryResponseBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxClusterQueryResponseBadRequest from json.
func (s *GetNsxClusterQueryResponseBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxClusterQueryResponseBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxClusterQueryResponseBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxClusterQueryResponseBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxClusterQueryResponseBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxClusterQueryResponseInternalServerError as json.
func (s *GetNsxClusterQueryResponseInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxClusterQueryResponseInternalServerError from json.
func (s *GetNsxClusterQueryResponseInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxClusterQueryResponseInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxClusterQueryResponseInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxClusterQueryResponseInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxClusterQueryResponseInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxClusterQueryResponseNotFound as json.
func (s *GetNsxClusterQueryResponseNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxClusterQueryResponseNotFound from json.
func (s *GetNsxClusterQueryResponseNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxClusterQueryResponseNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxClusterQueryResponseNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxClusterQueryResponseNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxClusterQueryResponseNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxClusterQueryResponseOK as json.
func (s *GetNsxClusterQueryResponseOK) Encode(e *jx.Encoder) {
	unwrapped := (*NsxTQueryResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxClusterQueryResponseOK from json.
func (s *GetNsxClusterQueryResponseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxClusterQueryResponseOK to nil")
	}
	var unwrapped NsxTQueryResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxClusterQueryResponseOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxClusterQueryResponseOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxClusterQueryResponseOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxClustersBadRequest as json.
func (s *GetNsxClustersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxClustersBadRequest from json.
func (s *GetNsxClustersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxClustersBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxClustersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxClustersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxClustersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxClustersInternalServerError as json.
func (s *GetNsxClustersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxClustersInternalServerError from json.
func (s *GetNsxClustersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxClustersInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxClustersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxClustersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxClustersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxIpAddressPoolInternalServerError as json.
func (s *GetNsxIpAddressPoolInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxIpAddressPoolInternalServerError from json.
func (s *GetNsxIpAddressPoolInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxIpAddressPoolInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxIpAddressPoolInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxIpAddressPoolInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxIpAddressPoolInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxIpAddressPoolNotFound as json.
func (s *GetNsxIpAddressPoolNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxIpAddressPoolNotFound from json.
func (s *GetNsxIpAddressPoolNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxIpAddressPoolNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxIpAddressPoolNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxIpAddressPoolNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxIpAddressPoolNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxIpAddressPoolsInternalServerError as json.
func (s *GetNsxIpAddressPoolsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxIpAddressPoolsInternalServerError from json.
func (s *GetNsxIpAddressPoolsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxIpAddressPoolsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxIpAddressPoolsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxIpAddressPoolsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxIpAddressPoolsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxIpAddressPoolsNotFound as json.
func (s *GetNsxIpAddressPoolsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxIpAddressPoolsNotFound from json.
func (s *GetNsxIpAddressPoolsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxIpAddressPoolsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxIpAddressPoolsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxIpAddressPoolsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxIpAddressPoolsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxUpgradeResourcesInternalServerError as json.
func (s *GetNsxUpgradeResourcesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxUpgradeResourcesInternalServerError from json.
func (s *GetNsxUpgradeResourcesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxUpgradeResourcesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxUpgradeResourcesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxUpgradeResourcesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxUpgradeResourcesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNsxUpgradeResourcesNotFound as json.
func (s *GetNsxUpgradeResourcesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNsxUpgradeResourcesNotFound from json.
func (s *GetNsxUpgradeResourcesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNsxUpgradeResourcesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNsxUpgradeResourcesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNsxUpgradeResourcesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNsxUpgradeResourcesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNtpConfigurationBadRequest as json.
func (s *GetNtpConfigurationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNtpConfigurationBadRequest from json.
func (s *GetNtpConfigurationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNtpConfigurationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNtpConfigurationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNtpConfigurationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNtpConfigurationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNtpConfigurationInternalServerError as json.
func (s *GetNtpConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetNtpConfigurationInternalServerError from json.
func (s *GetNtpConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNtpConfigurationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNtpConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNtpConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNtpConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPasswordExpirationBadRequest as json.
func (s *GetPasswordExpirationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPasswordExpirationBadRequest from json.
func (s *GetPasswordExpirationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPasswordExpirationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPasswordExpirationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPasswordExpirationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPasswordExpirationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPasswordExpirationByTaskIDBadRequest as json.
func (s *GetPasswordExpirationByTaskIDBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPasswordExpirationByTaskIDBadRequest from json.
func (s *GetPasswordExpirationByTaskIDBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPasswordExpirationByTaskIDBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPasswordExpirationByTaskIDBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPasswordExpirationByTaskIDBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPasswordExpirationByTaskIDBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPasswordExpirationByTaskIDInternalServerError as json.
func (s *GetPasswordExpirationByTaskIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPasswordExpirationByTaskIDInternalServerError from json.
func (s *GetPasswordExpirationByTaskIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPasswordExpirationByTaskIDInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPasswordExpirationByTaskIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPasswordExpirationByTaskIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPasswordExpirationByTaskIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPasswordExpirationByTaskIDNotFound as json.
func (s *GetPasswordExpirationByTaskIDNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPasswordExpirationByTaskIDNotFound from json.
func (s *GetPasswordExpirationByTaskIDNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPasswordExpirationByTaskIDNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPasswordExpirationByTaskIDNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPasswordExpirationByTaskIDNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPasswordExpirationByTaskIDNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPasswordExpirationForbidden as json.
func (s *GetPasswordExpirationForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPasswordExpirationForbidden from json.
func (s *GetPasswordExpirationForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPasswordExpirationForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPasswordExpirationForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPasswordExpirationForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPasswordExpirationForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPasswordExpirationInternalServerError as json.
func (s *GetPasswordExpirationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPasswordExpirationInternalServerError from json.
func (s *GetPasswordExpirationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPasswordExpirationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPasswordExpirationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPasswordExpirationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPasswordExpirationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPasswordExpirationTooManyRequests as json.
func (s *GetPasswordExpirationTooManyRequests) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPasswordExpirationTooManyRequests from json.
func (s *GetPasswordExpirationTooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPasswordExpirationTooManyRequests to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPasswordExpirationTooManyRequests(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPasswordExpirationTooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPasswordExpirationTooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPasswordExpirationUnauthorized as json.
func (s *GetPasswordExpirationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPasswordExpirationUnauthorized from json.
func (s *GetPasswordExpirationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPasswordExpirationUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPasswordExpirationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPasswordExpirationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPasswordExpirationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPersonalityInternalServerError as json.
func (s *GetPersonalityInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPersonalityInternalServerError from json.
func (s *GetPersonalityInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPersonalityInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPersonalityInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPersonalityInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPersonalityInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPersonalityNotFound as json.
func (s *GetPersonalityNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPersonalityNotFound from json.
func (s *GetPersonalityNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPersonalityNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPersonalityNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPersonalityNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPersonalityNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPrecheckTaskInternalServerError as json.
func (s *GetPrecheckTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPrecheckTaskInternalServerError from json.
func (s *GetPrecheckTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPrecheckTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPrecheckTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPrecheckTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPrecheckTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPrecheckTaskNotFound as json.
func (s *GetPrecheckTaskNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPrecheckTaskNotFound from json.
func (s *GetPrecheckTaskNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPrecheckTaskNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPrecheckTaskNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPrecheckTaskNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPrecheckTaskNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProductVersionCatalogInternalServerError as json.
func (s *GetProductVersionCatalogInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetProductVersionCatalogInternalServerError from json.
func (s *GetProductVersionCatalogInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProductVersionCatalogInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProductVersionCatalogInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProductVersionCatalogInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProductVersionCatalogInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProductVersionCatalogNotFound as json.
func (s *GetProductVersionCatalogNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetProductVersionCatalogNotFound from json.
func (s *GetProductVersionCatalogNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProductVersionCatalogNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProductVersionCatalogNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProductVersionCatalogNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProductVersionCatalogNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProxyConfigurationInternalServerError as json.
func (s *GetProxyConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ProxyConfiguration)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetProxyConfigurationInternalServerError from json.
func (s *GetProxyConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProxyConfigurationInternalServerError to nil")
	}
	var unwrapped ProxyConfiguration
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProxyConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProxyConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProxyConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProxyConfigurationOK as json.
func (s *GetProxyConfigurationOK) Encode(e *jx.Encoder) {
	unwrapped := (*ProxyConfiguration)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetProxyConfigurationOK from json.
func (s *GetProxyConfigurationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProxyConfigurationOK to nil")
	}
	var unwrapped ProxyConfiguration
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProxyConfigurationOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProxyConfigurationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProxyConfigurationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPscInternalServerError as json.
func (s *GetPscInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPscInternalServerError from json.
func (s *GetPscInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPscInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPscInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPscInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPscInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPscNotFound as json.
func (s *GetPscNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPscNotFound from json.
func (s *GetPscNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPscNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPscNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPscNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPscNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPscsBadRequest as json.
func (s *GetPscsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPscsBadRequest from json.
func (s *GetPscsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPscsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPscsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPscsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPscsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPscsInternalServerError as json.
func (s *GetPscsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPscsInternalServerError from json.
func (s *GetPscsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPscsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPscsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPscsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPscsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetReconciliationTaskBadRequest as json.
func (s *GetReconciliationTaskBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetReconciliationTaskBadRequest from json.
func (s *GetReconciliationTaskBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReconciliationTaskBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetReconciliationTaskBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetReconciliationTaskBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReconciliationTaskBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetReconciliationTaskInternalServerError as json.
func (s *GetReconciliationTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetReconciliationTaskInternalServerError from json.
func (s *GetReconciliationTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReconciliationTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetReconciliationTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetReconciliationTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReconciliationTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetReconciliationTaskNotFound as json.
func (s *GetReconciliationTaskNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetReconciliationTaskNotFound from json.
func (s *GetReconciliationTaskNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReconciliationTaskNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetReconciliationTaskNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetReconciliationTaskNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReconciliationTaskNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetReleaseByDomainInternalServerError as json.
func (s *GetReleaseByDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetReleaseByDomainInternalServerError from json.
func (s *GetReleaseByDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReleaseByDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetReleaseByDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetReleaseByDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReleaseByDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetReleaseByDomainNotFound as json.
func (s *GetReleaseByDomainNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetReleaseByDomainNotFound from json.
func (s *GetReleaseByDomainNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReleaseByDomainNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetReleaseByDomainNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetReleaseByDomainNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReleaseByDomainNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetReleasesInternalServerError as json.
func (s *GetReleasesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetReleasesInternalServerError from json.
func (s *GetReleasesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReleasesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetReleasesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetReleasesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReleasesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetReleasesNotFound as json.
func (s *GetReleasesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetReleasesNotFound from json.
func (s *GetReleasesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReleasesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetReleasesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetReleasesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReleasesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResourceCertificatesValidationByIDInternalServerError as json.
func (s *GetResourceCertificatesValidationByIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResourceCertificatesValidationByIDInternalServerError from json.
func (s *GetResourceCertificatesValidationByIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResourceCertificatesValidationByIDInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResourceCertificatesValidationByIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResourceCertificatesValidationByIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResourceCertificatesValidationByIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResourceCertificatesValidationByIDNotFound as json.
func (s *GetResourceCertificatesValidationByIDNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResourceCertificatesValidationByIDNotFound from json.
func (s *GetResourceCertificatesValidationByIDNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResourceCertificatesValidationByIDNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResourceCertificatesValidationByIDNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResourceCertificatesValidationByIDNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResourceCertificatesValidationByIDNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResourceFunctionalitiesBadRequest as json.
func (s *GetResourceFunctionalitiesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResourceFunctionalitiesBadRequest from json.
func (s *GetResourceFunctionalitiesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResourceFunctionalitiesBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResourceFunctionalitiesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResourceFunctionalitiesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResourceFunctionalitiesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResourceFunctionalitiesInternalServerError as json.
func (s *GetResourceFunctionalitiesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResourceFunctionalitiesInternalServerError from json.
func (s *GetResourceFunctionalitiesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResourceFunctionalitiesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResourceFunctionalitiesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResourceFunctionalitiesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResourceFunctionalitiesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResourceWarningInternalServerError as json.
func (s *GetResourceWarningInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResourceWarningInternalServerError from json.
func (s *GetResourceWarningInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResourceWarningInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResourceWarningInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResourceWarningInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResourceWarningInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResourceWarningNotFound as json.
func (s *GetResourceWarningNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResourceWarningNotFound from json.
func (s *GetResourceWarningNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResourceWarningNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResourceWarningNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResourceWarningNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResourceWarningNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResourceWarningsBadRequest as json.
func (s *GetResourceWarningsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResourceWarningsBadRequest from json.
func (s *GetResourceWarningsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResourceWarningsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResourceWarningsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResourceWarningsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResourceWarningsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResourceWarningsInternalServerError as json.
func (s *GetResourceWarningsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResourceWarningsInternalServerError from json.
func (s *GetResourceWarningsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResourceWarningsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResourceWarningsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResourceWarningsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResourceWarningsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResourcesFunctionalitiesAllowedGlobalBadRequest as json.
func (s *GetResourcesFunctionalitiesAllowedGlobalBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResourcesFunctionalitiesAllowedGlobalBadRequest from json.
func (s *GetResourcesFunctionalitiesAllowedGlobalBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResourcesFunctionalitiesAllowedGlobalBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResourcesFunctionalitiesAllowedGlobalBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResourcesFunctionalitiesAllowedGlobalBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResourcesFunctionalitiesAllowedGlobalBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResourcesFunctionalitiesAllowedGlobalInternalServerError as json.
func (s *GetResourcesFunctionalitiesAllowedGlobalInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResourcesFunctionalitiesAllowedGlobalInternalServerError from json.
func (s *GetResourcesFunctionalitiesAllowedGlobalInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResourcesFunctionalitiesAllowedGlobalInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResourcesFunctionalitiesAllowedGlobalInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResourcesFunctionalitiesAllowedGlobalInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResourcesFunctionalitiesAllowedGlobalInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRestoreTaskBadRequest as json.
func (s *GetRestoreTaskBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRestoreTaskBadRequest from json.
func (s *GetRestoreTaskBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRestoreTaskBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRestoreTaskBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRestoreTaskBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRestoreTaskBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRestoreTaskInternalServerError as json.
func (s *GetRestoreTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRestoreTaskInternalServerError from json.
func (s *GetRestoreTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRestoreTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRestoreTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRestoreTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRestoreTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResultBadRequest as json.
func (s *GetResultBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResultBadRequest from json.
func (s *GetResultBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResultBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResultBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResultBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResultBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResultInternalServerError as json.
func (s *GetResultInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResultInternalServerError from json.
func (s *GetResultInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResultInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResultInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResultInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResultInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResultNotFound as json.
func (s *GetResultNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResultNotFound from json.
func (s *GetResultNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResultNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResultNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResultNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResultNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRolesBadRequest as json.
func (s *GetRolesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRolesBadRequest from json.
func (s *GetRolesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRolesBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRolesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRolesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRolesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRolesInternalServerError as json.
func (s *GetRolesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRolesInternalServerError from json.
func (s *GetRolesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRolesInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRolesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRolesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRolesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRolesUnauthorized as json.
func (s *GetRolesUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRolesUnauthorized from json.
func (s *GetRolesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRolesUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRolesUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRolesUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRolesUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSSODomainEntitiesForbidden as json.
func (s *GetSSODomainEntitiesForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSSODomainEntitiesForbidden from json.
func (s *GetSSODomainEntitiesForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSSODomainEntitiesForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSSODomainEntitiesForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSSODomainEntitiesForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSSODomainEntitiesForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSSODomainEntitiesInternalServerError as json.
func (s *GetSSODomainEntitiesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSSODomainEntitiesInternalServerError from json.
func (s *GetSSODomainEntitiesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSSODomainEntitiesInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSSODomainEntitiesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSSODomainEntitiesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSSODomainEntitiesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSSODomainEntitiesUnauthorized as json.
func (s *GetSSODomainEntitiesUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSSODomainEntitiesUnauthorized from json.
func (s *GetSSODomainEntitiesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSSODomainEntitiesUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSSODomainEntitiesUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSSODomainEntitiesUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSSODomainEntitiesUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSSODomainsForbidden as json.
func (s *GetSSODomainsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSSODomainsForbidden from json.
func (s *GetSSODomainsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSSODomainsForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSSODomainsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSSODomainsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSSODomainsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSSODomainsInternalServerError as json.
func (s *GetSSODomainsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSSODomainsInternalServerError from json.
func (s *GetSSODomainsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSSODomainsInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSSODomainsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSSODomainsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSSODomainsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSSODomainsUnauthorized as json.
func (s *GetSSODomainsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSSODomainsUnauthorized from json.
func (s *GetSSODomainsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSSODomainsUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSSODomainsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSSODomainsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSSODomainsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcManagerHistoryInternalServerError as json.
func (s *GetSddcManagerHistoryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcManagerHistoryInternalServerError from json.
func (s *GetSddcManagerHistoryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcManagerHistoryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcManagerHistoryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcManagerHistoryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcManagerHistoryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcManagerHistoryNotFound as json.
func (s *GetSddcManagerHistoryNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcManagerHistoryNotFound from json.
func (s *GetSddcManagerHistoryNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcManagerHistoryNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcManagerHistoryNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcManagerHistoryNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcManagerHistoryNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcManagerInfoInternalServerError as json.
func (s *GetSddcManagerInfoInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SddcManagerInfo)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcManagerInfoInternalServerError from json.
func (s *GetSddcManagerInfoInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcManagerInfoInternalServerError to nil")
	}
	var unwrapped SddcManagerInfo
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcManagerInfoInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcManagerInfoInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcManagerInfoInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcManagerInfoNotFound as json.
func (s *GetSddcManagerInfoNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SddcManagerInfo)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcManagerInfoNotFound from json.
func (s *GetSddcManagerInfoNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcManagerInfoNotFound to nil")
	}
	var unwrapped SddcManagerInfo
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcManagerInfoNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcManagerInfoNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcManagerInfoNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcManagerInfoNotImplemented as json.
func (s *GetSddcManagerInfoNotImplemented) Encode(e *jx.Encoder) {
	unwrapped := (*SddcManagerInfo)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcManagerInfoNotImplemented from json.
func (s *GetSddcManagerInfoNotImplemented) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcManagerInfoNotImplemented to nil")
	}
	var unwrapped SddcManagerInfo
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcManagerInfoNotImplemented(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcManagerInfoNotImplemented) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcManagerInfoNotImplemented) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcManagerInfoOK as json.
func (s *GetSddcManagerInfoOK) Encode(e *jx.Encoder) {
	unwrapped := (*SddcManagerInfo)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcManagerInfoOK from json.
func (s *GetSddcManagerInfoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcManagerInfoOK to nil")
	}
	var unwrapped SddcManagerInfo
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcManagerInfoOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcManagerInfoOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcManagerInfoOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcManagerInternalServerError as json.
func (s *GetSddcManagerInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcManagerInternalServerError from json.
func (s *GetSddcManagerInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcManagerInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcManagerInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcManagerInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcManagerInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcManagerNotFound as json.
func (s *GetSddcManagerNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcManagerNotFound from json.
func (s *GetSddcManagerNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcManagerNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcManagerNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcManagerNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcManagerNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcManagersBadRequest as json.
func (s *GetSddcManagersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcManagersBadRequest from json.
func (s *GetSddcManagersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcManagersBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcManagersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcManagersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcManagersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcManagersInternalServerError as json.
func (s *GetSddcManagersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcManagersInternalServerError from json.
func (s *GetSddcManagersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcManagersInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcManagersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcManagersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcManagersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcWs1bOidcInfoBadRequest as json.
func (s *GetSddcWs1bOidcInfoBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcWs1bOidcInfoBadRequest from json.
func (s *GetSddcWs1bOidcInfoBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcWs1bOidcInfoBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcWs1bOidcInfoBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcWs1bOidcInfoBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcWs1bOidcInfoBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcWs1bOidcInfoInternalServerError as json.
func (s *GetSddcWs1bOidcInfoInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcWs1bOidcInfoInternalServerError from json.
func (s *GetSddcWs1bOidcInfoInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcWs1bOidcInfoInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcWs1bOidcInfoInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcWs1bOidcInfoInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcWs1bOidcInfoInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSddcWs1bOidcInfoUnauthorized as json.
func (s *GetSddcWs1bOidcInfoUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSddcWs1bOidcInfoUnauthorized from json.
func (s *GetSddcWs1bOidcInfoUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSddcWs1bOidcInfoUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSddcWs1bOidcInfoUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSddcWs1bOidcInfoUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSddcWs1bOidcInfoUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSupportBundleStatusBadRequest as json.
func (s *GetSupportBundleStatusBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSupportBundleStatusBadRequest from json.
func (s *GetSupportBundleStatusBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSupportBundleStatusBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSupportBundleStatusBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSupportBundleStatusBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSupportBundleStatusBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSupportBundleStatusInternalServerError as json.
func (s *GetSupportBundleStatusInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSupportBundleStatusInternalServerError from json.
func (s *GetSupportBundleStatusInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSupportBundleStatusInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSupportBundleStatusInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSupportBundleStatusInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSupportBundleStatusInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSupportBundleStatusUnauthorized as json.
func (s *GetSupportBundleStatusUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSupportBundleStatusUnauthorized from json.
func (s *GetSupportBundleStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSupportBundleStatusUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSupportBundleStatusUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSupportBundleStatusUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSupportBundleStatusUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSupportBundleTaskBadRequest as json.
func (s *GetSupportBundleTaskBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSupportBundleTaskBadRequest from json.
func (s *GetSupportBundleTaskBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSupportBundleTaskBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSupportBundleTaskBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSupportBundleTaskBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSupportBundleTaskBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSupportBundleTaskInternalServerError as json.
func (s *GetSupportBundleTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSupportBundleTaskInternalServerError from json.
func (s *GetSupportBundleTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSupportBundleTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSupportBundleTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSupportBundleTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSupportBundleTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSupportBundleTaskUnauthorized as json.
func (s *GetSupportBundleTaskUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSupportBundleTaskUnauthorized from json.
func (s *GetSupportBundleTaskUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSupportBundleTaskUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSupportBundleTaskUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSupportBundleTaskUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSupportBundleTaskUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSystemConfigurationBadRequest as json.
func (s *GetSystemConfigurationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSystemConfigurationBadRequest from json.
func (s *GetSystemConfigurationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSystemConfigurationBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSystemConfigurationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSystemConfigurationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSystemConfigurationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSystemConfigurationInternalServerError as json.
func (s *GetSystemConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSystemConfigurationInternalServerError from json.
func (s *GetSystemConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSystemConfigurationInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSystemConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSystemConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSystemConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSystemReleaseInternalServerError as json.
func (s *GetSystemReleaseInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSystemReleaseInternalServerError from json.
func (s *GetSystemReleaseInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSystemReleaseInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSystemReleaseInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSystemReleaseInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSystemReleaseInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSystemReleaseNotFound as json.
func (s *GetSystemReleaseNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSystemReleaseNotFound from json.
func (s *GetSystemReleaseNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSystemReleaseNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSystemReleaseNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSystemReleaseNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSystemReleaseNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagAssignableForClusterBadRequest as json.
func (s *GetTagAssignableForClusterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagAssignableForClusterBadRequest from json.
func (s *GetTagAssignableForClusterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagAssignableForClusterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagAssignableForClusterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagAssignableForClusterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagAssignableForClusterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagAssignableForClusterInternalServerError as json.
func (s *GetTagAssignableForClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagAssignableForClusterInternalServerError from json.
func (s *GetTagAssignableForClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagAssignableForClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagAssignableForClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagAssignableForClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagAssignableForClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToClusterBadRequest as json.
func (s *GetTagsAssignedToClusterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToClusterBadRequest from json.
func (s *GetTagsAssignedToClusterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToClusterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToClusterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToClusterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToClusterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToClusterInternalServerError as json.
func (s *GetTagsAssignedToClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToClusterInternalServerError from json.
func (s *GetTagsAssignedToClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToClustersBadRequest as json.
func (s *GetTagsAssignedToClustersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToClustersBadRequest from json.
func (s *GetTagsAssignedToClustersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToClustersBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToClustersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToClustersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToClustersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToClustersInternalServerError as json.
func (s *GetTagsAssignedToClustersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToClustersInternalServerError from json.
func (s *GetTagsAssignedToClustersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToClustersInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToClustersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToClustersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToClustersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToDomainBadRequest as json.
func (s *GetTagsAssignedToDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToDomainBadRequest from json.
func (s *GetTagsAssignedToDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToDomainBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToDomainInternalServerError as json.
func (s *GetTagsAssignedToDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToDomainInternalServerError from json.
func (s *GetTagsAssignedToDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToDomainsBadRequest as json.
func (s *GetTagsAssignedToDomainsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToDomainsBadRequest from json.
func (s *GetTagsAssignedToDomainsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToDomainsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToDomainsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToDomainsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToDomainsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToDomainsInternalServerError as json.
func (s *GetTagsAssignedToDomainsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToDomainsInternalServerError from json.
func (s *GetTagsAssignedToDomainsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToDomainsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToDomainsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToDomainsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToDomainsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToHostBadRequest as json.
func (s *GetTagsAssignedToHostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToHostBadRequest from json.
func (s *GetTagsAssignedToHostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToHostBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToHostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToHostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToHostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToHostInternalServerError as json.
func (s *GetTagsAssignedToHostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToHostInternalServerError from json.
func (s *GetTagsAssignedToHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToHostInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToHostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToHostsBadRequest as json.
func (s *GetTagsAssignedToHostsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToHostsBadRequest from json.
func (s *GetTagsAssignedToHostsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToHostsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToHostsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToHostsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToHostsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTagsAssignedToHostsInternalServerError as json.
func (s *GetTagsAssignedToHostsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTagsAssignedToHostsInternalServerError from json.
func (s *GetTagsAssignedToHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTagsAssignedToHostsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTagsAssignedToHostsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTagsAssignedToHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTagsAssignedToHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTaskInternalServerError as json.
func (s *GetTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTaskInternalServerError from json.
func (s *GetTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTaskNotFound as json.
func (s *GetTaskNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTaskNotFound from json.
func (s *GetTaskNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTaskNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTaskNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTaskNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTaskNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUiUsersBadRequest as json.
func (s *GetUiUsersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUiUsersBadRequest from json.
func (s *GetUiUsersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUiUsersBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUiUsersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUiUsersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUiUsersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUiUsersInternalServerError as json.
func (s *GetUiUsersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUiUsersInternalServerError from json.
func (s *GetUiUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUiUsersInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUiUsersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUiUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUiUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUiUsersUnauthorized as json.
func (s *GetUiUsersUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUiUsersUnauthorized from json.
func (s *GetUiUsersUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUiUsersUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUiUsersUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUiUsersUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUiUsersUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradablesByDomainInternalServerError as json.
func (s *GetUpgradablesByDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradablesByDomainInternalServerError from json.
func (s *GetUpgradablesByDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradablesByDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradablesByDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradablesByDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradablesByDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradablesByDomainNotFound as json.
func (s *GetUpgradablesByDomainNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradablesByDomainNotFound from json.
func (s *GetUpgradablesByDomainNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradablesByDomainNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradablesByDomainNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradablesByDomainNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradablesByDomainNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradablesClustersInternalServerError as json.
func (s *GetUpgradablesClustersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradablesClustersInternalServerError from json.
func (s *GetUpgradablesClustersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradablesClustersInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradablesClustersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradablesClustersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradablesClustersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradablesClustersNotFound as json.
func (s *GetUpgradablesClustersNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradablesClustersNotFound from json.
func (s *GetUpgradablesClustersNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradablesClustersNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradablesClustersNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradablesClustersNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradablesClustersNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradeByIdInternalServerError as json.
func (s *GetUpgradeByIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradeByIdInternalServerError from json.
func (s *GetUpgradeByIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradeByIdInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradeByIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradeByIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradeByIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradeByIdNotFound as json.
func (s *GetUpgradeByIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradeByIdNotFound from json.
func (s *GetUpgradeByIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradeByIdNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradeByIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradeByIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradeByIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradePrecheckByIDBadRequest as json.
func (s *GetUpgradePrecheckByIDBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradePrecheckByIDBadRequest from json.
func (s *GetUpgradePrecheckByIDBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradePrecheckByIDBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradePrecheckByIDBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradePrecheckByIDBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradePrecheckByIDBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradePrecheckByIDForbidden as json.
func (s *GetUpgradePrecheckByIDForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradePrecheckByIDForbidden from json.
func (s *GetUpgradePrecheckByIDForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradePrecheckByIDForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradePrecheckByIDForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradePrecheckByIDForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradePrecheckByIDForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradePrecheckByIDInternalServerError as json.
func (s *GetUpgradePrecheckByIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradePrecheckByIDInternalServerError from json.
func (s *GetUpgradePrecheckByIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradePrecheckByIDInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradePrecheckByIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradePrecheckByIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradePrecheckByIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradesBadRequest as json.
func (s *GetUpgradesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradesBadRequest from json.
func (s *GetUpgradesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradesBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradesInternalServerError as json.
func (s *GetUpgradesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradesInternalServerError from json.
func (s *GetUpgradesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUpgradesNotFound as json.
func (s *GetUpgradesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUpgradesNotFound from json.
func (s *GetUpgradesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUpgradesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUpgradesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUpgradesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUpgradesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUsersBadRequest as json.
func (s *GetUsersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUsersBadRequest from json.
func (s *GetUsersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsersBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUsersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUsersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUsersInternalServerError as json.
func (s *GetUsersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUsersInternalServerError from json.
func (s *GetUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsersInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUsersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUsersUnauthorized as json.
func (s *GetUsersUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUsersUnauthorized from json.
func (s *GetUsersUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsersUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUsersUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUsersUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsersUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetValidationOfDnsConfigurationInternalServerError as json.
func (s *GetValidationOfDnsConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetValidationOfDnsConfigurationInternalServerError from json.
func (s *GetValidationOfDnsConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetValidationOfDnsConfigurationInternalServerError to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetValidationOfDnsConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetValidationOfDnsConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetValidationOfDnsConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetValidationOfDnsConfigurationOK as json.
func (s *GetValidationOfDnsConfigurationOK) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetValidationOfDnsConfigurationOK from json.
func (s *GetValidationOfDnsConfigurationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetValidationOfDnsConfigurationOK to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetValidationOfDnsConfigurationOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetValidationOfDnsConfigurationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetValidationOfDnsConfigurationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetValidationOfNtpConfigurationInternalServerError as json.
func (s *GetValidationOfNtpConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetValidationOfNtpConfigurationInternalServerError from json.
func (s *GetValidationOfNtpConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetValidationOfNtpConfigurationInternalServerError to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetValidationOfNtpConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetValidationOfNtpConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetValidationOfNtpConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetValidationOfNtpConfigurationOK as json.
func (s *GetValidationOfNtpConfigurationOK) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetValidationOfNtpConfigurationOK from json.
func (s *GetValidationOfNtpConfigurationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetValidationOfNtpConfigurationOK to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetValidationOfNtpConfigurationOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetValidationOfNtpConfigurationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetValidationOfNtpConfigurationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetValidationsOfDNSConfigurationInternalServerErrorApplicationJSON as json.
func (s GetValidationsOfDNSConfigurationInternalServerErrorApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Validation(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetValidationsOfDNSConfigurationInternalServerErrorApplicationJSON from json.
func (s *GetValidationsOfDNSConfigurationInternalServerErrorApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetValidationsOfDNSConfigurationInternalServerErrorApplicationJSON to nil")
	}
	var unwrapped []Validation
	if err := func() error {
		unwrapped = make([]Validation, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Validation
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetValidationsOfDNSConfigurationInternalServerErrorApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetValidationsOfDNSConfigurationInternalServerErrorApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetValidationsOfDNSConfigurationInternalServerErrorApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetValidationsOfNtpConfigurationInternalServerErrorApplicationJSON as json.
func (s GetValidationsOfNtpConfigurationInternalServerErrorApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Validation(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetValidationsOfNtpConfigurationInternalServerErrorApplicationJSON from json.
func (s *GetValidationsOfNtpConfigurationInternalServerErrorApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetValidationsOfNtpConfigurationInternalServerErrorApplicationJSON to nil")
	}
	var unwrapped []Validation
	if err := func() error {
		unwrapped = make([]Validation, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Validation
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetValidationsOfNtpConfigurationInternalServerErrorApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetValidationsOfNtpConfigurationInternalServerErrorApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetValidationsOfNtpConfigurationInternalServerErrorApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderInternalServerError as json.
func (s *GetVasaProviderInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderInternalServerError from json.
func (s *GetVasaProviderInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderNotFound as json.
func (s *GetVasaProviderNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderNotFound from json.
func (s *GetVasaProviderNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderStorageContainersBadRequest as json.
func (s *GetVasaProviderStorageContainersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderStorageContainersBadRequest from json.
func (s *GetVasaProviderStorageContainersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderStorageContainersBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderStorageContainersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderStorageContainersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderStorageContainersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderStorageContainersInternalServerError as json.
func (s *GetVasaProviderStorageContainersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderStorageContainersInternalServerError from json.
func (s *GetVasaProviderStorageContainersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderStorageContainersInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderStorageContainersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderStorageContainersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderStorageContainersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderStorageContainersNotFound as json.
func (s *GetVasaProviderStorageContainersNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderStorageContainersNotFound from json.
func (s *GetVasaProviderStorageContainersNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderStorageContainersNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderStorageContainersNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderStorageContainersNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderStorageContainersNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderStorageContainersOKApplicationJSON as json.
func (s GetVasaProviderStorageContainersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []StorageContainer(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetVasaProviderStorageContainersOKApplicationJSON from json.
func (s *GetVasaProviderStorageContainersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderStorageContainersOKApplicationJSON to nil")
	}
	var unwrapped []StorageContainer
	if err := func() error {
		unwrapped = make([]StorageContainer, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem StorageContainer
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderStorageContainersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetVasaProviderStorageContainersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderStorageContainersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderUserBadRequest as json.
func (s *GetVasaProviderUserBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderUserBadRequest from json.
func (s *GetVasaProviderUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderUserBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderUserBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderUserInternalServerError as json.
func (s *GetVasaProviderUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderUserInternalServerError from json.
func (s *GetVasaProviderUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderUserInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderUserNotFound as json.
func (s *GetVasaProviderUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderUserNotFound from json.
func (s *GetVasaProviderUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderUserNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderUserOKApplicationJSON as json.
func (s GetVasaProviderUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []VasaUser(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetVasaProviderUserOKApplicationJSON from json.
func (s *GetVasaProviderUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderUserOKApplicationJSON to nil")
	}
	var unwrapped []VasaUser
	if err := func() error {
		unwrapped = make([]VasaUser, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem VasaUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderUserOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetVasaProviderUserOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderUserOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderValidationBadRequest as json.
func (s *GetVasaProviderValidationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderValidationBadRequest from json.
func (s *GetVasaProviderValidationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderValidationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderValidationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderValidationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderValidationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderValidationInternalServerError as json.
func (s *GetVasaProviderValidationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderValidationInternalServerError from json.
func (s *GetVasaProviderValidationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderValidationInternalServerError to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderValidationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderValidationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderValidationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderValidationNotFound as json.
func (s *GetVasaProviderValidationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderValidationNotFound from json.
func (s *GetVasaProviderValidationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderValidationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderValidationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderValidationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderValidationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProviderValidationOK as json.
func (s *GetVasaProviderValidationOK) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProviderValidationOK from json.
func (s *GetVasaProviderValidationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProviderValidationOK to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProviderValidationOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProviderValidationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProviderValidationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProvidersBadRequest as json.
func (s *GetVasaProvidersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProvidersBadRequest from json.
func (s *GetVasaProvidersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProvidersBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProvidersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProvidersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProvidersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVasaProvidersInternalServerError as json.
func (s *GetVasaProvidersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVasaProvidersInternalServerError from json.
func (s *GetVasaProvidersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVasaProvidersInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVasaProvidersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVasaProvidersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVasaProvidersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVcenterInternalServerError as json.
func (s *GetVcenterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVcenterInternalServerError from json.
func (s *GetVcenterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVcenterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVcenterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVcenterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVcenterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVcenterNotFound as json.
func (s *GetVcenterNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVcenterNotFound from json.
func (s *GetVcenterNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVcenterNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVcenterNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVcenterNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVcenterNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVcentersBadRequest as json.
func (s *GetVcentersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVcentersBadRequest from json.
func (s *GetVcentersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVcentersBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVcentersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVcentersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVcentersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVcentersInternalServerError as json.
func (s *GetVcentersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVcentersInternalServerError from json.
func (s *GetVcentersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVcentersInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVcentersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVcentersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVcentersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVcfServiceInternalServerError as json.
func (s *GetVcfServiceInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVcfServiceInternalServerError from json.
func (s *GetVcfServiceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVcfServiceInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVcfServiceInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVcfServiceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVcfServiceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVcfServiceNotFound as json.
func (s *GetVcfServiceNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVcfServiceNotFound from json.
func (s *GetVcfServiceNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVcfServiceNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVcfServiceNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVcfServiceNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVcfServiceNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVcfServicesBadRequest as json.
func (s *GetVcfServicesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVcfServicesBadRequest from json.
func (s *GetVcfServicesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVcfServicesBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVcfServicesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVcfServicesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVcfServicesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVcfServicesInternalServerError as json.
func (s *GetVcfServicesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVcfServicesInternalServerError from json.
func (s *GetVcfServicesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVcfServicesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVcfServicesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVcfServicesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVcfServicesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVdsesBadRequest as json.
func (s *GetVdsesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVdsesBadRequest from json.
func (s *GetVdsesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVdsesBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVdsesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVdsesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVdsesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVdsesInternalServerError as json.
func (s *GetVdsesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVdsesInternalServerError from json.
func (s *GetVdsesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVdsesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVdsesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVdsesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVdsesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVdsesNotFound as json.
func (s *GetVdsesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVdsesNotFound from json.
func (s *GetVdsesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVdsesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVdsesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVdsesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVdsesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVdsesOKApplicationJSON as json.
func (s GetVdsesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Vds(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetVdsesOKApplicationJSON from json.
func (s *GetVdsesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVdsesOKApplicationJSON to nil")
	}
	var unwrapped []Vds
	if err := func() error {
		unwrapped = make([]Vds, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Vds
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVdsesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetVdsesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVdsesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVrslcmValidationBadRequest as json.
func (s *GetVrslcmValidationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVrslcmValidationBadRequest from json.
func (s *GetVrslcmValidationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVrslcmValidationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVrslcmValidationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVrslcmValidationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVrslcmValidationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVrslcmValidationNotFound as json.
func (s *GetVrslcmValidationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVrslcmValidationNotFound from json.
func (s *GetVrslcmValidationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVrslcmValidationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVrslcmValidationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVrslcmValidationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVrslcmValidationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVsanHclAttributesInternalServerError as json.
func (s *GetVsanHclAttributesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVsanHclAttributesInternalServerError from json.
func (s *GetVsanHclAttributesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVsanHclAttributesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVsanHclAttributesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVsanHclAttributesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVsanHclAttributesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVsanHclAttributesNotFound as json.
func (s *GetVsanHclAttributesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVsanHclAttributesNotFound from json.
func (s *GetVsanHclAttributesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVsanHclAttributesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVsanHclAttributesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVsanHclAttributesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVsanHclAttributesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVsanHclConfigurationInternalServerError as json.
func (s *GetVsanHclConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVsanHclConfigurationInternalServerError from json.
func (s *GetVsanHclConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVsanHclConfigurationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVsanHclConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVsanHclConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVsanHclConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVsanHclConfigurationNotFound as json.
func (s *GetVsanHclConfigurationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVsanHclConfigurationNotFound from json.
func (s *GetVsanHclConfigurationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVsanHclConfigurationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVsanHclConfigurationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVsanHclConfigurationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVsanHclConfigurationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVsanHealthCheckByQueryIDBadRequest as json.
func (s *GetVsanHealthCheckByQueryIDBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVsanHealthCheckByQueryIDBadRequest from json.
func (s *GetVsanHealthCheckByQueryIDBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVsanHealthCheckByQueryIDBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVsanHealthCheckByQueryIDBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVsanHealthCheckByQueryIDBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVsanHealthCheckByQueryIDBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVsanHealthCheckByQueryIDInternalServerError as json.
func (s *GetVsanHealthCheckByQueryIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVsanHealthCheckByQueryIDInternalServerError from json.
func (s *GetVsanHealthCheckByQueryIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVsanHealthCheckByQueryIDInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVsanHealthCheckByQueryIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVsanHealthCheckByQueryIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVsanHealthCheckByQueryIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVsanHealthCheckByTaskIDBadRequest as json.
func (s *GetVsanHealthCheckByTaskIDBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVsanHealthCheckByTaskIDBadRequest from json.
func (s *GetVsanHealthCheckByTaskIDBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVsanHealthCheckByTaskIDBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVsanHealthCheckByTaskIDBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVsanHealthCheckByTaskIDBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVsanHealthCheckByTaskIDBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVsanHealthCheckByTaskIDInternalServerError as json.
func (s *GetVsanHealthCheckByTaskIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVsanHealthCheckByTaskIDInternalServerError from json.
func (s *GetVsanHealthCheckByTaskIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVsanHealthCheckByTaskIDInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVsanHealthCheckByTaskIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVsanHealthCheckByTaskIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVsanHealthCheckByTaskIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HardwareSupportInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HardwareSupportInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("packages")
		s.Packages.Encode(e)
	}
}

var jsonFieldsNameOfHardwareSupportInfo = [1]string{
	0: "packages",
}

// Decode decodes HardwareSupportInfo from json.
func (s *HardwareSupportInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HardwareSupportInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "packages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Packages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"packages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HardwareSupportInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHardwareSupportInfo) {
					name = jsonFieldsNameOfHardwareSupportInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HardwareSupportInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HardwareSupportInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HardwareSupportInfoPackages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HardwareSupportInfoPackages) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes HardwareSupportInfoPackages from json.
func (s *HardwareSupportInfoPackages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HardwareSupportInfoPackages to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem HardwareSupportPackageInfo
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HardwareSupportInfoPackages")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HardwareSupportInfoPackages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HardwareSupportInfoPackages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HardwareSupportPackage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HardwareSupportPackage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("displayName")
			s.DisplayName.Encode(e)
		}
	}
	{
		e.FieldStart("pkg")
		s.Pkg.Encode(e)
	}
}

var jsonFieldsNameOfHardwareSupportPackage = [3]string{
	0: "name",
	1: "displayName",
	2: "pkg",
}

// Decode decodes HardwareSupportPackage from json.
func (s *HardwareSupportPackage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HardwareSupportPackage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "pkg":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Pkg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pkg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HardwareSupportPackage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHardwareSupportPackage) {
					name = jsonFieldsNameOfHardwareSupportPackage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HardwareSupportPackage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HardwareSupportPackage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HardwareSupportPackageInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HardwareSupportPackageInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pkg")
		e.Str(s.Pkg)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfHardwareSupportPackageInfo = [2]string{
	0: "pkg",
	1: "version",
}

// Decode decodes HardwareSupportPackageInfo from json.
func (s *HardwareSupportPackageInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HardwareSupportPackageInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pkg":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Pkg = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pkg\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HardwareSupportPackageInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHardwareSupportPackageInfo) {
					name = jsonFieldsNameOfHardwareSupportPackageInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HardwareSupportPackageInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HardwareSupportPackageInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HardwareSupportPackages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HardwareSupportPackages) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("displayName")
		e.Str(s.DisplayName)
	}
	{
		e.FieldStart("packages")
		e.ArrStart()
		for _, elem := range s.Packages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfHardwareSupportPackages = [3]string{
	0: "name",
	1: "displayName",
	2: "packages",
}

// Decode decodes HardwareSupportPackages from json.
func (s *HardwareSupportPackages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HardwareSupportPackages to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "displayName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "packages":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Packages = make([]Package, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Package
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Packages = append(s.Packages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"packages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HardwareSupportPackages")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHardwareSupportPackages) {
					name = jsonFieldsNameOfHardwareSupportPackages[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HardwareSupportPackages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HardwareSupportPackages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HardwareSupportSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HardwareSupportSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("packageSpec")
		s.PackageSpec.Encode(e)
	}
}

var jsonFieldsNameOfHardwareSupportSpec = [2]string{
	0: "name",
	1: "packageSpec",
}

// Decode decodes HardwareSupportSpec from json.
func (s *HardwareSupportSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HardwareSupportSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "packageSpec":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PackageSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"packageSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HardwareSupportSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHardwareSupportSpec) {
					name = jsonFieldsNameOfHardwareSupportSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HardwareSupportSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HardwareSupportSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HciMeshData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HciMeshData) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.IsHciMeshEnabled.Set {
			e.FieldStart("isHciMeshEnabled")
			s.IsHciMeshEnabled.Encode(e)
		}
	}
	{
		if s.RemoteDatastore.Set {
			e.FieldStart("remoteDatastore")
			s.RemoteDatastore.Encode(e)
		}
	}
	{
		if s.PrimaryDataStoreId.Set {
			e.FieldStart("primaryDataStoreId")
			s.PrimaryDataStoreId.Encode(e)
		}
	}
	{
		if s.VsanDataStores != nil {
			e.FieldStart("vsanDataStores")
			e.ArrStart()
			for _, elem := range s.VsanDataStores {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ClientClusters != nil {
			e.FieldStart("clientClusters")
			e.ArrStart()
			for _, elem := range s.ClientClusters {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoteDatastoreInfos != nil {
			e.FieldStart("remoteDatastoreInfos")
			e.ArrStart()
			for _, elem := range s.RemoteDatastoreInfos {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsServer.Set {
			e.FieldStart("isServer")
			s.IsServer.Encode(e)
		}
	}
	{
		if s.IsClient.Set {
			e.FieldStart("isClient")
			s.IsClient.Encode(e)
		}
	}
	{
		if s.ComputeOnlyClient.Set {
			e.FieldStart("computeOnlyClient")
			s.ComputeOnlyClient.Encode(e)
		}
	}
	{
		if s.NumberOfClients.Set {
			e.FieldStart("numberOfClients")
			s.NumberOfClients.Encode(e)
		}
	}
	{
		if s.NumberOfServers.Set {
			e.FieldStart("numberOfServers")
			s.NumberOfServers.Encode(e)
		}
	}
}

var jsonFieldsNameOfHciMeshData = [12]string{
	0:  "name",
	1:  "isHciMeshEnabled",
	2:  "remoteDatastore",
	3:  "primaryDataStoreId",
	4:  "vsanDataStores",
	5:  "clientClusters",
	6:  "remoteDatastoreInfos",
	7:  "isServer",
	8:  "isClient",
	9:  "computeOnlyClient",
	10: "numberOfClients",
	11: "numberOfServers",
}

// Decode decodes HciMeshData from json.
func (s *HciMeshData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HciMeshData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "isHciMeshEnabled":
			if err := func() error {
				s.IsHciMeshEnabled.Reset()
				if err := s.IsHciMeshEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHciMeshEnabled\"")
			}
		case "remoteDatastore":
			if err := func() error {
				s.RemoteDatastore.Reset()
				if err := s.RemoteDatastore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remoteDatastore\"")
			}
		case "primaryDataStoreId":
			if err := func() error {
				s.PrimaryDataStoreId.Reset()
				if err := s.PrimaryDataStoreId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryDataStoreId\"")
			}
		case "vsanDataStores":
			if err := func() error {
				s.VsanDataStores = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.VsanDataStores = append(s.VsanDataStores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanDataStores\"")
			}
		case "clientClusters":
			if err := func() error {
				s.ClientClusters = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ClientClusters = append(s.ClientClusters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientClusters\"")
			}
		case "remoteDatastoreInfos":
			if err := func() error {
				s.RemoteDatastoreInfos = make([]RemoteDatastoreInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RemoteDatastoreInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RemoteDatastoreInfos = append(s.RemoteDatastoreInfos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remoteDatastoreInfos\"")
			}
		case "isServer":
			if err := func() error {
				s.IsServer.Reset()
				if err := s.IsServer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isServer\"")
			}
		case "isClient":
			if err := func() error {
				s.IsClient.Reset()
				if err := s.IsClient.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isClient\"")
			}
		case "computeOnlyClient":
			if err := func() error {
				s.ComputeOnlyClient.Reset()
				if err := s.ComputeOnlyClient.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"computeOnlyClient\"")
			}
		case "numberOfClients":
			if err := func() error {
				s.NumberOfClients.Reset()
				if err := s.NumberOfClients.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfClients\"")
			}
		case "numberOfServers":
			if err := func() error {
				s.NumberOfServers.Reset()
				if err := s.NumberOfServers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfServers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HciMeshData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HciMeshData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HciMeshData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthCheckQueryResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthCheckQueryResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resultId")
		e.Str(s.ResultId)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHealthCheckQueryResult = [3]string{
	0: "resultId",
	1: "status",
	2: "result",
}

// Decode decodes HealthCheckQueryResult from json.
func (s *HealthCheckQueryResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckQueryResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resultId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResultId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resultId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "result":
			if err := func() error {
				s.Result = make([]HealthCheckResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HealthCheckResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthCheckQueryResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthCheckQueryResult) {
					name = jsonFieldsNameOfHealthCheckQueryResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthCheckQueryResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckQueryResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthCheckResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthCheckResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ResourceType.Set {
			e.FieldStart("resourceType")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.ResourceId.Set {
			e.FieldStart("resourceId")
			s.ResourceId.Encode(e)
		}
	}
	{
		if s.ResourceName.Set {
			e.FieldStart("resourceName")
			s.ResourceName.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthCheckResult = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "type",
	4: "status",
	5: "resourceType",
	6: "resourceId",
	7: "resourceName",
}

// Decode decodes HealthCheckResult from json.
func (s *HealthCheckResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "resourceId":
			if err := func() error {
				s.ResourceId.Reset()
				if err := s.ResourceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceName":
			if err := func() error {
				s.ResourceName.Reset()
				if err := s.ResourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthCheckResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthCheckResult) {
					name = jsonFieldsNameOfHealthCheckResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthCheckResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthCheckSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthCheckSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		if s.ResourceName.Set {
			e.FieldStart("resourceName")
			s.ResourceName.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthCheckSpec = [5]string{
	0: "id",
	1: "name",
	2: "status",
	3: "resourceType",
	4: "resourceName",
}

// Decode decodes HealthCheckSpec from json.
func (s *HealthCheckSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "resourceType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "resourceName":
			if err := func() error {
				s.ResourceName.Reset()
				if err := s.ResourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthCheckSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthCheckSpec) {
					name = jsonFieldsNameOfHealthCheckSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthCheckSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthCheckTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthCheckTask) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("resourceStatus")
		s.ResourceStatus.Encode(e)
	}
}

var jsonFieldsNameOfHealthCheckTask = [3]string{
	0: "id",
	1: "status",
	2: "resourceStatus",
}

// Decode decodes HealthCheckTask from json.
func (s *HealthCheckTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckTask to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "resourceStatus":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ResourceStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthCheckTask")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthCheckTask) {
					name = jsonFieldsNameOfHealthCheckTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthCheckTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HealthCheckTaskResourceStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HealthCheckTaskResourceStatus) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes HealthCheckTaskResourceStatus from json.
func (s *HealthCheckTaskResourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckTaskResourceStatus to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthCheckTaskResourceStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthCheckTaskResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckTaskResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthChecks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthChecks) encodeFields(e *jx.Encoder) {
	{
		if s.ServicesHealth.Set {
			e.FieldStart("servicesHealth")
			s.ServicesHealth.Encode(e)
		}
	}
	{
		if s.NtpHealth.Set {
			e.FieldStart("ntpHealth")
			s.NtpHealth.Encode(e)
		}
	}
	{
		if s.GeneralHealth.Set {
			e.FieldStart("generalHealth")
			s.GeneralHealth.Encode(e)
		}
	}
	{
		if s.CertificateHealth.Set {
			e.FieldStart("certificateHealth")
			s.CertificateHealth.Encode(e)
		}
	}
	{
		if s.PasswordHealth.Set {
			e.FieldStart("passwordHealth")
			s.PasswordHealth.Encode(e)
		}
	}
	{
		if s.ConnectivityHealth.Set {
			e.FieldStart("connectivityHealth")
			s.ConnectivityHealth.Encode(e)
		}
	}
	{
		if s.ComputeHealth.Set {
			e.FieldStart("computeHealth")
			s.ComputeHealth.Encode(e)
		}
	}
	{
		if s.StorageHealth.Set {
			e.FieldStart("storageHealth")
			s.StorageHealth.Encode(e)
		}
	}
	{
		if s.DnsHealth.Set {
			e.FieldStart("dnsHealth")
			s.DnsHealth.Encode(e)
		}
	}
	{
		if s.HardwareCompatibilityHealth.Set {
			e.FieldStart("hardwareCompatibilityHealth")
			s.HardwareCompatibilityHealth.Encode(e)
		}
	}
	{
		if s.VersionHealth.Set {
			e.FieldStart("versionHealth")
			s.VersionHealth.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthChecks = [11]string{
	0:  "servicesHealth",
	1:  "ntpHealth",
	2:  "generalHealth",
	3:  "certificateHealth",
	4:  "passwordHealth",
	5:  "connectivityHealth",
	6:  "computeHealth",
	7:  "storageHealth",
	8:  "dnsHealth",
	9:  "hardwareCompatibilityHealth",
	10: "versionHealth",
}

// Decode decodes HealthChecks from json.
func (s *HealthChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthChecks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "servicesHealth":
			if err := func() error {
				s.ServicesHealth.Reset()
				if err := s.ServicesHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servicesHealth\"")
			}
		case "ntpHealth":
			if err := func() error {
				s.NtpHealth.Reset()
				if err := s.NtpHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ntpHealth\"")
			}
		case "generalHealth":
			if err := func() error {
				s.GeneralHealth.Reset()
				if err := s.GeneralHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generalHealth\"")
			}
		case "certificateHealth":
			if err := func() error {
				s.CertificateHealth.Reset()
				if err := s.CertificateHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateHealth\"")
			}
		case "passwordHealth":
			if err := func() error {
				s.PasswordHealth.Reset()
				if err := s.PasswordHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passwordHealth\"")
			}
		case "connectivityHealth":
			if err := func() error {
				s.ConnectivityHealth.Reset()
				if err := s.ConnectivityHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectivityHealth\"")
			}
		case "computeHealth":
			if err := func() error {
				s.ComputeHealth.Reset()
				if err := s.ComputeHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"computeHealth\"")
			}
		case "storageHealth":
			if err := func() error {
				s.StorageHealth.Reset()
				if err := s.StorageHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageHealth\"")
			}
		case "dnsHealth":
			if err := func() error {
				s.DnsHealth.Reset()
				if err := s.DnsHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dnsHealth\"")
			}
		case "hardwareCompatibilityHealth":
			if err := func() error {
				s.HardwareCompatibilityHealth.Reset()
				if err := s.HardwareCompatibilityHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hardwareCompatibilityHealth\"")
			}
		case "versionHealth":
			if err := func() error {
				s.VersionHealth.Reset()
				if err := s.VersionHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versionHealth\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthChecks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthSummary) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.CreationTimestamp.Set {
			e.FieldStart("creationTimestamp")
			s.CreationTimestamp.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.BundleAvailable.Set {
			e.FieldStart("bundleAvailable")
			s.BundleAvailable.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CompletionTimestamp.Set {
			e.FieldStart("completionTimestamp")
			s.CompletionTimestamp.Encode(e)
		}
	}
	{
		if s.BundleName.Set {
			e.FieldStart("bundleName")
			s.BundleName.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthSummary = [7]string{
	0: "status",
	1: "creationTimestamp",
	2: "description",
	3: "bundleAvailable",
	4: "id",
	5: "completionTimestamp",
	6: "bundleName",
}

// Decode decodes HealthSummary from json.
func (s *HealthSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "creationTimestamp":
			if err := func() error {
				s.CreationTimestamp.Reset()
				if err := s.CreationTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "bundleAvailable":
			if err := func() error {
				s.BundleAvailable.Reset()
				if err := s.BundleAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleAvailable\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "completionTimestamp":
			if err := func() error {
				s.CompletionTimestamp.Reset()
				if err := s.CompletionTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTimestamp\"")
			}
		case "bundleName":
			if err := func() error {
				s.BundleName.Reset()
				if err := s.BundleName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthSummaryConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthSummaryConfig) encodeFields(e *jx.Encoder) {
	{
		if s.SkipKnownHostCheck.Set {
			e.FieldStart("skipKnownHostCheck")
			s.SkipKnownHostCheck.Encode(e)
		}
	}
	{
		if s.Force.Set {
			e.FieldStart("force")
			s.Force.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthSummaryConfig = [2]string{
	0: "skipKnownHostCheck",
	1: "force",
}

// Decode decodes HealthSummaryConfig from json.
func (s *HealthSummaryConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthSummaryConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "skipKnownHostCheck":
			if err := func() error {
				s.SkipKnownHostCheck.Reset()
				if err := s.SkipKnownHostCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skipKnownHostCheck\"")
			}
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthSummaryConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthSummaryConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthSummaryConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthSummaryIncludeItems) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthSummaryIncludeItems) encodeFields(e *jx.Encoder) {
	{
		if s.SummaryReport.Set {
			e.FieldStart("summaryReport")
			s.SummaryReport.Encode(e)
		}
	}
	{
		if s.PrecheckReport.Set {
			e.FieldStart("precheckReport")
			s.PrecheckReport.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthSummaryIncludeItems = [2]string{
	0: "summaryReport",
	1: "precheckReport",
}

// Decode decodes HealthSummaryIncludeItems from json.
func (s *HealthSummaryIncludeItems) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthSummaryIncludeItems to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "summaryReport":
			if err := func() error {
				s.SummaryReport.Reset()
				if err := s.SummaryReport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summaryReport\"")
			}
		case "precheckReport":
			if err := func() error {
				s.PrecheckReport.Reset()
				if err := s.PrecheckReport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"precheckReport\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthSummaryIncludeItems")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthSummaryIncludeItems) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthSummaryIncludeItems) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthSummaryOption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthSummaryOption) encodeFields(e *jx.Encoder) {
	{
		if s.Config.Set {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
	{
		if s.Include.Set {
			e.FieldStart("include")
			s.Include.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthSummaryOption = [2]string{
	0: "config",
	1: "include",
}

// Decode decodes HealthSummaryOption from json.
func (s *HealthSummaryOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthSummaryOption to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "include":
			if err := func() error {
				s.Include.Reset()
				if err := s.Include.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthSummaryOption")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthSummaryOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthSummaryOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthSummaryScope) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthSummaryScope) encodeFields(e *jx.Encoder) {
	{
		if s.IncludeFreeHosts.Set {
			e.FieldStart("includeFreeHosts")
			s.IncludeFreeHosts.Encode(e)
		}
	}
	{
		if s.IncludeAllDomains.Set {
			e.FieldStart("includeAllDomains")
			s.IncludeAllDomains.Encode(e)
		}
	}
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHealthSummaryScope = [3]string{
	0: "includeFreeHosts",
	1: "includeAllDomains",
	2: "domains",
}

// Decode decodes HealthSummaryScope from json.
func (s *HealthSummaryScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthSummaryScope to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "includeFreeHosts":
			if err := func() error {
				s.IncludeFreeHosts.Reset()
				if err := s.IncludeFreeHosts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeFreeHosts\"")
			}
		case "includeAllDomains":
			if err := func() error {
				s.IncludeAllDomains.Reset()
				if err := s.IncludeAllDomains.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeAllDomains\"")
			}
		case "domains":
			if err := func() error {
				s.Domains = make([]Domains, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Domains
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthSummaryScope")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthSummaryScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthSummaryScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthSummarySpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthSummarySpec) encodeFields(e *jx.Encoder) {
	{
		if s.Options.Set {
			e.FieldStart("options")
			s.Options.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.HealthChecks.Set {
			e.FieldStart("healthChecks")
			s.HealthChecks.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthSummarySpec = [3]string{
	0: "options",
	1: "scope",
	2: "healthChecks",
}

// Decode decodes HealthSummarySpec from json.
func (s *HealthSummarySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthSummarySpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "options":
			if err := func() error {
				s.Options.Reset()
				if err := s.Options.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "healthChecks":
			if err := func() error {
				s.HealthChecks.Reset()
				if err := s.HealthChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthChecks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthSummarySpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthSummarySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthSummarySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HighAvailability) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HighAvailability) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfHighAvailability = [1]string{
	0: "enabled",
}

// Decode decodes HighAvailability from json.
func (s *HighAvailability) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HighAvailability to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HighAvailability")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHighAvailability) {
					name = jsonFieldsNameOfHighAvailability[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HighAvailability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HighAvailability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *History) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *History) encodeFields(e *jx.Encoder) {
	{
		if s.Versions != nil {
			e.FieldStart("versions")
			e.ArrStart()
			for _, elem := range s.Versions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHistory = [1]string{
	0: "versions",
}

// Decode decodes History from json.
func (s *History) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode History to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "versions":
			if err := func() error {
				s.Versions = make([]Version, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Version
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode History")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *History) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *History) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Host) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Host) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.SerialNumber.Set {
			e.FieldStart("serialNumber")
			s.SerialNumber.Encode(e)
		}
	}
	{
		if s.EsxiVersion.Set {
			e.FieldStart("esxiVersion")
			s.EsxiVersion.Encode(e)
		}
	}
	{
		if s.SshThumbprint.Set {
			e.FieldStart("sshThumbprint")
			s.SshThumbprint.Encode(e)
		}
	}
	{
		if s.SslThumbprint.Set {
			e.FieldStart("sslThumbprint")
			s.SslThumbprint.Encode(e)
		}
	}
	{
		if s.Fqdn.Set {
			e.FieldStart("fqdn")
			s.Fqdn.Encode(e)
		}
	}
	{
		if s.HardwareVendor.Set {
			e.FieldStart("hardwareVendor")
			s.HardwareVendor.Encode(e)
		}
	}
	{
		if s.HardwareModel.Set {
			e.FieldStart("hardwareModel")
			s.HardwareModel.Encode(e)
		}
	}
	{
		if s.IsPrimary.Set {
			e.FieldStart("isPrimary")
			s.IsPrimary.Encode(e)
		}
	}
	{
		if s.IsVsanEsaEligible.Set {
			e.FieldStart("isVsanEsaEligible")
			s.IsVsanEsaEligible.Encode(e)
		}
	}
	{
		if s.IpAddresses != nil {
			e.FieldStart("ipAddresses")
			e.ArrStart()
			for _, elem := range s.IpAddresses {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CPU.Set {
			e.FieldStart("cpu")
			s.CPU.Encode(e)
		}
	}
	{
		if s.Memory.Set {
			e.FieldStart("memory")
			s.Memory.Encode(e)
		}
	}
	{
		if s.Storage.Set {
			e.FieldStart("storage")
			s.Storage.Encode(e)
		}
	}
	{
		if s.PhysicalNics != nil {
			e.FieldStart("physicalNics")
			e.ArrStart()
			for _, elem := range s.PhysicalNics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Networks != nil {
			e.FieldStart("networks")
			e.ArrStart()
			for _, elem := range s.Networks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostNetworks != nil {
			e.FieldStart("hostNetworks")
			e.ArrStart()
			for _, elem := range s.HostNetworks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.Networkpool.Set {
			e.FieldStart("networkpool")
			s.Networkpool.Encode(e)
		}
	}
	{
		if s.Cluster.Set {
			e.FieldStart("cluster")
			s.Cluster.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.CompatibleStorageType.Set {
			e.FieldStart("compatibleStorageType")
			s.CompatibleStorageType.Encode(e)
		}
	}
	{
		if s.BundleRepoDatastore.Set {
			e.FieldStart("bundleRepoDatastore")
			s.BundleRepoDatastore.Encode(e)
		}
	}
	{
		if s.Hybrid.Set {
			e.FieldStart("hybrid")
			s.Hybrid.Encode(e)
		}
	}
	{
		if s.SoftwareInfo.Set {
			e.FieldStart("softwareInfo")
			s.SoftwareInfo.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ConfigurationStatus.Set {
			e.FieldStart("configurationStatus")
			s.ConfigurationStatus.Encode(e)
		}
	}
	{
		if s.DatastoreType.Set {
			e.FieldStart("datastoreType")
			s.DatastoreType.Encode(e)
		}
	}
}

var jsonFieldsNameOfHost = [28]string{
	0:  "id",
	1:  "serialNumber",
	2:  "esxiVersion",
	3:  "sshThumbprint",
	4:  "sslThumbprint",
	5:  "fqdn",
	6:  "hardwareVendor",
	7:  "hardwareModel",
	8:  "isPrimary",
	9:  "isVsanEsaEligible",
	10: "ipAddresses",
	11: "cpu",
	12: "memory",
	13: "storage",
	14: "physicalNics",
	15: "networks",
	16: "hostNetworks",
	17: "domain",
	18: "networkpool",
	19: "cluster",
	20: "status",
	21: "compatibleStorageType",
	22: "bundleRepoDatastore",
	23: "hybrid",
	24: "softwareInfo",
	25: "tags",
	26: "configurationStatus",
	27: "datastoreType",
}

// Decode decodes Host from json.
func (s *Host) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Host to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "serialNumber":
			if err := func() error {
				s.SerialNumber.Reset()
				if err := s.SerialNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serialNumber\"")
			}
		case "esxiVersion":
			if err := func() error {
				s.EsxiVersion.Reset()
				if err := s.EsxiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"esxiVersion\"")
			}
		case "sshThumbprint":
			if err := func() error {
				s.SshThumbprint.Reset()
				if err := s.SshThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sshThumbprint\"")
			}
		case "sslThumbprint":
			if err := func() error {
				s.SslThumbprint.Reset()
				if err := s.SslThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sslThumbprint\"")
			}
		case "fqdn":
			if err := func() error {
				s.Fqdn.Reset()
				if err := s.Fqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "hardwareVendor":
			if err := func() error {
				s.HardwareVendor.Reset()
				if err := s.HardwareVendor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hardwareVendor\"")
			}
		case "hardwareModel":
			if err := func() error {
				s.HardwareModel.Reset()
				if err := s.HardwareModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hardwareModel\"")
			}
		case "isPrimary":
			if err := func() error {
				s.IsPrimary.Reset()
				if err := s.IsPrimary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isPrimary\"")
			}
		case "isVsanEsaEligible":
			if err := func() error {
				s.IsVsanEsaEligible.Reset()
				if err := s.IsVsanEsaEligible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isVsanEsaEligible\"")
			}
		case "ipAddresses":
			if err := func() error {
				s.IpAddresses = make([]IpAddress, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IpAddress
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IpAddresses = append(s.IpAddresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddresses\"")
			}
		case "cpu":
			if err := func() error {
				s.CPU.Reset()
				if err := s.CPU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu\"")
			}
		case "memory":
			if err := func() error {
				s.Memory.Reset()
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		case "storage":
			if err := func() error {
				s.Storage.Reset()
				if err := s.Storage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storage\"")
			}
		case "physicalNics":
			if err := func() error {
				s.PhysicalNics = make([]PhysicalNic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PhysicalNic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PhysicalNics = append(s.PhysicalNics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalNics\"")
			}
		case "networks":
			if err := func() error {
				s.Networks = make([]Network, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Network
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Networks = append(s.Networks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networks\"")
			}
		case "hostNetworks":
			if err := func() error {
				s.HostNetworks = make([]HostNetwork, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostNetwork
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HostNetworks = append(s.HostNetworks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostNetworks\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "networkpool":
			if err := func() error {
				s.Networkpool.Reset()
				if err := s.Networkpool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkpool\"")
			}
		case "cluster":
			if err := func() error {
				s.Cluster.Reset()
				if err := s.Cluster.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cluster\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "compatibleStorageType":
			if err := func() error {
				s.CompatibleStorageType.Reset()
				if err := s.CompatibleStorageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compatibleStorageType\"")
			}
		case "bundleRepoDatastore":
			if err := func() error {
				s.BundleRepoDatastore.Reset()
				if err := s.BundleRepoDatastore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleRepoDatastore\"")
			}
		case "hybrid":
			if err := func() error {
				s.Hybrid.Reset()
				if err := s.Hybrid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hybrid\"")
			}
		case "softwareInfo":
			if err := func() error {
				s.SoftwareInfo.Reset()
				if err := s.SoftwareInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"softwareInfo\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "configurationStatus":
			if err := func() error {
				s.ConfigurationStatus.Reset()
				if err := s.ConfigurationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configurationStatus\"")
			}
		case "datastoreType":
			if err := func() error {
				s.DatastoreType.Reset()
				if err := s.DatastoreType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datastoreType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Host")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Host) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Host) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostCommissionSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostCommissionSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fqdn")
		e.Str(s.Fqdn)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		e.FieldStart("storageType")
		e.Str(s.StorageType)
	}
	{
		if s.VvolStorageProtocolType.Set {
			e.FieldStart("vvolStorageProtocolType")
			s.VvolStorageProtocolType.Encode(e)
		}
	}
	{
		e.FieldStart("networkPoolId")
		e.Str(s.NetworkPoolId)
	}
	{
		if s.NetworkPoolName.Set {
			e.FieldStart("networkPoolName")
			s.NetworkPoolName.Encode(e)
		}
	}
	{
		if s.SshThumbprint.Set {
			e.FieldStart("sshThumbprint")
			s.SshThumbprint.Encode(e)
		}
	}
	{
		if s.SslThumbprint.Set {
			e.FieldStart("sslThumbprint")
			s.SslThumbprint.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostCommissionSpec = [9]string{
	0: "fqdn",
	1: "username",
	2: "password",
	3: "storageType",
	4: "vvolStorageProtocolType",
	5: "networkPoolId",
	6: "networkPoolName",
	7: "sshThumbprint",
	8: "sslThumbprint",
}

// Decode decodes HostCommissionSpec from json.
func (s *HostCommissionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostCommissionSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fqdn":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Fqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "storageType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.StorageType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageType\"")
			}
		case "vvolStorageProtocolType":
			if err := func() error {
				s.VvolStorageProtocolType.Reset()
				if err := s.VvolStorageProtocolType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vvolStorageProtocolType\"")
			}
		case "networkPoolId":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.NetworkPoolId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkPoolId\"")
			}
		case "networkPoolName":
			if err := func() error {
				s.NetworkPoolName.Reset()
				if err := s.NetworkPoolName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkPoolName\"")
			}
		case "sshThumbprint":
			if err := func() error {
				s.SshThumbprint.Reset()
				if err := s.SshThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sshThumbprint\"")
			}
		case "sslThumbprint":
			if err := func() error {
				s.SslThumbprint.Reset()
				if err := s.SslThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sslThumbprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostCommissionSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00101111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostCommissionSpec) {
					name = jsonFieldsNameOfHostCommissionSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostCommissionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostCommissionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostCriterion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostCriterion) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.SubCriteria != nil {
			e.FieldStart("subCriteria")
			e.ArrStart()
			for _, elem := range s.SubCriteria {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Arguments.Set {
			e.FieldStart("arguments")
			s.Arguments.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostCriterion = [4]string{
	0: "name",
	1: "subCriteria",
	2: "arguments",
	3: "description",
}

// Decode decodes HostCriterion from json.
func (s *HostCriterion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostCriterion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "subCriteria":
			if err := func() error {
				s.SubCriteria = make([]HostCriterion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostCriterion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SubCriteria = append(s.SubCriteria, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subCriteria\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments.Reset()
				if err := s.Arguments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostCriterion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostCriterion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostCriterion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HostCriterionArguments) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HostCriterionArguments) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes HostCriterionArguments from json.
func (s *HostCriterionArguments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostCriterionArguments to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostCriterionArguments")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HostCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostDecommissionSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostDecommissionSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fqdn")
		e.Str(s.Fqdn)
	}
}

var jsonFieldsNameOfHostDecommissionSpec = [1]string{
	0: "fqdn",
}

// Decode decodes HostDecommissionSpec from json.
func (s *HostDecommissionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostDecommissionSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fqdn":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Fqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostDecommissionSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostDecommissionSpec) {
					name = jsonFieldsNameOfHostDecommissionSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostDecommissionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostDecommissionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostDetail) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.HostName.Set {
			e.FieldStart("hostName")
			s.HostName.Encode(e)
		}
	}
	{
		if s.HostNetworkConfiguration.Set {
			e.FieldStart("hostNetworkConfiguration")
			s.HostNetworkConfiguration.Encode(e)
		}
	}
	{
		if s.AzName.Set {
			e.FieldStart("azName")
			s.AzName.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostDetail = [4]string{
	0: "id",
	1: "hostName",
	2: "hostNetworkConfiguration",
	3: "azName",
}

// Decode decodes HostDetail from json.
func (s *HostDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "hostName":
			if err := func() error {
				s.HostName.Reset()
				if err := s.HostName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostName\"")
			}
		case "hostNetworkConfiguration":
			if err := func() error {
				s.HostNetworkConfiguration.Reset()
				if err := s.HostNetworkConfiguration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostNetworkConfiguration\"")
			}
		case "azName":
			if err := func() error {
				s.AzName.Reset()
				if err := s.AzName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostNetwork) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostNetwork) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("vlanId")
		e.Int32(s.VlanId)
	}
	{
		e.FieldStart("mtu")
		e.Int32(s.Mtu)
	}
}

var jsonFieldsNameOfHostNetwork = [3]string{
	0: "type",
	1: "vlanId",
	2: "mtu",
}

// Decode decodes HostNetwork from json.
func (s *HostNetwork) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostNetwork to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "vlanId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.VlanId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlanId\"")
			}
		case "mtu":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Mtu = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mtu\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostNetwork")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostNetwork) {
					name = jsonFieldsNameOfHostNetwork[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostNetwork) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostNetwork) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostNetworkConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostNetworkConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.VmNics != nil {
			e.FieldStart("vmNics")
			e.ArrStart()
			for _, elem := range s.VmNics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NetworkProfileName.Set {
			e.FieldStart("networkProfileName")
			s.NetworkProfileName.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostNetworkConfiguration = [2]string{
	0: "vmNics",
	1: "networkProfileName",
}

// Decode decodes HostNetworkConfiguration from json.
func (s *HostNetworkConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostNetworkConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vmNics":
			if err := func() error {
				s.VmNics = make([]HostVmnicUplinkConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostVmnicUplinkConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VmNics = append(s.VmNics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmNics\"")
			}
		case "networkProfileName":
			if err := func() error {
				s.NetworkProfileName.Reset()
				if err := s.NetworkProfileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkProfileName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostNetworkConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostNetworkConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostNetworkConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostNetworkSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostNetworkSpec) encodeFields(e *jx.Encoder) {
	{
		if s.VmNics != nil {
			e.FieldStart("vmNics")
			e.ArrStart()
			for _, elem := range s.VmNics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NetworkProfileName.Set {
			e.FieldStart("networkProfileName")
			s.NetworkProfileName.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostNetworkSpec = [2]string{
	0: "vmNics",
	1: "networkProfileName",
}

// Decode decodes HostNetworkSpec from json.
func (s *HostNetworkSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostNetworkSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vmNics":
			if err := func() error {
				s.VmNics = make([]VmNic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VmNic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VmNics = append(s.VmNics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmNics\"")
			}
		case "networkProfileName":
			if err := func() error {
				s.NetworkProfileName.Reset()
				if err := s.NetworkProfileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkProfileName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostNetworkSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostNetworkSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostNetworkSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostPrechecks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostPrechecks) encodeFields(e *jx.Encoder) {
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostPrechecks = [3]string{
	0: "host",
	1: "result",
	2: "error",
}

// Decode decodes HostPrechecks from json.
func (s *HostPrechecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostPrechecks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostPrechecks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostPrechecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostPrechecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostQueryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostQueryResponse) encodeFields(e *jx.Encoder) {
	{
		if s.QueryInfo.Set {
			e.FieldStart("queryInfo")
			s.QueryInfo.Encode(e)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostQueryResponse = [2]string{
	0: "queryInfo",
	1: "result",
}

// Decode decodes HostQueryResponse from json.
func (s *HostQueryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostQueryResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queryInfo":
			if err := func() error {
				s.QueryInfo.Reset()
				if err := s.QueryInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryInfo\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostQueryResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostQueryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostQueryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostReference) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.IpAddress.Set {
			e.FieldStart("ipAddress")
			s.IpAddress.Encode(e)
		}
	}
	{
		if s.Fqdn.Set {
			e.FieldStart("fqdn")
			s.Fqdn.Encode(e)
		}
	}
	{
		if s.VmNics != nil {
			e.FieldStart("vmNics")
			e.ArrStart()
			for _, elem := range s.VmNics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AzName.Set {
			e.FieldStart("azName")
			s.AzName.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostReference = [5]string{
	0: "id",
	1: "ipAddress",
	2: "fqdn",
	3: "vmNics",
	4: "azName",
}

// Decode decodes HostReference from json.
func (s *HostReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "ipAddress":
			if err := func() error {
				s.IpAddress.Reset()
				if err := s.IpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "fqdn":
			if err := func() error {
				s.Fqdn.Reset()
				if err := s.Fqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "vmNics":
			if err := func() error {
				s.VmNics = make([]VMNicInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VMNicInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VmNics = append(s.VmNics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmNics\"")
			}
		case "azName":
			if err := func() error {
				s.AzName.Reset()
				if err := s.AzName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostReference")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.LicenseKey.Set {
			e.FieldStart("licenseKey")
			s.LicenseKey.Encode(e)
		}
	}
	{
		if s.IpAddress.Set {
			e.FieldStart("ipAddress")
			s.IpAddress.Encode(e)
		}
	}
	{
		if s.HostName.Set {
			e.FieldStart("hostName")
			s.HostName.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.HostNetworkSpec.Set {
			e.FieldStart("hostNetworkSpec")
			s.HostNetworkSpec.Encode(e)
		}
	}
	{
		if s.AzName.Set {
			e.FieldStart("azName")
			s.AzName.Encode(e)
		}
	}
	{
		if s.SshThumbprint.Set {
			e.FieldStart("sshThumbprint")
			s.SshThumbprint.Encode(e)
		}
	}
	{
		if s.SerialNumber.Set {
			e.FieldStart("serialNumber")
			s.SerialNumber.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostSpec = [10]string{
	0: "id",
	1: "licenseKey",
	2: "ipAddress",
	3: "hostName",
	4: "username",
	5: "password",
	6: "hostNetworkSpec",
	7: "azName",
	8: "sshThumbprint",
	9: "serialNumber",
}

// Decode decodes HostSpec from json.
func (s *HostSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "licenseKey":
			if err := func() error {
				s.LicenseKey.Reset()
				if err := s.LicenseKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKey\"")
			}
		case "ipAddress":
			if err := func() error {
				s.IpAddress.Reset()
				if err := s.IpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "hostName":
			if err := func() error {
				s.HostName.Reset()
				if err := s.HostName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostName\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "hostNetworkSpec":
			if err := func() error {
				s.HostNetworkSpec.Reset()
				if err := s.HostNetworkSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostNetworkSpec\"")
			}
		case "azName":
			if err := func() error {
				s.AzName.Reset()
				if err := s.AzName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azName\"")
			}
		case "sshThumbprint":
			if err := func() error {
				s.SshThumbprint.Reset()
				if err := s.SshThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sshThumbprint\"")
			}
		case "serialNumber":
			if err := func() error {
				s.SerialNumber.Reset()
				if err := s.SerialNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serialNumber\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostSpec) {
					name = jsonFieldsNameOfHostSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostVmnicUplinkConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostVmnicUplinkConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.VdsName.Set {
			e.FieldStart("vdsName")
			s.VdsName.Encode(e)
		}
	}
	{
		if s.Uplink.Set {
			e.FieldStart("uplink")
			s.Uplink.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostVmnicUplinkConfiguration = [3]string{
	0: "id",
	1: "vdsName",
	2: "uplink",
}

// Decode decodes HostVmnicUplinkConfiguration from json.
func (s *HostVmnicUplinkConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostVmnicUplinkConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "vdsName":
			if err := func() error {
				s.VdsName.Reset()
				if err := s.VdsName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsName\"")
			}
		case "uplink":
			if err := func() error {
				s.Uplink.Reset()
				if err := s.Uplink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostVmnicUplinkConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostVmnicUplinkConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostVmnicUplinkConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsPrechecksRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsPrechecksRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Hosts != nil {
			e.FieldStart("hosts")
			e.ArrStart()
			for _, elem := range s.Hosts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsPrechecksRequest = [1]string{
	0: "hosts",
}

// Decode decodes HostsPrechecksRequest from json.
func (s *HostsPrechecksRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsPrechecksRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hosts":
			if err := func() error {
				s.Hosts = make([]HostCommissionSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostCommissionSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsPrechecksRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsPrechecksRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsPrechecksRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsPrechecksResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsPrechecksResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("executionStatus")
		e.Str(s.ExecutionStatus)
	}
	{
		e.FieldStart("result")
		e.Str(s.Result)
	}
	{
		if s.HostPrechecks != nil {
			e.FieldStart("hostPrechecks")
			e.ArrStart()
			for _, elem := range s.HostPrechecks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsPrechecksResponse = [4]string{
	0: "id",
	1: "executionStatus",
	2: "result",
	3: "hostPrechecks",
}

// Decode decodes HostsPrechecksResponse from json.
func (s *HostsPrechecksResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsPrechecksResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "executionStatus":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ExecutionStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executionStatus\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Result = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "hostPrechecks":
			if err := func() error {
				s.HostPrechecks = make([]HostPrechecks, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostPrechecks
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HostPrechecks = append(s.HostPrechecks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPrechecks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsPrechecksResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostsPrechecksResponse) {
					name = jsonFieldsNameOfHostsPrechecksResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsPrechecksResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsPrechecksResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IdentityProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IdentityProvider) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.DomainNames != nil {
			e.FieldStart("domainNames")
			e.ArrStart()
			for _, elem := range s.DomainNames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IdentitySources != nil {
			e.FieldStart("identitySources")
			e.ArrStart()
			for _, elem := range s.IdentitySources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ldap.Set {
			e.FieldStart("ldap")
			s.Ldap.Encode(e)
		}
	}
	{
		if s.Oidc.Set {
			e.FieldStart("oidc")
			s.Oidc.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.IdpMessage.Set {
			e.FieldStart("idpMessage")
			s.IdpMessage.Encode(e)
		}
	}
	{
		if s.FedIdp.Set {
			e.FieldStart("fedIdp")
			s.FedIdp.Encode(e)
		}
	}
}

var jsonFieldsNameOfIdentityProvider = [10]string{
	0: "id",
	1: "name",
	2: "type",
	3: "domainNames",
	4: "identitySources",
	5: "ldap",
	6: "oidc",
	7: "status",
	8: "idpMessage",
	9: "fedIdp",
}

// Decode decodes IdentityProvider from json.
func (s *IdentityProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IdentityProvider to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "domainNames":
			if err := func() error {
				s.DomainNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DomainNames = append(s.DomainNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainNames\"")
			}
		case "identitySources":
			if err := func() error {
				s.IdentitySources = make([]VcIdentitySources, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VcIdentitySources
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IdentitySources = append(s.IdentitySources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identitySources\"")
			}
		case "ldap":
			if err := func() error {
				s.Ldap.Reset()
				if err := s.Ldap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ldap\"")
			}
		case "oidc":
			if err := func() error {
				s.Oidc.Reset()
				if err := s.Oidc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidc\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "idpMessage":
			if err := func() error {
				s.IdpMessage.Reset()
				if err := s.IdpMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"idpMessage\"")
			}
		case "fedIdp":
			if err := func() error {
				s.FedIdp.Reset()
				if err := s.FedIdp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fedIdp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IdentityProvider")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IdentityProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IdentityProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IdentityProviderDirectory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IdentityProviderDirectory) encodeFields(e *jx.Encoder) {
	{
		if s.DirectoryId.Set {
			e.FieldStart("directoryId")
			s.DirectoryId.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("defaultDomain")
		e.Str(s.DefaultDomain)
	}
	{
		e.FieldStart("domains")
		e.ArrStart()
		for _, elem := range s.Domains {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("federatedIdpSourceType")
		e.Str(s.FederatedIdpSourceType)
	}
}

var jsonFieldsNameOfIdentityProviderDirectory = [5]string{
	0: "directoryId",
	1: "name",
	2: "defaultDomain",
	3: "domains",
	4: "federatedIdpSourceType",
}

// Decode decodes IdentityProviderDirectory from json.
func (s *IdentityProviderDirectory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IdentityProviderDirectory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "directoryId":
			if err := func() error {
				s.DirectoryId.Reset()
				if err := s.DirectoryId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"directoryId\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "defaultDomain":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DefaultDomain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultDomain\"")
			}
		case "domains":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Domains = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "federatedIdpSourceType":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.FederatedIdpSourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"federatedIdpSourceType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IdentityProviderDirectory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIdentityProviderDirectory) {
					name = jsonFieldsNameOfIdentityProviderDirectory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IdentityProviderDirectory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IdentityProviderDirectory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IdentityProviderPrecheckResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IdentityProviderPrecheckResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			e.ArrStart()
			for _, elem := range s.Details {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIdentityProviderPrecheckResult = [2]string{
	0: "status",
	1: "details",
}

// Decode decodes IdentityProviderPrecheckResult from json.
func (s *IdentityProviderPrecheckResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IdentityProviderPrecheckResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "details":
			if err := func() error {
				s.Details = make([]Details, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Details
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Details = append(s.Details, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IdentityProviderPrecheckResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIdentityProviderPrecheckResult) {
					name = jsonFieldsNameOfIdentityProviderPrecheckResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IdentityProviderPrecheckResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IdentityProviderPrecheckResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ImportVdsSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ImportVdsSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("listOfVdsDetails")
		e.ArrStart()
		for _, elem := range s.ListOfVdsDetails {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfImportVdsSpec = [1]string{
	0: "listOfVdsDetails",
}

// Decode decodes ImportVdsSpec from json.
func (s *ImportVdsSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportVdsSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "listOfVdsDetails":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ListOfVdsDetails = make([]VdsDetail, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VdsDetail
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ListOfVdsDetails = append(s.ListOfVdsDetails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"listOfVdsDetails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ImportVdsSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfImportVdsSpec) {
					name = jsonFieldsNameOfImportVdsSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ImportVdsSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImportVdsSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ImportVdsToInventoryBadRequest as json.
func (s *ImportVdsToInventoryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ImportVdsToInventoryBadRequest from json.
func (s *ImportVdsToInventoryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportVdsToInventoryBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ImportVdsToInventoryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ImportVdsToInventoryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImportVdsToInventoryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ImportVdsToInventoryInternalServerError as json.
func (s *ImportVdsToInventoryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ImportVdsToInventoryInternalServerError from json.
func (s *ImportVdsToInventoryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportVdsToInventoryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ImportVdsToInventoryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ImportVdsToInventoryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImportVdsToInventoryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InventoryMismatchInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InventoryMismatchInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.InventoryObjects != nil {
			e.FieldStart("inventoryObjects")
			e.ArrStart()
			for _, elem := range s.InventoryObjects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInventoryMismatchInfo = [2]string{
	0: "type",
	1: "inventoryObjects",
}

// Decode decodes InventoryMismatchInfo from json.
func (s *InventoryMismatchInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InventoryMismatchInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "inventoryObjects":
			if err := func() error {
				s.InventoryObjects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.InventoryObjects = append(s.InventoryObjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventoryObjects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InventoryMismatchInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InventoryMismatchInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InventoryMismatchInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IpAddress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IpAddress) encodeFields(e *jx.Encoder) {
	{
		if s.IpAddress.Set {
			e.FieldStart("ipAddress")
			s.IpAddress.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIpAddress = [2]string{
	0: "ipAddress",
	1: "type",
}

// Decode decodes IpAddress from json.
func (s *IpAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IpAddress to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddress":
			if err := func() error {
				s.IpAddress.Reset()
				if err := s.IpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IpAddress")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IpAddress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IpAddress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IpAddressPoolRangeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IpAddressPoolRangeSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("start")
		e.Str(s.Start)
	}
	{
		e.FieldStart("end")
		e.Str(s.End)
	}
}

var jsonFieldsNameOfIpAddressPoolRangeSpec = [2]string{
	0: "start",
	1: "end",
}

// Decode decodes IpAddressPoolRangeSpec from json.
func (s *IpAddressPoolRangeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IpAddressPoolRangeSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Start = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.End = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IpAddressPoolRangeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIpAddressPoolRangeSpec) {
					name = jsonFieldsNameOfIpAddressPoolRangeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IpAddressPoolRangeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IpAddressPoolRangeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IpAddressPoolSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IpAddressPoolSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.IgnoreUnavailableNsxtCluster.Set {
			e.FieldStart("ignoreUnavailableNsxtCluster")
			s.IgnoreUnavailableNsxtCluster.Encode(e)
		}
	}
	{
		if s.Subnets != nil {
			e.FieldStart("subnets")
			e.ArrStart()
			for _, elem := range s.Subnets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIpAddressPoolSpec = [4]string{
	0: "name",
	1: "description",
	2: "ignoreUnavailableNsxtCluster",
	3: "subnets",
}

// Decode decodes IpAddressPoolSpec from json.
func (s *IpAddressPoolSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IpAddressPoolSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "ignoreUnavailableNsxtCluster":
			if err := func() error {
				s.IgnoreUnavailableNsxtCluster.Reset()
				if err := s.IgnoreUnavailableNsxtCluster.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignoreUnavailableNsxtCluster\"")
			}
		case "subnets":
			if err := func() error {
				s.Subnets = make([]IpAddressPoolSubnetSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IpAddressPoolSubnetSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subnets = append(s.Subnets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subnets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IpAddressPoolSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIpAddressPoolSpec) {
					name = jsonFieldsNameOfIpAddressPoolSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IpAddressPoolSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IpAddressPoolSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IpAddressPoolSubnetSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IpAddressPoolSubnetSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ipAddressPoolRanges")
		e.ArrStart()
		for _, elem := range s.IpAddressPoolRanges {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("cidr")
		e.Str(s.Cidr)
	}
	{
		e.FieldStart("gateway")
		e.Str(s.Gateway)
	}
}

var jsonFieldsNameOfIpAddressPoolSubnetSpec = [3]string{
	0: "ipAddressPoolRanges",
	1: "cidr",
	2: "gateway",
}

// Decode decodes IpAddressPoolSubnetSpec from json.
func (s *IpAddressPoolSubnetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IpAddressPoolSubnetSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddressPoolRanges":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.IpAddressPoolRanges = make([]IpAddressPoolRangeSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IpAddressPoolRangeSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IpAddressPoolRanges = append(s.IpAddressPoolRanges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPoolRanges\"")
			}
		case "cidr":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Cidr = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cidr\"")
			}
		case "gateway":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Gateway = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IpAddressPoolSubnetSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIpAddressPoolSubnetSpec) {
					name = jsonFieldsNameOfIpAddressPoolSubnetSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IpAddressPoolSubnetSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IpAddressPoolSubnetSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IpAllocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IpAllocation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ipAddress")
		e.Str(s.IpAddress)
	}
	{
		if s.Gateway.Set {
			e.FieldStart("gateway")
			s.Gateway.Encode(e)
		}
	}
	{
		if s.Subnet.Set {
			e.FieldStart("subnet")
			s.Subnet.Encode(e)
		}
	}
	{
		if s.Cidr.Set {
			e.FieldStart("cidr")
			s.Cidr.Encode(e)
		}
	}
}

var jsonFieldsNameOfIpAllocation = [4]string{
	0: "ipAddress",
	1: "gateway",
	2: "subnet",
	3: "cidr",
}

// Decode decodes IpAllocation from json.
func (s *IpAllocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IpAllocation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IpAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "gateway":
			if err := func() error {
				s.Gateway.Reset()
				if err := s.Gateway.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		case "subnet":
			if err := func() error {
				s.Subnet.Reset()
				if err := s.Subnet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subnet\"")
			}
		case "cidr":
			if err := func() error {
				s.Cidr.Reset()
				if err := s.Cidr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cidr\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IpAllocation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIpAllocation) {
					name = jsonFieldsNameOfIpAllocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IpAllocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IpAllocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IpPool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IpPool) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("start")
		e.Str(s.Start)
	}
	{
		e.FieldStart("end")
		e.Str(s.End)
	}
}

var jsonFieldsNameOfIpPool = [2]string{
	0: "start",
	1: "end",
}

// Decode decodes IpPool from json.
func (s *IpPool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IpPool to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Start = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.End = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IpPool")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIpPool) {
					name = jsonFieldsNameOfIpPool[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IpPool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IpPool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IpRange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IpRange) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("startIpAddress")
		e.Str(s.StartIpAddress)
	}
	{
		e.FieldStart("endIpAddress")
		e.Str(s.EndIpAddress)
	}
}

var jsonFieldsNameOfIpRange = [2]string{
	0: "startIpAddress",
	1: "endIpAddress",
}

// Decode decodes IpRange from json.
func (s *IpRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IpRange to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "startIpAddress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.StartIpAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startIpAddress\"")
			}
		case "endIpAddress":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EndIpAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endIpAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IpRange")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIpRange) {
					name = jsonFieldsNameOfIpRange[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IpRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IpRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IsolationPrecheckResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IsolationPrecheckResult) encodeFields(e *jx.Encoder) {
	{
		if s.PrecheckFailures != nil {
			e.FieldStart("precheckFailures")
			e.ArrStart()
			for _, elem := range s.PrecheckFailures {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PrecheckWarnings != nil {
			e.FieldStart("precheckWarnings")
			e.ArrStart()
			for _, elem := range s.PrecheckWarnings {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Implications != nil {
			e.FieldStart("implications")
			e.ArrStart()
			for _, elem := range s.Implications {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("executionStatus")
		e.Str(s.ExecutionStatus)
	}
}

var jsonFieldsNameOfIsolationPrecheckResult = [4]string{
	0: "precheckFailures",
	1: "precheckWarnings",
	2: "implications",
	3: "executionStatus",
}

// Decode decodes IsolationPrecheckResult from json.
func (s *IsolationPrecheckResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IsolationPrecheckResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "precheckFailures":
			if err := func() error {
				s.PrecheckFailures = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PrecheckFailures = append(s.PrecheckFailures, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"precheckFailures\"")
			}
		case "precheckWarnings":
			if err := func() error {
				s.PrecheckWarnings = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PrecheckWarnings = append(s.PrecheckWarnings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"precheckWarnings\"")
			}
		case "implications":
			if err := func() error {
				s.Implications = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Implications = append(s.Implications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implications\"")
			}
		case "executionStatus":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ExecutionStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executionStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IsolationPrecheckResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIsolationPrecheckResult) {
					name = jsonFieldsNameOfIsolationPrecheckResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IsolationPrecheckResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IsolationPrecheckResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IsolationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IsolationSpec) encodeFields(e *jx.Encoder) {
	{
		if s.SsoDomainSpec.Set {
			e.FieldStart("ssoDomainSpec")
			s.SsoDomainSpec.Encode(e)
		}
	}
	{
		if s.DomainIdForIsolation.Set {
			e.FieldStart("domainIdForIsolation")
			s.DomainIdForIsolation.Encode(e)
		}
	}
	{
		if s.WorkloadDomainName.Set {
			e.FieldStart("workloadDomainName")
			s.WorkloadDomainName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIsolationSpec = [3]string{
	0: "ssoDomainSpec",
	1: "domainIdForIsolation",
	2: "workloadDomainName",
}

// Decode decodes IsolationSpec from json.
func (s *IsolationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IsolationSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ssoDomainSpec":
			if err := func() error {
				s.SsoDomainSpec.Reset()
				if err := s.SsoDomainSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssoDomainSpec\"")
			}
		case "domainIdForIsolation":
			if err := func() error {
				s.DomainIdForIsolation.Reset()
				if err := s.DomainIdForIsolation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainIdForIsolation\"")
			}
		case "workloadDomainName":
			if err := func() error {
				s.WorkloadDomainName.Reset()
				if err := s.WorkloadDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workloadDomainName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IsolationSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IsolationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IsolationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LdapInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LdapInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.DomainName.Set {
			e.FieldStart("domainName")
			s.DomainName.Encode(e)
		}
	}
	{
		if s.DomainAlias.Set {
			e.FieldStart("domainAlias")
			s.DomainAlias.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.SourceDetails.Set {
			e.FieldStart("sourceDetails")
			s.SourceDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfLdapInfo = [5]string{
	0: "type",
	1: "domainName",
	2: "domainAlias",
	3: "username",
	4: "sourceDetails",
}

// Decode decodes LdapInfo from json.
func (s *LdapInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LdapInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "domainName":
			if err := func() error {
				s.DomainName.Reset()
				if err := s.DomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainName\"")
			}
		case "domainAlias":
			if err := func() error {
				s.DomainAlias.Reset()
				if err := s.DomainAlias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainAlias\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "sourceDetails":
			if err := func() error {
				s.SourceDetails.Reset()
				if err := s.SourceDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDetails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LdapInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LdapInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LdapInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicenseKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicenseKey) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("productType")
		e.Str(s.ProductType)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.ProductVersion.Set {
			e.FieldStart("productVersion")
			s.ProductVersion.Encode(e)
		}
	}
	{
		if s.IsUnlimited.Set {
			e.FieldStart("isUnlimited")
			s.IsUnlimited.Encode(e)
		}
	}
	{
		if s.LicenseKeyUsage.Set {
			e.FieldStart("licenseKeyUsage")
			s.LicenseKeyUsage.Encode(e)
		}
	}
	{
		if s.LicenseKeyValidity.Set {
			e.FieldStart("licenseKeyValidity")
			s.LicenseKeyValidity.Encode(e)
		}
	}
	{
		if s.Features != nil {
			e.FieldStart("features")
			e.ArrStart()
			for _, elem := range s.Features {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LicenseEdition.Set {
			e.FieldStart("licenseEdition")
			s.LicenseEdition.Encode(e)
		}
	}
	{
		if s.LicenseUnit.Set {
			e.FieldStart("licenseUnit")
			s.LicenseUnit.Encode(e)
		}
	}
	{
		if s.MinimumCore.Set {
			e.FieldStart("minimumCore")
			s.MinimumCore.Encode(e)
		}
	}
}

var jsonFieldsNameOfLicenseKey = [12]string{
	0:  "id",
	1:  "key",
	2:  "productType",
	3:  "description",
	4:  "productVersion",
	5:  "isUnlimited",
	6:  "licenseKeyUsage",
	7:  "licenseKeyValidity",
	8:  "features",
	9:  "licenseEdition",
	10: "licenseUnit",
	11: "minimumCore",
}

// Decode decodes LicenseKey from json.
func (s *LicenseKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseKey to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "productType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ProductType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productType\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "productVersion":
			if err := func() error {
				s.ProductVersion.Reset()
				if err := s.ProductVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productVersion\"")
			}
		case "isUnlimited":
			if err := func() error {
				s.IsUnlimited.Reset()
				if err := s.IsUnlimited.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isUnlimited\"")
			}
		case "licenseKeyUsage":
			if err := func() error {
				s.LicenseKeyUsage.Reset()
				if err := s.LicenseKeyUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKeyUsage\"")
			}
		case "licenseKeyValidity":
			if err := func() error {
				s.LicenseKeyValidity.Reset()
				if err := s.LicenseKeyValidity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKeyValidity\"")
			}
		case "features":
			if err := func() error {
				s.Features = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Features = append(s.Features, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"features\"")
			}
		case "licenseEdition":
			if err := func() error {
				s.LicenseEdition.Reset()
				if err := s.LicenseEdition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseEdition\"")
			}
		case "licenseUnit":
			if err := func() error {
				s.LicenseUnit.Reset()
				if err := s.LicenseUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseUnit\"")
			}
		case "minimumCore":
			if err := func() error {
				s.MinimumCore.Reset()
				if err := s.MinimumCore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimumCore\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseKey")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicenseKey) {
					name = jsonFieldsNameOfLicenseKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicenseKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicenseKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicenseKeyUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicenseKeyUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfLicenseKeyUpdateSpec = [1]string{
	0: "description",
}

// Decode decodes LicenseKeyUpdateSpec from json.
func (s *LicenseKeyUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseKeyUpdateSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseKeyUpdateSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicenseKeyUpdateSpec) {
					name = jsonFieldsNameOfLicenseKeyUpdateSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicenseKeyUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicenseKeyUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicenseKeyUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicenseKeyUsage) encodeFields(e *jx.Encoder) {
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Remaining.Set {
			e.FieldStart("remaining")
			s.Remaining.Encode(e)
		}
	}
	{
		if s.Used.Set {
			e.FieldStart("used")
			s.Used.Encode(e)
		}
	}
	{
		if s.LicenseUnit.Set {
			e.FieldStart("licenseUnit")
			s.LicenseUnit.Encode(e)
		}
	}
}

var jsonFieldsNameOfLicenseKeyUsage = [4]string{
	0: "total",
	1: "remaining",
	2: "used",
	3: "licenseUnit",
}

// Decode decodes LicenseKeyUsage from json.
func (s *LicenseKeyUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseKeyUsage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "remaining":
			if err := func() error {
				s.Remaining.Reset()
				if err := s.Remaining.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining\"")
			}
		case "used":
			if err := func() error {
				s.Used.Reset()
				if err := s.Used.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		case "licenseUnit":
			if err := func() error {
				s.LicenseUnit.Reset()
				if err := s.LicenseUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseUnit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseKeyUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicenseKeyUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicenseKeyUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicenseKeyValidity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicenseKeyValidity) encodeFields(e *jx.Encoder) {
	{
		if s.LicenseKeyStatus.Set {
			e.FieldStart("licenseKeyStatus")
			s.LicenseKeyStatus.Encode(e)
		}
	}
	{
		if s.ExpiryDate.Set {
			e.FieldStart("expiryDate")
			s.ExpiryDate.Encode(e)
		}
	}
}

var jsonFieldsNameOfLicenseKeyValidity = [2]string{
	0: "licenseKeyStatus",
	1: "expiryDate",
}

// Decode decodes LicenseKeyValidity from json.
func (s *LicenseKeyValidity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseKeyValidity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "licenseKeyStatus":
			if err := func() error {
				s.LicenseKeyStatus.Reset()
				if err := s.LicenseKeyStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKeyStatus\"")
			}
		case "expiryDate":
			if err := func() error {
				s.ExpiryDate.Reset()
				if err := s.ExpiryDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiryDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseKeyValidity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicenseKeyValidity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicenseKeyValidity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicensingInfoReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicensingInfoReference) encodeFields(e *jx.Encoder) {
	{
		if s.LicensingMode.Set {
			e.FieldStart("licensingMode")
			s.LicensingMode.Encode(e)
		}
	}
	{
		if s.SubscriptionStatus.Set {
			e.FieldStart("subscriptionStatus")
			s.SubscriptionStatus.Encode(e)
		}
	}
	{
		if s.IsRegistered.Set {
			e.FieldStart("isRegistered")
			s.IsRegistered.Encode(e)
		}
	}
	{
		if s.IsSubscribed.Set {
			e.FieldStart("isSubscribed")
			s.IsSubscribed.Encode(e)
		}
	}
	{
		if s.DaysRemainingToSubscribe.Set {
			e.FieldStart("daysRemainingToSubscribe")
			s.DaysRemainingToSubscribe.Encode(e)
		}
	}
}

var jsonFieldsNameOfLicensingInfoReference = [5]string{
	0: "licensingMode",
	1: "subscriptionStatus",
	2: "isRegistered",
	3: "isSubscribed",
	4: "daysRemainingToSubscribe",
}

// Decode decodes LicensingInfoReference from json.
func (s *LicensingInfoReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicensingInfoReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "licensingMode":
			if err := func() error {
				s.LicensingMode.Reset()
				if err := s.LicensingMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licensingMode\"")
			}
		case "subscriptionStatus":
			if err := func() error {
				s.SubscriptionStatus.Reset()
				if err := s.SubscriptionStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionStatus\"")
			}
		case "isRegistered":
			if err := func() error {
				s.IsRegistered.Reset()
				if err := s.IsRegistered.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isRegistered\"")
			}
		case "isSubscribed":
			if err := func() error {
				s.IsSubscribed.Reset()
				if err := s.IsSubscribed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSubscribed\"")
			}
		case "daysRemainingToSubscribe":
			if err := func() error {
				s.DaysRemainingToSubscribe.Reset()
				if err := s.DaysRemainingToSubscribe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysRemainingToSubscribe\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicensingInfoReference")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicensingInfoReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicensingInfoReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicensingSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicensingSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceLicensingInfos")
		e.ArrStart()
		for _, elem := range s.ResourceLicensingInfos {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfLicensingSpec = [1]string{
	0: "resourceLicensingInfos",
}

// Decode decodes LicensingSpec from json.
func (s *LicensingSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicensingSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceLicensingInfos":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ResourceLicensingInfos = make([]ResourceLicensingInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourceLicensingInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResourceLicensingInfos = append(s.ResourceLicensingInfos, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceLicensingInfos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicensingSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicensingSpec) {
					name = jsonFieldsNameOfLicensingSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicensingSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicensingSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LocalAccountPasswordInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LocalAccountPasswordInfo) encodeFields(e *jx.Encoder) {
	{
		if s.OldPassword.Set {
			e.FieldStart("oldPassword")
			s.OldPassword.Encode(e)
		}
	}
	{
		e.FieldStart("newPassword")
		e.Str(s.NewPassword)
	}
}

var jsonFieldsNameOfLocalAccountPasswordInfo = [2]string{
	0: "oldPassword",
	1: "newPassword",
}

// Decode decodes LocalAccountPasswordInfo from json.
func (s *LocalAccountPasswordInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocalAccountPasswordInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "oldPassword":
			if err := func() error {
				s.OldPassword.Reset()
				if err := s.OldPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oldPassword\"")
			}
		case "newPassword":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NewPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"newPassword\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LocalAccountPasswordInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLocalAccountPasswordInfo) {
					name = jsonFieldsNameOfLocalAccountPasswordInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LocalAccountPasswordInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocalAccountPasswordInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LocalOsUserAccount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LocalOsUserAccount) encodeFields(e *jx.Encoder) {
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.LastPasswordChange.Set {
			e.FieldStart("lastPasswordChange")
			s.LastPasswordChange.Encode(e)
		}
	}
	{
		if s.PasswordExpiresAt.Set {
			e.FieldStart("passwordExpiresAt")
			s.PasswordExpiresAt.Encode(e)
		}
	}
	{
		if s.PasswordInactiveAt.Set {
			e.FieldStart("passwordInactiveAt")
			s.PasswordInactiveAt.Encode(e)
		}
	}
	{
		if s.AccountExpiresAt.Set {
			e.FieldStart("accountExpiresAt")
			s.AccountExpiresAt.Encode(e)
		}
	}
	{
		if s.MaxDaysBetweenPasswordChange.Set {
			e.FieldStart("maxDaysBetweenPasswordChange")
			s.MaxDaysBetweenPasswordChange.Encode(e)
		}
	}
	{
		if s.MinDaysBetweenPasswordChange.Set {
			e.FieldStart("minDaysBetweenPasswordChange")
			s.MinDaysBetweenPasswordChange.Encode(e)
		}
	}
	{
		if s.WarnDaysBeforePasswordExpiration.Set {
			e.FieldStart("warnDaysBeforePasswordExpiration")
			s.WarnDaysBeforePasswordExpiration.Encode(e)
		}
	}
}

var jsonFieldsNameOfLocalOsUserAccount = [8]string{
	0: "username",
	1: "lastPasswordChange",
	2: "passwordExpiresAt",
	3: "passwordInactiveAt",
	4: "accountExpiresAt",
	5: "maxDaysBetweenPasswordChange",
	6: "minDaysBetweenPasswordChange",
	7: "warnDaysBeforePasswordExpiration",
}

// Decode decodes LocalOsUserAccount from json.
func (s *LocalOsUserAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocalOsUserAccount to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "lastPasswordChange":
			if err := func() error {
				s.LastPasswordChange.Reset()
				if err := s.LastPasswordChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastPasswordChange\"")
			}
		case "passwordExpiresAt":
			if err := func() error {
				s.PasswordExpiresAt.Reset()
				if err := s.PasswordExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passwordExpiresAt\"")
			}
		case "passwordInactiveAt":
			if err := func() error {
				s.PasswordInactiveAt.Reset()
				if err := s.PasswordInactiveAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passwordInactiveAt\"")
			}
		case "accountExpiresAt":
			if err := func() error {
				s.AccountExpiresAt.Reset()
				if err := s.AccountExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountExpiresAt\"")
			}
		case "maxDaysBetweenPasswordChange":
			if err := func() error {
				s.MaxDaysBetweenPasswordChange.Reset()
				if err := s.MaxDaysBetweenPasswordChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxDaysBetweenPasswordChange\"")
			}
		case "minDaysBetweenPasswordChange":
			if err := func() error {
				s.MinDaysBetweenPasswordChange.Reset()
				if err := s.MinDaysBetweenPasswordChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minDaysBetweenPasswordChange\"")
			}
		case "warnDaysBeforePasswordExpiration":
			if err := func() error {
				s.WarnDaysBeforePasswordExpiration.Reset()
				if err := s.WarnDaysBeforePasswordExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warnDaysBeforePasswordExpiration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LocalOsUserAccount")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LocalOsUserAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocalOsUserAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LocalUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LocalUser) encodeFields(e *jx.Encoder) {
	{
		if s.IsConfigured.Set {
			e.FieldStart("isConfigured")
			s.IsConfigured.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.ApiKey.Set {
			e.FieldStart("apiKey")
			s.ApiKey.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		if s.CreationTimestamp.Set {
			e.FieldStart("creationTimestamp")
			s.CreationTimestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfLocalUser = [8]string{
	0: "isConfigured",
	1: "id",
	2: "name",
	3: "domain",
	4: "type",
	5: "apiKey",
	6: "role",
	7: "creationTimestamp",
}

// Decode decodes LocalUser from json.
func (s *LocalUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocalUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isConfigured":
			if err := func() error {
				s.IsConfigured.Reset()
				if err := s.IsConfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConfigured\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "apiKey":
			if err := func() error {
				s.ApiKey.Reset()
				if err := s.ApiKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKey\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "creationTimestamp":
			if err := func() error {
				s.CreationTimestamp.Reset()
				if err := s.CreationTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LocalUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01010100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLocalUser) {
					name = jsonFieldsNameOfLocalUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LocalUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocalUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LocalizableWarningPack) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LocalizableWarningPack) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("warningCode")
		e.Str(s.WarningCode)
	}
	{
		e.FieldStart("localBundle")
		e.Str(s.LocalBundle)
	}
	{
		e.FieldStart("vipComponent")
		e.Str(s.VipComponent)
	}
	{
		e.FieldStart("defaultMessage")
		e.Str(s.DefaultMessage)
	}
	{
		if s.Arguments != nil {
			e.FieldStart("arguments")
			e.ArrStart()
			for _, elem := range s.Arguments {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReferenceToken.Set {
			e.FieldStart("referenceToken")
			s.ReferenceToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfLocalizableWarningPack = [6]string{
	0: "warningCode",
	1: "localBundle",
	2: "vipComponent",
	3: "defaultMessage",
	4: "arguments",
	5: "referenceToken",
}

// Decode decodes LocalizableWarningPack from json.
func (s *LocalizableWarningPack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocalizableWarningPack to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "warningCode":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.WarningCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warningCode\"")
			}
		case "localBundle":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LocalBundle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localBundle\"")
			}
		case "vipComponent":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VipComponent = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vipComponent\"")
			}
		case "defaultMessage":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DefaultMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultMessage\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Arguments = append(s.Arguments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "referenceToken":
			if err := func() error {
				s.ReferenceToken.Reset()
				if err := s.ReferenceToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LocalizableWarningPack")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLocalizableWarningPack) {
					name = jsonFieldsNameOfLocalizableWarningPack[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LocalizableWarningPack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocalizableWarningPack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Logs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Logs) encodeFields(e *jx.Encoder) {
	{
		if s.VcLogs.Set {
			e.FieldStart("vcLogs")
			s.VcLogs.Encode(e)
		}
	}
	{
		if s.NsxLogs.Set {
			e.FieldStart("nsxLogs")
			s.NsxLogs.Encode(e)
		}
	}
	{
		if s.EsxLogs.Set {
			e.FieldStart("esxLogs")
			s.EsxLogs.Encode(e)
		}
	}
	{
		if s.WcpLogs.Set {
			e.FieldStart("wcpLogs")
			s.WcpLogs.Encode(e)
		}
	}
	{
		if s.SddcManagerLogs.Set {
			e.FieldStart("sddcManagerLogs")
			s.SddcManagerLogs.Encode(e)
		}
	}
	{
		if s.ApiLogs.Set {
			e.FieldStart("apiLogs")
			s.ApiLogs.Encode(e)
		}
	}
	{
		if s.VxrailManagerLogs.Set {
			e.FieldStart("vxrailManagerLogs")
			s.VxrailManagerLogs.Encode(e)
		}
	}
	{
		if s.SystemDebugLogs.Set {
			e.FieldStart("systemDebugLogs")
			s.SystemDebugLogs.Encode(e)
		}
	}
	{
		if s.VmScreenshots.Set {
			e.FieldStart("vmScreenshots")
			s.VmScreenshots.Encode(e)
		}
	}
	{
		if s.VraLogs.Set {
			e.FieldStart("vraLogs")
			s.VraLogs.Encode(e)
		}
	}
	{
		if s.VropsLogs.Set {
			e.FieldStart("vropsLogs")
			s.VropsLogs.Encode(e)
		}
	}
	{
		if s.VrliLogs.Set {
			e.FieldStart("vrliLogs")
			s.VrliLogs.Encode(e)
		}
	}
	{
		if s.VrslcmLogs.Set {
			e.FieldStart("vrslcmLogs")
			s.VrslcmLogs.Encode(e)
		}
	}
	{
		if s.AutomationLogs.Set {
			e.FieldStart("automationLogs")
			s.AutomationLogs.Encode(e)
		}
	}
	{
		if s.OperationsLogs.Set {
			e.FieldStart("operationsLogs")
			s.OperationsLogs.Encode(e)
		}
	}
	{
		if s.OperationsForLogs.Set {
			e.FieldStart("operationsForLogs")
			s.OperationsForLogs.Encode(e)
		}
	}
	{
		if s.LifecycleLogs.Set {
			e.FieldStart("lifecycleLogs")
			s.LifecycleLogs.Encode(e)
		}
	}
}

var jsonFieldsNameOfLogs = [17]string{
	0:  "vcLogs",
	1:  "nsxLogs",
	2:  "esxLogs",
	3:  "wcpLogs",
	4:  "sddcManagerLogs",
	5:  "apiLogs",
	6:  "vxrailManagerLogs",
	7:  "systemDebugLogs",
	8:  "vmScreenshots",
	9:  "vraLogs",
	10: "vropsLogs",
	11: "vrliLogs",
	12: "vrslcmLogs",
	13: "automationLogs",
	14: "operationsLogs",
	15: "operationsForLogs",
	16: "lifecycleLogs",
}

// Decode decodes Logs from json.
func (s *Logs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Logs to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcLogs":
			if err := func() error {
				s.VcLogs.Reset()
				if err := s.VcLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcLogs\"")
			}
		case "nsxLogs":
			if err := func() error {
				s.NsxLogs.Reset()
				if err := s.NsxLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxLogs\"")
			}
		case "esxLogs":
			if err := func() error {
				s.EsxLogs.Reset()
				if err := s.EsxLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"esxLogs\"")
			}
		case "wcpLogs":
			if err := func() error {
				s.WcpLogs.Reset()
				if err := s.WcpLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wcpLogs\"")
			}
		case "sddcManagerLogs":
			if err := func() error {
				s.SddcManagerLogs.Reset()
				if err := s.SddcManagerLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sddcManagerLogs\"")
			}
		case "apiLogs":
			if err := func() error {
				s.ApiLogs.Reset()
				if err := s.ApiLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiLogs\"")
			}
		case "vxrailManagerLogs":
			if err := func() error {
				s.VxrailManagerLogs.Reset()
				if err := s.VxrailManagerLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vxrailManagerLogs\"")
			}
		case "systemDebugLogs":
			if err := func() error {
				s.SystemDebugLogs.Reset()
				if err := s.SystemDebugLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"systemDebugLogs\"")
			}
		case "vmScreenshots":
			if err := func() error {
				s.VmScreenshots.Reset()
				if err := s.VmScreenshots.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmScreenshots\"")
			}
		case "vraLogs":
			if err := func() error {
				s.VraLogs.Reset()
				if err := s.VraLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vraLogs\"")
			}
		case "vropsLogs":
			if err := func() error {
				s.VropsLogs.Reset()
				if err := s.VropsLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vropsLogs\"")
			}
		case "vrliLogs":
			if err := func() error {
				s.VrliLogs.Reset()
				if err := s.VrliLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vrliLogs\"")
			}
		case "vrslcmLogs":
			if err := func() error {
				s.VrslcmLogs.Reset()
				if err := s.VrslcmLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vrslcmLogs\"")
			}
		case "automationLogs":
			if err := func() error {
				s.AutomationLogs.Reset()
				if err := s.AutomationLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"automationLogs\"")
			}
		case "operationsLogs":
			if err := func() error {
				s.OperationsLogs.Reset()
				if err := s.OperationsLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationsLogs\"")
			}
		case "operationsForLogs":
			if err := func() error {
				s.OperationsForLogs.Reset()
				if err := s.OperationsForLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationsForLogs\"")
			}
		case "lifecycleLogs":
			if err := func() error {
				s.LifecycleLogs.Reset()
				if err := s.LifecycleLogs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifecycleLogs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Logs")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Logs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Logs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Memory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Memory) encodeFields(e *jx.Encoder) {
	{
		if s.TotalCapacityMB.Set {
			e.FieldStart("totalCapacityMB")
			s.TotalCapacityMB.Encode(e)
		}
	}
	{
		if s.UsedCapacityMB.Set {
			e.FieldStart("usedCapacityMB")
			s.UsedCapacityMB.Encode(e)
		}
	}
}

var jsonFieldsNameOfMemory = [2]string{
	0: "totalCapacityMB",
	1: "usedCapacityMB",
}

// Decode decodes Memory from json.
func (s *Memory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Memory to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalCapacityMB":
			if err := func() error {
				s.TotalCapacityMB.Reset()
				if err := s.TotalCapacityMB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalCapacityMB\"")
			}
		case "usedCapacityMB":
			if err := func() error {
				s.UsedCapacityMB.Reset()
				if err := s.UsedCapacityMB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedCapacityMB\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Memory")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Memory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Memory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MemoryInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MemoryInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Used.Set {
			e.FieldStart("used")
			s.Used.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfMemoryInfo = [2]string{
	0: "used",
	1: "total",
}

// Decode decodes MemoryInfo from json.
func (s *MemoryInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MemoryInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "used":
			if err := func() error {
				s.Used.Reset()
				if err := s.Used.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MemoryInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MemoryInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MemoryInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MessagePack) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MessagePack) encodeFields(e *jx.Encoder) {
	{
		if s.Component.Set {
			e.FieldStart("component")
			s.Component.Encode(e)
		}
	}
	{
		e.FieldStart("messageKey")
		e.Str(s.MessageKey)
	}
	{
		if s.Arguments != nil {
			e.FieldStart("arguments")
			e.ArrStart()
			for _, elem := range s.Arguments {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Bundle.Set {
			e.FieldStart("bundle")
			s.Bundle.Encode(e)
		}
	}
}

var jsonFieldsNameOfMessagePack = [5]string{
	0: "component",
	1: "messageKey",
	2: "arguments",
	3: "message",
	4: "bundle",
}

// Decode decodes MessagePack from json.
func (s *MessagePack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MessagePack to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "component":
			if err := func() error {
				s.Component.Reset()
				if err := s.Component.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "messageKey":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MessageKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messageKey\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Arguments = append(s.Arguments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "bundle":
			if err := func() error {
				s.Bundle.Reset()
				if err := s.Bundle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundle\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MessagePack")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessagePack) {
					name = jsonFieldsNameOfMessagePack[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MessagePack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MessagePack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MicrosoftCertificateAuthoritySpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MicrosoftCertificateAuthoritySpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("secret")
		e.Str(s.Secret)
	}
	{
		e.FieldStart("serverUrl")
		e.Str(s.ServerUrl)
	}
	{
		e.FieldStart("templateName")
		e.Str(s.TemplateName)
	}
}

var jsonFieldsNameOfMicrosoftCertificateAuthoritySpec = [4]string{
	0: "username",
	1: "secret",
	2: "serverUrl",
	3: "templateName",
}

// Decode decodes MicrosoftCertificateAuthoritySpec from json.
func (s *MicrosoftCertificateAuthoritySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MicrosoftCertificateAuthoritySpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "secret":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Secret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "serverUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ServerUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverUrl\"")
			}
		case "templateName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TemplateName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MicrosoftCertificateAuthoritySpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMicrosoftCertificateAuthoritySpec) {
					name = jsonFieldsNameOfMicrosoftCertificateAuthoritySpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MicrosoftCertificateAuthoritySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MicrosoftCertificateAuthoritySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NasVolumeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NasVolumeSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("serverName")
		e.ArrStart()
		for _, elem := range s.ServerName {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("readOnly")
		e.Bool(s.ReadOnly)
	}
	{
		if s.UserTag.Set {
			e.FieldStart("userTag")
			s.UserTag.Encode(e)
		}
	}
}

var jsonFieldsNameOfNasVolumeSpec = [4]string{
	0: "serverName",
	1: "path",
	2: "readOnly",
	3: "userTag",
}

// Decode decodes NasVolumeSpec from json.
func (s *NasVolumeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NasVolumeSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "serverName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ServerName = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ServerName = append(s.ServerName, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverName\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "readOnly":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.ReadOnly = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "userTag":
			if err := func() error {
				s.UserTag.Reset()
				if err := s.UserTag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userTag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NasVolumeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNasVolumeSpec) {
					name = jsonFieldsNameOfNasVolumeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NasVolumeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NasVolumeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Network) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Network) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("vlanId")
		e.Int32(s.VlanId)
	}
	{
		e.FieldStart("mtu")
		e.Int32(s.Mtu)
	}
	{
		e.FieldStart("subnet")
		e.Str(s.Subnet)
	}
	{
		e.FieldStart("mask")
		e.Str(s.Mask)
	}
	{
		e.FieldStart("gateway")
		e.Str(s.Gateway)
	}
	{
		if s.IpPools != nil {
			e.FieldStart("ipPools")
			e.ArrStart()
			for _, elem := range s.IpPools {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FreeIps != nil {
			e.FieldStart("freeIps")
			e.ArrStart()
			for _, elem := range s.FreeIps {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.UsedIps != nil {
			e.FieldStart("usedIps")
			e.ArrStart()
			for _, elem := range s.UsedIps {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNetwork = [10]string{
	0: "id",
	1: "type",
	2: "vlanId",
	3: "mtu",
	4: "subnet",
	5: "mask",
	6: "gateway",
	7: "ipPools",
	8: "freeIps",
	9: "usedIps",
}

// Decode decodes Network from json.
func (s *Network) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Network to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "vlanId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.VlanId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlanId\"")
			}
		case "mtu":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Mtu = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mtu\"")
			}
		case "subnet":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subnet = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subnet\"")
			}
		case "mask":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Mask = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mask\"")
			}
		case "gateway":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Gateway = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		case "ipPools":
			if err := func() error {
				s.IpPools = make([]IpPool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IpPool
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IpPools = append(s.IpPools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipPools\"")
			}
		case "freeIps":
			if err := func() error {
				s.FreeIps = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FreeIps = append(s.FreeIps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"freeIps\"")
			}
		case "usedIps":
			if err := func() error {
				s.UsedIps = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.UsedIps = append(s.UsedIps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedIps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Network")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetwork) {
					name = jsonFieldsNameOfNetwork[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Network) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Network) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkDetailsSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkDetailsSpec) encodeFields(e *jx.Encoder) {
	{
		if s.IpAddress.Set {
			e.FieldStart("ipAddress")
			s.IpAddress.Encode(e)
		}
	}
	{
		e.FieldStart("dnsName")
		e.Str(s.DnsName)
	}
	{
		if s.Gateway.Set {
			e.FieldStart("gateway")
			s.Gateway.Encode(e)
		}
	}
	{
		if s.SubnetMask.Set {
			e.FieldStart("subnetMask")
			s.SubnetMask.Encode(e)
		}
	}
}

var jsonFieldsNameOfNetworkDetailsSpec = [4]string{
	0: "ipAddress",
	1: "dnsName",
	2: "gateway",
	3: "subnetMask",
}

// Decode decodes NetworkDetailsSpec from json.
func (s *NetworkDetailsSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkDetailsSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddress":
			if err := func() error {
				s.IpAddress.Reset()
				if err := s.IpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "dnsName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DnsName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dnsName\"")
			}
		case "gateway":
			if err := func() error {
				s.Gateway.Reset()
				if err := s.Gateway.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		case "subnetMask":
			if err := func() error {
				s.SubnetMask.Reset()
				if err := s.SubnetMask.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subnetMask\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkDetailsSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkDetailsSpec) {
					name = jsonFieldsNameOfNetworkDetailsSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkDetailsSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkDetailsSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkPool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkPool) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("networks")
		e.ArrStart()
		for _, elem := range s.Networks {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNetworkPool = [3]string{
	0: "id",
	1: "name",
	2: "networks",
}

// Decode decodes NetworkPool from json.
func (s *NetworkPool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkPool to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "networks":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Networks = make([]Network, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Network
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Networks = append(s.Networks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkPool")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkPool) {
					name = jsonFieldsNameOfNetworkPool[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkPool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkPool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkPoolReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkPoolReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfNetworkPoolReference = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes NetworkPoolReference from json.
func (s *NetworkPoolReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkPoolReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkPoolReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkPoolReference) {
					name = jsonFieldsNameOfNetworkPoolReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkPoolReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkPoolReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkPoolUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkPoolUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfNetworkPoolUpdateSpec = [1]string{
	0: "name",
}

// Decode decodes NetworkPoolUpdateSpec from json.
func (s *NetworkPoolUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkPoolUpdateSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkPoolUpdateSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkPoolUpdateSpec) {
					name = jsonFieldsNameOfNetworkPoolUpdateSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkPoolUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkPoolUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.IsDefault.Set {
			e.FieldStart("isDefault")
			s.IsDefault.Encode(e)
		}
	}
	{
		e.FieldStart("nsxtHostSwitchConfigs")
		e.ArrStart()
		for _, elem := range s.NsxtHostSwitchConfigs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNetworkProfile = [4]string{
	0: "name",
	1: "description",
	2: "isDefault",
	3: "nsxtHostSwitchConfigs",
}

// Decode decodes NetworkProfile from json.
func (s *NetworkProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "isDefault":
			if err := func() error {
				s.IsDefault.Reset()
				if err := s.IsDefault.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDefault\"")
			}
		case "nsxtHostSwitchConfigs":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.NsxtHostSwitchConfigs = make([]NsxtHostSwitchConfig, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtHostSwitchConfig
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxtHostSwitchConfigs = append(s.NsxtHostSwitchConfigs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtHostSwitchConfigs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkProfile) {
					name = jsonFieldsNameOfNetworkProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkProfileConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkProfileConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.IsDefault.Set {
			e.FieldStart("isDefault")
			s.IsDefault.Encode(e)
		}
	}
	{
		if s.NsxtHostSwitchConfigs != nil {
			e.FieldStart("nsxtHostSwitchConfigs")
			e.ArrStart()
			for _, elem := range s.NsxtHostSwitchConfigs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNetworkProfileConfiguration = [3]string{
	0: "name",
	1: "isDefault",
	2: "nsxtHostSwitchConfigs",
}

// Decode decodes NetworkProfileConfiguration from json.
func (s *NetworkProfileConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkProfileConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "isDefault":
			if err := func() error {
				s.IsDefault.Reset()
				if err := s.IsDefault.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDefault\"")
			}
		case "nsxtHostSwitchConfigs":
			if err := func() error {
				s.NsxtHostSwitchConfigs = make([]NsxtHostSwitchConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtHostSwitchConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxtHostSwitchConfigs = append(s.NsxtHostSwitchConfigs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtHostSwitchConfigs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkProfileConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkProfileConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkProfileConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkSpec) encodeFields(e *jx.Encoder) {
	{
		if s.VdsSpecs != nil {
			e.FieldStart("vdsSpecs")
			e.ArrStart()
			for _, elem := range s.VdsSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NsxClusterSpec.Set {
			e.FieldStart("nsxClusterSpec")
			s.NsxClusterSpec.Encode(e)
		}
	}
	{
		if s.NetworkProfiles != nil {
			e.FieldStart("networkProfiles")
			e.ArrStart()
			for _, elem := range s.NetworkProfiles {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNetworkSpec = [3]string{
	0: "vdsSpecs",
	1: "nsxClusterSpec",
	2: "networkProfiles",
}

// Decode decodes NetworkSpec from json.
func (s *NetworkSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vdsSpecs":
			if err := func() error {
				s.VdsSpecs = make([]VdsSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VdsSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VdsSpecs = append(s.VdsSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsSpecs\"")
			}
		case "nsxClusterSpec":
			if err := func() error {
				s.NsxClusterSpec.Reset()
				if err := s.NsxClusterSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxClusterSpec\"")
			}
		case "networkProfiles":
			if err := func() error {
				s.NetworkProfiles = make([]NetworkProfile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NetworkProfile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NetworkProfiles = append(s.NetworkProfiles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkProfiles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NfsDatastoreSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NfsDatastoreSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("datastoreName")
		e.Str(s.DatastoreName)
	}
	{
		e.FieldStart("nasVolume")
		s.NasVolume.Encode(e)
	}
}

var jsonFieldsNameOfNfsDatastoreSpec = [2]string{
	0: "datastoreName",
	1: "nasVolume",
}

// Decode decodes NfsDatastoreSpec from json.
func (s *NfsDatastoreSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NfsDatastoreSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "datastoreName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatastoreName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datastoreName\"")
			}
		case "nasVolume":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NasVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nasVolume\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NfsDatastoreSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNfsDatastoreSpec) {
					name = jsonFieldsNameOfNfsDatastoreSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NfsDatastoreSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NfsDatastoreSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NiocBandwidthAllocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NiocBandwidthAllocation) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.NiocTrafficResourceAllocation.Set {
			e.FieldStart("niocTrafficResourceAllocation")
			s.NiocTrafficResourceAllocation.Encode(e)
		}
	}
}

var jsonFieldsNameOfNiocBandwidthAllocation = [2]string{
	0: "type",
	1: "niocTrafficResourceAllocation",
}

// Decode decodes NiocBandwidthAllocation from json.
func (s *NiocBandwidthAllocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NiocBandwidthAllocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "niocTrafficResourceAllocation":
			if err := func() error {
				s.NiocTrafficResourceAllocation.Reset()
				if err := s.NiocTrafficResourceAllocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"niocTrafficResourceAllocation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NiocBandwidthAllocation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NiocBandwidthAllocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NiocBandwidthAllocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NiocBandwidthAllocationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NiocBandwidthAllocationSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("niocTrafficResourceAllocation")
		s.NiocTrafficResourceAllocation.Encode(e)
	}
}

var jsonFieldsNameOfNiocBandwidthAllocationSpec = [2]string{
	0: "type",
	1: "niocTrafficResourceAllocation",
}

// Decode decodes NiocBandwidthAllocationSpec from json.
func (s *NiocBandwidthAllocationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NiocBandwidthAllocationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "niocTrafficResourceAllocation":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NiocTrafficResourceAllocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"niocTrafficResourceAllocation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NiocBandwidthAllocationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNiocBandwidthAllocationSpec) {
					name = jsonFieldsNameOfNiocBandwidthAllocationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NiocBandwidthAllocationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NiocBandwidthAllocationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NiocSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NiocSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("trafficType")
		e.Str(s.TrafficType)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfNiocSpec = [2]string{
	0: "trafficType",
	1: "value",
}

// Decode decodes NiocSpec from json.
func (s *NiocSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NiocSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trafficType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrafficType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficType\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NiocSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNiocSpec) {
					name = jsonFieldsNameOfNiocSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NiocSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NiocSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NiocTrafficResourceAllocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NiocTrafficResourceAllocation) encodeFields(e *jx.Encoder) {
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.SharesInfo.Set {
			e.FieldStart("sharesInfo")
			s.SharesInfo.Encode(e)
		}
	}
	{
		if s.Reservation.Set {
			e.FieldStart("reservation")
			s.Reservation.Encode(e)
		}
	}
}

var jsonFieldsNameOfNiocTrafficResourceAllocation = [3]string{
	0: "limit",
	1: "sharesInfo",
	2: "reservation",
}

// Decode decodes NiocTrafficResourceAllocation from json.
func (s *NiocTrafficResourceAllocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NiocTrafficResourceAllocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "sharesInfo":
			if err := func() error {
				s.SharesInfo.Reset()
				if err := s.SharesInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sharesInfo\"")
			}
		case "reservation":
			if err := func() error {
				s.Reservation.Reset()
				if err := s.Reservation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reservation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NiocTrafficResourceAllocation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NiocTrafficResourceAllocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NiocTrafficResourceAllocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxALBCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxALBCluster) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ClusterName.Set {
			e.FieldStart("clusterName")
			s.ClusterName.Encode(e)
		}
	}
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NsxClusters != nil {
			e.FieldStart("nsxClusters")
			e.ArrStart()
			for _, elem := range s.NsxClusters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ClusterFqdn.Set {
			e.FieldStart("clusterFqdn")
			s.ClusterFqdn.Encode(e)
		}
	}
	{
		if s.ClusterIpAddress.Set {
			e.FieldStart("clusterIpAddress")
			s.ClusterIpAddress.Encode(e)
		}
	}
	{
		if s.ClusterStatus.Set {
			e.FieldStart("clusterStatus")
			s.ClusterStatus.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.DeploymentStatus.Set {
			e.FieldStart("deploymentStatus")
			s.DeploymentStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxALBCluster = [9]string{
	0: "id",
	1: "clusterName",
	2: "domains",
	3: "nsxClusters",
	4: "clusterFqdn",
	5: "clusterIpAddress",
	6: "clusterStatus",
	7: "version",
	8: "deploymentStatus",
}

// Decode decodes NsxALBCluster from json.
func (s *NsxALBCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxALBCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "clusterName":
			if err := func() error {
				s.ClusterName.Reset()
				if err := s.ClusterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterName\"")
			}
		case "domains":
			if err := func() error {
				s.Domains = make([]DomainReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "nsxClusters":
			if err := func() error {
				s.NsxClusters = make([]NsxTClusterReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxTClusterReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxClusters = append(s.NsxClusters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxClusters\"")
			}
		case "clusterFqdn":
			if err := func() error {
				s.ClusterFqdn.Reset()
				if err := s.ClusterFqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterFqdn\"")
			}
		case "clusterIpAddress":
			if err := func() error {
				s.ClusterIpAddress.Reset()
				if err := s.ClusterIpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterIpAddress\"")
			}
		case "clusterStatus":
			if err := func() error {
				s.ClusterStatus.Reset()
				if err := s.ClusterStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterStatus\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "deploymentStatus":
			if err := func() error {
				s.DeploymentStatus.Reset()
				if err := s.DeploymentStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deploymentStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxALBCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxALBCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxALBCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxAlbControllerClusterSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxAlbControllerClusterSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("domainIds")
		e.ArrStart()
		for _, elem := range s.DomainIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("clusterName")
		e.Str(s.ClusterName)
	}
	{
		e.FieldStart("clusterFqdn")
		e.Str(s.ClusterFqdn)
	}
	{
		e.FieldStart("clusterIpAddress")
		e.Str(s.ClusterIpAddress)
	}
	{
		e.FieldStart("formFactor")
		e.Str(s.FormFactor)
	}
	{
		e.FieldStart("adminPassword")
		e.Str(s.AdminPassword)
	}
	{
		if s.Nodes != nil {
			e.FieldStart("nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BundleId.Set {
			e.FieldStart("bundleId")
			s.BundleId.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxAlbControllerClusterSpec = [8]string{
	0: "domainIds",
	1: "clusterName",
	2: "clusterFqdn",
	3: "clusterIpAddress",
	4: "formFactor",
	5: "adminPassword",
	6: "nodes",
	7: "bundleId",
}

// Decode decodes NsxAlbControllerClusterSpec from json.
func (s *NsxAlbControllerClusterSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxAlbControllerClusterSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.DomainIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DomainIds = append(s.DomainIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainIds\"")
			}
		case "clusterName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ClusterName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterName\"")
			}
		case "clusterFqdn":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ClusterFqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterFqdn\"")
			}
		case "clusterIpAddress":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ClusterIpAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterIpAddress\"")
			}
		case "formFactor":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.FormFactor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"formFactor\"")
			}
		case "adminPassword":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AdminPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adminPassword\"")
			}
		case "nodes":
			if err := func() error {
				s.Nodes = make([]NsxAlbControllerNodeSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxAlbControllerNodeSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "bundleId":
			if err := func() error {
				s.BundleId.Reset()
				if err := s.BundleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxAlbControllerClusterSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxAlbControllerClusterSpec) {
					name = jsonFieldsNameOfNsxAlbControllerClusterSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxAlbControllerClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxAlbControllerClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxAlbControllerNodeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxAlbControllerNodeSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ipAddress")
		e.Str(s.IpAddress)
	}
}

var jsonFieldsNameOfNsxAlbControllerNodeSpec = [1]string{
	0: "ipAddress",
}

// Decode decodes NsxAlbControllerNodeSpec from json.
func (s *NsxAlbControllerNodeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxAlbControllerNodeSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IpAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxAlbControllerNodeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxAlbControllerNodeSpec) {
					name = jsonFieldsNameOfNsxAlbControllerNodeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxAlbControllerNodeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxAlbControllerNodeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxAlbVersionValidationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxAlbVersionValidationSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("domainIds")
		e.ArrStart()
		for _, elem := range s.DomainIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("bundleId")
		e.Str(s.BundleId)
	}
}

var jsonFieldsNameOfNsxAlbVersionValidationSpec = [2]string{
	0: "domainIds",
	1: "bundleId",
}

// Decode decodes NsxAlbVersionValidationSpec from json.
func (s *NsxAlbVersionValidationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxAlbVersionValidationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.DomainIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DomainIds = append(s.DomainIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainIds\"")
			}
		case "bundleId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BundleId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxAlbVersionValidationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxAlbVersionValidationSpec) {
					name = jsonFieldsNameOfNsxAlbVersionValidationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxAlbVersionValidationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxAlbVersionValidationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxClusterSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxClusterSpec) encodeFields(e *jx.Encoder) {
	{
		if s.NsxTClusterSpec.Set {
			e.FieldStart("nsxTClusterSpec")
			s.NsxTClusterSpec.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxClusterSpec = [1]string{
	0: "nsxTClusterSpec",
}

// Decode decodes NsxClusterSpec from json.
func (s *NsxClusterSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxClusterSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nsxTClusterSpec":
			if err := func() error {
				s.NsxTClusterSpec.Reset()
				if err := s.NsxTClusterSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxTClusterSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxClusterSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxManagerSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxManagerSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("networkDetailsSpec")
		s.NetworkDetailsSpec.Encode(e)
	}
}

var jsonFieldsNameOfNsxManagerSpec = [2]string{
	0: "name",
	1: "networkDetailsSpec",
}

// Decode decodes NsxManagerSpec from json.
func (s *NsxManagerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxManagerSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "networkDetailsSpec":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NetworkDetailsSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkDetailsSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxManagerSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxManagerSpec) {
					name = jsonFieldsNameOfNsxManagerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxManagerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxManagerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxStretchClusterSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxStretchClusterSpec) encodeFields(e *jx.Encoder) {
	{
		if s.IpAddressPoolsSpec != nil {
			e.FieldStart("ipAddressPoolsSpec")
			e.ArrStart()
			for _, elem := range s.IpAddressPoolsSpec {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("uplinkProfiles")
		e.ArrStart()
		for _, elem := range s.UplinkProfiles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNsxStretchClusterSpec = [2]string{
	0: "ipAddressPoolsSpec",
	1: "uplinkProfiles",
}

// Decode decodes NsxStretchClusterSpec from json.
func (s *NsxStretchClusterSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxStretchClusterSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddressPoolsSpec":
			if err := func() error {
				s.IpAddressPoolsSpec = make([]IpAddressPoolSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IpAddressPoolSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IpAddressPoolsSpec = append(s.IpAddressPoolsSpec, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPoolsSpec\"")
			}
		case "uplinkProfiles":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.UplinkProfiles = make([]UplinkProfile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UplinkProfile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UplinkProfiles = append(s.UplinkProfiles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplinkProfiles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxStretchClusterSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxStretchClusterSpec) {
					name = jsonFieldsNameOfNsxStretchClusterSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxStretchClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxStretchClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxTCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxTCluster) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NativeId.Set {
			e.FieldStart("nativeId")
			s.NativeId.Encode(e)
		}
	}
	{
		if s.VipFqdn.Set {
			e.FieldStart("vipFqdn")
			s.VipFqdn.Encode(e)
		}
	}
	{
		if s.Vip.Set {
			e.FieldStart("vip")
			s.Vip.Encode(e)
		}
	}
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Nodes != nil {
			e.FieldStart("nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.IsShared.Set {
			e.FieldStart("isShared")
			s.IsShared.Encode(e)
		}
	}
	{
		if s.IsShareable.Set {
			e.FieldStart("isShareable")
			s.IsShareable.Encode(e)
		}
	}
	{
		if s.IsVlcmCompatible.Set {
			e.FieldStart("isVlcmCompatible")
			s.IsVlcmCompatible.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxTCluster = [11]string{
	0:  "id",
	1:  "nativeId",
	2:  "vipFqdn",
	3:  "vip",
	4:  "domains",
	5:  "nodes",
	6:  "version",
	7:  "isShared",
	8:  "isShareable",
	9:  "isVlcmCompatible",
	10: "status",
}

// Decode decodes NsxTCluster from json.
func (s *NsxTCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "nativeId":
			if err := func() error {
				s.NativeId.Reset()
				if err := s.NativeId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nativeId\"")
			}
		case "vipFqdn":
			if err := func() error {
				s.VipFqdn.Reset()
				if err := s.VipFqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vipFqdn\"")
			}
		case "vip":
			if err := func() error {
				s.Vip.Reset()
				if err := s.Vip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vip\"")
			}
		case "domains":
			if err := func() error {
				s.Domains = make([]DomainReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "nodes":
			if err := func() error {
				s.Nodes = make([]NsxTManager, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxTManager
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "isShared":
			if err := func() error {
				s.IsShared.Reset()
				if err := s.IsShared.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShared\"")
			}
		case "isShareable":
			if err := func() error {
				s.IsShareable.Reset()
				if err := s.IsShareable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShareable\"")
			}
		case "isVlcmCompatible":
			if err := func() error {
				s.IsVlcmCompatible.Reset()
				if err := s.IsVlcmCompatible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isVlcmCompatible\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxTCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxTClusterReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxTClusterReference) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.VipFqdn.Set {
			e.FieldStart("vipFqdn")
			s.VipFqdn.Encode(e)
		}
	}
	{
		if s.Vip.Set {
			e.FieldStart("vip")
			s.Vip.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxTClusterReference = [3]string{
	0: "id",
	1: "vipFqdn",
	2: "vip",
}

// Decode decodes NsxTClusterReference from json.
func (s *NsxTClusterReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTClusterReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "vipFqdn":
			if err := func() error {
				s.VipFqdn.Reset()
				if err := s.VipFqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vipFqdn\"")
			}
		case "vip":
			if err := func() error {
				s.Vip.Reset()
				if err := s.Vip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vip\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTClusterReference")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxTClusterReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTClusterReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxTClusterSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxTClusterSpec) encodeFields(e *jx.Encoder) {
	{
		if s.GeneveVlanId.Set {
			e.FieldStart("geneveVlanId")
			s.GeneveVlanId.Encode(e)
		}
	}
	{
		if s.IpAddressPoolSpec.Set {
			e.FieldStart("ipAddressPoolSpec")
			s.IpAddressPoolSpec.Encode(e)
		}
	}
	{
		if s.IpAddressPoolsSpec != nil {
			e.FieldStart("ipAddressPoolsSpec")
			e.ArrStart()
			for _, elem := range s.IpAddressPoolsSpec {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.UplinkProfiles != nil {
			e.FieldStart("uplinkProfiles")
			e.ArrStart()
			for _, elem := range s.UplinkProfiles {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNsxTClusterSpec = [4]string{
	0: "geneveVlanId",
	1: "ipAddressPoolSpec",
	2: "ipAddressPoolsSpec",
	3: "uplinkProfiles",
}

// Decode decodes NsxTClusterSpec from json.
func (s *NsxTClusterSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTClusterSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "geneveVlanId":
			if err := func() error {
				s.GeneveVlanId.Reset()
				if err := s.GeneveVlanId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"geneveVlanId\"")
			}
		case "ipAddressPoolSpec":
			if err := func() error {
				s.IpAddressPoolSpec.Reset()
				if err := s.IpAddressPoolSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPoolSpec\"")
			}
		case "ipAddressPoolsSpec":
			if err := func() error {
				s.IpAddressPoolsSpec = make([]IpAddressPoolSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IpAddressPoolSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IpAddressPoolsSpec = append(s.IpAddressPoolsSpec, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPoolsSpec\"")
			}
		case "uplinkProfiles":
			if err := func() error {
				s.UplinkProfiles = make([]UplinkProfile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UplinkProfile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UplinkProfiles = append(s.UplinkProfiles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplinkProfiles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTClusterSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxTClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxTCriterion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxTCriterion) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Arguments.Set {
			e.FieldStart("arguments")
			s.Arguments.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxTCriterion = [3]string{
	0: "name",
	1: "arguments",
	2: "description",
}

// Decode decodes NsxTCriterion from json.
func (s *NsxTCriterion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTCriterion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments.Reset()
				if err := s.Arguments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTCriterion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxTCriterion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTCriterion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NsxTCriterionArguments) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NsxTCriterionArguments) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes NsxTCriterionArguments from json.
func (s *NsxTCriterionArguments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTCriterionArguments to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTCriterionArguments")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NsxTCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxTEdgeClusterProfileSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxTEdgeClusterProfileSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("edgeClusterProfileName")
		e.Str(s.EdgeClusterProfileName)
	}
	{
		e.FieldStart("bfdAllowedHop")
		e.Int64(s.BfdAllowedHop)
	}
	{
		e.FieldStart("bfdDeclareDeadMultiple")
		e.Int64(s.BfdDeclareDeadMultiple)
	}
	{
		e.FieldStart("bfdProbeInterval")
		e.Int64(s.BfdProbeInterval)
	}
	{
		e.FieldStart("standbyRelocationThreshold")
		e.Int64(s.StandbyRelocationThreshold)
	}
}

var jsonFieldsNameOfNsxTEdgeClusterProfileSpec = [5]string{
	0: "edgeClusterProfileName",
	1: "bfdAllowedHop",
	2: "bfdDeclareDeadMultiple",
	3: "bfdProbeInterval",
	4: "standbyRelocationThreshold",
}

// Decode decodes NsxTEdgeClusterProfileSpec from json.
func (s *NsxTEdgeClusterProfileSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTEdgeClusterProfileSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "edgeClusterProfileName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EdgeClusterProfileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeClusterProfileName\"")
			}
		case "bfdAllowedHop":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.BfdAllowedHop = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bfdAllowedHop\"")
			}
		case "bfdDeclareDeadMultiple":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.BfdDeclareDeadMultiple = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bfdDeclareDeadMultiple\"")
			}
		case "bfdProbeInterval":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.BfdProbeInterval = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bfdProbeInterval\"")
			}
		case "standbyRelocationThreshold":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.StandbyRelocationThreshold = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standbyRelocationThreshold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTEdgeClusterProfileSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxTEdgeClusterProfileSpec) {
					name = jsonFieldsNameOfNsxTEdgeClusterProfileSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxTEdgeClusterProfileSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTEdgeClusterProfileSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxTEdgeNodeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxTEdgeNodeSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("edgeNodeName")
		e.Str(s.EdgeNodeName)
	}
	{
		e.FieldStart("managementIP")
		e.Str(s.ManagementIP)
	}
	{
		e.FieldStart("managementGateway")
		e.Str(s.ManagementGateway)
	}
	{
		if s.VmManagementPortgroupVlan.Set {
			e.FieldStart("vmManagementPortgroupVlan")
			s.VmManagementPortgroupVlan.Encode(e)
		}
	}
	{
		if s.VmManagementPortgroupName.Set {
			e.FieldStart("vmManagementPortgroupName")
			s.VmManagementPortgroupName.Encode(e)
		}
	}
	{
		if s.EdgeTepGateway.Set {
			e.FieldStart("edgeTepGateway")
			s.EdgeTepGateway.Encode(e)
		}
	}
	{
		if s.EdgeTep1IP.Set {
			e.FieldStart("edgeTep1IP")
			s.EdgeTep1IP.Encode(e)
		}
	}
	{
		if s.EdgeTep2IP.Set {
			e.FieldStart("edgeTep2IP")
			s.EdgeTep2IP.Encode(e)
		}
	}
	{
		if s.EdgeTepIpAddressPool.Set {
			e.FieldStart("edgeTepIpAddressPool")
			s.EdgeTepIpAddressPool.Encode(e)
		}
	}
	{
		e.FieldStart("edgeTepVlan")
		e.Int32(s.EdgeTepVlan)
	}
	{
		if s.ClusterId.Set {
			e.FieldStart("clusterId")
			s.ClusterId.Encode(e)
		}
	}
	{
		if s.InterRackCluster.Set {
			e.FieldStart("interRackCluster")
			s.InterRackCluster.Encode(e)
		}
	}
	{
		if s.UplinkNetwork != nil {
			e.FieldStart("uplinkNetwork")
			e.ArrStart()
			for _, elem := range s.UplinkNetwork {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FirstNsxVdsUplink.Set {
			e.FieldStart("firstNsxVdsUplink")
			s.FirstNsxVdsUplink.Encode(e)
		}
	}
	{
		if s.SecondNsxVdsUplink.Set {
			e.FieldStart("secondNsxVdsUplink")
			s.SecondNsxVdsUplink.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxTEdgeNodeSpec = [15]string{
	0:  "edgeNodeName",
	1:  "managementIP",
	2:  "managementGateway",
	3:  "vmManagementPortgroupVlan",
	4:  "vmManagementPortgroupName",
	5:  "edgeTepGateway",
	6:  "edgeTep1IP",
	7:  "edgeTep2IP",
	8:  "edgeTepIpAddressPool",
	9:  "edgeTepVlan",
	10: "clusterId",
	11: "interRackCluster",
	12: "uplinkNetwork",
	13: "firstNsxVdsUplink",
	14: "secondNsxVdsUplink",
}

// Decode decodes NsxTEdgeNodeSpec from json.
func (s *NsxTEdgeNodeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTEdgeNodeSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "edgeNodeName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EdgeNodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeNodeName\"")
			}
		case "managementIP":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ManagementIP = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"managementIP\"")
			}
		case "managementGateway":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ManagementGateway = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"managementGateway\"")
			}
		case "vmManagementPortgroupVlan":
			if err := func() error {
				s.VmManagementPortgroupVlan.Reset()
				if err := s.VmManagementPortgroupVlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmManagementPortgroupVlan\"")
			}
		case "vmManagementPortgroupName":
			if err := func() error {
				s.VmManagementPortgroupName.Reset()
				if err := s.VmManagementPortgroupName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmManagementPortgroupName\"")
			}
		case "edgeTepGateway":
			if err := func() error {
				s.EdgeTepGateway.Reset()
				if err := s.EdgeTepGateway.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeTepGateway\"")
			}
		case "edgeTep1IP":
			if err := func() error {
				s.EdgeTep1IP.Reset()
				if err := s.EdgeTep1IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeTep1IP\"")
			}
		case "edgeTep2IP":
			if err := func() error {
				s.EdgeTep2IP.Reset()
				if err := s.EdgeTep2IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeTep2IP\"")
			}
		case "edgeTepIpAddressPool":
			if err := func() error {
				s.EdgeTepIpAddressPool.Reset()
				if err := s.EdgeTepIpAddressPool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeTepIpAddressPool\"")
			}
		case "edgeTepVlan":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.EdgeTepVlan = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeTepVlan\"")
			}
		case "clusterId":
			if err := func() error {
				s.ClusterId.Reset()
				if err := s.ClusterId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterId\"")
			}
		case "interRackCluster":
			if err := func() error {
				s.InterRackCluster.Reset()
				if err := s.InterRackCluster.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interRackCluster\"")
			}
		case "uplinkNetwork":
			if err := func() error {
				s.UplinkNetwork = make([]NsxTEdgeUplinkNetwork, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxTEdgeUplinkNetwork
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UplinkNetwork = append(s.UplinkNetwork, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplinkNetwork\"")
			}
		case "firstNsxVdsUplink":
			if err := func() error {
				s.FirstNsxVdsUplink.Reset()
				if err := s.FirstNsxVdsUplink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstNsxVdsUplink\"")
			}
		case "secondNsxVdsUplink":
			if err := func() error {
				s.SecondNsxVdsUplink.Reset()
				if err := s.SecondNsxVdsUplink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secondNsxVdsUplink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTEdgeNodeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxTEdgeNodeSpec) {
					name = jsonFieldsNameOfNsxTEdgeNodeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxTEdgeNodeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTEdgeNodeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxTEdgeUplinkNetwork) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxTEdgeUplinkNetwork) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uplinkVlan")
		e.Int32(s.UplinkVlan)
	}
	{
		e.FieldStart("uplinkInterfaceIP")
		e.Str(s.UplinkInterfaceIP)
	}
	{
		if s.PeerIP.Set {
			e.FieldStart("peerIP")
			s.PeerIP.Encode(e)
		}
	}
	{
		if s.AsnPeer.Set {
			e.FieldStart("asnPeer")
			s.AsnPeer.Encode(e)
		}
	}
	{
		if s.BgpPeerPassword.Set {
			e.FieldStart("bgpPeerPassword")
			s.BgpPeerPassword.Encode(e)
		}
	}
	{
		if s.BgpPeers != nil {
			e.FieldStart("bgpPeers")
			e.ArrStart()
			for _, elem := range s.BgpPeers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNsxTEdgeUplinkNetwork = [6]string{
	0: "uplinkVlan",
	1: "uplinkInterfaceIP",
	2: "peerIP",
	3: "asnPeer",
	4: "bgpPeerPassword",
	5: "bgpPeers",
}

// Decode decodes NsxTEdgeUplinkNetwork from json.
func (s *NsxTEdgeUplinkNetwork) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTEdgeUplinkNetwork to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uplinkVlan":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.UplinkVlan = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplinkVlan\"")
			}
		case "uplinkInterfaceIP":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UplinkInterfaceIP = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplinkInterfaceIP\"")
			}
		case "peerIP":
			if err := func() error {
				s.PeerIP.Reset()
				if err := s.PeerIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"peerIP\"")
			}
		case "asnPeer":
			if err := func() error {
				s.AsnPeer.Reset()
				if err := s.AsnPeer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asnPeer\"")
			}
		case "bgpPeerPassword":
			if err := func() error {
				s.BgpPeerPassword.Reset()
				if err := s.BgpPeerPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bgpPeerPassword\"")
			}
		case "bgpPeers":
			if err := func() error {
				s.BgpPeers = make([]BgpPeerSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BgpPeerSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BgpPeers = append(s.BgpPeers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bgpPeers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTEdgeUplinkNetwork")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxTEdgeUplinkNetwork) {
					name = jsonFieldsNameOfNsxTEdgeUplinkNetwork[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxTEdgeUplinkNetwork) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTEdgeUplinkNetwork) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxTManager) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxTManager) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Fqdn.Set {
			e.FieldStart("fqdn")
			s.Fqdn.Encode(e)
		}
	}
	{
		if s.IpAddress.Set {
			e.FieldStart("ipAddress")
			s.IpAddress.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxTManager = [4]string{
	0: "id",
	1: "fqdn",
	2: "ipAddress",
	3: "name",
}

// Decode decodes NsxTManager from json.
func (s *NsxTManager) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTManager to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "fqdn":
			if err := func() error {
				s.Fqdn.Reset()
				if err := s.Fqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "ipAddress":
			if err := func() error {
				s.IpAddress.Reset()
				if err := s.IpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTManager")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxTManager) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTManager) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxTQueryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxTQueryResponse) encodeFields(e *jx.Encoder) {
	{
		if s.QueryInfo.Set {
			e.FieldStart("queryInfo")
			s.QueryInfo.Encode(e)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxTQueryResponse = [2]string{
	0: "queryInfo",
	1: "result",
}

// Decode decodes NsxTQueryResponse from json.
func (s *NsxTQueryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTQueryResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queryInfo":
			if err := func() error {
				s.QueryInfo.Reset()
				if err := s.QueryInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryInfo\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTQueryResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxTQueryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTQueryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxTSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxTSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nsxManagerSpecs")
		e.ArrStart()
		for _, elem := range s.NsxManagerSpecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Vip.Set {
			e.FieldStart("vip")
			s.Vip.Encode(e)
		}
	}
	{
		e.FieldStart("vipFqdn")
		e.Str(s.VipFqdn)
	}
	{
		if s.LicenseKey.Set {
			e.FieldStart("licenseKey")
			s.LicenseKey.Encode(e)
		}
	}
	{
		if s.NsxManagerAdminPassword.Set {
			e.FieldStart("nsxManagerAdminPassword")
			s.NsxManagerAdminPassword.Encode(e)
		}
	}
	{
		if s.NsxManagerAuditPassword.Set {
			e.FieldStart("nsxManagerAuditPassword")
			s.NsxManagerAuditPassword.Encode(e)
		}
	}
	{
		if s.FormFactor.Set {
			e.FieldStart("formFactor")
			s.FormFactor.Encode(e)
		}
	}
	{
		if s.IpAddressPoolSpec.Set {
			e.FieldStart("ipAddressPoolSpec")
			s.IpAddressPoolSpec.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxTSpec = [8]string{
	0: "nsxManagerSpecs",
	1: "vip",
	2: "vipFqdn",
	3: "licenseKey",
	4: "nsxManagerAdminPassword",
	5: "nsxManagerAuditPassword",
	6: "formFactor",
	7: "ipAddressPoolSpec",
}

// Decode decodes NsxTSpec from json.
func (s *NsxTSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nsxManagerSpecs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NsxManagerSpecs = make([]NsxManagerSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxManagerSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxManagerSpecs = append(s.NsxManagerSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxManagerSpecs\"")
			}
		case "vip":
			if err := func() error {
				s.Vip.Reset()
				if err := s.Vip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vip\"")
			}
		case "vipFqdn":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VipFqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vipFqdn\"")
			}
		case "licenseKey":
			if err := func() error {
				s.LicenseKey.Reset()
				if err := s.LicenseKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKey\"")
			}
		case "nsxManagerAdminPassword":
			if err := func() error {
				s.NsxManagerAdminPassword.Reset()
				if err := s.NsxManagerAdminPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxManagerAdminPassword\"")
			}
		case "nsxManagerAuditPassword":
			if err := func() error {
				s.NsxManagerAuditPassword.Reset()
				if err := s.NsxManagerAuditPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxManagerAuditPassword\"")
			}
		case "formFactor":
			if err := func() error {
				s.FormFactor.Reset()
				if err := s.FormFactor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"formFactor\"")
			}
		case "ipAddressPoolSpec":
			if err := func() error {
				s.IpAddressPoolSpec.Reset()
				if err := s.IpAddressPoolSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPoolSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxTSpec) {
					name = jsonFieldsNameOfNsxTSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxTSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxTransportZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxTransportZone) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.TransportType.Set {
			e.FieldStart("transportType")
			s.TransportType.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxTransportZone = [2]string{
	0: "name",
	1: "transportType",
}

// Decode decodes NsxTransportZone from json.
func (s *NsxTransportZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxTransportZone to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "transportType":
			if err := func() error {
				s.TransportType.Reset()
				if err := s.TransportType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transportType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxTransportZone")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxTransportZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxTransportZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtEdgeCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtEdgeCluster) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.UpgradeStatus.Set {
			e.FieldStart("upgradeStatus")
			s.UpgradeStatus.Encode(e)
		}
	}
	{
		if s.ResourceHealth.Set {
			e.FieldStart("resourceHealth")
			s.ResourceHealth.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtEdgeCluster = [5]string{
	0: "id",
	1: "name",
	2: "upgradeStatus",
	3: "resourceHealth",
	4: "version",
}

// Decode decodes NsxtEdgeCluster from json.
func (s *NsxtEdgeCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtEdgeCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "upgradeStatus":
			if err := func() error {
				s.UpgradeStatus.Reset()
				if err := s.UpgradeStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upgradeStatus\"")
			}
		case "resourceHealth":
			if err := func() error {
				s.ResourceHealth.Reset()
				if err := s.ResourceHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceHealth\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtEdgeCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtEdgeCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtEdgeCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtEdgeClusterUpgradeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtEdgeClusterUpgradeSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("edgeClusterId")
		e.Str(s.EdgeClusterId)
	}
	{
		if s.EdgeParallelUpgrade.Set {
			e.FieldStart("edgeParallelUpgrade")
			s.EdgeParallelUpgrade.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtEdgeClusterUpgradeSpec = [2]string{
	0: "edgeClusterId",
	1: "edgeParallelUpgrade",
}

// Decode decodes NsxtEdgeClusterUpgradeSpec from json.
func (s *NsxtEdgeClusterUpgradeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtEdgeClusterUpgradeSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "edgeClusterId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EdgeClusterId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeClusterId\"")
			}
		case "edgeParallelUpgrade":
			if err := func() error {
				s.EdgeParallelUpgrade.Reset()
				if err := s.EdgeParallelUpgrade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edgeParallelUpgrade\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtEdgeClusterUpgradeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxtEdgeClusterUpgradeSpec) {
					name = jsonFieldsNameOfNsxtEdgeClusterUpgradeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtEdgeClusterUpgradeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtEdgeClusterUpgradeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtHostCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtHostCluster) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.UpgradeStatus.Set {
			e.FieldStart("upgradeStatus")
			s.UpgradeStatus.Encode(e)
		}
	}
	{
		if s.ResourceHealth.Set {
			e.FieldStart("resourceHealth")
			s.ResourceHealth.Encode(e)
		}
	}
	{
		if s.UpgradedUnits.Set {
			e.FieldStart("upgradedUnits")
			s.UpgradedUnits.Encode(e)
		}
	}
	{
		if s.TotalUnits.Set {
			e.FieldStart("totalUnits")
			s.TotalUnits.Encode(e)
		}
	}
	{
		if s.DomainId.Set {
			e.FieldStart("domainId")
			s.DomainId.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.PrimaryCluster.Set {
			e.FieldStart("primaryCluster")
			s.PrimaryCluster.Encode(e)
		}
	}
	{
		if s.VLcmEnabled.Set {
			e.FieldStart("vLcmEnabled")
			s.VLcmEnabled.Encode(e)
		}
	}
	{
		if s.ConfiguredHardwareSupportManagers != nil {
			e.FieldStart("configuredHardwareSupportManagers")
			e.ArrStart()
			for _, elem := range s.ConfiguredHardwareSupportManagers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AvailableHardwareSupportManagers != nil {
			e.FieldStart("availableHardwareSupportManagers")
			e.ArrStart()
			for _, elem := range s.AvailableHardwareSupportManagers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNsxtHostCluster = [12]string{
	0:  "id",
	1:  "name",
	2:  "upgradeStatus",
	3:  "resourceHealth",
	4:  "upgradedUnits",
	5:  "totalUnits",
	6:  "domainId",
	7:  "version",
	8:  "primaryCluster",
	9:  "vLcmEnabled",
	10: "configuredHardwareSupportManagers",
	11: "availableHardwareSupportManagers",
}

// Decode decodes NsxtHostCluster from json.
func (s *NsxtHostCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtHostCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "upgradeStatus":
			if err := func() error {
				s.UpgradeStatus.Reset()
				if err := s.UpgradeStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upgradeStatus\"")
			}
		case "resourceHealth":
			if err := func() error {
				s.ResourceHealth.Reset()
				if err := s.ResourceHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceHealth\"")
			}
		case "upgradedUnits":
			if err := func() error {
				s.UpgradedUnits.Reset()
				if err := s.UpgradedUnits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upgradedUnits\"")
			}
		case "totalUnits":
			if err := func() error {
				s.TotalUnits.Reset()
				if err := s.TotalUnits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUnits\"")
			}
		case "domainId":
			if err := func() error {
				s.DomainId.Reset()
				if err := s.DomainId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainId\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "primaryCluster":
			if err := func() error {
				s.PrimaryCluster.Reset()
				if err := s.PrimaryCluster.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryCluster\"")
			}
		case "vLcmEnabled":
			if err := func() error {
				s.VLcmEnabled.Reset()
				if err := s.VLcmEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vLcmEnabled\"")
			}
		case "configuredHardwareSupportManagers":
			if err := func() error {
				s.ConfiguredHardwareSupportManagers = make([]HardwareSupportPackage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HardwareSupportPackage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ConfiguredHardwareSupportManagers = append(s.ConfiguredHardwareSupportManagers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configuredHardwareSupportManagers\"")
			}
		case "availableHardwareSupportManagers":
			if err := func() error {
				s.AvailableHardwareSupportManagers = make([]HardwareSupportPackages, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HardwareSupportPackages
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AvailableHardwareSupportManagers = append(s.AvailableHardwareSupportManagers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableHardwareSupportManagers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtHostCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtHostCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtHostCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtHostClusterUpgradeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtHostClusterUpgradeSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hostClusterId")
		e.Str(s.HostClusterId)
	}
	{
		if s.HostParallelUpgrade.Set {
			e.FieldStart("hostParallelUpgrade")
			s.HostParallelUpgrade.Encode(e)
		}
	}
	{
		if s.LiveUpgrade.Set {
			e.FieldStart("liveUpgrade")
			s.LiveUpgrade.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtHostClusterUpgradeSpec = [3]string{
	0: "hostClusterId",
	1: "hostParallelUpgrade",
	2: "liveUpgrade",
}

// Decode decodes NsxtHostClusterUpgradeSpec from json.
func (s *NsxtHostClusterUpgradeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtHostClusterUpgradeSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostClusterId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostClusterId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostClusterId\"")
			}
		case "hostParallelUpgrade":
			if err := func() error {
				s.HostParallelUpgrade.Reset()
				if err := s.HostParallelUpgrade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostParallelUpgrade\"")
			}
		case "liveUpgrade":
			if err := func() error {
				s.LiveUpgrade.Reset()
				if err := s.LiveUpgrade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"liveUpgrade\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtHostClusterUpgradeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxtHostClusterUpgradeSpec) {
					name = jsonFieldsNameOfNsxtHostClusterUpgradeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtHostClusterUpgradeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtHostClusterUpgradeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtHostSwitchConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtHostSwitchConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vdsName")
		e.Str(s.VdsName)
	}
	{
		e.FieldStart("uplinkProfileName")
		e.Str(s.UplinkProfileName)
	}
	{
		if s.IpAddressPoolName.Set {
			e.FieldStart("ipAddressPoolName")
			s.IpAddressPoolName.Encode(e)
		}
	}
	{
		e.FieldStart("vdsUplinkToNsxUplink")
		e.ArrStart()
		for _, elem := range s.VdsUplinkToNsxUplink {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNsxtHostSwitchConfig = [4]string{
	0: "vdsName",
	1: "uplinkProfileName",
	2: "ipAddressPoolName",
	3: "vdsUplinkToNsxUplink",
}

// Decode decodes NsxtHostSwitchConfig from json.
func (s *NsxtHostSwitchConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtHostSwitchConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vdsName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VdsName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsName\"")
			}
		case "uplinkProfileName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UplinkProfileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplinkProfileName\"")
			}
		case "ipAddressPoolName":
			if err := func() error {
				s.IpAddressPoolName.Reset()
				if err := s.IpAddressPoolName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPoolName\"")
			}
		case "vdsUplinkToNsxUplink":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.VdsUplinkToNsxUplink = make([]UplinkMapping, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UplinkMapping
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VdsUplinkToNsxUplink = append(s.VdsUplinkToNsxUplink, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsUplinkToNsxUplink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtHostSwitchConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxtHostSwitchConfig) {
					name = jsonFieldsNameOfNsxtHostSwitchConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtHostSwitchConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtHostSwitchConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtHostSwitchConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtHostSwitchConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.VdsName.Set {
			e.FieldStart("vdsName")
			s.VdsName.Encode(e)
		}
	}
	{
		if s.UplinkProfileName.Set {
			e.FieldStart("uplinkProfileName")
			s.UplinkProfileName.Encode(e)
		}
	}
	{
		if s.IpAddressPoolName.Set {
			e.FieldStart("ipAddressPoolName")
			s.IpAddressPoolName.Encode(e)
		}
	}
	{
		if s.VdsUplinkToNsxUplink != nil {
			e.FieldStart("vdsUplinkToNsxUplink")
			e.ArrStart()
			for _, elem := range s.VdsUplinkToNsxUplink {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNsxtHostSwitchConfiguration = [4]string{
	0: "vdsName",
	1: "uplinkProfileName",
	2: "ipAddressPoolName",
	3: "vdsUplinkToNsxUplink",
}

// Decode decodes NsxtHostSwitchConfiguration from json.
func (s *NsxtHostSwitchConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtHostSwitchConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vdsName":
			if err := func() error {
				s.VdsName.Reset()
				if err := s.VdsName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsName\"")
			}
		case "uplinkProfileName":
			if err := func() error {
				s.UplinkProfileName.Reset()
				if err := s.UplinkProfileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplinkProfileName\"")
			}
		case "ipAddressPoolName":
			if err := func() error {
				s.IpAddressPoolName.Reset()
				if err := s.IpAddressPoolName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPoolName\"")
			}
		case "vdsUplinkToNsxUplink":
			if err := func() error {
				s.VdsUplinkToNsxUplink = make([]VdsUplinkToNsxUplinkConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VdsUplinkToNsxUplinkConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VdsUplinkToNsxUplink = append(s.VdsUplinkToNsxUplink, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsUplinkToNsxUplink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtHostSwitchConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtHostSwitchConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtHostSwitchConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtIpAddressPool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtIpAddressPool) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.AvailableIpAddresses.Set {
			e.FieldStart("availableIpAddresses")
			s.AvailableIpAddresses.Encode(e)
		}
	}
	{
		if s.TotalIpAddresses.Set {
			e.FieldStart("totalIpAddresses")
			s.TotalIpAddresses.Encode(e)
		}
	}
	{
		if s.BlockSubnets != nil {
			e.FieldStart("blockSubnets")
			e.ArrStart()
			for _, elem := range s.BlockSubnets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StaticSubnets != nil {
			e.FieldStart("staticSubnets")
			e.ArrStart()
			for _, elem := range s.StaticSubnets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNsxtIpAddressPool = [6]string{
	0: "name",
	1: "description",
	2: "availableIpAddresses",
	3: "totalIpAddresses",
	4: "blockSubnets",
	5: "staticSubnets",
}

// Decode decodes NsxtIpAddressPool from json.
func (s *NsxtIpAddressPool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtIpAddressPool to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "availableIpAddresses":
			if err := func() error {
				s.AvailableIpAddresses.Reset()
				if err := s.AvailableIpAddresses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableIpAddresses\"")
			}
		case "totalIpAddresses":
			if err := func() error {
				s.TotalIpAddresses.Reset()
				if err := s.TotalIpAddresses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalIpAddresses\"")
			}
		case "blockSubnets":
			if err := func() error {
				s.BlockSubnets = make([]NsxtIpAddressPoolBlockSubnet, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtIpAddressPoolBlockSubnet
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BlockSubnets = append(s.BlockSubnets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockSubnets\"")
			}
		case "staticSubnets":
			if err := func() error {
				s.StaticSubnets = make([]NsxtIpAddressPoolStaticSubnet, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtIpAddressPoolStaticSubnet
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.StaticSubnets = append(s.StaticSubnets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"staticSubnets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtIpAddressPool")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtIpAddressPool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtIpAddressPool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtIpAddressPoolBlockSubnet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtIpAddressPoolBlockSubnet) encodeFields(e *jx.Encoder) {
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.GatewayAssigned.Set {
			e.FieldStart("gatewayAssigned")
			s.GatewayAssigned.Encode(e)
		}
	}
	{
		if s.Cidr.Set {
			e.FieldStart("cidr")
			s.Cidr.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtIpAddressPoolBlockSubnet = [3]string{
	0: "size",
	1: "gatewayAssigned",
	2: "cidr",
}

// Decode decodes NsxtIpAddressPoolBlockSubnet from json.
func (s *NsxtIpAddressPoolBlockSubnet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtIpAddressPoolBlockSubnet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "gatewayAssigned":
			if err := func() error {
				s.GatewayAssigned.Reset()
				if err := s.GatewayAssigned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gatewayAssigned\"")
			}
		case "cidr":
			if err := func() error {
				s.Cidr.Reset()
				if err := s.Cidr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cidr\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtIpAddressPoolBlockSubnet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtIpAddressPoolBlockSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtIpAddressPoolBlockSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtIpAddressPoolRange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtIpAddressPoolRange) encodeFields(e *jx.Encoder) {
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtIpAddressPoolRange = [2]string{
	0: "start",
	1: "end",
}

// Decode decodes NsxtIpAddressPoolRange from json.
func (s *NsxtIpAddressPoolRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtIpAddressPoolRange to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtIpAddressPoolRange")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtIpAddressPoolRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtIpAddressPoolRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtIpAddressPoolStaticSubnet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtIpAddressPoolStaticSubnet) encodeFields(e *jx.Encoder) {
	{
		if s.IpAddressPoolRanges != nil {
			e.FieldStart("ipAddressPoolRanges")
			e.ArrStart()
			for _, elem := range s.IpAddressPoolRanges {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Gateway.Set {
			e.FieldStart("gateway")
			s.Gateway.Encode(e)
		}
	}
	{
		if s.Cidr.Set {
			e.FieldStart("cidr")
			s.Cidr.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtIpAddressPoolStaticSubnet = [3]string{
	0: "ipAddressPoolRanges",
	1: "gateway",
	2: "cidr",
}

// Decode decodes NsxtIpAddressPoolStaticSubnet from json.
func (s *NsxtIpAddressPoolStaticSubnet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtIpAddressPoolStaticSubnet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddressPoolRanges":
			if err := func() error {
				s.IpAddressPoolRanges = make([]NsxtIpAddressPoolRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtIpAddressPoolRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IpAddressPoolRanges = append(s.IpAddressPoolRanges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPoolRanges\"")
			}
		case "gateway":
			if err := func() error {
				s.Gateway.Reset()
				if err := s.Gateway.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		case "cidr":
			if err := func() error {
				s.Cidr.Reset()
				if err := s.Cidr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cidr\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtIpAddressPoolStaticSubnet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtIpAddressPoolStaticSubnet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtIpAddressPoolStaticSubnet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtIpAddressPoolValidationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtIpAddressPoolValidationSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ipAddressPoolSpec")
		s.IpAddressPoolSpec.Encode(e)
	}
	{
		if s.NsxtClusterId.Set {
			e.FieldStart("nsxtClusterId")
			s.NsxtClusterId.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtIpAddressPoolValidationSpec = [2]string{
	0: "ipAddressPoolSpec",
	1: "nsxtClusterId",
}

// Decode decodes NsxtIpAddressPoolValidationSpec from json.
func (s *NsxtIpAddressPoolValidationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtIpAddressPoolValidationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddressPoolSpec":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.IpAddressPoolSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPoolSpec\"")
			}
		case "nsxtClusterId":
			if err := func() error {
				s.NsxtClusterId.Reset()
				if err := s.NsxtClusterId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtClusterId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtIpAddressPoolValidationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxtIpAddressPoolValidationSpec) {
					name = jsonFieldsNameOfNsxtIpAddressPoolValidationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtIpAddressPoolValidationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtIpAddressPoolValidationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtManagerCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtManagerCluster) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.UpgradeStatus.Set {
			e.FieldStart("upgradeStatus")
			s.UpgradeStatus.Encode(e)
		}
	}
	{
		if s.ResourceHealth.Set {
			e.FieldStart("resourceHealth")
			s.ResourceHealth.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtManagerCluster = [5]string{
	0: "id",
	1: "name",
	2: "upgradeStatus",
	3: "resourceHealth",
	4: "version",
}

// Decode decodes NsxtManagerCluster from json.
func (s *NsxtManagerCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtManagerCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "upgradeStatus":
			if err := func() error {
				s.UpgradeStatus.Reset()
				if err := s.UpgradeStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upgradeStatus\"")
			}
		case "resourceHealth":
			if err := func() error {
				s.ResourceHealth.Reset()
				if err := s.ResourceHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceHealth\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtManagerCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtManagerCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtManagerCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtManagerSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtManagerSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Hostname.Set {
			e.FieldStart("hostname")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.IP.Set {
			e.FieldStart("ip")
			s.IP.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtManagerSpec = [2]string{
	0: "hostname",
	1: "ip",
}

// Decode decodes NsxtManagerSpec from json.
func (s *NsxtManagerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtManagerSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "ip":
			if err := func() error {
				s.IP.Reset()
				if err := s.IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtManagerSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtManagerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtManagerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtOidcSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtOidcSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("entityInventoryId")
		e.Str(s.EntityInventoryId)
	}
	{
		e.FieldStart("oidcType")
		s.OidcType.Encode(e)
	}
}

var jsonFieldsNameOfNsxtOidcSpec = [2]string{
	0: "entityInventoryId",
	1: "oidcType",
}

// Decode decodes NsxtOidcSpec from json.
func (s *NsxtOidcSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtOidcSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entityInventoryId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EntityInventoryId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityInventoryId\"")
			}
		case "oidcType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.OidcType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidcType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtOidcSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxtOidcSpec) {
					name = jsonFieldsNameOfNsxtOidcSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtOidcSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtOidcSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxtOidcSpecOidcType as json.
func (s NsxtOidcSpecOidcType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NsxtOidcSpecOidcType from json.
func (s *NsxtOidcSpecOidcType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtOidcSpecOidcType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NsxtOidcSpecOidcType(v) {
	case NsxtOidcSpecOidcTypeVcenter:
		*s = NsxtOidcSpecOidcTypeVcenter
	default:
		*s = NsxtOidcSpecOidcType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NsxtOidcSpecOidcType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtOidcSpecOidcType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtResources) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtResources) encodeFields(e *jx.Encoder) {
	{
		if s.NsxtHostClusters != nil {
			e.FieldStart("nsxtHostClusters")
			e.ArrStart()
			for _, elem := range s.NsxtHostClusters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NsxtEdgeClusters != nil {
			e.FieldStart("nsxtEdgeClusters")
			e.ArrStart()
			for _, elem := range s.NsxtEdgeClusters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NsxtManagerCluster.Set {
			e.FieldStart("nsxtManagerCluster")
			s.NsxtManagerCluster.Encode(e)
		}
	}
	{
		if s.NsxtUpgradeCoordinator.Set {
			e.FieldStart("nsxtUpgradeCoordinator")
			s.NsxtUpgradeCoordinator.Encode(e)
		}
	}
	{
		if s.BundleId.Set {
			e.FieldStart("bundleId")
			s.BundleId.Encode(e)
		}
	}
	{
		if s.DomainId.Set {
			e.FieldStart("domainId")
			s.DomainId.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtResources = [6]string{
	0: "nsxtHostClusters",
	1: "nsxtEdgeClusters",
	2: "nsxtManagerCluster",
	3: "nsxtUpgradeCoordinator",
	4: "bundleId",
	5: "domainId",
}

// Decode decodes NsxtResources from json.
func (s *NsxtResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtResources to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nsxtHostClusters":
			if err := func() error {
				s.NsxtHostClusters = make([]NsxtHostCluster, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtHostCluster
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxtHostClusters = append(s.NsxtHostClusters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtHostClusters\"")
			}
		case "nsxtEdgeClusters":
			if err := func() error {
				s.NsxtEdgeClusters = make([]NsxtEdgeCluster, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtEdgeCluster
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxtEdgeClusters = append(s.NsxtEdgeClusters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtEdgeClusters\"")
			}
		case "nsxtManagerCluster":
			if err := func() error {
				s.NsxtManagerCluster.Reset()
				if err := s.NsxtManagerCluster.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtManagerCluster\"")
			}
		case "nsxtUpgradeCoordinator":
			if err := func() error {
				s.NsxtUpgradeCoordinator.Reset()
				if err := s.NsxtUpgradeCoordinator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtUpgradeCoordinator\"")
			}
		case "bundleId":
			if err := func() error {
				s.BundleId.Reset()
				if err := s.BundleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleId\"")
			}
		case "domainId":
			if err := func() error {
				s.DomainId.Reset()
				if err := s.DomainId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtResources")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtSwitchConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtSwitchConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("transportZones")
		e.ArrStart()
		for _, elem := range s.TransportZones {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.HostSwitchOperationalMode.Set {
			e.FieldStart("hostSwitchOperationalMode")
			s.HostSwitchOperationalMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtSwitchConfig = [2]string{
	0: "transportZones",
	1: "hostSwitchOperationalMode",
}

// Decode decodes NsxtSwitchConfig from json.
func (s *NsxtSwitchConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtSwitchConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transportZones":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.TransportZones = make([]TransportZone, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TransportZone
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TransportZones = append(s.TransportZones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transportZones\"")
			}
		case "hostSwitchOperationalMode":
			if err := func() error {
				s.HostSwitchOperationalMode.Reset()
				if err := s.HostSwitchOperationalMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostSwitchOperationalMode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtSwitchConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxtSwitchConfig) {
					name = jsonFieldsNameOfNsxtSwitchConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtSwitchConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtSwitchConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtSwitchConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtSwitchConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.TransportZones != nil {
			e.FieldStart("transportZones")
			e.ArrStart()
			for _, elem := range s.TransportZones {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostSwitchOperationalMode.Set {
			e.FieldStart("hostSwitchOperationalMode")
			s.HostSwitchOperationalMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtSwitchConfiguration = [2]string{
	0: "transportZones",
	1: "hostSwitchOperationalMode",
}

// Decode decodes NsxtSwitchConfiguration from json.
func (s *NsxtSwitchConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtSwitchConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transportZones":
			if err := func() error {
				s.TransportZones = make([]NsxTransportZone, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxTransportZone
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TransportZones = append(s.TransportZones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transportZones\"")
			}
		case "hostSwitchOperationalMode":
			if err := func() error {
				s.HostSwitchOperationalMode.Reset()
				if err := s.HostSwitchOperationalMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostSwitchOperationalMode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtSwitchConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtSwitchConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtSwitchConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtTransportZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtTransportZone) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("zoneName")
		e.Str(s.ZoneName)
	}
	{
		e.FieldStart("networkName")
		e.Str(s.NetworkName)
	}
}

var jsonFieldsNameOfNsxtTransportZone = [2]string{
	0: "zoneName",
	1: "networkName",
}

// Decode decodes NsxtTransportZone from json.
func (s *NsxtTransportZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtTransportZone to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "zoneName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ZoneName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zoneName\"")
			}
		case "networkName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NetworkName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtTransportZone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNsxtTransportZone) {
					name = jsonFieldsNameOfNsxtTransportZone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtTransportZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtTransportZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtTransportZoneInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtTransportZoneInfo) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNsxtTransportZoneInfo = [0]string{}

// Decode decodes NsxtTransportZoneInfo from json.
func (s *NsxtTransportZoneInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtTransportZoneInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NsxtTransportZoneInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtTransportZoneInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtTransportZoneInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtUpgradeCoordinator) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtUpgradeCoordinator) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.UpgradeStatus.Set {
			e.FieldStart("upgradeStatus")
			s.UpgradeStatus.Encode(e)
		}
	}
	{
		if s.ResourceHealth.Set {
			e.FieldStart("resourceHealth")
			s.ResourceHealth.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.EnabledOn.Set {
			e.FieldStart("enabledOn")
			s.EnabledOn.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtUpgradeCoordinator = [5]string{
	0: "id",
	1: "upgradeStatus",
	2: "resourceHealth",
	3: "version",
	4: "enabledOn",
}

// Decode decodes NsxtUpgradeCoordinator from json.
func (s *NsxtUpgradeCoordinator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtUpgradeCoordinator to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "upgradeStatus":
			if err := func() error {
				s.UpgradeStatus.Reset()
				if err := s.UpgradeStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upgradeStatus\"")
			}
		case "resourceHealth":
			if err := func() error {
				s.ResourceHealth.Reset()
				if err := s.ResourceHealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceHealth\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "enabledOn":
			if err := func() error {
				s.EnabledOn.Reset()
				if err := s.EnabledOn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabledOn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtUpgradeCoordinator")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtUpgradeCoordinator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtUpgradeCoordinator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtUpgradeOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtUpgradeOptions) encodeFields(e *jx.Encoder) {
	{
		if s.IsEdgeOnlyUpgrade.Set {
			e.FieldStart("isEdgeOnlyUpgrade")
			s.IsEdgeOnlyUpgrade.Encode(e)
		}
	}
	{
		if s.IsHostClustersUpgradeParallel.Set {
			e.FieldStart("isHostClustersUpgradeParallel")
			s.IsHostClustersUpgradeParallel.Encode(e)
		}
	}
	{
		if s.IsEdgeClustersUpgradeParallel.Set {
			e.FieldStart("isEdgeClustersUpgradeParallel")
			s.IsEdgeClustersUpgradeParallel.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtUpgradeOptions = [3]string{
	0: "isEdgeOnlyUpgrade",
	1: "isHostClustersUpgradeParallel",
	2: "isEdgeClustersUpgradeParallel",
}

// Decode decodes NsxtUpgradeOptions from json.
func (s *NsxtUpgradeOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtUpgradeOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isEdgeOnlyUpgrade":
			if err := func() error {
				s.IsEdgeOnlyUpgrade.Reset()
				if err := s.IsEdgeOnlyUpgrade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEdgeOnlyUpgrade\"")
			}
		case "isHostClustersUpgradeParallel":
			if err := func() error {
				s.IsHostClustersUpgradeParallel.Reset()
				if err := s.IsHostClustersUpgradeParallel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHostClustersUpgradeParallel\"")
			}
		case "isEdgeClustersUpgradeParallel":
			if err := func() error {
				s.IsEdgeClustersUpgradeParallel.Reset()
				if err := s.IsEdgeClustersUpgradeParallel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEdgeClustersUpgradeParallel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtUpgradeOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtUpgradeOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtUpgradeOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NsxtUpgradeUserInputSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NsxtUpgradeUserInputSpec) encodeFields(e *jx.Encoder) {
	{
		if s.NsxtHostClusterUpgradeSpecs != nil {
			e.FieldStart("nsxtHostClusterUpgradeSpecs")
			e.ArrStart()
			for _, elem := range s.NsxtHostClusterUpgradeSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NsxtEdgeClusterUpgradeSpecs != nil {
			e.FieldStart("nsxtEdgeClusterUpgradeSpecs")
			e.ArrStart()
			for _, elem := range s.NsxtEdgeClusterUpgradeSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NsxtUpgradeOptions.Set {
			e.FieldStart("nsxtUpgradeOptions")
			s.NsxtUpgradeOptions.Encode(e)
		}
	}
	{
		if s.NsxtId.Set {
			e.FieldStart("nsxtId")
			s.NsxtId.Encode(e)
		}
	}
}

var jsonFieldsNameOfNsxtUpgradeUserInputSpec = [4]string{
	0: "nsxtHostClusterUpgradeSpecs",
	1: "nsxtEdgeClusterUpgradeSpecs",
	2: "nsxtUpgradeOptions",
	3: "nsxtId",
}

// Decode decodes NsxtUpgradeUserInputSpec from json.
func (s *NsxtUpgradeUserInputSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NsxtUpgradeUserInputSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nsxtHostClusterUpgradeSpecs":
			if err := func() error {
				s.NsxtHostClusterUpgradeSpecs = make([]NsxtHostClusterUpgradeSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtHostClusterUpgradeSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxtHostClusterUpgradeSpecs = append(s.NsxtHostClusterUpgradeSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtHostClusterUpgradeSpecs\"")
			}
		case "nsxtEdgeClusterUpgradeSpecs":
			if err := func() error {
				s.NsxtEdgeClusterUpgradeSpecs = make([]NsxtEdgeClusterUpgradeSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtEdgeClusterUpgradeSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxtEdgeClusterUpgradeSpecs = append(s.NsxtEdgeClusterUpgradeSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtEdgeClusterUpgradeSpecs\"")
			}
		case "nsxtUpgradeOptions":
			if err := func() error {
				s.NsxtUpgradeOptions.Reset()
				if err := s.NsxtUpgradeOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtUpgradeOptions\"")
			}
		case "nsxtId":
			if err := func() error {
				s.NsxtId.Reset()
				if err := s.NsxtId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NsxtUpgradeUserInputSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NsxtUpgradeUserInputSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NsxtUpgradeUserInputSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NtpConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NtpConfiguration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ntpServers")
		e.ArrStart()
		for _, elem := range s.NtpServers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNtpConfiguration = [1]string{
	0: "ntpServers",
}

// Decode decodes NtpConfiguration from json.
func (s *NtpConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NtpConfiguration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ntpServers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NtpServers = make([]NtpServer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NtpServer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NtpServers = append(s.NtpServers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ntpServers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NtpConfiguration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNtpConfiguration) {
					name = jsonFieldsNameOfNtpConfiguration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NtpConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NtpConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NtpServer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NtpServer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ipAddress")
		e.Str(s.IpAddress)
	}
}

var jsonFieldsNameOfNtpServer = [1]string{
	0: "ipAddress",
}

// Decode decodes NtpServer from json.
func (s *NtpServer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NtpServer to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IpAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NtpServer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNtpServer) {
					name = jsonFieldsNameOfNtpServer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NtpServer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NtpServer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OidcInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OidcInfo) encodeFields(e *jx.Encoder) {
	{
		if s.ClientId.Set {
			e.FieldStart("clientId")
			s.ClientId.Encode(e)
		}
	}
	{
		if s.DiscoveryEndpoint.Set {
			e.FieldStart("discoveryEndpoint")
			s.DiscoveryEndpoint.Encode(e)
		}
	}
	{
		if s.AuthEndpoint.Set {
			e.FieldStart("authEndpoint")
			s.AuthEndpoint.Encode(e)
		}
	}
	{
		if s.AuthMethod.Set {
			e.FieldStart("authMethod")
			s.AuthMethod.Encode(e)
		}
	}
	{
		if s.LogoutEndpoint.Set {
			e.FieldStart("logoutEndpoint")
			s.LogoutEndpoint.Encode(e)
		}
	}
	{
		if s.Issuer.Set {
			e.FieldStart("issuer")
			s.Issuer.Encode(e)
		}
	}
	{
		if s.PublicKeyUri.Set {
			e.FieldStart("publicKeyUri")
			s.PublicKeyUri.Encode(e)
		}
	}
	{
		if s.TokenEndpoint.Set {
			e.FieldStart("tokenEndpoint")
			s.TokenEndpoint.Encode(e)
		}
	}
}

var jsonFieldsNameOfOidcInfo = [8]string{
	0: "clientId",
	1: "discoveryEndpoint",
	2: "authEndpoint",
	3: "authMethod",
	4: "logoutEndpoint",
	5: "issuer",
	6: "publicKeyUri",
	7: "tokenEndpoint",
}

// Decode decodes OidcInfo from json.
func (s *OidcInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OidcInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientId":
			if err := func() error {
				s.ClientId.Reset()
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "discoveryEndpoint":
			if err := func() error {
				s.DiscoveryEndpoint.Reset()
				if err := s.DiscoveryEndpoint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discoveryEndpoint\"")
			}
		case "authEndpoint":
			if err := func() error {
				s.AuthEndpoint.Reset()
				if err := s.AuthEndpoint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authEndpoint\"")
			}
		case "authMethod":
			if err := func() error {
				s.AuthMethod.Reset()
				if err := s.AuthMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authMethod\"")
			}
		case "logoutEndpoint":
			if err := func() error {
				s.LogoutEndpoint.Reset()
				if err := s.LogoutEndpoint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logoutEndpoint\"")
			}
		case "issuer":
			if err := func() error {
				s.Issuer.Reset()
				if err := s.Issuer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuer\"")
			}
		case "publicKeyUri":
			if err := func() error {
				s.PublicKeyUri.Reset()
				if err := s.PublicKeyUri.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicKeyUri\"")
			}
		case "tokenEndpoint":
			if err := func() error {
				s.TokenEndpoint.Reset()
				if err := s.TokenEndpoint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenEndpoint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OidcInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OidcInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OidcInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OpenSSLCertificateAuthoritySpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OpenSSLCertificateAuthoritySpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("commonName")
		e.Str(s.CommonName)
	}
	{
		e.FieldStart("country")
		e.Str(s.Country)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("locality")
		e.Str(s.Locality)
	}
	{
		e.FieldStart("organization")
		e.Str(s.Organization)
	}
	{
		e.FieldStart("organizationUnit")
		e.Str(s.OrganizationUnit)
	}
}

var jsonFieldsNameOfOpenSSLCertificateAuthoritySpec = [6]string{
	0: "commonName",
	1: "country",
	2: "state",
	3: "locality",
	4: "organization",
	5: "organizationUnit",
}

// Decode decodes OpenSSLCertificateAuthoritySpec from json.
func (s *OpenSSLCertificateAuthoritySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OpenSSLCertificateAuthoritySpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commonName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommonName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commonName\"")
			}
		case "country":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Country = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "locality":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Locality = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locality\"")
			}
		case "organization":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Organization = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "organizationUnit":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.OrganizationUnit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizationUnit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OpenSSLCertificateAuthoritySpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOpenSSLCertificateAuthoritySpec) {
					name = jsonFieldsNameOfOpenSSLCertificateAuthoritySpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OpenSSLCertificateAuthoritySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OpenSSLCertificateAuthoritySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddOnInfo as json.
func (o OptAddOnInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AddOnInfo from json.
func (o *OptAddOnInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAddOnInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAddOnInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAddOnInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdvancedOptions as json.
func (o OptAdvancedOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AdvancedOptions from json.
func (o *OptAdvancedOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAdvancedOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAdvancedOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAdvancedOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Applicability as json.
func (o OptApplicability) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Applicability from json.
func (o *OptApplicability) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptApplicability to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptApplicability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptApplicability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssessmentMetadata as json.
func (o OptAssessmentMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AssessmentMetadata from json.
func (o *OptAssessmentMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssessmentMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssessmentMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssessmentMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssessmentOutputPresentedArtifactsMap as json.
func (o OptAssessmentOutputPresentedArtifactsMap) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AssessmentOutputPresentedArtifactsMap from json.
func (o *OptAssessmentOutputPresentedArtifactsMap) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssessmentOutputPresentedArtifactsMap to nil")
	}
	o.Set = true
	o.Value = make(AssessmentOutputPresentedArtifactsMap)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssessmentOutputPresentedArtifactsMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssessmentOutputPresentedArtifactsMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssessmentOutputStatus as json.
func (o OptAssessmentOutputStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AssessmentOutputStatus from json.
func (o *OptAssessmentOutputStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssessmentOutputStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssessmentOutputStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssessmentOutputStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssessmentPartialRetryInputOptions as json.
func (o OptAssessmentPartialRetryInputOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AssessmentPartialRetryInputOptions from json.
func (o *OptAssessmentPartialRetryInputOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssessmentPartialRetryInputOptions to nil")
	}
	o.Set = true
	o.Value = make(AssessmentPartialRetryInputOptions)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssessmentPartialRetryInputOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssessmentPartialRetryInputOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssociatedTask as json.
func (o OptAssociatedTask) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AssociatedTask from json.
func (o *OptAssociatedTask) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssociatedTask to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssociatedTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssociatedTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthenticatedResource as json.
func (o OptAuthenticatedResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AuthenticatedResource from json.
func (o *OptAuthenticatedResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuthenticatedResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAuthenticatedResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAuthenticatedResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutoRotateCredentialPolicy as json.
func (o OptAutoRotateCredentialPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AutoRotateCredentialPolicy from json.
func (o *OptAutoRotateCredentialPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAutoRotateCredentialPolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAutoRotateCredentialPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAutoRotateCredentialPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutoRotateCredentialPolicyInputSpec as json.
func (o OptAutoRotateCredentialPolicyInputSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AutoRotateCredentialPolicyInputSpec from json.
func (o *OptAutoRotateCredentialPolicyInputSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAutoRotateCredentialPolicyInputSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAutoRotateCredentialPolicyInputSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAutoRotateCredentialPolicyInputSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BackupRetentionPolicy as json.
func (o OptBackupRetentionPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BackupRetentionPolicy from json.
func (o *OptBackupRetentionPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBackupRetentionPolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBackupRetentionPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBackupRetentionPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BaseImageDetails as json.
func (o OptBaseImageDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BaseImageDetails from json.
func (o *OptBaseImageDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBaseImageDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBaseImageDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBaseImageDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BasicAuthDetails as json.
func (o OptBasicAuthDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BasicAuthDetails from json.
func (o *OptBasicAuthDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBasicAuthDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBasicAuthDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBasicAuthDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Bundle as json.
func (o OptBundle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Bundle from json.
func (o *OptBundle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBundle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBundle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBundle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BundleDownloadSpec as json.
func (o OptBundleDownloadSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BundleDownloadSpec from json.
func (o *OptBundleDownloadSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBundleDownloadSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBundleDownloadSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBundleDownloadSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CPU as json.
func (o OptCPU) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CPU from json.
func (o *OptCPU) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCPU to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCPU) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCPU) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Capacity as json.
func (o OptCapacity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Capacity from json.
func (o *OptCapacity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCapacity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCapacity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCapacity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckSetQueryResourceResultExtraContext as json.
func (o OptCheckSetQueryResourceResultExtraContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CheckSetQueryResourceResultExtraContext from json.
func (o *OptCheckSetQueryResourceResultExtraContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCheckSetQueryResourceResultExtraContext to nil")
	}
	o.Set = true
	o.Value = make(CheckSetQueryResourceResultExtraContext)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCheckSetQueryResourceResultExtraContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCheckSetQueryResourceResultExtraContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClassificationSource as json.
func (o OptClassificationSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ClassificationSource from json.
func (o *OptClassificationSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClassificationSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClassificationSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClassificationSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClusterCompactionSpec as json.
func (o OptClusterCompactionSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClusterCompactionSpec from json.
func (o *OptClusterCompactionSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClusterCompactionSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClusterCompactionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClusterCompactionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClusterCriterionArguments as json.
func (o OptClusterCriterionArguments) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClusterCriterionArguments from json.
func (o *OptClusterCriterionArguments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClusterCriterionArguments to nil")
	}
	o.Set = true
	o.Value = make(ClusterCriterionArguments)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClusterCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClusterCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClusterExpansionNetworkSpec as json.
func (o OptClusterExpansionNetworkSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClusterExpansionNetworkSpec from json.
func (o *OptClusterExpansionNetworkSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClusterExpansionNetworkSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClusterExpansionNetworkSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClusterExpansionNetworkSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClusterExpansionSpec as json.
func (o OptClusterExpansionSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClusterExpansionSpec from json.
func (o *OptClusterExpansionSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClusterExpansionSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClusterExpansionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClusterExpansionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClusterNetworkConfigurationCriterionArguments as json.
func (o OptClusterNetworkConfigurationCriterionArguments) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClusterNetworkConfigurationCriterionArguments from json.
func (o *OptClusterNetworkConfigurationCriterionArguments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClusterNetworkConfigurationCriterionArguments to nil")
	}
	o.Set = true
	o.Value = make(ClusterNetworkConfigurationCriterionArguments)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClusterNetworkConfigurationCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClusterNetworkConfigurationCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClusterReference as json.
func (o OptClusterReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClusterReference from json.
func (o *OptClusterReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClusterReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClusterReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClusterReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClusterSpec as json.
func (o OptClusterSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClusterSpec from json.
func (o *OptClusterSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClusterSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClusterStretchNetworkSpec as json.
func (o OptClusterStretchNetworkSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClusterStretchNetworkSpec from json.
func (o *OptClusterStretchNetworkSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClusterStretchNetworkSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClusterStretchNetworkSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClusterStretchNetworkSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClusterStretchSpec as json.
func (o OptClusterStretchSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClusterStretchSpec from json.
func (o *OptClusterStretchSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClusterStretchSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClusterStretchSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClusterStretchSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CpuInfo as json.
func (o OptCpuInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CpuInfo from json.
func (o *OptCpuInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCpuInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCpuInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCpuInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CustomISOSpec as json.
func (o OptCustomISOSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CustomISOSpec from json.
func (o *OptCustomISOSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCustomISOSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCustomISOSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCustomISOSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataMetric as json.
func (o OptDataMetric) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataMetric from json.
func (o *OptDataMetric) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataMetric to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataMetric) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataMetric) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataMetricUnit as json.
func (o OptDataMetricUnit) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DataMetricUnit from json.
func (o *OptDataMetricUnit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataMetricUnit to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataMetricUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataMetricUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatastoreCriterionArguments as json.
func (o OptDatastoreCriterionArguments) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatastoreCriterionArguments from json.
func (o *OptDatastoreCriterionArguments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatastoreCriterionArguments to nil")
	}
	o.Set = true
	o.Value = make(DatastoreCriterionArguments)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatastoreCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatastoreCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DepotAccount as json.
func (o OptDepotAccount) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DepotAccount from json.
func (o *OptDepotAccount) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDepotAccount to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDepotAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDepotAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DepotConfiguration as json.
func (o OptDepotConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DepotConfiguration from json.
func (o *OptDepotConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDepotConfiguration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDepotConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDepotConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DiscoveryProgress as json.
func (o OptDiscoveryProgress) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DiscoveryProgress from json.
func (o *OptDiscoveryProgress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDiscoveryProgress to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDiscoveryProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDiscoveryProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainInfo as json.
func (o OptDomainInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DomainInfo from json.
func (o *OptDomainInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDomainInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDomainInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDomainInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainInfoDomainType as json.
func (o OptDomainInfoDomainType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DomainInfoDomainType from json.
func (o *OptDomainInfoDomainType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDomainInfoDomainType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDomainInfoDomainType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDomainInfoDomainType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainReference as json.
func (o OptDomainReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DomainReference from json.
func (o *OptDomainReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDomainReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDomainReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDomainReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainRelease as json.
func (o OptDomainRelease) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DomainRelease from json.
func (o *OptDomainRelease) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDomainRelease to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDomainRelease) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDomainRelease) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EdgeClusterExpansionSpec as json.
func (o OptEdgeClusterExpansionSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EdgeClusterExpansionSpec from json.
func (o *OptEdgeClusterExpansionSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEdgeClusterExpansionSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEdgeClusterExpansionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEdgeClusterExpansionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EdgeClusterNsxtEntityCriterionArguments as json.
func (o OptEdgeClusterNsxtEntityCriterionArguments) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EdgeClusterNsxtEntityCriterionArguments from json.
func (o *OptEdgeClusterNsxtEntityCriterionArguments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEdgeClusterNsxtEntityCriterionArguments to nil")
	}
	o.Set = true
	o.Value = make(EdgeClusterNsxtEntityCriterionArguments)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEdgeClusterNsxtEntityCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEdgeClusterNsxtEntityCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EdgeClusterShrinkageSpec as json.
func (o OptEdgeClusterShrinkageSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EdgeClusterShrinkageSpec from json.
func (o *OptEdgeClusterShrinkageSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEdgeClusterShrinkageSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEdgeClusterShrinkageSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEdgeClusterShrinkageSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EdgeTepIpAddressPoolSpec as json.
func (o OptEdgeTepIpAddressPoolSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EdgeTepIpAddressPoolSpec from json.
func (o *OptEdgeTepIpAddressPoolSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEdgeTepIpAddressPoolSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEdgeTepIpAddressPoolSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEdgeTepIpAddressPoolSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Encryption as json.
func (o OptEncryption) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Encryption from json.
func (o *OptEncryption) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEncryption to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEncryption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEncryption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityRest as json.
func (o OptEntityRest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EntityRest from json.
func (o *OptEntityRest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEntityRest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEntityRest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEntityRest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EntityRestProperties as json.
func (o OptEntityRestProperties) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EntityRestProperties from json.
func (o *OptEntityRestProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEntityRestProperties to nil")
	}
	o.Set = true
	o.Value = make(EntityRestProperties)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEntityRestProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEntityRestProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Error as json.
func (o OptError) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Error from json.
func (o *OptError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptError to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorContext as json.
func (o OptErrorContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorContext from json.
func (o *OptErrorContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorContext to nil")
	}
	o.Set = true
	o.Value = make(ErrorContext)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorResponseContext as json.
func (o OptErrorResponseContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorResponseContext from json.
func (o *OptErrorResponseContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorResponseContext to nil")
	}
	o.Set = true
	o.Value = make(ErrorResponseContext)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorResponseContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorResponseContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EsaConfig as json.
func (o OptEsaConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EsaConfig from json.
func (o *OptEsaConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEsaConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEsaConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEsaConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EsxUpgradeFailureAction as json.
func (o OptEsxUpgradeFailureAction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EsxUpgradeFailureAction from json.
func (o *OptEsxUpgradeFailureAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEsxUpgradeFailureAction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEsxUpgradeFailureAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEsxUpgradeFailureAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EsxUpgradeOptionsSpec as json.
func (o OptEsxUpgradeOptionsSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EsxUpgradeOptionsSpec from json.
func (o *OptEsxUpgradeOptionsSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEsxUpgradeOptionsSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEsxUpgradeOptionsSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEsxUpgradeOptionsSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExpirationDetails as json.
func (o OptExpirationDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExpirationDetails from json.
func (o *OptExpirationDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExpirationDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExpirationDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExpirationDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FederatedIdentityProviderInfo as json.
func (o OptFederatedIdentityProviderInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FederatedIdentityProviderInfo from json.
func (o *OptFederatedIdentityProviderInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFederatedIdentityProviderInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFederatedIdentityProviderInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFederatedIdentityProviderInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FrequencyMetric as json.
func (o OptFrequencyMetric) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FrequencyMetric from json.
func (o *OptFrequencyMetric) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFrequencyMetric to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFrequencyMetric) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFrequencyMetric) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FrequencyMetricUnit as json.
func (o OptFrequencyMetricUnit) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes FrequencyMetricUnit from json.
func (o *OptFrequencyMetricUnit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFrequencyMetricUnit to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFrequencyMetricUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFrequencyMetricUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HardwareSupportInfo as json.
func (o OptHardwareSupportInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HardwareSupportInfo from json.
func (o *OptHardwareSupportInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHardwareSupportInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHardwareSupportInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHardwareSupportInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HciMeshData as json.
func (o OptHciMeshData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HciMeshData from json.
func (o *OptHciMeshData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHciMeshData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHciMeshData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHciMeshData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthChecks as json.
func (o OptHealthChecks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HealthChecks from json.
func (o *OptHealthChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthChecks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthSummaryConfig as json.
func (o OptHealthSummaryConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HealthSummaryConfig from json.
func (o *OptHealthSummaryConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthSummaryConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthSummaryConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthSummaryConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthSummaryIncludeItems as json.
func (o OptHealthSummaryIncludeItems) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HealthSummaryIncludeItems from json.
func (o *OptHealthSummaryIncludeItems) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthSummaryIncludeItems to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthSummaryIncludeItems) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthSummaryIncludeItems) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthSummaryOption as json.
func (o OptHealthSummaryOption) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HealthSummaryOption from json.
func (o *OptHealthSummaryOption) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthSummaryOption to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthSummaryOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthSummaryOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthSummaryScope as json.
func (o OptHealthSummaryScope) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HealthSummaryScope from json.
func (o *OptHealthSummaryScope) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthSummaryScope to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthSummaryScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthSummaryScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HighAvailability as json.
func (o OptHighAvailability) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HighAvailability from json.
func (o *OptHighAvailability) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHighAvailability to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHighAvailability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHighAvailability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Host as json.
func (o OptHost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Host from json.
func (o *OptHost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HostCriterionArguments as json.
func (o OptHostCriterionArguments) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HostCriterionArguments from json.
func (o *OptHostCriterionArguments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHostCriterionArguments to nil")
	}
	o.Set = true
	o.Value = make(HostCriterionArguments)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHostCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHostCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HostNetworkConfiguration as json.
func (o OptHostNetworkConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HostNetworkConfiguration from json.
func (o *OptHostNetworkConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHostNetworkConfiguration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHostNetworkConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHostNetworkConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HostNetworkSpec as json.
func (o OptHostNetworkSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HostNetworkSpec from json.
func (o *OptHostNetworkSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHostNetworkSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHostNetworkSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHostNetworkSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IdentityProviderDirectory as json.
func (o OptIdentityProviderDirectory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IdentityProviderDirectory from json.
func (o *OptIdentityProviderDirectory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIdentityProviderDirectory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIdentityProviderDirectory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIdentityProviderDirectory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IpAddressPoolSpec as json.
func (o OptIpAddressPoolSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IpAddressPoolSpec from json.
func (o *OptIpAddressPoolSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIpAddressPoolSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIpAddressPoolSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIpAddressPoolSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IpAllocation as json.
func (o OptIpAllocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IpAllocation from json.
func (o *OptIpAllocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIpAllocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIpAllocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIpAllocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IsolationSpec as json.
func (o OptIsolationSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IsolationSpec from json.
func (o *OptIsolationSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIsolationSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIsolationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIsolationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LdapInfo as json.
func (o OptLdapInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LdapInfo from json.
func (o *OptLdapInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLdapInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLdapInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLdapInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LicenseKeyUsage as json.
func (o OptLicenseKeyUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LicenseKeyUsage from json.
func (o *OptLicenseKeyUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLicenseKeyUsage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLicenseKeyUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLicenseKeyUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LicenseKeyValidity as json.
func (o OptLicenseKeyValidity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LicenseKeyValidity from json.
func (o *OptLicenseKeyValidity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLicenseKeyValidity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLicenseKeyValidity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLicenseKeyValidity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LicensingInfoReference as json.
func (o OptLicensingInfoReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LicensingInfoReference from json.
func (o *OptLicensingInfoReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLicensingInfoReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLicensingInfoReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLicensingInfoReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Logs as json.
func (o OptLogs) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Logs from json.
func (o *OptLogs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLogs to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLogs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLogs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Memory as json.
func (o OptMemory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Memory from json.
func (o *OptMemory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMemory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MemoryInfo as json.
func (o OptMemoryInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MemoryInfo from json.
func (o *OptMemoryInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMemoryInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMemoryInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMemoryInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MessagePack as json.
func (o OptMessagePack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MessagePack from json.
func (o *OptMessagePack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMessagePack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMessagePack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMessagePack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MicrosoftCertificateAuthoritySpec as json.
func (o OptMicrosoftCertificateAuthoritySpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MicrosoftCertificateAuthoritySpec from json.
func (o *OptMicrosoftCertificateAuthoritySpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMicrosoftCertificateAuthoritySpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMicrosoftCertificateAuthoritySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMicrosoftCertificateAuthoritySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkPoolReference as json.
func (o OptNetworkPoolReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NetworkPoolReference from json.
func (o *OptNetworkPoolReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNetworkPoolReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNetworkPoolReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNetworkPoolReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NiocTrafficResourceAllocation as json.
func (o OptNiocTrafficResourceAllocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NiocTrafficResourceAllocation from json.
func (o *OptNiocTrafficResourceAllocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNiocTrafficResourceAllocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNiocTrafficResourceAllocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNiocTrafficResourceAllocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxClusterSpec as json.
func (o OptNsxClusterSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxClusterSpec from json.
func (o *OptNsxClusterSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxClusterSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxTClusterReference as json.
func (o OptNsxTClusterReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxTClusterReference from json.
func (o *OptNsxTClusterReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxTClusterReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxTClusterReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxTClusterReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxTClusterSpec as json.
func (o OptNsxTClusterSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxTClusterSpec from json.
func (o *OptNsxTClusterSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxTClusterSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxTClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxTClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxTCriterionArguments as json.
func (o OptNsxTCriterionArguments) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxTCriterionArguments from json.
func (o *OptNsxTCriterionArguments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxTCriterionArguments to nil")
	}
	o.Set = true
	o.Value = make(NsxTCriterionArguments)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxTCriterionArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxTCriterionArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxTSpec as json.
func (o OptNsxTSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxTSpec from json.
func (o *OptNsxTSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxTSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxTSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxTSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxtManagerCluster as json.
func (o OptNsxtManagerCluster) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxtManagerCluster from json.
func (o *OptNsxtManagerCluster) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxtManagerCluster to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxtManagerCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxtManagerCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxtSwitchConfig as json.
func (o OptNsxtSwitchConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxtSwitchConfig from json.
func (o *OptNsxtSwitchConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxtSwitchConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxtSwitchConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxtSwitchConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxtSwitchConfiguration as json.
func (o OptNsxtSwitchConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxtSwitchConfiguration from json.
func (o *OptNsxtSwitchConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxtSwitchConfiguration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxtSwitchConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxtSwitchConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxtTransportZone as json.
func (o OptNsxtTransportZone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxtTransportZone from json.
func (o *OptNsxtTransportZone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxtTransportZone to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxtTransportZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxtTransportZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxtUpgradeCoordinator as json.
func (o OptNsxtUpgradeCoordinator) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxtUpgradeCoordinator from json.
func (o *OptNsxtUpgradeCoordinator) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxtUpgradeCoordinator to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxtUpgradeCoordinator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxtUpgradeCoordinator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxtUpgradeOptions as json.
func (o OptNsxtUpgradeOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxtUpgradeOptions from json.
func (o *OptNsxtUpgradeOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxtUpgradeOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxtUpgradeOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxtUpgradeOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NsxtUpgradeUserInputSpec as json.
func (o OptNsxtUpgradeUserInputSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NsxtUpgradeUserInputSpec from json.
func (o *OptNsxtUpgradeUserInputSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNsxtUpgradeUserInputSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNsxtUpgradeUserInputSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNsxtUpgradeUserInputSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OidcInfo as json.
func (o OptOidcInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OidcInfo from json.
func (o *OptOidcInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOidcInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOidcInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOidcInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OpenSSLCertificateAuthoritySpec as json.
func (o OptOpenSSLCertificateAuthoritySpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OpenSSLCertificateAuthoritySpec from json.
func (o *OptOpenSSLCertificateAuthoritySpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOpenSSLCertificateAuthoritySpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOpenSSLCertificateAuthoritySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOpenSSLCertificateAuthoritySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PageCluster as json.
func (o OptPageCluster) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PageCluster from json.
func (o *OptPageCluster) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPageCluster to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPageCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPageCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PageClusterNetworkConfiguration as json.
func (o OptPageClusterNetworkConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PageClusterNetworkConfiguration from json.
func (o *OptPageClusterNetworkConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPageClusterNetworkConfiguration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPageClusterNetworkConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPageClusterNetworkConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PageDatastore as json.
func (o OptPageDatastore) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PageDatastore from json.
func (o *OptPageDatastore) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPageDatastore to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPageDatastore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPageDatastore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PageHost as json.
func (o OptPageHost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PageHost from json.
func (o *OptPageHost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPageHost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPageHost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPageHost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PageMetadata as json.
func (o OptPageMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PageMetadata from json.
func (o *OptPageMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPageMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPageMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPageMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PageNsxTCluster as json.
func (o OptPageNsxTCluster) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PageNsxTCluster from json.
func (o *OptPageNsxTCluster) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPageNsxTCluster to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPageNsxTCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPageNsxTCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PartnerExtensionSpec as json.
func (o OptPartnerExtensionSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PartnerExtensionSpec from json.
func (o *OptPartnerExtensionSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPartnerExtensionSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPartnerExtensionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPartnerExtensionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalitySpec as json.
func (o OptPersonalitySpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonalitySpec from json.
func (o *OptPersonalitySpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPersonalitySpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPersonalitySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPersonalitySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalityUploadSpecRaw as json.
func (o OptPersonalityUploadSpecRaw) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonalityUploadSpecRaw from json.
func (o *OptPersonalityUploadSpecRaw) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPersonalityUploadSpecRaw to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPersonalityUploadSpecRaw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPersonalityUploadSpecRaw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalityUploadSpecRawWithFileUploadId as json.
func (o OptPersonalityUploadSpecRawWithFileUploadId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonalityUploadSpecRawWithFileUploadId from json.
func (o *OptPersonalityUploadSpecRawWithFileUploadId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPersonalityUploadSpecRawWithFileUploadId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPersonalityUploadSpecRawWithFileUploadId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPersonalityUploadSpecRawWithFileUploadId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonalityUploadSpecReferred as json.
func (o OptPersonalityUploadSpecReferred) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonalityUploadSpecReferred from json.
func (o *OptPersonalityUploadSpecReferred) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPersonalityUploadSpecReferred to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPersonalityUploadSpecReferred) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPersonalityUploadSpecReferred) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PhysicalNicUnit as json.
func (o OptPhysicalNicUnit) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PhysicalNicUnit from json.
func (o *OptPhysicalNicUnit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPhysicalNicUnit to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPhysicalNicUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPhysicalNicUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PortgroupConfigSupportedTeamingPolicies as json.
func (o OptPortgroupConfigSupportedTeamingPolicies) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PortgroupConfigSupportedTeamingPolicies from json.
func (o *OptPortgroupConfigSupportedTeamingPolicies) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPortgroupConfigSupportedTeamingPolicies to nil")
	}
	o.Set = true
	o.Value = make(PortgroupConfigSupportedTeamingPolicies)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPortgroupConfigSupportedTeamingPolicies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPortgroupConfigSupportedTeamingPolicies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProductInfo as json.
func (o OptProductInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProductInfo from json.
func (o *OptProductInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProductInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProductInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProductInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProductVersionCatalogPatches as json.
func (o OptProductVersionCatalogPatches) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProductVersionCatalogPatches from json.
func (o *OptProductVersionCatalogPatches) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProductVersionCatalogPatches to nil")
	}
	o.Set = true
	o.Value = make(ProductVersionCatalogPatches)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProductVersionCatalogPatches) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProductVersionCatalogPatches) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyConfigurationTransferProtocol as json.
func (o OptProxyConfigurationTransferProtocol) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProxyConfigurationTransferProtocol from json.
func (o *OptProxyConfigurationTransferProtocol) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProxyConfigurationTransferProtocol to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProxyConfigurationTransferProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProxyConfigurationTransferProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxySpec as json.
func (o OptProxySpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProxySpec from json.
func (o *OptProxySpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProxySpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProxySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProxySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueryInfo as json.
func (o OptQueryInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes QueryInfo from json.
func (o *OptQueryInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQueryInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQueryInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQueryInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RefreshToken as json.
func (o OptRefreshToken) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RefreshToken from json.
func (o *OptRefreshToken) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRefreshToken to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRefreshToken) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRefreshToken) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Resource as json.
func (o OptResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Resource from json.
func (o *OptResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceDomainInfo as json.
func (o OptResourceDomainInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResourceDomainInfo from json.
func (o *OptResourceDomainInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResourceDomainInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResourceDomainInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResourceDomainInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceDomainInfoDomainType as json.
func (o OptResourceDomainInfoDomainType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResourceDomainInfoDomainType from json.
func (o *OptResourceDomainInfoDomainType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResourceDomainInfoDomainType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResourceDomainInfoDomainType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResourceDomainInfoDomainType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourcePoolSpecCpuSharesLevel as json.
func (o OptResourcePoolSpecCpuSharesLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResourcePoolSpecCpuSharesLevel from json.
func (o *OptResourcePoolSpecCpuSharesLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResourcePoolSpecCpuSharesLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResourcePoolSpecCpuSharesLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResourcePoolSpecCpuSharesLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourcePoolSpecMemorySharesLevel as json.
func (o OptResourcePoolSpecMemorySharesLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResourcePoolSpecMemorySharesLevel from json.
func (o *OptResourcePoolSpecMemorySharesLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResourcePoolSpecMemorySharesLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResourcePoolSpecMemorySharesLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResourcePoolSpecMemorySharesLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourcePoolSpecType as json.
func (o OptResourcePoolSpecType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResourcePoolSpecType from json.
func (o *OptResourcePoolSpecType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResourcePoolSpecType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResourcePoolSpecType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResourcePoolSpecType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceWarningContext as json.
func (o OptResourceWarningContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResourceWarningContext from json.
func (o *OptResourceWarningContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResourceWarningContext to nil")
	}
	o.Set = true
	o.Value = make(ResourceWarningContext)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResourceWarningContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResourceWarningContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceWarningCreationSpecContext as json.
func (o OptResourceWarningCreationSpecContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResourceWarningCreationSpecContext from json.
func (o *OptResourceWarningCreationSpecContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResourceWarningCreationSpecContext to nil")
	}
	o.Set = true
	o.Value = make(ResourceWarningCreationSpecContext)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResourceWarningCreationSpecContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResourceWarningCreationSpecContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SddcClusterSpec as json.
func (o OptSddcClusterSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SddcClusterSpec from json.
func (o *OptSddcClusterSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSddcClusterSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSddcClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSddcClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SddcClusterSpecVmFolders as json.
func (o OptSddcClusterSpecVmFolders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SddcClusterSpecVmFolders from json.
func (o *OptSddcClusterSpecVmFolders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSddcClusterSpecVmFolders to nil")
	}
	o.Set = true
	o.Value = make(SddcClusterSpecVmFolders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSddcClusterSpecVmFolders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSddcClusterSpecVmFolders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SddcCredentials as json.
func (o OptSddcCredentials) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SddcCredentials from json.
func (o *OptSddcCredentials) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSddcCredentials to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSddcCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSddcCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SddcManagerSpec as json.
func (o OptSddcManagerSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SddcManagerSpec from json.
func (o *OptSddcManagerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSddcManagerSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSddcManagerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSddcManagerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SddcNsxtSpec as json.
func (o OptSddcNsxtSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SddcNsxtSpec from json.
func (o *OptSddcNsxtSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSddcNsxtSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSddcNsxtSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSddcNsxtSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SddcSpec as json.
func (o OptSddcSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SddcSpec from json.
func (o *OptSddcSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSddcSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSddcSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSddcSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecuritySpec as json.
func (o OptSecuritySpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SecuritySpec from json.
func (o *OptSecuritySpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSecuritySpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSecuritySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSecuritySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SharesInfo as json.
func (o OptSharesInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SharesInfo from json.
func (o *OptSharesInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSharesInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSharesInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSharesInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SmartNicInfo as json.
func (o OptSmartNicInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SmartNicInfo from json.
func (o *OptSmartNicInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSmartNicInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSmartNicInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSmartNicInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SoftwareInfo as json.
func (o OptSoftwareInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SoftwareInfo from json.
func (o *OptSoftwareInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSoftwareInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSoftwareInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSoftwareInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SoftwareInfoComponents as json.
func (o OptSoftwareInfoComponents) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SoftwareInfoComponents from json.
func (o *OptSoftwareInfoComponents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSoftwareInfoComponents to nil")
	}
	o.Set = true
	o.Value = make(SoftwareInfoComponents)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSoftwareInfoComponents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSoftwareInfoComponents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SourceDetails as json.
func (o OptSourceDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SourceDetails from json.
func (o *OptSourceDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSourceDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSourceDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSourceDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SsoDomainSpec as json.
func (o OptSsoDomainSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SsoDomainSpec from json.
func (o *OptSsoDomainSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSsoDomainSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSsoDomainSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSsoDomainSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Storage as json.
func (o OptStorage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Storage from json.
func (o *OptStorage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStorage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStorage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStorage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StorageInfo as json.
func (o OptStorageInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StorageInfo from json.
func (o *OptStorageInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStorageInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStorageInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStorageInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SupportBundleConfig as json.
func (o OptSupportBundleConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SupportBundleConfig from json.
func (o *OptSupportBundleConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSupportBundleConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSupportBundleConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSupportBundleConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SupportBundleIncludeItems as json.
func (o OptSupportBundleIncludeItems) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SupportBundleIncludeItems from json.
func (o *OptSupportBundleIncludeItems) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSupportBundleIncludeItems to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSupportBundleIncludeItems) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSupportBundleIncludeItems) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SupportBundleOption as json.
func (o OptSupportBundleOption) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SupportBundleOption from json.
func (o *OptSupportBundleOption) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSupportBundleOption to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSupportBundleOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSupportBundleOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SupportBundleScope as json.
func (o OptSupportBundleScope) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SupportBundleScope from json.
func (o *OptSupportBundleScope) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSupportBundleScope to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSupportBundleScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSupportBundleScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SyncClientTokenInfo as json.
func (o OptSyncClientTokenInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SyncClientTokenInfo from json.
func (o *OptSyncClientTokenInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSyncClientTokenInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSyncClientTokenInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSyncClientTokenInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaggedResource as json.
func (o OptTaggedResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TaggedResource from json.
func (o *OptTaggedResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTaggedResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTaggedResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTaggedResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnmanagedResourceCredential as json.
func (o OptUnmanagedResourceCredential) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UnmanagedResourceCredential from json.
func (o *OptUnmanagedResourceCredential) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUnmanagedResourceCredential to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUnmanagedResourceCredential) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUnmanagedResourceCredential) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpgradeStatus as json.
func (o OptUpgradeStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpgradeStatus from json.
func (o *OptUpgradeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpgradeStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpgradeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpgradeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UplinkProfileSupportedTeamingPolicies as json.
func (o OptUplinkProfileSupportedTeamingPolicies) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UplinkProfileSupportedTeamingPolicies from json.
func (o *OptUplinkProfileSupportedTeamingPolicies) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUplinkProfileSupportedTeamingPolicies to nil")
	}
	o.Set = true
	o.Value = make(UplinkProfileSupportedTeamingPolicies)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUplinkProfileSupportedTeamingPolicies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUplinkProfileSupportedTeamingPolicies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationAdditionalProperties as json.
func (o OptValidationAdditionalProperties) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValidationAdditionalProperties from json.
func (o *OptValidationAdditionalProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValidationAdditionalProperties to nil")
	}
	o.Set = true
	o.Value = make(ValidationAdditionalProperties)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValidationAdditionalProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValidationAdditionalProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VcenterReference as json.
func (o OptVcenterReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VcenterReference from json.
func (o *OptVcenterReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVcenterReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVcenterReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVcenterReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VmfsDatastoreSpec as json.
func (o OptVmfsDatastoreSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VmfsDatastoreSpec from json.
func (o *OptVmfsDatastoreSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVmfsDatastoreSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVmfsDatastoreSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVmfsDatastoreSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VrealizeProductNodeType as json.
func (o OptVrealizeProductNodeType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VrealizeProductNodeType from json.
func (o *OptVrealizeProductNodeType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVrealizeProductNodeType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVrealizeProductNodeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVrealizeProductNodeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VropsNodeType as json.
func (o OptVropsNodeType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VropsNodeType from json.
func (o *OptVropsNodeType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVropsNodeType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVropsNodeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVropsNodeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VsanDatastoreSpec as json.
func (o OptVsanDatastoreSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VsanDatastoreSpec from json.
func (o *OptVsanDatastoreSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVsanDatastoreSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVsanDatastoreSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVsanDatastoreSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VsanEsaConfig as json.
func (o OptVsanEsaConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VsanEsaConfig from json.
func (o *OptVsanEsaConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVsanEsaConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVsanEsaConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVsanEsaConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VsanMaxConfig as json.
func (o OptVsanMaxConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VsanMaxConfig from json.
func (o *OptVsanMaxConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVsanMaxConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVsanMaxConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVsanMaxConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VsanRemoteDatastoreClusterSpec as json.
func (o OptVsanRemoteDatastoreClusterSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VsanRemoteDatastoreClusterSpec from json.
func (o *OptVsanRemoteDatastoreClusterSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVsanRemoteDatastoreClusterSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVsanRemoteDatastoreClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVsanRemoteDatastoreClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VsanSpec as json.
func (o OptVsanSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VsanSpec from json.
func (o *OptVsanSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVsanSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVsanSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVsanSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VxManagerSpec as json.
func (o OptVxManagerSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VxManagerSpec from json.
func (o *OptVxManagerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVxManagerSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVxManagerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVxManagerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VxRailArrayAssociationContext as json.
func (o OptVxRailArrayAssociationContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VxRailArrayAssociationContext from json.
func (o *OptVxRailArrayAssociationContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVxRailArrayAssociationContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVxRailArrayAssociationContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVxRailArrayAssociationContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VxRailArrayAssociationContextArrayAttributeIdsKeyValue as json.
func (o OptVxRailArrayAssociationContextArrayAttributeIdsKeyValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VxRailArrayAssociationContextArrayAttributeIdsKeyValue from json.
func (o *OptVxRailArrayAssociationContextArrayAttributeIdsKeyValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVxRailArrayAssociationContextArrayAttributeIdsKeyValue to nil")
	}
	o.Set = true
	o.Value = make(VxRailArrayAssociationContextArrayAttributeIdsKeyValue)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVxRailArrayAssociationContextArrayAttributeIdsKeyValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVxRailArrayAssociationContextArrayAttributeIdsKeyValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VxRailContextDatatype as json.
func (o OptVxRailContextDatatype) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VxRailContextDatatype from json.
func (o *OptVxRailContextDatatype) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVxRailContextDatatype to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVxRailContextDatatype) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVxRailContextDatatype) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VxRailDetails as json.
func (o OptVxRailDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VxRailDetails from json.
func (o *OptVxRailDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVxRailDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVxRailDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVxRailDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VxRailDetailsArrayContextWithKeyValuePair as json.
func (o OptVxRailDetailsArrayContextWithKeyValuePair) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VxRailDetailsArrayContextWithKeyValuePair from json.
func (o *OptVxRailDetailsArrayContextWithKeyValuePair) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVxRailDetailsArrayContextWithKeyValuePair to nil")
	}
	o.Set = true
	o.Value = make(VxRailDetailsArrayContextWithKeyValuePair)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVxRailDetailsArrayContextWithKeyValuePair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVxRailDetailsArrayContextWithKeyValuePair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VxRailDetailsContextWithKeyValuePair as json.
func (o OptVxRailDetailsContextWithKeyValuePair) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VxRailDetailsContextWithKeyValuePair from json.
func (o *OptVxRailDetailsContextWithKeyValuePair) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVxRailDetailsContextWithKeyValuePair to nil")
	}
	o.Set = true
	o.Value = make(VxRailDetailsContextWithKeyValuePair)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVxRailDetailsContextWithKeyValuePair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVxRailDetailsContextWithKeyValuePair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WitnessSpec as json.
func (o OptWitnessSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WitnessSpec from json.
func (o *OptWitnessSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWitnessSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWitnessSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWitnessSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Package) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Package) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfPackage = [2]string{
	0: "name",
	1: "version",
}

// Decode decodes Package from json.
func (s *Package) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Package to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Package")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackage) {
					name = jsonFieldsNameOfPackage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Package) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Package) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PackageSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PackageSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfPackageSpec = [2]string{
	0: "name",
	1: "version",
}

// Decode decodes PackageSpec from json.
func (s *PackageSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PackageSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackageSpec) {
					name = jsonFieldsNameOfPackageSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackageSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackageSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Page) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Page) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPage = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes Page from json.
func (s *Page) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Page to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]TrustedCertificate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TrustedCertificate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Page")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Page) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Page) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageCluster) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageCluster = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageCluster from json.
func (s *PageCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Cluster, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Cluster
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageClusterNetworkConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageClusterNetworkConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageClusterNetworkConfiguration = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageClusterNetworkConfiguration from json.
func (s *PageClusterNetworkConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageClusterNetworkConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]ClusterNetworkConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClusterNetworkConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageClusterNetworkConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageClusterNetworkConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageClusterNetworkConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageDatastore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageDatastore) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageDatastore = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageDatastore from json.
func (s *PageDatastore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageDatastore to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Datastore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Datastore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageDatastore")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageDatastore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageDatastore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageHost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageHost) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageHost = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageHost from json.
func (s *PageHost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageHost to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Host, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Host
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageHost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageHost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageHost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageMetadata) encodeFields(e *jx.Encoder) {
	{
		if s.PageNumber.Set {
			e.FieldStart("pageNumber")
			s.PageNumber.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("pageSize")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.TotalElements.Set {
			e.FieldStart("totalElements")
			s.TotalElements.Encode(e)
		}
	}
	{
		if s.TotalPages.Set {
			e.FieldStart("totalPages")
			s.TotalPages.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageMetadata = [4]string{
	0: "pageNumber",
	1: "pageSize",
	2: "totalElements",
	3: "totalPages",
}

// Decode decodes PageMetadata from json.
func (s *PageMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pageNumber":
			if err := func() error {
				s.PageNumber.Reset()
				if err := s.PageNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageNumber\"")
			}
		case "pageSize":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageSize\"")
			}
		case "totalElements":
			if err := func() error {
				s.TotalElements.Reset()
				if err := s.TotalElements.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalElements\"")
			}
		case "totalPages":
			if err := func() error {
				s.TotalPages.Reset()
				if err := s.TotalPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalPages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageNsxTCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageNsxTCluster) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageNsxTCluster = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageNsxTCluster from json.
func (s *PageNsxTCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageNsxTCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]NsxTCluster, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxTCluster
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageNsxTCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageNsxTCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageNsxTCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfBundle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfBundle) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfBundle = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfBundle from json.
func (s *PageOfBundle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfBundle to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Bundle, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Bundle
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfBundle")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfBundle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfBundle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfCertificate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfCertificate) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfCertificate = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfCertificate from json.
func (s *PageOfCertificate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfCertificate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Certificate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Certificate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfCertificate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfCertificate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfCertificate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfCertificateAuthority) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfCertificateAuthority) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfCertificateAuthority = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfCertificateAuthority from json.
func (s *PageOfCertificateAuthority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfCertificateAuthority to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]CertificateAuthority, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CertificateAuthority
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfCertificateAuthority")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfCertificateAuthority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfCertificateAuthority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfCluster) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfCluster = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfCluster from json.
func (s *PageOfCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Cluster, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Cluster
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfClusterCriterion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfClusterCriterion) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfClusterCriterion = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfClusterCriterion from json.
func (s *PageOfClusterCriterion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfClusterCriterion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]ClusterCriterion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClusterCriterion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfClusterCriterion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfClusterCriterion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfClusterCriterion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfCompatibilityMatrix) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfCompatibilityMatrix) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfCompatibilityMatrix = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfCompatibilityMatrix from json.
func (s *PageOfCompatibilityMatrix) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfCompatibilityMatrix to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]CompatibilityMatrix, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CompatibilityMatrix
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfCompatibilityMatrix")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfCompatibilityMatrix) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfCompatibilityMatrix) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfComplianceAudit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfComplianceAudit) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfComplianceAudit = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfComplianceAudit from json.
func (s *PageOfComplianceAudit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfComplianceAudit to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]ComplianceAudit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ComplianceAudit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfComplianceAudit")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfComplianceAudit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfComplianceAudit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfComplianceAuditItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfComplianceAuditItem) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfComplianceAuditItem = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfComplianceAuditItem from json.
func (s *PageOfComplianceAuditItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfComplianceAuditItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]ComplianceAuditItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ComplianceAuditItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfComplianceAuditItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfComplianceAuditItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfComplianceAuditItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfComplianceConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfComplianceConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfComplianceConfiguration = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfComplianceConfiguration from json.
func (s *PageOfComplianceConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfComplianceConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]ComplianceConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ComplianceConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfComplianceConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfComplianceConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfComplianceConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfComplianceStandard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfComplianceStandard) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfComplianceStandard = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfComplianceStandard from json.
func (s *PageOfComplianceStandard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfComplianceStandard to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]ComplianceStandard, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ComplianceStandard
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfComplianceStandard")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfComplianceStandard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfComplianceStandard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfConfigDriftSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfConfigDriftSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfConfigDriftSpec = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfConfigDriftSpec from json.
func (s *PageOfConfigDriftSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfConfigDriftSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]ConfigDriftSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConfigDriftSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfConfigDriftSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfConfigDriftSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfConfigDriftSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfCredential) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfCredential) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfCredential = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfCredential from json.
func (s *PageOfCredential) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfCredential to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Credential, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Credential
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfCredential")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfCredential) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfCredential) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfCredentialsTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfCredentialsTask) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfCredentialsTask = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfCredentialsTask from json.
func (s *PageOfCredentialsTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfCredentialsTask to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]CredentialsTask, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CredentialsTask
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfCredentialsTask")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfCredentialsTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfCredentialsTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfCsr) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfCsr) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfCsr = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfCsr from json.
func (s *PageOfCsr) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfCsr to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Csr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Csr
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfCsr")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfCsr) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfCsr) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfCustomIso) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfCustomIso) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfCustomIso = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfCustomIso from json.
func (s *PageOfCustomIso) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfCustomIso to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]CustomIso, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CustomIso
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfCustomIso")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfCustomIso) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfCustomIso) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfDatastoreCriterion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfDatastoreCriterion) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfDatastoreCriterion = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfDatastoreCriterion from json.
func (s *PageOfDatastoreCriterion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfDatastoreCriterion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]DatastoreCriterion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatastoreCriterion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfDatastoreCriterion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfDatastoreCriterion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfDatastoreCriterion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfDomain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfDomain) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfDomain = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfDomain from json.
func (s *PageOfDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfDomain to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Domain, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Domain
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfDomain")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfDomainFutureRelease) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfDomainFutureRelease) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfDomainFutureRelease = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfDomainFutureRelease from json.
func (s *PageOfDomainFutureRelease) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfDomainFutureRelease to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]DomainFutureRelease, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainFutureRelease
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfDomainFutureRelease")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfDomainFutureRelease) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfDomainFutureRelease) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfDomainIntegration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfDomainIntegration) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfDomainIntegration = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfDomainIntegration from json.
func (s *PageOfDomainIntegration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfDomainIntegration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]DomainIntegration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainIntegration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfDomainIntegration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfDomainIntegration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfDomainIntegration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfDomainReleaseView) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfDomainReleaseView) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfDomainReleaseView = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfDomainReleaseView from json.
func (s *PageOfDomainReleaseView) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfDomainReleaseView to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]DomainReleaseView, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainReleaseView
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfDomainReleaseView")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfDomainReleaseView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfDomainReleaseView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfEdgeCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfEdgeCluster) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfEdgeCluster = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfEdgeCluster from json.
func (s *PageOfEdgeCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfEdgeCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]EdgeCluster, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EdgeCluster
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfEdgeCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfEdgeCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfEdgeCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfEdgeClusterNsxtEntityCriterion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfEdgeClusterNsxtEntityCriterion) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfEdgeClusterNsxtEntityCriterion = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfEdgeClusterNsxtEntityCriterion from json.
func (s *PageOfEdgeClusterNsxtEntityCriterion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfEdgeClusterNsxtEntityCriterion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]EdgeClusterNsxtEntityCriterion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EdgeClusterNsxtEntityCriterion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfEdgeClusterNsxtEntityCriterion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfEdgeClusterNsxtEntityCriterion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfEdgeClusterNsxtEntityCriterion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfEndpoint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfEndpoint) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfEndpoint = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfEndpoint from json.
func (s *PageOfEndpoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfEndpoint to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Endpoint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Endpoint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfEndpoint")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfEndpoint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfEndpoint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfHealthSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfHealthSummary) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfHealthSummary = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfHealthSummary from json.
func (s *PageOfHealthSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfHealthSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]HealthSummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HealthSummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfHealthSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfHealthSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfHealthSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfHost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfHost) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfHost = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfHost from json.
func (s *PageOfHost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfHost to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Host, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Host
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfHost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfHost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfHost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfHostCriterion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfHostCriterion) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfHostCriterion = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfHostCriterion from json.
func (s *PageOfHostCriterion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfHostCriterion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]HostCriterion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostCriterion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfHostCriterion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfHostCriterion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfHostCriterion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfIdentityProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfIdentityProvider) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfIdentityProvider = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfIdentityProvider from json.
func (s *PageOfIdentityProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfIdentityProvider to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]IdentityProvider, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IdentityProvider
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfIdentityProvider")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfIdentityProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfIdentityProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfLicenseKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfLicenseKey) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfLicenseKey = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfLicenseKey from json.
func (s *PageOfLicenseKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfLicenseKey to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]LicenseKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LicenseKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfLicenseKey")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfLicenseKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfLicenseKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfNetwork) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfNetwork) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfNetwork = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfNetwork from json.
func (s *PageOfNetwork) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfNetwork to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Network, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Network
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfNetwork")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfNetwork) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfNetwork) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfNetworkPool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfNetworkPool) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfNetworkPool = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfNetworkPool from json.
func (s *PageOfNetworkPool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfNetworkPool to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]NetworkPool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NetworkPool
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfNetworkPool")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfNetworkPool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfNetworkPool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfNsxALBCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfNsxALBCluster) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfNsxALBCluster = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfNsxALBCluster from json.
func (s *PageOfNsxALBCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfNsxALBCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]NsxALBCluster, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxALBCluster
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfNsxALBCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfNsxALBCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfNsxALBCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfNsxTCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfNsxTCluster) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfNsxTCluster = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfNsxTCluster from json.
func (s *PageOfNsxTCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfNsxTCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]NsxTCluster, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxTCluster
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfNsxTCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfNsxTCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfNsxTCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfNsxTCriterion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfNsxTCriterion) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfNsxTCriterion = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfNsxTCriterion from json.
func (s *PageOfNsxTCriterion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfNsxTCriterion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]NsxTCriterion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxTCriterion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfNsxTCriterion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfNsxTCriterion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfNsxTCriterion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfNsxtIpAddressPool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfNsxtIpAddressPool) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfNsxtIpAddressPool = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfNsxtIpAddressPool from json.
func (s *PageOfNsxtIpAddressPool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfNsxtIpAddressPool to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]NsxtIpAddressPool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtIpAddressPool
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfNsxtIpAddressPool")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfNsxtIpAddressPool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfNsxtIpAddressPool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfNsxtTransportZoneInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfNsxtTransportZoneInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfNsxtTransportZoneInfo = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfNsxtTransportZoneInfo from json.
func (s *PageOfNsxtTransportZoneInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfNsxtTransportZoneInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]NsxtTransportZoneInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtTransportZoneInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfNsxtTransportZoneInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfNsxtTransportZoneInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfNsxtTransportZoneInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfPersonality) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfPersonality) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfPersonality = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfPersonality from json.
func (s *PageOfPersonality) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfPersonality to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Personality, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Personality
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfPersonality")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfPersonality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfPersonality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfPsc) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfPsc) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfPsc = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfPsc from json.
func (s *PageOfPsc) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfPsc to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Psc, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Psc
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfPsc")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfPsc) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfPsc) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfRelease) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfRelease) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfRelease = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfRelease from json.
func (s *PageOfRelease) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfRelease to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Release, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Release
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfRelease")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfRelease) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfRelease) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfResourceFunctionalities) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfResourceFunctionalities) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfResourceFunctionalities = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfResourceFunctionalities from json.
func (s *PageOfResourceFunctionalities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfResourceFunctionalities to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]ResourceFunctionalities, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourceFunctionalities
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfResourceFunctionalities")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfResourceFunctionalities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfResourceFunctionalities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfResourceWarning) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfResourceWarning) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfResourceWarning = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfResourceWarning from json.
func (s *PageOfResourceWarning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfResourceWarning to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]ResourceWarning, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourceWarning
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfResourceWarning")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfResourceWarning) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfResourceWarning) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfRole) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfRole) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfRole = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfRole from json.
func (s *PageOfRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfRole to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Role, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Role
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfRole")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfSddcManager) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfSddcManager) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfSddcManager = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfSddcManager from json.
func (s *PageOfSddcManager) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfSddcManager to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]SddcManager, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SddcManager
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfSddcManager")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfSddcManager) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfSddcManager) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfSddcTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfSddcTask) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfSddcTask = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfSddcTask from json.
func (s *PageOfSddcTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfSddcTask to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]SddcTask, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SddcTask
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfSddcTask")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfSddcTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfSddcTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfSsoDomainEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfSsoDomainEntity) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfSsoDomainEntity = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfSsoDomainEntity from json.
func (s *PageOfSsoDomainEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfSsoDomainEntity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]SsoDomainEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SsoDomainEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfSsoDomainEntity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfSsoDomainEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfSsoDomainEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfString) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfString) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfString = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfString from json.
func (s *PageOfString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfString to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfString")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfSupportBundle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfSupportBundle) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfSupportBundle = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfSupportBundle from json.
func (s *PageOfSupportBundle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfSupportBundle to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]SupportBundle, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SupportBundle
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfSupportBundle")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfSupportBundle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfSupportBundle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfTag) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfTag = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfTag from json.
func (s *PageOfTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfTag to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfTag")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfTagsForResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfTagsForResource) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfTagsForResource = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfTagsForResource from json.
func (s *PageOfTagsForResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfTagsForResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]TagsForResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TagsForResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfTagsForResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfTagsForResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfTagsForResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfTask) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfTask = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfTask from json.
func (s *PageOfTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfTask to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Task, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Task
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfTask")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfTrustedCertificate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfTrustedCertificate) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfTrustedCertificate = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfTrustedCertificate from json.
func (s *PageOfTrustedCertificate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfTrustedCertificate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]TrustedCertificate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TrustedCertificate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfTrustedCertificate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfTrustedCertificate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfTrustedCertificate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfUpgradable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfUpgradable) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfUpgradable = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfUpgradable from json.
func (s *PageOfUpgradable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfUpgradable to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Upgradable, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Upgradable
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfUpgradable")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfUpgradable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfUpgradable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfUpgradablesClusterResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfUpgradablesClusterResource) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPageOfUpgradablesClusterResource = [1]string{
	0: "elements",
}

// Decode decodes PageOfUpgradablesClusterResource from json.
func (s *PageOfUpgradablesClusterResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfUpgradablesClusterResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]UpgradablesClusterResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpgradablesClusterResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfUpgradablesClusterResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfUpgradablesClusterResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfUpgradablesClusterResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfUpgrade) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfUpgrade) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfUpgrade = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfUpgrade from json.
func (s *PageOfUpgrade) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfUpgrade to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Upgrade, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Upgrade
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfUpgrade")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfUpgrade) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfUpgrade) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfUser) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfUser = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfUser from json.
func (s *PageOfUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfUser to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]User, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem User
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfUser")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfValidation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfValidation) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfValidation = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfValidation from json.
func (s *PageOfValidation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfValidation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Validation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Validation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfValidation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfValidation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfValidation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfVasaProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfVasaProvider) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfVasaProvider = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfVasaProvider from json.
func (s *PageOfVasaProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfVasaProvider to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]VasaProvider, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VasaProvider
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfVasaProvider")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfVasaProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfVasaProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfVcenter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfVcenter) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfVcenter = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfVcenter from json.
func (s *PageOfVcenter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfVcenter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Vcenter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vcenter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfVcenter")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfVcenter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfVcenter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfVcfService) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfVcfService) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfVcfService = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfVcfService from json.
func (s *PageOfVcfService) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfVcfService to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]VcfService, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VcfService
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfVcfService")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfVcfService) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfVcfService) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfVersionAliasesForBundleComponentType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfVersionAliasesForBundleComponentType) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfVersionAliasesForBundleComponentType = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfVersionAliasesForBundleComponentType from json.
func (s *PageOfVersionAliasesForBundleComponentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfVersionAliasesForBundleComponentType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]VersionAliasesForBundleComponentType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VersionAliasesForBundleComponentType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfVersionAliasesForBundleComponentType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfVersionAliasesForBundleComponentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfVersionAliasesForBundleComponentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfVra) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfVra) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfVra = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfVra from json.
func (s *PageOfVra) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfVra to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Vra, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vra
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfVra")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfVra) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfVra) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfVrli) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfVrli) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfVrli = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfVrli from json.
func (s *PageOfVrli) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfVrli to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Vrli, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vrli
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfVrli")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfVrli) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfVrli) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfVrops) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfVrops) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfVrops = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfVrops from json.
func (s *PageOfVrops) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfVrops to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Vrops, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vrops
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfVrops")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfVrops) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfVrops) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfVrslcm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfVrslcm) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfVrslcm = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfVrslcm from json.
func (s *PageOfVrslcm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfVrslcm to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Vrslcm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vrslcm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfVrslcm")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfVrslcm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfVrslcm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageOfWsa) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageOfWsa) encodeFields(e *jx.Encoder) {
	{
		if s.Elements != nil {
			e.FieldStart("elements")
			e.ArrStart()
			for _, elem := range s.Elements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PageMetadata.Set {
			e.FieldStart("pageMetadata")
			s.PageMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageOfWsa = [2]string{
	0: "elements",
	1: "pageMetadata",
}

// Decode decodes PageOfWsa from json.
func (s *PageOfWsa) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageOfWsa to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			if err := func() error {
				s.Elements = make([]Wsa, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Wsa
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "pageMetadata":
			if err := func() error {
				s.PageMetadata.Reset()
				if err := s.PageMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageOfWsa")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageOfWsa) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageOfWsa) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PartnerExtensionSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PartnerExtensionSpec) encodeFields(e *jx.Encoder) {
	{
		if s.PartnerBundleVersion.Set {
			e.FieldStart("partnerBundleVersion")
			s.PartnerBundleVersion.Encode(e)
		}
	}
	{
		if s.PartnerBundleMetadataFilePath.Set {
			e.FieldStart("partnerBundleMetadataFilePath")
			s.PartnerBundleMetadataFilePath.Encode(e)
		}
	}
}

var jsonFieldsNameOfPartnerExtensionSpec = [2]string{
	0: "partnerBundleVersion",
	1: "partnerBundleMetadataFilePath",
}

// Decode decodes PartnerExtensionSpec from json.
func (s *PartnerExtensionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PartnerExtensionSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "partnerBundleVersion":
			if err := func() error {
				s.PartnerBundleVersion.Reset()
				if err := s.PartnerBundleVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partnerBundleVersion\"")
			}
		case "partnerBundleMetadataFilePath":
			if err := func() error {
				s.PartnerBundleMetadataFilePath.Reset()
				if err := s.PartnerBundleMetadataFilePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partnerBundleMetadataFilePath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PartnerExtensionSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PartnerExtensionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PartnerExtensionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Patch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Patch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("productVersion")
		e.Str(s.ProductVersion)
	}
	{
		e.FieldStart("artifacts")
		s.Artifacts.Encode(e)
	}
}

var jsonFieldsNameOfPatch = [2]string{
	0: "productVersion",
	1: "artifacts",
}

// Decode decodes Patch from json.
func (s *Patch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Patch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "productVersion":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ProductVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productVersion\"")
			}
		case "artifacts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Artifacts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifacts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Patch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPatch) {
					name = jsonFieldsNameOfPatch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Patch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Patch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PatchBundle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PatchBundle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bundleId")
		e.Str(s.BundleId)
	}
	{
		e.FieldStart("bundleType")
		e.Str(s.BundleType)
	}
	{
		e.FieldStart("bundleElements")
		e.ArrStart()
		for _, elem := range s.BundleElements {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("cumulativeFromVcfVersion")
		e.Str(s.CumulativeFromVcfVersion)
	}
}

var jsonFieldsNameOfPatchBundle = [4]string{
	0: "bundleId",
	1: "bundleType",
	2: "bundleElements",
	3: "cumulativeFromVcfVersion",
}

// Decode decodes PatchBundle from json.
func (s *PatchBundle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchBundle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bundleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BundleId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleId\"")
			}
		case "bundleType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BundleType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleType\"")
			}
		case "bundleElements":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.BundleElements = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.BundleElements = append(s.BundleElements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleElements\"")
			}
		case "cumulativeFromVcfVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CumulativeFromVcfVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cumulativeFromVcfVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PatchBundle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPatchBundle) {
					name = jsonFieldsNameOfPatchBundle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchBundle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchBundle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PerformDomainIsolationPrecheckBadRequest as json.
func (s *PerformDomainIsolationPrecheckBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PerformDomainIsolationPrecheckBadRequest from json.
func (s *PerformDomainIsolationPrecheckBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformDomainIsolationPrecheckBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PerformDomainIsolationPrecheckBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformDomainIsolationPrecheckBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformDomainIsolationPrecheckBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PerformDomainIsolationPrecheckInternalServerError as json.
func (s *PerformDomainIsolationPrecheckInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PerformDomainIsolationPrecheckInternalServerError from json.
func (s *PerformDomainIsolationPrecheckInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformDomainIsolationPrecheckInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PerformDomainIsolationPrecheckInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformDomainIsolationPrecheckInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformDomainIsolationPrecheckInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PerformDomainIsolationPrecheckNotFound as json.
func (s *PerformDomainIsolationPrecheckNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PerformDomainIsolationPrecheckNotFound from json.
func (s *PerformDomainIsolationPrecheckNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformDomainIsolationPrecheckNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PerformDomainIsolationPrecheckNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformDomainIsolationPrecheckNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformDomainIsolationPrecheckNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PerformUpgradeBadRequest as json.
func (s *PerformUpgradeBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PerformUpgradeBadRequest from json.
func (s *PerformUpgradeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformUpgradeBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PerformUpgradeBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformUpgradeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformUpgradeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PerformUpgradeFailedDependency as json.
func (s *PerformUpgradeFailedDependency) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PerformUpgradeFailedDependency from json.
func (s *PerformUpgradeFailedDependency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformUpgradeFailedDependency to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PerformUpgradeFailedDependency(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformUpgradeFailedDependency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformUpgradeFailedDependency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PerformUpgradeForbidden as json.
func (s *PerformUpgradeForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PerformUpgradeForbidden from json.
func (s *PerformUpgradeForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformUpgradeForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PerformUpgradeForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformUpgradeForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformUpgradeForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PerformUpgradeInternalServerError as json.
func (s *PerformUpgradeInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PerformUpgradeInternalServerError from json.
func (s *PerformUpgradeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformUpgradeInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PerformUpgradeInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformUpgradeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformUpgradeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Personality) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Personality) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("personalityId")
		e.Str(s.PersonalityId)
	}
	{
		e.FieldStart("personalityName")
		e.Str(s.PersonalityName)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("createdBy")
			s.CreatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("imageSize")
		e.Str(s.ImageSize)
	}
	{
		e.FieldStart("imageChecksum")
		e.Str(s.ImageChecksum)
	}
	{
		e.FieldStart("vsphereExportedZipPath")
		e.Str(s.VsphereExportedZipPath)
	}
	{
		e.FieldStart("vsphereExportedIsoPath")
		e.Str(s.VsphereExportedIsoPath)
	}
	{
		e.FieldStart("vsphereExportedJsonPath")
		e.Str(s.VsphereExportedJsonPath)
	}
	{
		e.FieldStart("displayName")
		e.Str(s.DisplayName)
	}
	{
		if s.ReleaseDate.Set {
			e.FieldStart("releaseDate")
			s.ReleaseDate.Encode(e)
		}
	}
	{
		if s.ImportTimestamp.Set {
			e.FieldStart("importTimestamp")
			s.ImportTimestamp.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.KbArticles.Set {
			e.FieldStart("kbArticles")
			s.KbArticles.Encode(e)
		}
	}
	{
		e.FieldStart("softwareInfo")
		s.SoftwareInfo.Encode(e)
	}
}

var jsonFieldsNameOfPersonality = [16]string{
	0:  "version",
	1:  "personalityId",
	2:  "personalityName",
	3:  "description",
	4:  "createdBy",
	5:  "imageSize",
	6:  "imageChecksum",
	7:  "vsphereExportedZipPath",
	8:  "vsphereExportedIsoPath",
	9:  "vsphereExportedJsonPath",
	10: "displayName",
	11: "releaseDate",
	12: "importTimestamp",
	13: "tags",
	14: "kbArticles",
	15: "softwareInfo",
}

// Decode decodes Personality from json.
func (s *Personality) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Personality to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "personalityId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PersonalityId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personalityId\"")
			}
		case "personalityName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PersonalityName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personalityName\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "createdBy":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBy\"")
			}
		case "imageSize":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ImageSize = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageSize\"")
			}
		case "imageChecksum":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ImageChecksum = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageChecksum\"")
			}
		case "vsphereExportedZipPath":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.VsphereExportedZipPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsphereExportedZipPath\"")
			}
		case "vsphereExportedIsoPath":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VsphereExportedIsoPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsphereExportedIsoPath\"")
			}
		case "vsphereExportedJsonPath":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VsphereExportedJsonPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsphereExportedJsonPath\"")
			}
		case "displayName":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "releaseDate":
			if err := func() error {
				s.ReleaseDate.Reset()
				if err := s.ReleaseDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releaseDate\"")
			}
		case "importTimestamp":
			if err := func() error {
				s.ImportTimestamp.Reset()
				if err := s.ImportTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importTimestamp\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "kbArticles":
			if err := func() error {
				s.KbArticles.Reset()
				if err := s.KbArticles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kbArticles\"")
			}
		case "softwareInfo":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.SoftwareInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"softwareInfo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Personality")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b10000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonality) {
					name = jsonFieldsNameOfPersonality[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Personality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Personality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonalitySpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonalitySpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("personalityId")
		e.Str(s.PersonalityId)
	}
	{
		if s.HardwareSupportSpecs != nil {
			e.FieldStart("hardwareSupportSpecs")
			e.ArrStart()
			for _, elem := range s.HardwareSupportSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPersonalitySpec = [2]string{
	0: "personalityId",
	1: "hardwareSupportSpecs",
}

// Decode decodes PersonalitySpec from json.
func (s *PersonalitySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalitySpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "personalityId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PersonalityId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personalityId\"")
			}
		case "hardwareSupportSpecs":
			if err := func() error {
				s.HardwareSupportSpecs = make([]HardwareSupportSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HardwareSupportSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HardwareSupportSpecs = append(s.HardwareSupportSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hardwareSupportSpecs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonalitySpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonalitySpec) {
					name = jsonFieldsNameOfPersonalitySpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonalitySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalitySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonalityUploadSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonalityUploadSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uploadMode")
		e.Str(s.UploadMode)
	}
	{
		if s.UploadSpecRawMode.Set {
			e.FieldStart("uploadSpecRawMode")
			s.UploadSpecRawMode.Encode(e)
		}
	}
	{
		if s.UploadSpecRawWithFileUploadIdMode.Set {
			e.FieldStart("uploadSpecRawWithFileUploadIdMode")
			s.UploadSpecRawWithFileUploadIdMode.Encode(e)
		}
	}
	{
		if s.UploadSpecReferredMode.Set {
			e.FieldStart("uploadSpecReferredMode")
			s.UploadSpecReferredMode.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfPersonalityUploadSpec = [5]string{
	0: "uploadMode",
	1: "uploadSpecRawMode",
	2: "uploadSpecRawWithFileUploadIdMode",
	3: "uploadSpecReferredMode",
	4: "name",
}

// Decode decodes PersonalityUploadSpec from json.
func (s *PersonalityUploadSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalityUploadSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uploadMode":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UploadMode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadMode\"")
			}
		case "uploadSpecRawMode":
			if err := func() error {
				s.UploadSpecRawMode.Reset()
				if err := s.UploadSpecRawMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadSpecRawMode\"")
			}
		case "uploadSpecRawWithFileUploadIdMode":
			if err := func() error {
				s.UploadSpecRawWithFileUploadIdMode.Reset()
				if err := s.UploadSpecRawWithFileUploadIdMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadSpecRawWithFileUploadIdMode\"")
			}
		case "uploadSpecReferredMode":
			if err := func() error {
				s.UploadSpecReferredMode.Reset()
				if err := s.UploadSpecReferredMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadSpecReferredMode\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonalityUploadSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonalityUploadSpec) {
					name = jsonFieldsNameOfPersonalityUploadSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonalityUploadSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalityUploadSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonalityUploadSpecRaw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonalityUploadSpecRaw) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("personalityInfoJSONFilePath")
		e.Str(s.PersonalityInfoJSONFilePath)
	}
	{
		e.FieldStart("personalityJSONFilePath")
		e.Str(s.PersonalityJSONFilePath)
	}
	{
		e.FieldStart("personalityZIPFilePath")
		e.Str(s.PersonalityZIPFilePath)
	}
	{
		if s.PersonalityISOFilePath.Set {
			e.FieldStart("personalityISOFilePath")
			s.PersonalityISOFilePath.Encode(e)
		}
	}
}

var jsonFieldsNameOfPersonalityUploadSpecRaw = [4]string{
	0: "personalityInfoJSONFilePath",
	1: "personalityJSONFilePath",
	2: "personalityZIPFilePath",
	3: "personalityISOFilePath",
}

// Decode decodes PersonalityUploadSpecRaw from json.
func (s *PersonalityUploadSpecRaw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalityUploadSpecRaw to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "personalityInfoJSONFilePath":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PersonalityInfoJSONFilePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personalityInfoJSONFilePath\"")
			}
		case "personalityJSONFilePath":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PersonalityJSONFilePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personalityJSONFilePath\"")
			}
		case "personalityZIPFilePath":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PersonalityZIPFilePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personalityZIPFilePath\"")
			}
		case "personalityISOFilePath":
			if err := func() error {
				s.PersonalityISOFilePath.Reset()
				if err := s.PersonalityISOFilePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personalityISOFilePath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonalityUploadSpecRaw")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonalityUploadSpecRaw) {
					name = jsonFieldsNameOfPersonalityUploadSpecRaw[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonalityUploadSpecRaw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalityUploadSpecRaw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonalityUploadSpecRawWithFileUploadId) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonalityUploadSpecRawWithFileUploadId) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fileUploadId")
		e.Str(s.FileUploadId)
	}
}

var jsonFieldsNameOfPersonalityUploadSpecRawWithFileUploadId = [1]string{
	0: "fileUploadId",
}

// Decode decodes PersonalityUploadSpecRawWithFileUploadId from json.
func (s *PersonalityUploadSpecRawWithFileUploadId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalityUploadSpecRawWithFileUploadId to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fileUploadId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileUploadId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileUploadId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonalityUploadSpecRawWithFileUploadId")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonalityUploadSpecRawWithFileUploadId) {
					name = jsonFieldsNameOfPersonalityUploadSpecRawWithFileUploadId[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonalityUploadSpecRawWithFileUploadId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalityUploadSpecRawWithFileUploadId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonalityUploadSpecReferred) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonalityUploadSpecReferred) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vCenterId")
		e.Str(s.VCenterId)
	}
	{
		e.FieldStart("clusterId")
		e.Str(s.ClusterId)
	}
}

var jsonFieldsNameOfPersonalityUploadSpecReferred = [2]string{
	0: "vCenterId",
	1: "clusterId",
}

// Decode decodes PersonalityUploadSpecReferred from json.
func (s *PersonalityUploadSpecReferred) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonalityUploadSpecReferred to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vCenterId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VCenterId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vCenterId\"")
			}
		case "clusterId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ClusterId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonalityUploadSpecReferred")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonalityUploadSpecReferred) {
					name = jsonFieldsNameOfPersonalityUploadSpecReferred[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonalityUploadSpecReferred) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonalityUploadSpecReferred) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PhysicalNic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PhysicalNic) encodeFields(e *jx.Encoder) {
	{
		if s.DeviceName.Set {
			e.FieldStart("deviceName")
			s.DeviceName.Encode(e)
		}
	}
	{
		if s.MacAddress.Set {
			e.FieldStart("macAddress")
			s.MacAddress.Encode(e)
		}
	}
	{
		if s.Speed.Set {
			e.FieldStart("speed")
			s.Speed.Encode(e)
		}
	}
	{
		if s.Unit.Set {
			e.FieldStart("unit")
			s.Unit.Encode(e)
		}
	}
	{
		if s.SmartNicInfo.Set {
			e.FieldStart("smartNicInfo")
			s.SmartNicInfo.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
}

var jsonFieldsNameOfPhysicalNic = [6]string{
	0: "deviceName",
	1: "macAddress",
	2: "speed",
	3: "unit",
	4: "smartNicInfo",
	5: "state",
}

// Decode decodes PhysicalNic from json.
func (s *PhysicalNic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PhysicalNic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deviceName":
			if err := func() error {
				s.DeviceName.Reset()
				if err := s.DeviceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceName\"")
			}
		case "macAddress":
			if err := func() error {
				s.MacAddress.Reset()
				if err := s.MacAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"macAddress\"")
			}
		case "speed":
			if err := func() error {
				s.Speed.Reset()
				if err := s.Speed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "unit":
			if err := func() error {
				s.Unit.Reset()
				if err := s.Unit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit\"")
			}
		case "smartNicInfo":
			if err := func() error {
				s.SmartNicInfo.Reset()
				if err := s.SmartNicInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smartNicInfo\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PhysicalNic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PhysicalNic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PhysicalNic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PhysicalNicUnit as json.
func (s PhysicalNicUnit) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PhysicalNicUnit from json.
func (s *PhysicalNicUnit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PhysicalNicUnit to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PhysicalNicUnit(v) {
	case PhysicalNicUnitKB:
		*s = PhysicalNicUnitKB
	case PhysicalNicUnitMB:
		*s = PhysicalNicUnitMB
	case PhysicalNicUnitGB:
		*s = PhysicalNicUnitGB
	case PhysicalNicUnitTB:
		*s = PhysicalNicUnitTB
	case PhysicalNicUnitPB:
		*s = PhysicalNicUnitPB
	default:
		*s = PhysicalNicUnit(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PhysicalNicUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PhysicalNicUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Portgroup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Portgroup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("transportType")
		e.Str(s.TransportType)
	}
	{
		if s.PortBindingType.Set {
			e.FieldStart("portBindingType")
			s.PortBindingType.Encode(e)
		}
	}
	{
		if s.VlanId.Set {
			e.FieldStart("vlanId")
			s.VlanId.Encode(e)
		}
	}
	{
		if s.ActiveUplinks != nil {
			e.FieldStart("activeUplinks")
			e.ArrStart()
			for _, elem := range s.ActiveUplinks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StandbyUplinks != nil {
			e.FieldStart("standbyUplinks")
			e.ArrStart()
			for _, elem := range s.StandbyUplinks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPortgroup = [6]string{
	0: "name",
	1: "transportType",
	2: "portBindingType",
	3: "vlanId",
	4: "activeUplinks",
	5: "standbyUplinks",
}

// Decode decodes Portgroup from json.
func (s *Portgroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Portgroup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "transportType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TransportType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transportType\"")
			}
		case "portBindingType":
			if err := func() error {
				s.PortBindingType.Reset()
				if err := s.PortBindingType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portBindingType\"")
			}
		case "vlanId":
			if err := func() error {
				s.VlanId.Reset()
				if err := s.VlanId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlanId\"")
			}
		case "activeUplinks":
			if err := func() error {
				s.ActiveUplinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ActiveUplinks = append(s.ActiveUplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUplinks\"")
			}
		case "standbyUplinks":
			if err := func() error {
				s.StandbyUplinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StandbyUplinks = append(s.StandbyUplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standbyUplinks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Portgroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPortgroup) {
					name = jsonFieldsNameOfPortgroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Portgroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Portgroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PortgroupConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PortgroupConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.TransportType.Set {
			e.FieldStart("transportType")
			s.TransportType.Encode(e)
		}
	}
	{
		if s.ActiveUplinks != nil {
			e.FieldStart("activeUplinks")
			e.ArrStart()
			for _, elem := range s.ActiveUplinks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StandByUplinks != nil {
			e.FieldStart("standByUplinks")
			e.ArrStart()
			for _, elem := range s.StandByUplinks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Policy.Set {
			e.FieldStart("policy")
			s.Policy.Encode(e)
		}
	}
	{
		if s.SupportedTeamingPolicies.Set {
			e.FieldStart("supportedTeamingPolicies")
			s.SupportedTeamingPolicies.Encode(e)
		}
	}
	{
		if s.VlanId.Set {
			e.FieldStart("vlanId")
			s.VlanId.Encode(e)
		}
	}
	{
		if s.Mtu.Set {
			e.FieldStart("mtu")
			s.Mtu.Encode(e)
		}
	}
}

var jsonFieldsNameOfPortgroupConfig = [8]string{
	0: "name",
	1: "transportType",
	2: "activeUplinks",
	3: "standByUplinks",
	4: "policy",
	5: "supportedTeamingPolicies",
	6: "vlanId",
	7: "mtu",
}

// Decode decodes PortgroupConfig from json.
func (s *PortgroupConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortgroupConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "transportType":
			if err := func() error {
				s.TransportType.Reset()
				if err := s.TransportType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transportType\"")
			}
		case "activeUplinks":
			if err := func() error {
				s.ActiveUplinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ActiveUplinks = append(s.ActiveUplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUplinks\"")
			}
		case "standByUplinks":
			if err := func() error {
				s.StandByUplinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StandByUplinks = append(s.StandByUplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standByUplinks\"")
			}
		case "policy":
			if err := func() error {
				s.Policy.Reset()
				if err := s.Policy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policy\"")
			}
		case "supportedTeamingPolicies":
			if err := func() error {
				s.SupportedTeamingPolicies.Reset()
				if err := s.SupportedTeamingPolicies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportedTeamingPolicies\"")
			}
		case "vlanId":
			if err := func() error {
				s.VlanId.Reset()
				if err := s.VlanId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlanId\"")
			}
		case "mtu":
			if err := func() error {
				s.Mtu.Reset()
				if err := s.Mtu.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mtu\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PortgroupConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PortgroupConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PortgroupConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PortgroupConfigSupportedTeamingPolicies) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PortgroupConfigSupportedTeamingPolicies) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes PortgroupConfigSupportedTeamingPolicies from json.
func (s *PortgroupConfigSupportedTeamingPolicies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortgroupConfigSupportedTeamingPolicies to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PortgroupConfigSupportedTeamingPolicies")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PortgroupConfigSupportedTeamingPolicies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PortgroupConfigSupportedTeamingPolicies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PortgroupSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PortgroupSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("transportType")
		e.Str(s.TransportType)
	}
	{
		if s.ActiveUplinks != nil {
			e.FieldStart("activeUplinks")
			e.ArrStart()
			for _, elem := range s.ActiveUplinks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StandByUplinks != nil {
			e.FieldStart("standByUplinks")
			e.ArrStart()
			for _, elem := range s.StandByUplinks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TeamingPolicy.Set {
			e.FieldStart("teamingPolicy")
			s.TeamingPolicy.Encode(e)
		}
	}
}

var jsonFieldsNameOfPortgroupSpec = [5]string{
	0: "name",
	1: "transportType",
	2: "activeUplinks",
	3: "standByUplinks",
	4: "teamingPolicy",
}

// Decode decodes PortgroupSpec from json.
func (s *PortgroupSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortgroupSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "transportType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TransportType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transportType\"")
			}
		case "activeUplinks":
			if err := func() error {
				s.ActiveUplinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ActiveUplinks = append(s.ActiveUplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUplinks\"")
			}
		case "standByUplinks":
			if err := func() error {
				s.StandByUplinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StandByUplinks = append(s.StandByUplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standByUplinks\"")
			}
		case "teamingPolicy":
			if err := func() error {
				s.TeamingPolicy.Reset()
				if err := s.TeamingPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamingPolicy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PortgroupSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPortgroupSpec) {
					name = jsonFieldsNameOfPortgroupSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PortgroupSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PortgroupSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostClusterQueryBadRequest as json.
func (s *PostClusterQueryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostClusterQueryBadRequest from json.
func (s *PostClusterQueryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostClusterQueryBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostClusterQueryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostClusterQueryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostClusterQueryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostClusterQueryInternalServerError as json.
func (s *PostClusterQueryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostClusterQueryInternalServerError from json.
func (s *PostClusterQueryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostClusterQueryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostClusterQueryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostClusterQueryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostClusterQueryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostClustersQueryBadRequest as json.
func (s *PostClustersQueryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostClustersQueryBadRequest from json.
func (s *PostClustersQueryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostClustersQueryBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostClustersQueryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostClustersQueryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostClustersQueryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostClustersQueryInternalServerError as json.
func (s *PostClustersQueryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostClustersQueryInternalServerError from json.
func (s *PostClustersQueryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostClustersQueryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostClustersQueryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostClustersQueryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostClustersQueryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostDatastoreQuery1BadRequest as json.
func (s *PostDatastoreQuery1BadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostDatastoreQuery1BadRequest from json.
func (s *PostDatastoreQuery1BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostDatastoreQuery1BadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostDatastoreQuery1BadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostDatastoreQuery1BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostDatastoreQuery1BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostDatastoreQuery1InternalServerError as json.
func (s *PostDatastoreQuery1InternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostDatastoreQuery1InternalServerError from json.
func (s *PostDatastoreQuery1InternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostDatastoreQuery1InternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostDatastoreQuery1InternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostDatastoreQuery1InternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostDatastoreQuery1InternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostDatastoreQueryBadRequest as json.
func (s *PostDatastoreQueryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostDatastoreQueryBadRequest from json.
func (s *PostDatastoreQueryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostDatastoreQueryBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostDatastoreQueryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostDatastoreQueryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostDatastoreQueryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostDatastoreQueryInternalServerError as json.
func (s *PostDatastoreQueryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostDatastoreQueryInternalServerError from json.
func (s *PostDatastoreQueryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostDatastoreQueryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostDatastoreQueryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostDatastoreQueryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostDatastoreQueryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostHostQueryBadRequest as json.
func (s *PostHostQueryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostHostQueryBadRequest from json.
func (s *PostHostQueryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostHostQueryBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostHostQueryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostHostQueryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostHostQueryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostHostQueryInternalServerError as json.
func (s *PostHostQueryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostHostQueryInternalServerError from json.
func (s *PostHostQueryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostHostQueryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostHostQueryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostHostQueryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostHostQueryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostHostsPrechecks1BadRequest as json.
func (s *PostHostsPrechecks1BadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostHostsPrechecks1BadRequest from json.
func (s *PostHostsPrechecks1BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostHostsPrechecks1BadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostHostsPrechecks1BadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostHostsPrechecks1BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostHostsPrechecks1BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostHostsPrechecks1InternalServerError as json.
func (s *PostHostsPrechecks1InternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostHostsPrechecks1InternalServerError from json.
func (s *PostHostsPrechecks1InternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostHostsPrechecks1InternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostHostsPrechecks1InternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostHostsPrechecks1InternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostHostsPrechecks1InternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostQueryBadRequest as json.
func (s *PostQueryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostQueryBadRequest from json.
func (s *PostQueryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostQueryBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostQueryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostQueryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostQueryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostQueryInternalServerError as json.
func (s *PostQueryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes PostQueryInternalServerError from json.
func (s *PostQueryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostQueryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostQueryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostQueryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostQueryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PrecheckSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PrecheckSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resources")
		e.ArrStart()
		for _, elem := range s.Resources {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.BundleId.Set {
			e.FieldStart("bundleId")
			s.BundleId.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
}

var jsonFieldsNameOfPrecheckSpec = [3]string{
	0: "resources",
	1: "bundleId",
	2: "mode",
}

// Decode decodes PrecheckSpec from json.
func (s *PrecheckSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PrecheckSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resources":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Resources = make([]Resource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Resource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "bundleId":
			if err := func() error {
				s.BundleId.Reset()
				if err := s.BundleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleId\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PrecheckSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPrecheckSpec) {
					name = jsonFieldsNameOfPrecheckSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PrecheckSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PrecheckSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProductInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProductInfo) encodeFields(e *jx.Encoder) {
	{
		if s.LicenseKey.Set {
			e.FieldStart("licenseKey")
			s.LicenseKey.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.LicensingMode.Set {
			e.FieldStart("licensingMode")
			s.LicensingMode.Encode(e)
		}
	}
	{
		if s.LicenseKeyStatus.Set {
			e.FieldStart("licenseKeyStatus")
			s.LicenseKeyStatus.Encode(e)
		}
	}
	{
		if s.LicenseKeyExpirationDate.Set {
			e.FieldStart("licenseKeyExpirationDate")
			s.LicenseKeyExpirationDate.Encode(e)
		}
	}
	{
		if s.ErrorResponse.Set {
			e.FieldStart("errorResponse")
			s.ErrorResponse.Encode(e)
		}
	}
}

var jsonFieldsNameOfProductInfo = [6]string{
	0: "licenseKey",
	1: "type",
	2: "licensingMode",
	3: "licenseKeyStatus",
	4: "licenseKeyExpirationDate",
	5: "errorResponse",
}

// Decode decodes ProductInfo from json.
func (s *ProductInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProductInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "licenseKey":
			if err := func() error {
				s.LicenseKey.Reset()
				if err := s.LicenseKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKey\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "licensingMode":
			if err := func() error {
				s.LicensingMode.Reset()
				if err := s.LicensingMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licensingMode\"")
			}
		case "licenseKeyStatus":
			if err := func() error {
				s.LicenseKeyStatus.Reset()
				if err := s.LicenseKeyStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKeyStatus\"")
			}
		case "licenseKeyExpirationDate":
			if err := func() error {
				s.LicenseKeyExpirationDate.Reset()
				if err := s.LicenseKeyExpirationDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKeyExpirationDate\"")
			}
		case "errorResponse":
			if err := func() error {
				s.ErrorResponse.Reset()
				if err := s.ErrorResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorResponse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProductInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProductInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProductInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProductVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProductVersion) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("publicName")
		e.Str(s.PublicName)
	}
	{
		if s.ReleaseURL.Set {
			e.FieldStart("releaseURL")
			s.ReleaseURL.Encode(e)
		}
	}
	{
		if s.AdditionalMetadata.Set {
			e.FieldStart("additionalMetadata")
			s.AdditionalMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfProductVersion = [5]string{
	0: "name",
	1: "version",
	2: "publicName",
	3: "releaseURL",
	4: "additionalMetadata",
}

// Decode decodes ProductVersion from json.
func (s *ProductVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProductVersion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "publicName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PublicName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicName\"")
			}
		case "releaseURL":
			if err := func() error {
				s.ReleaseURL.Reset()
				if err := s.ReleaseURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releaseURL\"")
			}
		case "additionalMetadata":
			if err := func() error {
				s.AdditionalMetadata.Reset()
				if err := s.AdditionalMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProductVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProductVersion) {
					name = jsonFieldsNameOfProductVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProductVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProductVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProductVersionCatalog) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProductVersionCatalog) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.SequenceNumber.Set {
			e.FieldStart("sequenceNumber")
			s.SequenceNumber.Encode(e)
		}
	}
	{
		if s.CreationTime.Set {
			e.FieldStart("creationTime")
			s.CreationTime.Encode(e)
		}
	}
	{
		if s.PublishedTime.Set {
			e.FieldStart("publishedTime")
			s.PublishedTime.Encode(e)
		}
	}
	{
		if s.Patches.Set {
			e.FieldStart("patches")
			s.Patches.Encode(e)
		}
	}
}

var jsonFieldsNameOfProductVersionCatalog = [5]string{
	0: "version",
	1: "sequenceNumber",
	2: "creationTime",
	3: "publishedTime",
	4: "patches",
}

// Decode decodes ProductVersionCatalog from json.
func (s *ProductVersionCatalog) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProductVersionCatalog to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "sequenceNumber":
			if err := func() error {
				s.SequenceNumber.Reset()
				if err := s.SequenceNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sequenceNumber\"")
			}
		case "creationTime":
			if err := func() error {
				s.CreationTime.Reset()
				if err := s.CreationTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTime\"")
			}
		case "publishedTime":
			if err := func() error {
				s.PublishedTime.Reset()
				if err := s.PublishedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publishedTime\"")
			}
		case "patches":
			if err := func() error {
				s.Patches.Reset()
				if err := s.Patches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProductVersionCatalog")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProductVersionCatalog) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProductVersionCatalog) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ProductVersionCatalogPatches) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ProductVersionCatalogPatches) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes ProductVersionCatalogPatches from json.
func (s *ProductVersionCatalogPatches) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProductVersionCatalogPatches to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []Patch
		if err := func() error {
			elem = make([]Patch, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem Patch
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProductVersionCatalogPatches")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProductVersionCatalogPatches) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProductVersionCatalogPatches) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProxyConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProxyConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.IsConfigured.Set {
			e.FieldStart("isConfigured")
			s.IsConfigured.Encode(e)
		}
	}
	{
		if s.IsEnabled.Set {
			e.FieldStart("isEnabled")
			s.IsEnabled.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.TransferProtocol.Set {
			e.FieldStart("transferProtocol")
			s.TransferProtocol.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.IsAuthenticated.Set {
			e.FieldStart("isAuthenticated")
			s.IsAuthenticated.Encode(e)
		}
	}
}

var jsonFieldsNameOfProxyConfiguration = [8]string{
	0: "isConfigured",
	1: "isEnabled",
	2: "host",
	3: "port",
	4: "transferProtocol",
	5: "username",
	6: "password",
	7: "isAuthenticated",
}

// Decode decodes ProxyConfiguration from json.
func (s *ProxyConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isConfigured":
			if err := func() error {
				s.IsConfigured.Reset()
				if err := s.IsConfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConfigured\"")
			}
		case "isEnabled":
			if err := func() error {
				s.IsEnabled.Reset()
				if err := s.IsEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEnabled\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "transferProtocol":
			if err := func() error {
				s.TransferProtocol.Reset()
				if err := s.TransferProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transferProtocol\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "isAuthenticated":
			if err := func() error {
				s.IsAuthenticated.Reset()
				if err := s.IsAuthenticated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAuthenticated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProxyConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProxyConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyConfigurationTransferProtocol as json.
func (s ProxyConfigurationTransferProtocol) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProxyConfigurationTransferProtocol from json.
func (s *ProxyConfigurationTransferProtocol) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyConfigurationTransferProtocol to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProxyConfigurationTransferProtocol(v) {
	case ProxyConfigurationTransferProtocolHTTP:
		*s = ProxyConfigurationTransferProtocolHTTP
	case ProxyConfigurationTransferProtocolHTTPS:
		*s = ProxyConfigurationTransferProtocolHTTPS
	default:
		*s = ProxyConfigurationTransferProtocol(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProxyConfigurationTransferProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyConfigurationTransferProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProxySpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProxySpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("port")
		e.Int32(s.Port)
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.TransferProtocol.Set {
			e.FieldStart("transferProtocol")
			s.TransferProtocol.Encode(e)
		}
	}
}

var jsonFieldsNameOfProxySpec = [5]string{
	0: "host",
	1: "port",
	2: "username",
	3: "password",
	4: "transferProtocol",
}

// Decode decodes ProxySpec from json.
func (s *ProxySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxySpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "transferProtocol":
			if err := func() error {
				s.TransferProtocol.Reset()
				if err := s.TransferProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transferProtocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProxySpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProxySpec) {
					name = jsonFieldsNameOfProxySpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProxySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Psc) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Psc) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Fqdn.Set {
			e.FieldStart("fqdn")
			s.Fqdn.Encode(e)
		}
	}
	{
		if s.IpAddress.Set {
			e.FieldStart("ipAddress")
			s.IpAddress.Encode(e)
		}
	}
	{
		if s.SsoDomainName.Set {
			e.FieldStart("ssoDomainName")
			s.SsoDomainName.Encode(e)
		}
	}
	{
		if s.SsoSubDomainName.Set {
			e.FieldStart("ssoSubDomainName")
			s.SsoSubDomainName.Encode(e)
		}
	}
	{
		if s.IsReplica.Set {
			e.FieldStart("isReplica")
			s.IsReplica.Encode(e)
		}
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
}

var jsonFieldsNameOfPsc = [7]string{
	0: "id",
	1: "fqdn",
	2: "ipAddress",
	3: "ssoDomainName",
	4: "ssoSubDomainName",
	5: "isReplica",
	6: "domain",
}

// Decode decodes Psc from json.
func (s *Psc) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Psc to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "fqdn":
			if err := func() error {
				s.Fqdn.Reset()
				if err := s.Fqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "ipAddress":
			if err := func() error {
				s.IpAddress.Reset()
				if err := s.IpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "ssoDomainName":
			if err := func() error {
				s.SsoDomainName.Reset()
				if err := s.SsoDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssoDomainName\"")
			}
		case "ssoSubDomainName":
			if err := func() error {
				s.SsoSubDomainName.Reset()
				if err := s.SsoSubDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssoSubDomainName\"")
			}
		case "isReplica":
			if err := func() error {
				s.IsReplica.Reset()
				if err := s.IsReplica.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isReplica\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Psc")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Psc) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Psc) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PscSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PscSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pscSsoSpec")
		s.PscSsoSpec.Encode(e)
	}
	{
		if s.AdminUserSsoPassword.Set {
			e.FieldStart("adminUserSsoPassword")
			s.AdminUserSsoPassword.Encode(e)
		}
	}
}

var jsonFieldsNameOfPscSpec = [2]string{
	0: "pscSsoSpec",
	1: "adminUserSsoPassword",
}

// Decode decodes PscSpec from json.
func (s *PscSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PscSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pscSsoSpec":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PscSsoSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pscSsoSpec\"")
			}
		case "adminUserSsoPassword":
			if err := func() error {
				s.AdminUserSsoPassword.Reset()
				if err := s.AdminUserSsoPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adminUserSsoPassword\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PscSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPscSpec) {
					name = jsonFieldsNameOfPscSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PscSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PscSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PscSsoSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PscSsoSpec) encodeFields(e *jx.Encoder) {
	{
		if s.SsoDomain.Set {
			e.FieldStart("ssoDomain")
			s.SsoDomain.Encode(e)
		}
	}
}

var jsonFieldsNameOfPscSsoSpec = [1]string{
	0: "ssoDomain",
}

// Decode decodes PscSsoSpec from json.
func (s *PscSsoSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PscSsoSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ssoDomain":
			if err := func() error {
				s.SsoDomain.Reset()
				if err := s.SsoDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssoDomain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PscSsoSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PscSsoSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PscSsoSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueryCheckSetsBadRequest as json.
func (s *QueryCheckSetsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes QueryCheckSetsBadRequest from json.
func (s *QueryCheckSetsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryCheckSetsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = QueryCheckSetsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryCheckSetsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryCheckSetsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueryCheckSetsInternalServerError as json.
func (s *QueryCheckSetsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes QueryCheckSetsInternalServerError from json.
func (s *QueryCheckSetsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryCheckSetsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = QueryCheckSetsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryCheckSetsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryCheckSetsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.QueryId.Set {
			e.FieldStart("queryId")
			s.QueryId.Encode(e)
		}
	}
	{
		if s.ErrorResponse.Set {
			e.FieldStart("errorResponse")
			s.ErrorResponse.Encode(e)
		}
	}
	{
		if s.Failure.Set {
			e.FieldStart("failure")
			s.Failure.Encode(e)
		}
	}
	{
		if s.Completed.Set {
			e.FieldStart("completed")
			s.Completed.Encode(e)
		}
	}
	{
		if s.Processing.Set {
			e.FieldStart("processing")
			s.Processing.Encode(e)
		}
	}
}

var jsonFieldsNameOfQueryInfo = [6]string{
	0: "status",
	1: "queryId",
	2: "errorResponse",
	3: "failure",
	4: "completed",
	5: "processing",
}

// Decode decodes QueryInfo from json.
func (s *QueryInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "queryId":
			if err := func() error {
				s.QueryId.Reset()
				if err := s.QueryId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryId\"")
			}
		case "errorResponse":
			if err := func() error {
				s.ErrorResponse.Reset()
				if err := s.ErrorResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorResponse\"")
			}
		case "failure":
			if err := func() error {
				s.Failure.Reset()
				if err := s.Failure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure\"")
			}
		case "completed":
			if err := func() error {
				s.Completed.Reset()
				if err := s.Completed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed\"")
			}
		case "processing":
			if err := func() error {
				s.Processing.Reset()
				if err := s.Processing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReconcileConfigsBadRequest as json.
func (s *ReconcileConfigsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReconcileConfigsBadRequest from json.
func (s *ReconcileConfigsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReconcileConfigsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReconcileConfigsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReconcileConfigsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReconcileConfigsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReconcileConfigsInternalServerError as json.
func (s *ReconcileConfigsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReconcileConfigsInternalServerError from json.
func (s *ReconcileConfigsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReconcileConfigsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReconcileConfigsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReconcileConfigsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReconcileConfigsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReconciliationForResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReconciliationForResource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceId")
		e.Str(s.ResourceId)
	}
	{
		e.FieldStart("applyAll")
		e.Bool(s.ApplyAll)
	}
}

var jsonFieldsNameOfReconciliationForResource = [2]string{
	0: "resourceId",
	1: "applyAll",
}

// Decode decodes ReconciliationForResource from json.
func (s *ReconciliationForResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReconciliationForResource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "applyAll":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.ApplyAll = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applyAll\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReconciliationForResource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReconciliationForResource) {
					name = jsonFieldsNameOfReconciliationForResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReconciliationForResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReconciliationForResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RefreshAccessTokenBadRequest as json.
func (s *RefreshAccessTokenBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RefreshAccessTokenBadRequest from json.
func (s *RefreshAccessTokenBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RefreshAccessTokenBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RefreshAccessTokenBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RefreshAccessTokenBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RefreshAccessTokenBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RefreshAccessTokenInternalServerError as json.
func (s *RefreshAccessTokenInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RefreshAccessTokenInternalServerError from json.
func (s *RefreshAccessTokenInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RefreshAccessTokenInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RefreshAccessTokenInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RefreshAccessTokenInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RefreshAccessTokenInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RefreshAccessTokenNotFound as json.
func (s *RefreshAccessTokenNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RefreshAccessTokenNotFound from json.
func (s *RefreshAccessTokenNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RefreshAccessTokenNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RefreshAccessTokenNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RefreshAccessTokenNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RefreshAccessTokenNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RefreshAccessTokenOKApplicationJSON as json.
func (s RefreshAccessTokenOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RefreshAccessTokenOKApplicationJSON from json.
func (s *RefreshAccessTokenOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RefreshAccessTokenOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RefreshAccessTokenOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RefreshAccessTokenOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RefreshAccessTokenOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RefreshToken) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RefreshToken) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfRefreshToken = [1]string{
	0: "id",
}

// Decode decodes RefreshToken from json.
func (s *RefreshToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RefreshToken to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RefreshToken")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RefreshToken) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RefreshToken) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Release) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Release) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("product")
		e.Str(s.Product)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("minCompatibleVcfVersion")
		e.Str(s.MinCompatibleVcfVersion)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("releaseDate")
		e.Str(s.ReleaseDate)
	}
	{
		e.FieldStart("bom")
		e.ArrStart()
		for _, elem := range s.Bom {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.IsApplicable.Set {
			e.FieldStart("isApplicable")
			s.IsApplicable.Encode(e)
		}
	}
	{
		if s.NotApplicableReason.Set {
			e.FieldStart("notApplicableReason")
			s.NotApplicableReason.Encode(e)
		}
	}
	{
		if s.Sku != nil {
			e.FieldStart("sku")
			e.ArrStart()
			for _, elem := range s.Sku {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Updates != nil {
			e.FieldStart("updates")
			e.ArrStart()
			for _, elem := range s.Updates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PatchBundles != nil {
			e.FieldStart("patchBundles")
			e.ArrStart()
			for _, elem := range s.PatchBundles {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Eol.Set {
			e.FieldStart("eol")
			s.Eol.Encode(e)
		}
	}
	{
		if s.UpgradeOrder.Set {
			e.FieldStart("upgradeOrder")
			s.UpgradeOrder.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelease = [13]string{
	0:  "product",
	1:  "version",
	2:  "minCompatibleVcfVersion",
	3:  "description",
	4:  "releaseDate",
	5:  "bom",
	6:  "isApplicable",
	7:  "notApplicableReason",
	8:  "sku",
	9:  "updates",
	10: "patchBundles",
	11: "eol",
	12: "upgradeOrder",
}

// Decode decodes Release from json.
func (s *Release) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Release to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "product":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Product = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "minCompatibleVcfVersion":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MinCompatibleVcfVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minCompatibleVcfVersion\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "releaseDate":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ReleaseDate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releaseDate\"")
			}
		case "bom":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Bom = make([]ProductVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProductVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Bom = append(s.Bom, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bom\"")
			}
		case "isApplicable":
			if err := func() error {
				s.IsApplicable.Reset()
				if err := s.IsApplicable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isApplicable\"")
			}
		case "notApplicableReason":
			if err := func() error {
				s.NotApplicableReason.Reset()
				if err := s.NotApplicableReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notApplicableReason\"")
			}
		case "sku":
			if err := func() error {
				s.Sku = make([]SkuBomDetails, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SkuBomDetails
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sku = append(s.Sku, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sku\"")
			}
		case "updates":
			if err := func() error {
				s.Updates = make([]ReleaseUpdate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReleaseUpdate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Updates = append(s.Updates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updates\"")
			}
		case "patchBundles":
			if err := func() error {
				s.PatchBundles = make([]PatchBundle, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PatchBundle
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PatchBundles = append(s.PatchBundles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patchBundles\"")
			}
		case "eol":
			if err := func() error {
				s.Eol.Reset()
				if err := s.Eol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eol\"")
			}
		case "upgradeOrder":
			if err := func() error {
				s.UpgradeOrder.Reset()
				if err := s.UpgradeOrder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upgradeOrder\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Release")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelease) {
					name = jsonFieldsNameOfRelease[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Release) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Release) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReleaseUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReleaseUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("productName")
		e.Str(s.ProductName)
	}
	{
		e.FieldStart("baseProductVersion")
		e.Str(s.BaseProductVersion)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.ReleaseUpdateURL.Set {
			e.FieldStart("releaseUpdateURL")
			s.ReleaseUpdateURL.Encode(e)
		}
	}
	{
		e.FieldStart("releaseDate")
		e.Str(s.ReleaseDate)
	}
}

var jsonFieldsNameOfReleaseUpdate = [6]string{
	0: "id",
	1: "productName",
	2: "baseProductVersion",
	3: "description",
	4: "releaseUpdateURL",
	5: "releaseDate",
}

// Decode decodes ReleaseUpdate from json.
func (s *ReleaseUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReleaseUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "productName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProductName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productName\"")
			}
		case "baseProductVersion":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BaseProductVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"baseProductVersion\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "releaseUpdateURL":
			if err := func() error {
				s.ReleaseUpdateURL.Reset()
				if err := s.ReleaseUpdateURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releaseUpdateURL\"")
			}
		case "releaseDate":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ReleaseDate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releaseDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReleaseUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReleaseUpdate) {
					name = jsonFieldsNameOfReleaseUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReleaseUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReleaseUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoteDatastoreInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoteDatastoreInfo) encodeFields(e *jx.Encoder) {
	{
		if s.ServerCluster.Set {
			e.FieldStart("serverCluster")
			s.ServerCluster.Encode(e)
		}
	}
	{
		if s.RemoteDatastore.Set {
			e.FieldStart("remoteDatastore")
			s.RemoteDatastore.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemoteDatastoreInfo = [2]string{
	0: "serverCluster",
	1: "remoteDatastore",
}

// Decode decodes RemoteDatastoreInfo from json.
func (s *RemoteDatastoreInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoteDatastoreInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "serverCluster":
			if err := func() error {
				s.ServerCluster.Reset()
				if err := s.ServerCluster.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverCluster\"")
			}
		case "remoteDatastore":
			if err := func() error {
				s.RemoteDatastore.Reset()
				if err := s.RemoteDatastore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remoteDatastore\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoteDatastoreInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoteDatastoreInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoteDatastoreInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveCertificateAuthorityBadRequest as json.
func (s *RemoveCertificateAuthorityBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveCertificateAuthorityBadRequest from json.
func (s *RemoveCertificateAuthorityBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveCertificateAuthorityBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveCertificateAuthorityBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveCertificateAuthorityBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveCertificateAuthorityBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveCertificateAuthorityInternalServerError as json.
func (s *RemoveCertificateAuthorityInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveCertificateAuthorityInternalServerError from json.
func (s *RemoveCertificateAuthorityInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveCertificateAuthorityInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveCertificateAuthorityInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveCertificateAuthorityInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveCertificateAuthorityInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveCertificateAuthorityNotFound as json.
func (s *RemoveCertificateAuthorityNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveCertificateAuthorityNotFound from json.
func (s *RemoveCertificateAuthorityNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveCertificateAuthorityNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveCertificateAuthorityNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveCertificateAuthorityNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveCertificateAuthorityNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveDatastoreFromClusterAccepted as json.
func (s *RemoveDatastoreFromClusterAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*Task)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveDatastoreFromClusterAccepted from json.
func (s *RemoveDatastoreFromClusterAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveDatastoreFromClusterAccepted to nil")
	}
	var unwrapped Task
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveDatastoreFromClusterAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveDatastoreFromClusterAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveDatastoreFromClusterAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveDatastoreFromClusterBadRequest as json.
func (s *RemoveDatastoreFromClusterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveDatastoreFromClusterBadRequest from json.
func (s *RemoveDatastoreFromClusterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveDatastoreFromClusterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveDatastoreFromClusterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveDatastoreFromClusterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveDatastoreFromClusterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveDatastoreFromClusterInternalServerError as json.
func (s *RemoveDatastoreFromClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveDatastoreFromClusterInternalServerError from json.
func (s *RemoveDatastoreFromClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveDatastoreFromClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveDatastoreFromClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveDatastoreFromClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveDatastoreFromClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveDatastoreFromClusterNotFound as json.
func (s *RemoveDatastoreFromClusterNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveDatastoreFromClusterNotFound from json.
func (s *RemoveDatastoreFromClusterNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveDatastoreFromClusterNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveDatastoreFromClusterNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveDatastoreFromClusterNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveDatastoreFromClusterNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveDatastoreFromClusterOK as json.
func (s *RemoveDatastoreFromClusterOK) Encode(e *jx.Encoder) {
	unwrapped := (*Task)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveDatastoreFromClusterOK from json.
func (s *RemoveDatastoreFromClusterOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveDatastoreFromClusterOK to nil")
	}
	var unwrapped Task
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveDatastoreFromClusterOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveDatastoreFromClusterOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveDatastoreFromClusterOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveTagsFromClusterBadRequest as json.
func (s *RemoveTagsFromClusterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveTagsFromClusterBadRequest from json.
func (s *RemoveTagsFromClusterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveTagsFromClusterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveTagsFromClusterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveTagsFromClusterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveTagsFromClusterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveTagsFromClusterInternalServerError as json.
func (s *RemoveTagsFromClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveTagsFromClusterInternalServerError from json.
func (s *RemoveTagsFromClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveTagsFromClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveTagsFromClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveTagsFromClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveTagsFromClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveTagsFromDomainBadRequest as json.
func (s *RemoveTagsFromDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveTagsFromDomainBadRequest from json.
func (s *RemoveTagsFromDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveTagsFromDomainBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveTagsFromDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveTagsFromDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveTagsFromDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveTagsFromDomainInternalServerError as json.
func (s *RemoveTagsFromDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveTagsFromDomainInternalServerError from json.
func (s *RemoveTagsFromDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveTagsFromDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveTagsFromDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveTagsFromDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveTagsFromDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveTagsFromHostBadRequest as json.
func (s *RemoveTagsFromHostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveTagsFromHostBadRequest from json.
func (s *RemoveTagsFromHostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveTagsFromHostBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveTagsFromHostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveTagsFromHostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveTagsFromHostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveTagsFromHostInternalServerError as json.
func (s *RemoveTagsFromHostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveTagsFromHostInternalServerError from json.
func (s *RemoveTagsFromHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveTagsFromHostInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveTagsFromHostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveTagsFromHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveTagsFromHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveUserInternalServerError as json.
func (s *RemoveUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveUserInternalServerError from json.
func (s *RemoveUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveUserInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveUserNotFound as json.
func (s *RemoveUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveUserNotFound from json.
func (s *RemoveUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveUserNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveVasaProviderBadRequest as json.
func (s *RemoveVasaProviderBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveVasaProviderBadRequest from json.
func (s *RemoveVasaProviderBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveVasaProviderBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveVasaProviderBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveVasaProviderBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveVasaProviderBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveVasaProviderInternalServerError as json.
func (s *RemoveVasaProviderInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveVasaProviderInternalServerError from json.
func (s *RemoveVasaProviderInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveVasaProviderInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveVasaProviderInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveVasaProviderInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveVasaProviderInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveVasaProviderNotFound as json.
func (s *RemoveVasaProviderNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveVasaProviderNotFound from json.
func (s *RemoveVasaProviderNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveVasaProviderNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveVasaProviderNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveVasaProviderNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveVasaProviderNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveVasaProviderStorageContainerBadRequest as json.
func (s *RemoveVasaProviderStorageContainerBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveVasaProviderStorageContainerBadRequest from json.
func (s *RemoveVasaProviderStorageContainerBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveVasaProviderStorageContainerBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveVasaProviderStorageContainerBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveVasaProviderStorageContainerBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveVasaProviderStorageContainerBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveVasaProviderStorageContainerInternalServerError as json.
func (s *RemoveVasaProviderStorageContainerInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveVasaProviderStorageContainerInternalServerError from json.
func (s *RemoveVasaProviderStorageContainerInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveVasaProviderStorageContainerInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveVasaProviderStorageContainerInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveVasaProviderStorageContainerInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveVasaProviderStorageContainerInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveVasaProviderStorageContainerNotFound as json.
func (s *RemoveVasaProviderStorageContainerNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveVasaProviderStorageContainerNotFound from json.
func (s *RemoveVasaProviderStorageContainerNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveVasaProviderStorageContainerNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveVasaProviderStorageContainerNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveVasaProviderStorageContainerNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveVasaProviderStorageContainerNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RenameCustomIsoByIdBadRequest as json.
func (s *RenameCustomIsoByIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RenameCustomIsoByIdBadRequest from json.
func (s *RenameCustomIsoByIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RenameCustomIsoByIdBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RenameCustomIsoByIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RenameCustomIsoByIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RenameCustomIsoByIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RenameCustomIsoByIdInternalServerError as json.
func (s *RenameCustomIsoByIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RenameCustomIsoByIdInternalServerError from json.
func (s *RenameCustomIsoByIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RenameCustomIsoByIdInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RenameCustomIsoByIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RenameCustomIsoByIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RenameCustomIsoByIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RenameCustomIsoByIdNotFound as json.
func (s *RenameCustomIsoByIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RenameCustomIsoByIdNotFound from json.
func (s *RenameCustomIsoByIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RenameCustomIsoByIdNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RenameCustomIsoByIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RenameCustomIsoByIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RenameCustomIsoByIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RenamePersonalityByIdBadRequest as json.
func (s *RenamePersonalityByIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RenamePersonalityByIdBadRequest from json.
func (s *RenamePersonalityByIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RenamePersonalityByIdBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RenamePersonalityByIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RenamePersonalityByIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RenamePersonalityByIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RenamePersonalityByIdInternalServerError as json.
func (s *RenamePersonalityByIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RenamePersonalityByIdInternalServerError from json.
func (s *RenamePersonalityByIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RenamePersonalityByIdInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RenamePersonalityByIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RenamePersonalityByIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RenamePersonalityByIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RenamePersonalityByIdNotFound as json.
func (s *RenamePersonalityByIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RenamePersonalityByIdNotFound from json.
func (s *RenamePersonalityByIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RenamePersonalityByIdNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RenamePersonalityByIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RenamePersonalityByIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RenamePersonalityByIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReplaceCertificatesBadRequest as json.
func (s *ReplaceCertificatesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReplaceCertificatesBadRequest from json.
func (s *ReplaceCertificatesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplaceCertificatesBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReplaceCertificatesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplaceCertificatesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplaceCertificatesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReplaceCertificatesConflict as json.
func (s *ReplaceCertificatesConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReplaceCertificatesConflict from json.
func (s *ReplaceCertificatesConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplaceCertificatesConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReplaceCertificatesConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplaceCertificatesConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplaceCertificatesConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReplaceCertificatesForbidden as json.
func (s *ReplaceCertificatesForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReplaceCertificatesForbidden from json.
func (s *ReplaceCertificatesForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplaceCertificatesForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReplaceCertificatesForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplaceCertificatesForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplaceCertificatesForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReplaceCertificatesInternalServerError as json.
func (s *ReplaceCertificatesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReplaceCertificatesInternalServerError from json.
func (s *ReplaceCertificatesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplaceCertificatesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReplaceCertificatesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplaceCertificatesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplaceCertificatesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReplaceCertificatesNotFound as json.
func (s *ReplaceCertificatesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReplaceCertificatesNotFound from json.
func (s *ReplaceCertificatesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplaceCertificatesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReplaceCertificatesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplaceCertificatesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplaceCertificatesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReplaceResourceCertificatesInternalServerError as json.
func (s *ReplaceResourceCertificatesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReplaceResourceCertificatesInternalServerError from json.
func (s *ReplaceResourceCertificatesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplaceResourceCertificatesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReplaceResourceCertificatesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplaceResourceCertificatesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplaceResourceCertificatesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReplaceResourceCertificatesNotFound as json.
func (s *ReplaceResourceCertificatesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReplaceResourceCertificatesNotFound from json.
func (s *ReplaceResourceCertificatesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplaceResourceCertificatesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReplaceResourceCertificatesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplaceResourceCertificatesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplaceResourceCertificatesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Resource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Resource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceId")
		e.Str(s.ResourceId)
	}
	{
		if s.Fqdn.Set {
			e.FieldStart("fqdn")
			s.Fqdn.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Sans != nil {
			e.FieldStart("sans")
			e.ArrStart()
			for _, elem := range s.Sans {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfResource = [5]string{
	0: "resourceId",
	1: "fqdn",
	2: "type",
	3: "name",
	4: "sans",
}

// Decode decodes Resource from json.
func (s *Resource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Resource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "fqdn":
			if err := func() error {
				s.Fqdn.Reset()
				if err := s.Fqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "sans":
			if err := func() error {
				s.Sans = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Sans = append(s.Sans, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sans\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Resource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResource) {
					name = jsonFieldsNameOfResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Resource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Resource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceCertificateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceCertificateSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ResourceId.Set {
			e.FieldStart("resourceId")
			s.ResourceId.Encode(e)
		}
	}
	{
		if s.ResourceFqdn.Set {
			e.FieldStart("resourceFqdn")
			s.ResourceFqdn.Encode(e)
		}
	}
	{
		if s.ResourceCertificate.Set {
			e.FieldStart("resourceCertificate")
			s.ResourceCertificate.Encode(e)
		}
	}
	{
		if s.CaCertificate.Set {
			e.FieldStart("caCertificate")
			s.CaCertificate.Encode(e)
		}
	}
	{
		if s.CertificateChain.Set {
			e.FieldStart("certificateChain")
			s.CertificateChain.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourceCertificateSpec = [5]string{
	0: "resourceId",
	1: "resourceFqdn",
	2: "resourceCertificate",
	3: "caCertificate",
	4: "certificateChain",
}

// Decode decodes ResourceCertificateSpec from json.
func (s *ResourceCertificateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceCertificateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceId":
			if err := func() error {
				s.ResourceId.Reset()
				if err := s.ResourceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceFqdn":
			if err := func() error {
				s.ResourceFqdn.Reset()
				if err := s.ResourceFqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceFqdn\"")
			}
		case "resourceCertificate":
			if err := func() error {
				s.ResourceCertificate.Reset()
				if err := s.ResourceCertificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceCertificate\"")
			}
		case "caCertificate":
			if err := func() error {
				s.CaCertificate.Reset()
				if err := s.CaCertificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caCertificate\"")
			}
		case "certificateChain":
			if err := func() error {
				s.CertificateChain.Reset()
				if err := s.CertificateChain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateChain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceCertificateSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceCertificateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceCertificateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceCredentials) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceCredentials) encodeFields(e *jx.Encoder) {
	{
		if s.ResourceName.Set {
			e.FieldStart("resourceName")
			s.ResourceName.Encode(e)
		}
	}
	{
		if s.ResourceId.Set {
			e.FieldStart("resourceId")
			s.ResourceId.Encode(e)
		}
	}
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		e.FieldStart("credentials")
		e.ArrStart()
		for _, elem := range s.Credentials {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfResourceCredentials = [4]string{
	0: "resourceName",
	1: "resourceId",
	2: "resourceType",
	3: "credentials",
}

// Decode decodes ResourceCredentials from json.
func (s *ResourceCredentials) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceCredentials to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceName":
			if err := func() error {
				s.ResourceName.Reset()
				if err := s.ResourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		case "resourceId":
			if err := func() error {
				s.ResourceId.Reset()
				if err := s.ResourceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "credentials":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Credentials = make([]BaseCredential, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BaseCredential
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Credentials = append(s.Credentials, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentials\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceCredentials")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceCredentials) {
					name = jsonFieldsNameOfResourceCredentials[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceDomainInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceDomainInfo) encodeFields(e *jx.Encoder) {
	{
		if s.DomainId.Set {
			e.FieldStart("domainId")
			s.DomainId.Encode(e)
		}
	}
	{
		if s.DomainName.Set {
			e.FieldStart("domainName")
			s.DomainName.Encode(e)
		}
	}
	{
		if s.DomainType.Set {
			e.FieldStart("domainType")
			s.DomainType.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourceDomainInfo = [3]string{
	0: "domainId",
	1: "domainName",
	2: "domainType",
}

// Decode decodes ResourceDomainInfo from json.
func (s *ResourceDomainInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceDomainInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainId":
			if err := func() error {
				s.DomainId.Reset()
				if err := s.DomainId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainId\"")
			}
		case "domainName":
			if err := func() error {
				s.DomainName.Reset()
				if err := s.DomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainName\"")
			}
		case "domainType":
			if err := func() error {
				s.DomainType.Reset()
				if err := s.DomainType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceDomainInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceDomainInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceDomainInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceDomainInfoDomainType as json.
func (s ResourceDomainInfoDomainType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourceDomainInfoDomainType from json.
func (s *ResourceDomainInfoDomainType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceDomainInfoDomainType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourceDomainInfoDomainType(v) {
	case ResourceDomainInfoDomainTypeMANAGEMENT:
		*s = ResourceDomainInfoDomainTypeMANAGEMENT
	case ResourceDomainInfoDomainTypeVI:
		*s = ResourceDomainInfoDomainTypeVI
	default:
		*s = ResourceDomainInfoDomainType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceDomainInfoDomainType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceDomainInfoDomainType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceFunctionalities) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceFunctionalities) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		if s.ResourceId.Set {
			e.FieldStart("resourceId")
			s.ResourceId.Encode(e)
		}
	}
	{
		if s.Functionalities != nil {
			e.FieldStart("functionalities")
			e.ArrStart()
			for _, elem := range s.Functionalities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfResourceFunctionalities = [3]string{
	0: "resourceType",
	1: "resourceId",
	2: "functionalities",
}

// Decode decodes ResourceFunctionalities from json.
func (s *ResourceFunctionalities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceFunctionalities to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "resourceId":
			if err := func() error {
				s.ResourceId.Reset()
				if err := s.ResourceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "functionalities":
			if err := func() error {
				s.Functionalities = make([]Functionality, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Functionality
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Functionalities = append(s.Functionalities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"functionalities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceFunctionalities")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceFunctionalities) {
					name = jsonFieldsNameOfResourceFunctionalities[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceFunctionalities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceFunctionalities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceFunctionalitiesCaller) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceFunctionalitiesCaller) encodeFields(e *jx.Encoder) {
	{
		if s.OperationId.Set {
			e.FieldStart("operationId")
			s.OperationId.Encode(e)
		}
	}
	{
		if s.OperationName.Set {
			e.FieldStart("operationName")
			s.OperationName.Encode(e)
		}
	}
	{
		if s.ServiceId.Set {
			e.FieldStart("serviceId")
			s.ServiceId.Encode(e)
		}
	}
	{
		if s.ResourceFunctionalities != nil {
			e.FieldStart("resourceFunctionalities")
			e.ArrStart()
			for _, elem := range s.ResourceFunctionalities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfResourceFunctionalitiesCaller = [4]string{
	0: "operationId",
	1: "operationName",
	2: "serviceId",
	3: "resourceFunctionalities",
}

// Decode decodes ResourceFunctionalitiesCaller from json.
func (s *ResourceFunctionalitiesCaller) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceFunctionalitiesCaller to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operationId":
			if err := func() error {
				s.OperationId.Reset()
				if err := s.OperationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationId\"")
			}
		case "operationName":
			if err := func() error {
				s.OperationName.Reset()
				if err := s.OperationName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationName\"")
			}
		case "serviceId":
			if err := func() error {
				s.ServiceId.Reset()
				if err := s.ServiceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceId\"")
			}
		case "resourceFunctionalities":
			if err := func() error {
				s.ResourceFunctionalities = make([]ResourceFunctionalities, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourceFunctionalities
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResourceFunctionalities = append(s.ResourceFunctionalities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceFunctionalities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceFunctionalitiesCaller")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceFunctionalitiesCaller) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceFunctionalitiesCaller) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceFunctionalitiesGlobalConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceFunctionalitiesGlobalConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.IsAllowed.Set {
			e.FieldStart("isAllowed")
			s.IsAllowed.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("errorMessage")
			s.ErrorMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourceFunctionalitiesGlobalConfiguration = [2]string{
	0: "isAllowed",
	1: "errorMessage",
}

// Decode decodes ResourceFunctionalitiesGlobalConfiguration from json.
func (s *ResourceFunctionalitiesGlobalConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceFunctionalitiesGlobalConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isAllowed":
			if err := func() error {
				s.IsAllowed.Reset()
				if err := s.IsAllowed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAllowed\"")
			}
		case "errorMessage":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorMessage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceFunctionalitiesGlobalConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceFunctionalitiesGlobalConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceFunctionalitiesGlobalConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceFunctionalitiesGlobalConfigurationCaller) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceFunctionalitiesGlobalConfigurationCaller) encodeFields(e *jx.Encoder) {
	{
		if s.OperationId.Set {
			e.FieldStart("operationId")
			s.OperationId.Encode(e)
		}
	}
	{
		if s.OperationName.Set {
			e.FieldStart("operationName")
			s.OperationName.Encode(e)
		}
	}
	{
		if s.ServiceId.Set {
			e.FieldStart("serviceId")
			s.ServiceId.Encode(e)
		}
	}
	{
		if s.IsAllowed.Set {
			e.FieldStart("isAllowed")
			s.IsAllowed.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourceFunctionalitiesGlobalConfigurationCaller = [4]string{
	0: "operationId",
	1: "operationName",
	2: "serviceId",
	3: "isAllowed",
}

// Decode decodes ResourceFunctionalitiesGlobalConfigurationCaller from json.
func (s *ResourceFunctionalitiesGlobalConfigurationCaller) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceFunctionalitiesGlobalConfigurationCaller to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operationId":
			if err := func() error {
				s.OperationId.Reset()
				if err := s.OperationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationId\"")
			}
		case "operationName":
			if err := func() error {
				s.OperationName.Reset()
				if err := s.OperationName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationName\"")
			}
		case "serviceId":
			if err := func() error {
				s.ServiceId.Reset()
				if err := s.ServiceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceId\"")
			}
		case "isAllowed":
			if err := func() error {
				s.IsAllowed.Reset()
				if err := s.IsAllowed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAllowed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceFunctionalitiesGlobalConfigurationCaller")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceFunctionalitiesGlobalConfigurationCaller) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceFunctionalitiesGlobalConfigurationCaller) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceFunctionalitiesGlobalUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceFunctionalitiesGlobalUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("serviceId")
		e.Str(s.ServiceId)
	}
	{
		e.FieldStart("operationName")
		e.Str(s.OperationName)
	}
	{
		e.FieldStart("operationId")
		e.Str(s.OperationId)
	}
	{
		e.FieldStart("isAllowed")
		e.Bool(s.IsAllowed)
	}
}

var jsonFieldsNameOfResourceFunctionalitiesGlobalUpdateSpec = [4]string{
	0: "serviceId",
	1: "operationName",
	2: "operationId",
	3: "isAllowed",
}

// Decode decodes ResourceFunctionalitiesGlobalUpdateSpec from json.
func (s *ResourceFunctionalitiesGlobalUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceFunctionalitiesGlobalUpdateSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "serviceId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ServiceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceId\"")
			}
		case "operationName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OperationName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationName\"")
			}
		case "operationId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OperationId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationId\"")
			}
		case "isAllowed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAllowed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceFunctionalitiesGlobalUpdateSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceFunctionalitiesGlobalUpdateSpec) {
					name = jsonFieldsNameOfResourceFunctionalitiesGlobalUpdateSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceFunctionalitiesGlobalUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceFunctionalitiesGlobalUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceFunctionalitiesUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceFunctionalitiesUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("serviceId")
		e.Str(s.ServiceId)
	}
	{
		e.FieldStart("operationName")
		e.Str(s.OperationName)
	}
	{
		e.FieldStart("operationId")
		e.Str(s.OperationId)
	}
	{
		e.FieldStart("resourceFunctionalities")
		e.ArrStart()
		for _, elem := range s.ResourceFunctionalities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfResourceFunctionalitiesUpdateSpec = [4]string{
	0: "serviceId",
	1: "operationName",
	2: "operationId",
	3: "resourceFunctionalities",
}

// Decode decodes ResourceFunctionalitiesUpdateSpec from json.
func (s *ResourceFunctionalitiesUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceFunctionalitiesUpdateSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "serviceId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ServiceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceId\"")
			}
		case "operationName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OperationName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationName\"")
			}
		case "operationId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OperationId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationId\"")
			}
		case "resourceFunctionalities":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.ResourceFunctionalities = make([]ResourceFunctionalities, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourceFunctionalities
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResourceFunctionalities = append(s.ResourceFunctionalities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceFunctionalities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceFunctionalitiesUpdateSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceFunctionalitiesUpdateSpec) {
					name = jsonFieldsNameOfResourceFunctionalitiesUpdateSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceFunctionalitiesUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceFunctionalitiesUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("domainId")
		e.Str(s.DomainId)
	}
	{
		if s.ClusterId.Set {
			e.FieldStart("clusterId")
			s.ClusterId.Encode(e)
		}
	}
	{
		if s.HostId.Set {
			e.FieldStart("hostId")
			s.HostId.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourceInfo = [3]string{
	0: "domainId",
	1: "clusterId",
	2: "hostId",
}

// Decode decodes ResourceInfo from json.
func (s *ResourceInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DomainId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainId\"")
			}
		case "clusterId":
			if err := func() error {
				s.ClusterId.Reset()
				if err := s.ClusterId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterId\"")
			}
		case "hostId":
			if err := func() error {
				s.HostId.Reset()
				if err := s.HostId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceInfo) {
					name = jsonFieldsNameOfResourceInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceLicensingInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceLicensingInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceInfo")
		s.ResourceInfo.Encode(e)
	}
	{
		if s.ProductInfo.Set {
			e.FieldStart("productInfo")
			s.ProductInfo.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourceLicensingInfo = [2]string{
	0: "resourceInfo",
	1: "productInfo",
}

// Decode decodes ResourceLicensingInfo from json.
func (s *ResourceLicensingInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceLicensingInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceInfo":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ResourceInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceInfo\"")
			}
		case "productInfo":
			if err := func() error {
				s.ProductInfo.Reset()
				if err := s.ProductInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productInfo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceLicensingInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceLicensingInfo) {
					name = jsonFieldsNameOfResourceLicensingInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceLicensingInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceLicensingInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourcePoolSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourcePoolSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.CpuReservationPercentage.Set {
			e.FieldStart("cpuReservationPercentage")
			s.CpuReservationPercentage.Encode(e)
		}
	}
	{
		if s.CpuReservationMhz.Set {
			e.FieldStart("cpuReservationMhz")
			s.CpuReservationMhz.Encode(e)
		}
	}
	{
		if s.CpuLimit.Set {
			e.FieldStart("cpuLimit")
			s.CpuLimit.Encode(e)
		}
	}
	{
		if s.CpuReservationExpandable.Set {
			e.FieldStart("cpuReservationExpandable")
			s.CpuReservationExpandable.Encode(e)
		}
	}
	{
		if s.CpuSharesLevel.Set {
			e.FieldStart("cpuSharesLevel")
			s.CpuSharesLevel.Encode(e)
		}
	}
	{
		if s.CpuSharesValue.Set {
			e.FieldStart("cpuSharesValue")
			s.CpuSharesValue.Encode(e)
		}
	}
	{
		if s.MemoryReservationPercentage.Set {
			e.FieldStart("memoryReservationPercentage")
			s.MemoryReservationPercentage.Encode(e)
		}
	}
	{
		if s.MemoryReservationMb.Set {
			e.FieldStart("memoryReservationMb")
			s.MemoryReservationMb.Encode(e)
		}
	}
	{
		if s.MemoryLimit.Set {
			e.FieldStart("memoryLimit")
			s.MemoryLimit.Encode(e)
		}
	}
	{
		if s.MemoryReservationExpandable.Set {
			e.FieldStart("memoryReservationExpandable")
			s.MemoryReservationExpandable.Encode(e)
		}
	}
	{
		if s.MemorySharesLevel.Set {
			e.FieldStart("memorySharesLevel")
			s.MemorySharesLevel.Encode(e)
		}
	}
	{
		if s.MemorySharesValue.Set {
			e.FieldStart("memorySharesValue")
			s.MemorySharesValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourcePoolSpec = [14]string{
	0:  "name",
	1:  "type",
	2:  "cpuReservationPercentage",
	3:  "cpuReservationMhz",
	4:  "cpuLimit",
	5:  "cpuReservationExpandable",
	6:  "cpuSharesLevel",
	7:  "cpuSharesValue",
	8:  "memoryReservationPercentage",
	9:  "memoryReservationMb",
	10: "memoryLimit",
	11: "memoryReservationExpandable",
	12: "memorySharesLevel",
	13: "memorySharesValue",
}

// Decode decodes ResourcePoolSpec from json.
func (s *ResourcePoolSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourcePoolSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "cpuReservationPercentage":
			if err := func() error {
				s.CpuReservationPercentage.Reset()
				if err := s.CpuReservationPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuReservationPercentage\"")
			}
		case "cpuReservationMhz":
			if err := func() error {
				s.CpuReservationMhz.Reset()
				if err := s.CpuReservationMhz.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuReservationMhz\"")
			}
		case "cpuLimit":
			if err := func() error {
				s.CpuLimit.Reset()
				if err := s.CpuLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuLimit\"")
			}
		case "cpuReservationExpandable":
			if err := func() error {
				s.CpuReservationExpandable.Reset()
				if err := s.CpuReservationExpandable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuReservationExpandable\"")
			}
		case "cpuSharesLevel":
			if err := func() error {
				s.CpuSharesLevel.Reset()
				if err := s.CpuSharesLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuSharesLevel\"")
			}
		case "cpuSharesValue":
			if err := func() error {
				s.CpuSharesValue.Reset()
				if err := s.CpuSharesValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuSharesValue\"")
			}
		case "memoryReservationPercentage":
			if err := func() error {
				s.MemoryReservationPercentage.Reset()
				if err := s.MemoryReservationPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryReservationPercentage\"")
			}
		case "memoryReservationMb":
			if err := func() error {
				s.MemoryReservationMb.Reset()
				if err := s.MemoryReservationMb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryReservationMb\"")
			}
		case "memoryLimit":
			if err := func() error {
				s.MemoryLimit.Reset()
				if err := s.MemoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryLimit\"")
			}
		case "memoryReservationExpandable":
			if err := func() error {
				s.MemoryReservationExpandable.Reset()
				if err := s.MemoryReservationExpandable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryReservationExpandable\"")
			}
		case "memorySharesLevel":
			if err := func() error {
				s.MemorySharesLevel.Reset()
				if err := s.MemorySharesLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memorySharesLevel\"")
			}
		case "memorySharesValue":
			if err := func() error {
				s.MemorySharesValue.Reset()
				if err := s.MemorySharesValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memorySharesValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourcePoolSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourcePoolSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourcePoolSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourcePoolSpecCpuSharesLevel as json.
func (s ResourcePoolSpecCpuSharesLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourcePoolSpecCpuSharesLevel from json.
func (s *ResourcePoolSpecCpuSharesLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourcePoolSpecCpuSharesLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourcePoolSpecCpuSharesLevel(v) {
	case ResourcePoolSpecCpuSharesLevelCustom:
		*s = ResourcePoolSpecCpuSharesLevelCustom
	case ResourcePoolSpecCpuSharesLevelHigh:
		*s = ResourcePoolSpecCpuSharesLevelHigh
	case ResourcePoolSpecCpuSharesLevelLow:
		*s = ResourcePoolSpecCpuSharesLevelLow
	case ResourcePoolSpecCpuSharesLevelNormal:
		*s = ResourcePoolSpecCpuSharesLevelNormal
	default:
		*s = ResourcePoolSpecCpuSharesLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourcePoolSpecCpuSharesLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourcePoolSpecCpuSharesLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourcePoolSpecMemorySharesLevel as json.
func (s ResourcePoolSpecMemorySharesLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourcePoolSpecMemorySharesLevel from json.
func (s *ResourcePoolSpecMemorySharesLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourcePoolSpecMemorySharesLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourcePoolSpecMemorySharesLevel(v) {
	case ResourcePoolSpecMemorySharesLevelCustom:
		*s = ResourcePoolSpecMemorySharesLevelCustom
	case ResourcePoolSpecMemorySharesLevelHigh:
		*s = ResourcePoolSpecMemorySharesLevelHigh
	case ResourcePoolSpecMemorySharesLevelLow:
		*s = ResourcePoolSpecMemorySharesLevelLow
	case ResourcePoolSpecMemorySharesLevelNormal:
		*s = ResourcePoolSpecMemorySharesLevelNormal
	default:
		*s = ResourcePoolSpecMemorySharesLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourcePoolSpecMemorySharesLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourcePoolSpecMemorySharesLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourcePoolSpecType as json.
func (s ResourcePoolSpecType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourcePoolSpecType from json.
func (s *ResourcePoolSpecType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourcePoolSpecType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourcePoolSpecType(v) {
	case ResourcePoolSpecTypeManagement:
		*s = ResourcePoolSpecTypeManagement
	case ResourcePoolSpecTypeCompute:
		*s = ResourcePoolSpecTypeCompute
	case ResourcePoolSpecTypeNetwork:
		*s = ResourcePoolSpecTypeNetwork
	default:
		*s = ResourcePoolSpecType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourcePoolSpecType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourcePoolSpecType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceUpgradeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceUpgradeSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceId")
		e.Str(s.ResourceId)
	}
	{
		if s.ShutdownVms.Set {
			e.FieldStart("shutdownVms")
			s.ShutdownVms.Encode(e)
		}
	}
	{
		if s.ToVersion.Set {
			e.FieldStart("toVersion")
			s.ToVersion.Encode(e)
		}
	}
	{
		if s.ScheduledTimestamp.Set {
			e.FieldStart("scheduledTimestamp")
			s.ScheduledTimestamp.Encode(e)
		}
	}
	{
		if s.UpgradeNow.Set {
			e.FieldStart("upgradeNow")
			s.UpgradeNow.Encode(e)
		}
	}
	{
		if s.PersonalitySpec.Set {
			e.FieldStart("personalitySpec")
			s.PersonalitySpec.Encode(e)
		}
	}
	{
		if s.CustomIsoSpec.Set {
			e.FieldStart("customIsoSpec")
			s.CustomIsoSpec.Encode(e)
		}
	}
	{
		if s.EnableQuickboot.Set {
			e.FieldStart("enableQuickboot")
			s.EnableQuickboot.Encode(e)
		}
	}
	{
		if s.EvacuateOfflineVms.Set {
			e.FieldStart("evacuateOfflineVms")
			s.EvacuateOfflineVms.Encode(e)
		}
	}
	{
		if s.EsxUpgradeOptionsSpec.Set {
			e.FieldStart("esxUpgradeOptionsSpec")
			s.EsxUpgradeOptionsSpec.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourceUpgradeSpec = [10]string{
	0: "resourceId",
	1: "shutdownVms",
	2: "toVersion",
	3: "scheduledTimestamp",
	4: "upgradeNow",
	5: "personalitySpec",
	6: "customIsoSpec",
	7: "enableQuickboot",
	8: "evacuateOfflineVms",
	9: "esxUpgradeOptionsSpec",
}

// Decode decodes ResourceUpgradeSpec from json.
func (s *ResourceUpgradeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceUpgradeSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "shutdownVms":
			if err := func() error {
				s.ShutdownVms.Reset()
				if err := s.ShutdownVms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shutdownVms\"")
			}
		case "toVersion":
			if err := func() error {
				s.ToVersion.Reset()
				if err := s.ToVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"toVersion\"")
			}
		case "scheduledTimestamp":
			if err := func() error {
				s.ScheduledTimestamp.Reset()
				if err := s.ScheduledTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduledTimestamp\"")
			}
		case "upgradeNow":
			if err := func() error {
				s.UpgradeNow.Reset()
				if err := s.UpgradeNow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upgradeNow\"")
			}
		case "personalitySpec":
			if err := func() error {
				s.PersonalitySpec.Reset()
				if err := s.PersonalitySpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personalitySpec\"")
			}
		case "customIsoSpec":
			if err := func() error {
				s.CustomIsoSpec.Reset()
				if err := s.CustomIsoSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customIsoSpec\"")
			}
		case "enableQuickboot":
			if err := func() error {
				s.EnableQuickboot.Reset()
				if err := s.EnableQuickboot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enableQuickboot\"")
			}
		case "evacuateOfflineVms":
			if err := func() error {
				s.EvacuateOfflineVms.Reset()
				if err := s.EvacuateOfflineVms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evacuateOfflineVms\"")
			}
		case "esxUpgradeOptionsSpec":
			if err := func() error {
				s.EsxUpgradeOptionsSpec.Reset()
				if err := s.EsxUpgradeOptionsSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"esxUpgradeOptionsSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceUpgradeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceUpgradeSpec) {
					name = jsonFieldsNameOfResourceUpgradeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceUpgradeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceUpgradeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceWarning) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceWarning) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.WarningCode.Set {
			e.FieldStart("warningCode")
			s.WarningCode.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.RemediationMessage.Set {
			e.FieldStart("remediationMessage")
			s.RemediationMessage.Encode(e)
		}
	}
	{
		if s.ReferenceToken.Set {
			e.FieldStart("referenceToken")
			s.ReferenceToken.Encode(e)
		}
	}
	{
		if s.ResourceId.Set {
			e.FieldStart("resourceId")
			s.ResourceId.Encode(e)
		}
	}
	{
		if s.ResourceType.Set {
			e.FieldStart("resourceType")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.ResourceName.Set {
			e.FieldStart("resourceName")
			s.ResourceName.Encode(e)
		}
	}
	{
		if s.WarningType.Set {
			e.FieldStart("warningType")
			s.WarningType.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		e.FieldStart("occurredAtTimestamp")
		e.Str(s.OccurredAtTimestamp)
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.AssociatedTask.Set {
			e.FieldStart("associatedTask")
			s.AssociatedTask.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourceWarning = [13]string{
	0:  "id",
	1:  "warningCode",
	2:  "message",
	3:  "remediationMessage",
	4:  "referenceToken",
	5:  "resourceId",
	6:  "resourceType",
	7:  "resourceName",
	8:  "warningType",
	9:  "severity",
	10: "occurredAtTimestamp",
	11: "context",
	12: "associatedTask",
}

// Decode decodes ResourceWarning from json.
func (s *ResourceWarning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceWarning to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "warningCode":
			if err := func() error {
				s.WarningCode.Reset()
				if err := s.WarningCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warningCode\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "remediationMessage":
			if err := func() error {
				s.RemediationMessage.Reset()
				if err := s.RemediationMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediationMessage\"")
			}
		case "referenceToken":
			if err := func() error {
				s.ReferenceToken.Reset()
				if err := s.ReferenceToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceToken\"")
			}
		case "resourceId":
			if err := func() error {
				s.ResourceId.Reset()
				if err := s.ResourceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "resourceName":
			if err := func() error {
				s.ResourceName.Reset()
				if err := s.ResourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		case "warningType":
			if err := func() error {
				s.WarningType.Reset()
				if err := s.WarningType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warningType\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "occurredAtTimestamp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OccurredAtTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"occurredAtTimestamp\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "associatedTask":
			if err := func() error {
				s.AssociatedTask.Reset()
				if err := s.AssociatedTask.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"associatedTask\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceWarning")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceWarning) {
					name = jsonFieldsNameOfResourceWarning[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceWarning) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceWarning) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ResourceWarningContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ResourceWarningContext) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ResourceWarningContext from json.
func (s *ResourceWarningContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceWarningContext to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceWarningContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceWarningContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceWarningContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceWarningCreationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceWarningCreationSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceId")
		e.Str(s.ResourceId)
	}
	{
		e.FieldStart("resourceName")
		e.Str(s.ResourceName)
	}
	{
		e.FieldStart("resourceType")
		s.ResourceType.Encode(e)
	}
	{
		e.FieldStart("warningType")
		s.WarningType.Encode(e)
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	{
		e.FieldStart("occurredAtTimestamp")
		e.Int64(s.OccurredAtTimestamp)
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		e.FieldStart("localizableWarningPack")
		s.LocalizableWarningPack.Encode(e)
	}
	{
		if s.AssociatedTask.Set {
			e.FieldStart("associatedTask")
			s.AssociatedTask.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourceWarningCreationSpec = [9]string{
	0: "resourceId",
	1: "resourceName",
	2: "resourceType",
	3: "warningType",
	4: "severity",
	5: "occurredAtTimestamp",
	6: "context",
	7: "localizableWarningPack",
	8: "associatedTask",
}

// Decode decodes ResourceWarningCreationSpec from json.
func (s *ResourceWarningCreationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceWarningCreationSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ResourceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceName\"")
			}
		case "resourceType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "warningType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.WarningType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warningType\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "occurredAtTimestamp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.OccurredAtTimestamp = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"occurredAtTimestamp\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "localizableWarningPack":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.LocalizableWarningPack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localizableWarningPack\"")
			}
		case "associatedTask":
			if err := func() error {
				s.AssociatedTask.Reset()
				if err := s.AssociatedTask.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"associatedTask\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceWarningCreationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceWarningCreationSpec) {
					name = jsonFieldsNameOfResourceWarningCreationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceWarningCreationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceWarningCreationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ResourceWarningCreationSpecContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ResourceWarningCreationSpecContext) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ResourceWarningCreationSpecContext from json.
func (s *ResourceWarningCreationSpecContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceWarningCreationSpecContext to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceWarningCreationSpecContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceWarningCreationSpecContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceWarningCreationSpecContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceWarningCreationSpecResourceType as json.
func (s ResourceWarningCreationSpecResourceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourceWarningCreationSpecResourceType from json.
func (s *ResourceWarningCreationSpecResourceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceWarningCreationSpecResourceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourceWarningCreationSpecResourceType(v) {
	case ResourceWarningCreationSpecResourceTypeHOST:
		*s = ResourceWarningCreationSpecResourceTypeHOST
	case ResourceWarningCreationSpecResourceTypeCLUSTER:
		*s = ResourceWarningCreationSpecResourceTypeCLUSTER
	case ResourceWarningCreationSpecResourceTypeDOMAIN:
		*s = ResourceWarningCreationSpecResourceTypeDOMAIN
	default:
		*s = ResourceWarningCreationSpecResourceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceWarningCreationSpecResourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceWarningCreationSpecResourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceWarningCreationSpecSeverity as json.
func (s ResourceWarningCreationSpecSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourceWarningCreationSpecSeverity from json.
func (s *ResourceWarningCreationSpecSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceWarningCreationSpecSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourceWarningCreationSpecSeverity(v) {
	case ResourceWarningCreationSpecSeverityMAJOR:
		*s = ResourceWarningCreationSpecSeverityMAJOR
	case ResourceWarningCreationSpecSeverityMINOR:
		*s = ResourceWarningCreationSpecSeverityMINOR
	default:
		*s = ResourceWarningCreationSpecSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceWarningCreationSpecSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceWarningCreationSpecSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceWarningCreationSpecWarningType as json.
func (s ResourceWarningCreationSpecWarningType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourceWarningCreationSpecWarningType from json.
func (s *ResourceWarningCreationSpecWarningType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceWarningCreationSpecWarningType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourceWarningCreationSpecWarningType(v) {
	case ResourceWarningCreationSpecWarningTypeCONFIGURATION:
		*s = ResourceWarningCreationSpecWarningTypeCONFIGURATION
	case ResourceWarningCreationSpecWarningTypeOTHER:
		*s = ResourceWarningCreationSpecWarningTypeOTHER
	case ResourceWarningCreationSpecWarningTypeSKIPPEDRESOURCE:
		*s = ResourceWarningCreationSpecWarningTypeSKIPPEDRESOURCE
	case ResourceWarningCreationSpecWarningTypeVALIDATION:
		*s = ResourceWarningCreationSpecWarningTypeVALIDATION
	default:
		*s = ResourceWarningCreationSpecWarningType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceWarningCreationSpecWarningType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceWarningCreationSpecWarningType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestoreSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestoreSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("elements")
		e.ArrStart()
		for _, elem := range s.Elements {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("backupFile")
		e.Str(s.BackupFile)
	}
	{
		e.FieldStart("encryption")
		s.Encryption.Encode(e)
	}
}

var jsonFieldsNameOfRestoreSpec = [3]string{
	0: "elements",
	1: "backupFile",
	2: "encryption",
}

// Decode decodes RestoreSpec from json.
func (s *RestoreSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestoreSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Elements = make([]BackupResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BackupResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		case "backupFile":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BackupFile = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupFile\"")
			}
		case "encryption":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Encryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryption\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestoreSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestoreSpec) {
					name = jsonFieldsNameOfRestoreSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestoreSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestoreSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetryComplianceAuditTaskBadRequest as json.
func (s *RetryComplianceAuditTaskBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetryComplianceAuditTaskBadRequest from json.
func (s *RetryComplianceAuditTaskBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetryComplianceAuditTaskBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetryComplianceAuditTaskBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetryComplianceAuditTaskBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetryComplianceAuditTaskBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetryComplianceAuditTaskInternalServerError as json.
func (s *RetryComplianceAuditTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetryComplianceAuditTaskInternalServerError from json.
func (s *RetryComplianceAuditTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetryComplianceAuditTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetryComplianceAuditTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetryComplianceAuditTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetryComplianceAuditTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetryComplianceAuditTaskNotFound as json.
func (s *RetryComplianceAuditTaskNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetryComplianceAuditTaskNotFound from json.
func (s *RetryComplianceAuditTaskNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetryComplianceAuditTaskNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetryComplianceAuditTaskNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetryComplianceAuditTaskNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetryComplianceAuditTaskNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetryCredentialsTaskBadRequest as json.
func (s *RetryCredentialsTaskBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetryCredentialsTaskBadRequest from json.
func (s *RetryCredentialsTaskBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetryCredentialsTaskBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetryCredentialsTaskBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetryCredentialsTaskBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetryCredentialsTaskBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetryCredentialsTaskForbidden as json.
func (s *RetryCredentialsTaskForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetryCredentialsTaskForbidden from json.
func (s *RetryCredentialsTaskForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetryCredentialsTaskForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetryCredentialsTaskForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetryCredentialsTaskForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetryCredentialsTaskForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetryCredentialsTaskInternalServerError as json.
func (s *RetryCredentialsTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetryCredentialsTaskInternalServerError from json.
func (s *RetryCredentialsTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetryCredentialsTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetryCredentialsTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetryCredentialsTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetryCredentialsTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetryCredentialsTaskUnauthorized as json.
func (s *RetryCredentialsTaskUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetryCredentialsTaskUnauthorized from json.
func (s *RetryCredentialsTaskUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetryCredentialsTaskUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetryCredentialsTaskUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetryCredentialsTaskUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetryCredentialsTaskUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetrySddcBadRequest as json.
func (s *RetrySddcBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetrySddcBadRequest from json.
func (s *RetrySddcBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrySddcBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetrySddcBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrySddcBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrySddcBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetrySddcInternalServerError as json.
func (s *RetrySddcInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetrySddcInternalServerError from json.
func (s *RetrySddcInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrySddcInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetrySddcInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrySddcInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrySddcInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetrySddcMethodNotAllowed as json.
func (s *RetrySddcMethodNotAllowed) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetrySddcMethodNotAllowed from json.
func (s *RetrySddcMethodNotAllowed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrySddcMethodNotAllowed to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetrySddcMethodNotAllowed(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrySddcMethodNotAllowed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrySddcMethodNotAllowed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetrySddcNotFound as json.
func (s *RetrySddcNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetrySddcNotFound from json.
func (s *RetrySddcNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrySddcNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetrySddcNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrySddcNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrySddcNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetryTaskConflict as json.
func (s *RetryTaskConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetryTaskConflict from json.
func (s *RetryTaskConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetryTaskConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetryTaskConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetryTaskConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetryTaskConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetryTaskInternalServerError as json.
func (s *RetryTaskInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetryTaskInternalServerError from json.
func (s *RetryTaskInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetryTaskInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetryTaskInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetryTaskInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetryTaskInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetryTaskNotFound as json.
func (s *RetryTaskNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetryTaskNotFound from json.
func (s *RetryTaskNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetryTaskNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetryTaskNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetryTaskNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetryTaskNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Role) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Role) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfRole = [3]string{
	0: "id",
	1: "name",
	2: "description",
}

// Decode decodes Role from json.
func (s *Role) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Role to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Role")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRole) {
					name = jsonFieldsNameOfRole[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Role) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Role) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RoleReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RoleReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfRoleReference = [1]string{
	0: "id",
}

// Decode decodes RoleReference from json.
func (s *RoleReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoleReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RoleReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRoleReference) {
					name = jsonFieldsNameOfRoleReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RoleReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoleReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RootCaCerts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RootCaCerts) encodeFields(e *jx.Encoder) {
	{
		if s.Alias.Set {
			e.FieldStart("alias")
			s.Alias.Encode(e)
		}
	}
	{
		if s.CertChain != nil {
			e.FieldStart("certChain")
			e.ArrStart()
			for _, elem := range s.CertChain {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRootCaCerts = [2]string{
	0: "alias",
	1: "certChain",
}

// Decode decodes RootCaCerts from json.
func (s *RootCaCerts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RootCaCerts to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alias":
			if err := func() error {
				s.Alias.Reset()
				if err := s.Alias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		case "certChain":
			if err := func() error {
				s.CertChain = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CertChain = append(s.CertChain, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certChain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RootCaCerts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RootCaCerts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RootCaCerts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SDDCManagerOidcInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SDDCManagerOidcInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("oidcClientId")
		e.Str(s.OidcClientId)
	}
	{
		e.FieldStart("oidcAuthorizationEndpoint")
		e.Str(s.OidcAuthorizationEndpoint)
	}
	{
		e.FieldStart("oidcEndSessionEndpoint")
		e.Str(s.OidcEndSessionEndpoint)
	}
	{
		e.FieldStart("idpType")
		e.Str(s.IdpType)
	}
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
}

var jsonFieldsNameOfSDDCManagerOidcInfo = [5]string{
	0: "oidcClientId",
	1: "oidcAuthorizationEndpoint",
	2: "oidcEndSessionEndpoint",
	3: "idpType",
	4: "source",
}

// Decode decodes SDDCManagerOidcInfo from json.
func (s *SDDCManagerOidcInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SDDCManagerOidcInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "oidcClientId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OidcClientId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidcClientId\"")
			}
		case "oidcAuthorizationEndpoint":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OidcAuthorizationEndpoint = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidcAuthorizationEndpoint\"")
			}
		case "oidcEndSessionEndpoint":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OidcEndSessionEndpoint = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidcEndSessionEndpoint\"")
			}
		case "idpType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.IdpType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"idpType\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SDDCManagerOidcInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSDDCManagerOidcInfo) {
					name = jsonFieldsNameOfSDDCManagerOidcInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SDDCManagerOidcInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SDDCManagerOidcInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcClusterSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcClusterSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ClusterName.Set {
			e.FieldStart("clusterName")
			s.ClusterName.Encode(e)
		}
	}
	{
		if s.ClusterEvcMode.Set {
			e.FieldStart("clusterEvcMode")
			s.ClusterEvcMode.Encode(e)
		}
	}
	{
		if s.PersonalityName.Set {
			e.FieldStart("personalityName")
			s.PersonalityName.Encode(e)
		}
	}
	{
		if s.ClusterImageEnabled.Set {
			e.FieldStart("clusterImageEnabled")
			s.ClusterImageEnabled.Encode(e)
		}
	}
	{
		if s.ResourcePoolSpecs != nil {
			e.FieldStart("resourcePoolSpecs")
			e.ArrStart()
			for _, elem := range s.ResourcePoolSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostFailuresToTolerate.Set {
			e.FieldStart("hostFailuresToTolerate")
			s.HostFailuresToTolerate.Encode(e)
		}
	}
	{
		if s.VmFolders.Set {
			e.FieldStart("vmFolders")
			s.VmFolders.Encode(e)
		}
	}
}

var jsonFieldsNameOfSddcClusterSpec = [7]string{
	0: "clusterName",
	1: "clusterEvcMode",
	2: "personalityName",
	3: "clusterImageEnabled",
	4: "resourcePoolSpecs",
	5: "hostFailuresToTolerate",
	6: "vmFolders",
}

// Decode decodes SddcClusterSpec from json.
func (s *SddcClusterSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcClusterSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusterName":
			if err := func() error {
				s.ClusterName.Reset()
				if err := s.ClusterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterName\"")
			}
		case "clusterEvcMode":
			if err := func() error {
				s.ClusterEvcMode.Reset()
				if err := s.ClusterEvcMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterEvcMode\"")
			}
		case "personalityName":
			if err := func() error {
				s.PersonalityName.Reset()
				if err := s.PersonalityName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personalityName\"")
			}
		case "clusterImageEnabled":
			if err := func() error {
				s.ClusterImageEnabled.Reset()
				if err := s.ClusterImageEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterImageEnabled\"")
			}
		case "resourcePoolSpecs":
			if err := func() error {
				s.ResourcePoolSpecs = make([]ResourcePoolSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourcePoolSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResourcePoolSpecs = append(s.ResourcePoolSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourcePoolSpecs\"")
			}
		case "hostFailuresToTolerate":
			if err := func() error {
				s.HostFailuresToTolerate.Reset()
				if err := s.HostFailuresToTolerate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostFailuresToTolerate\"")
			}
		case "vmFolders":
			if err := func() error {
				s.VmFolders.Reset()
				if err := s.VmFolders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmFolders\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcClusterSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SddcClusterSpecVmFolders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SddcClusterSpecVmFolders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SddcClusterSpecVmFolders from json.
func (s *SddcClusterSpecVmFolders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcClusterSpecVmFolders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcClusterSpecVmFolders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SddcClusterSpecVmFolders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcClusterSpecVmFolders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcCredentials) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcCredentials) encodeFields(e *jx.Encoder) {
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfSddcCredentials = [2]string{
	0: "username",
	1: "password",
}

// Decode decodes SddcCredentials from json.
func (s *SddcCredentials) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcCredentials to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcCredentials")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSddcCredentials) {
					name = jsonFieldsNameOfSddcCredentials[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcHostSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcHostSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Association.Set {
			e.FieldStart("association")
			s.Association.Encode(e)
		}
	}
	{
		if s.IpAddressPrivate.Set {
			e.FieldStart("ipAddressPrivate")
			s.IpAddressPrivate.Encode(e)
		}
	}
	{
		e.FieldStart("hostname")
		e.Str(s.Hostname)
	}
	{
		if s.Credentials.Set {
			e.FieldStart("credentials")
			s.Credentials.Encode(e)
		}
	}
	{
		if s.VSwitch.Set {
			e.FieldStart("vSwitch")
			s.VSwitch.Encode(e)
		}
	}
	{
		if s.SshThumbprint.Set {
			e.FieldStart("sshThumbprint")
			s.SshThumbprint.Encode(e)
		}
	}
	{
		if s.SslThumbprint.Set {
			e.FieldStart("sslThumbprint")
			s.SslThumbprint.Encode(e)
		}
	}
}

var jsonFieldsNameOfSddcHostSpec = [7]string{
	0: "association",
	1: "ipAddressPrivate",
	2: "hostname",
	3: "credentials",
	4: "vSwitch",
	5: "sshThumbprint",
	6: "sslThumbprint",
}

// Decode decodes SddcHostSpec from json.
func (s *SddcHostSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcHostSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "association":
			if err := func() error {
				s.Association.Reset()
				if err := s.Association.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"association\"")
			}
		case "ipAddressPrivate":
			if err := func() error {
				s.IpAddressPrivate.Reset()
				if err := s.IpAddressPrivate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPrivate\"")
			}
		case "hostname":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Hostname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "credentials":
			if err := func() error {
				s.Credentials.Reset()
				if err := s.Credentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentials\"")
			}
		case "vSwitch":
			if err := func() error {
				s.VSwitch.Reset()
				if err := s.VSwitch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vSwitch\"")
			}
		case "sshThumbprint":
			if err := func() error {
				s.SshThumbprint.Reset()
				if err := s.SshThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sshThumbprint\"")
			}
		case "sslThumbprint":
			if err := func() error {
				s.SslThumbprint.Reset()
				if err := s.SslThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sslThumbprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcHostSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSddcHostSpec) {
					name = jsonFieldsNameOfSddcHostSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcHostSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcHostSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcManager) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcManager) encodeFields(e *jx.Encoder) {
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.BasicAuthDetails.Set {
			e.FieldStart("basicAuthDetails")
			s.BasicAuthDetails.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Fqdn.Set {
			e.FieldStart("fqdn")
			s.Fqdn.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.IpAddress.Set {
			e.FieldStart("ipAddress")
			s.IpAddress.Encode(e)
		}
	}
}

var jsonFieldsNameOfSddcManager = [6]string{
	0: "domain",
	1: "basicAuthDetails",
	2: "id",
	3: "fqdn",
	4: "version",
	5: "ipAddress",
}

// Decode decodes SddcManager from json.
func (s *SddcManager) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcManager to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "basicAuthDetails":
			if err := func() error {
				s.BasicAuthDetails.Reset()
				if err := s.BasicAuthDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basicAuthDetails\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "fqdn":
			if err := func() error {
				s.Fqdn.Reset()
				if err := s.Fqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "ipAddress":
			if err := func() error {
				s.IpAddress.Reset()
				if err := s.IpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcManager")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcManager) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcManager) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcManagerInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcManagerInfo) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Fqdn.Set {
			e.FieldStart("fqdn")
			s.Fqdn.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.IpAddress.Set {
			e.FieldStart("ipAddress")
			s.IpAddress.Encode(e)
		}
	}
}

var jsonFieldsNameOfSddcManagerInfo = [4]string{
	0: "id",
	1: "fqdn",
	2: "version",
	3: "ipAddress",
}

// Decode decodes SddcManagerInfo from json.
func (s *SddcManagerInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcManagerInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "fqdn":
			if err := func() error {
				s.Fqdn.Reset()
				if err := s.Fqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "ipAddress":
			if err := func() error {
				s.IpAddress.Reset()
				if err := s.IpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcManagerInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcManagerInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcManagerInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcManagerSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcManagerSpec) encodeFields(e *jx.Encoder) {
	{
		if s.RootUserCredentials.Set {
			e.FieldStart("rootUserCredentials")
			s.RootUserCredentials.Encode(e)
		}
	}
	{
		e.FieldStart("hostname")
		e.Str(s.Hostname)
	}
	{
		if s.SecondUserCredentials.Set {
			e.FieldStart("secondUserCredentials")
			s.SecondUserCredentials.Encode(e)
		}
	}
	{
		if s.LocalUserPassword.Set {
			e.FieldStart("localUserPassword")
			s.LocalUserPassword.Encode(e)
		}
	}
	{
		if s.IpAddress.Set {
			e.FieldStart("ipAddress")
			s.IpAddress.Encode(e)
		}
	}
}

var jsonFieldsNameOfSddcManagerSpec = [5]string{
	0: "rootUserCredentials",
	1: "hostname",
	2: "secondUserCredentials",
	3: "localUserPassword",
	4: "ipAddress",
}

// Decode decodes SddcManagerSpec from json.
func (s *SddcManagerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcManagerSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rootUserCredentials":
			if err := func() error {
				s.RootUserCredentials.Reset()
				if err := s.RootUserCredentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rootUserCredentials\"")
			}
		case "hostname":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Hostname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "secondUserCredentials":
			if err := func() error {
				s.SecondUserCredentials.Reset()
				if err := s.SecondUserCredentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secondUserCredentials\"")
			}
		case "localUserPassword":
			if err := func() error {
				s.LocalUserPassword.Reset()
				if err := s.LocalUserPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localUserPassword\"")
			}
		case "ipAddress":
			if err := func() error {
				s.IpAddress.Reset()
				if err := s.IpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcManagerSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSddcManagerSpec) {
					name = jsonFieldsNameOfSddcManagerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcManagerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcManagerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcNetworkSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcNetworkSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("networkType")
		e.Str(s.NetworkType)
	}
	{
		if s.Subnet.Set {
			e.FieldStart("subnet")
			s.Subnet.Encode(e)
		}
	}
	{
		if s.Gateway.Set {
			e.FieldStart("gateway")
			s.Gateway.Encode(e)
		}
	}
	{
		if s.SubnetMask.Set {
			e.FieldStart("subnetMask")
			s.SubnetMask.Encode(e)
		}
	}
	{
		if s.ExcludeIpaddresses != nil {
			e.FieldStart("excludeIpaddresses")
			e.ArrStart()
			for _, elem := range s.ExcludeIpaddresses {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExcludeIpAddressRanges != nil {
			e.FieldStart("excludeIpAddressRanges")
			e.ArrStart()
			for _, elem := range s.ExcludeIpAddressRanges {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IncludeIpAddress != nil {
			e.FieldStart("includeIpAddress")
			e.ArrStart()
			for _, elem := range s.IncludeIpAddress {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IncludeIpAddressRanges != nil {
			e.FieldStart("includeIpAddressRanges")
			e.ArrStart()
			for _, elem := range s.IncludeIpAddressRanges {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("vlanId")
		e.Int(s.VlanId)
	}
	{
		if s.Mtu.Set {
			e.FieldStart("mtu")
			s.Mtu.Encode(e)
		}
	}
	{
		if s.TeamingPolicy.Set {
			e.FieldStart("teamingPolicy")
			s.TeamingPolicy.Encode(e)
		}
	}
	{
		if s.ActiveUplinks != nil {
			e.FieldStart("activeUplinks")
			e.ArrStart()
			for _, elem := range s.ActiveUplinks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StandbyUplinks != nil {
			e.FieldStart("standbyUplinks")
			e.ArrStart()
			for _, elem := range s.StandbyUplinks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PortGroupKey.Set {
			e.FieldStart("portGroupKey")
			s.PortGroupKey.Encode(e)
		}
	}
}

var jsonFieldsNameOfSddcNetworkSpec = [14]string{
	0:  "networkType",
	1:  "subnet",
	2:  "gateway",
	3:  "subnetMask",
	4:  "excludeIpaddresses",
	5:  "excludeIpAddressRanges",
	6:  "includeIpAddress",
	7:  "includeIpAddressRanges",
	8:  "vlanId",
	9:  "mtu",
	10: "teamingPolicy",
	11: "activeUplinks",
	12: "standbyUplinks",
	13: "portGroupKey",
}

// Decode decodes SddcNetworkSpec from json.
func (s *SddcNetworkSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcNetworkSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "networkType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NetworkType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkType\"")
			}
		case "subnet":
			if err := func() error {
				s.Subnet.Reset()
				if err := s.Subnet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subnet\"")
			}
		case "gateway":
			if err := func() error {
				s.Gateway.Reset()
				if err := s.Gateway.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		case "subnetMask":
			if err := func() error {
				s.SubnetMask.Reset()
				if err := s.SubnetMask.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subnetMask\"")
			}
		case "excludeIpaddresses":
			if err := func() error {
				s.ExcludeIpaddresses = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExcludeIpaddresses = append(s.ExcludeIpaddresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludeIpaddresses\"")
			}
		case "excludeIpAddressRanges":
			if err := func() error {
				s.ExcludeIpAddressRanges = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExcludeIpAddressRanges = append(s.ExcludeIpAddressRanges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludeIpAddressRanges\"")
			}
		case "includeIpAddress":
			if err := func() error {
				s.IncludeIpAddress = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IncludeIpAddress = append(s.IncludeIpAddress, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeIpAddress\"")
			}
		case "includeIpAddressRanges":
			if err := func() error {
				s.IncludeIpAddressRanges = make([]IpRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IpRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IncludeIpAddressRanges = append(s.IncludeIpAddressRanges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeIpAddressRanges\"")
			}
		case "vlanId":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.VlanId = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlanId\"")
			}
		case "mtu":
			if err := func() error {
				s.Mtu.Reset()
				if err := s.Mtu.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mtu\"")
			}
		case "teamingPolicy":
			if err := func() error {
				s.TeamingPolicy.Reset()
				if err := s.TeamingPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamingPolicy\"")
			}
		case "activeUplinks":
			if err := func() error {
				s.ActiveUplinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ActiveUplinks = append(s.ActiveUplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUplinks\"")
			}
		case "standbyUplinks":
			if err := func() error {
				s.StandbyUplinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StandbyUplinks = append(s.StandbyUplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standbyUplinks\"")
			}
		case "portGroupKey":
			if err := func() error {
				s.PortGroupKey.Reset()
				if err := s.PortGroupKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portGroupKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcNetworkSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSddcNetworkSpec) {
					name = jsonFieldsNameOfSddcNetworkSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcNetworkSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcNetworkSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcNsxtSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcNsxtSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nsxtManagers")
		e.ArrStart()
		for _, elem := range s.NsxtManagers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.NsxtManagerSize.Set {
			e.FieldStart("nsxtManagerSize")
			s.NsxtManagerSize.Encode(e)
		}
	}
	{
		if s.NsxtLicense.Set {
			e.FieldStart("nsxtLicense")
			s.NsxtLicense.Encode(e)
		}
	}
	{
		if s.Vip.Set {
			e.FieldStart("vip")
			s.Vip.Encode(e)
		}
	}
	{
		e.FieldStart("vipFqdn")
		e.Str(s.VipFqdn)
	}
	{
		if s.RootNsxtManagerPassword.Set {
			e.FieldStart("rootNsxtManagerPassword")
			s.RootNsxtManagerPassword.Encode(e)
		}
	}
	{
		if s.NsxtAdminPassword.Set {
			e.FieldStart("nsxtAdminPassword")
			s.NsxtAdminPassword.Encode(e)
		}
	}
	{
		if s.NsxtAuditPassword.Set {
			e.FieldStart("nsxtAuditPassword")
			s.NsxtAuditPassword.Encode(e)
		}
	}
	{
		if s.OverLayTransportZone.Set {
			e.FieldStart("overLayTransportZone")
			s.OverLayTransportZone.Encode(e)
		}
	}
	{
		if s.TransportVlanId.Set {
			e.FieldStart("transportVlanId")
			s.TransportVlanId.Encode(e)
		}
	}
	{
		if s.IpAddressPoolSpec.Set {
			e.FieldStart("ipAddressPoolSpec")
			s.IpAddressPoolSpec.Encode(e)
		}
	}
}

var jsonFieldsNameOfSddcNsxtSpec = [11]string{
	0:  "nsxtManagers",
	1:  "nsxtManagerSize",
	2:  "nsxtLicense",
	3:  "vip",
	4:  "vipFqdn",
	5:  "rootNsxtManagerPassword",
	6:  "nsxtAdminPassword",
	7:  "nsxtAuditPassword",
	8:  "overLayTransportZone",
	9:  "transportVlanId",
	10: "ipAddressPoolSpec",
}

// Decode decodes SddcNsxtSpec from json.
func (s *SddcNsxtSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcNsxtSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nsxtManagers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NsxtManagers = make([]NsxtManagerSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtManagerSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxtManagers = append(s.NsxtManagers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtManagers\"")
			}
		case "nsxtManagerSize":
			if err := func() error {
				s.NsxtManagerSize.Reset()
				if err := s.NsxtManagerSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtManagerSize\"")
			}
		case "nsxtLicense":
			if err := func() error {
				s.NsxtLicense.Reset()
				if err := s.NsxtLicense.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtLicense\"")
			}
		case "vip":
			if err := func() error {
				s.Vip.Reset()
				if err := s.Vip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vip\"")
			}
		case "vipFqdn":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.VipFqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vipFqdn\"")
			}
		case "rootNsxtManagerPassword":
			if err := func() error {
				s.RootNsxtManagerPassword.Reset()
				if err := s.RootNsxtManagerPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rootNsxtManagerPassword\"")
			}
		case "nsxtAdminPassword":
			if err := func() error {
				s.NsxtAdminPassword.Reset()
				if err := s.NsxtAdminPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtAdminPassword\"")
			}
		case "nsxtAuditPassword":
			if err := func() error {
				s.NsxtAuditPassword.Reset()
				if err := s.NsxtAuditPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtAuditPassword\"")
			}
		case "overLayTransportZone":
			if err := func() error {
				s.OverLayTransportZone.Reset()
				if err := s.OverLayTransportZone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overLayTransportZone\"")
			}
		case "transportVlanId":
			if err := func() error {
				s.TransportVlanId.Reset()
				if err := s.TransportVlanId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transportVlanId\"")
			}
		case "ipAddressPoolSpec":
			if err := func() error {
				s.IpAddressPoolSpec.Reset()
				if err := s.IpAddressPoolSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddressPoolSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcNsxtSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSddcNsxtSpec) {
					name = jsonFieldsNameOfSddcNsxtSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcNsxtSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcNsxtSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sddcId")
		e.Str(s.SddcId)
	}
	{
		if s.TaskName.Set {
			e.FieldStart("taskName")
			s.TaskName.Encode(e)
		}
	}
	{
		if s.WorkflowType.Set {
			e.FieldStart("workflowType")
			s.WorkflowType.Encode(e)
		}
	}
	{
		e.FieldStart("hostSpecs")
		e.ArrStart()
		for _, elem := range s.HostSpecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("vcenterSpec")
		s.VcenterSpec.Encode(e)
	}
	{
		if s.ClusterSpec.Set {
			e.FieldStart("clusterSpec")
			s.ClusterSpec.Encode(e)
		}
	}
	{
		if s.DvsSpecs != nil {
			e.FieldStart("dvsSpecs")
			e.ArrStart()
			for _, elem := range s.DvsSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VsanSpec.Set {
			e.FieldStart("vsanSpec")
			s.VsanSpec.Encode(e)
		}
	}
	{
		if s.NsxtSpec.Set {
			e.FieldStart("nsxtSpec")
			s.NsxtSpec.Encode(e)
		}
	}
	{
		e.FieldStart("networkSpecs")
		e.ArrStart()
		for _, elem := range s.NetworkSpecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("dnsSpec")
		s.DnsSpec.Encode(e)
	}
	{
		e.FieldStart("ntpServers")
		e.ArrStart()
		for _, elem := range s.NtpServers {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.SddcManagerSpec.Set {
			e.FieldStart("sddcManagerSpec")
			s.SddcManagerSpec.Encode(e)
		}
	}
	{
		if s.PscSpecs != nil {
			e.FieldStart("pscSpecs")
			e.ArrStart()
			for _, elem := range s.PscSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VxManagerSpec.Set {
			e.FieldStart("vxManagerSpec")
			s.VxManagerSpec.Encode(e)
		}
	}
	{
		if s.ManagementPoolName.Set {
			e.FieldStart("managementPoolName")
			s.ManagementPoolName.Encode(e)
		}
	}
	{
		if s.ExcludedComponents != nil {
			e.FieldStart("excludedComponents")
			e.ArrStart()
			for _, elem := range s.ExcludedComponents {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DvSwitchVersion.Set {
			e.FieldStart("dvSwitchVersion")
			s.DvSwitchVersion.Encode(e)
		}
	}
	{
		if s.CeipEnabled.Set {
			e.FieldStart("ceipEnabled")
			s.CeipEnabled.Encode(e)
		}
	}
	{
		if s.FipsEnabled.Set {
			e.FieldStart("fipsEnabled")
			s.FipsEnabled.Encode(e)
		}
	}
	{
		if s.EsxLicense.Set {
			e.FieldStart("esxLicense")
			s.EsxLicense.Encode(e)
		}
	}
	{
		if s.SkipEsxThumbprintValidation.Set {
			e.FieldStart("skipEsxThumbprintValidation")
			s.SkipEsxThumbprintValidation.Encode(e)
		}
	}
	{
		if s.SkipGatewayPingValidation.Set {
			e.FieldStart("skipGatewayPingValidation")
			s.SkipGatewayPingValidation.Encode(e)
		}
	}
	{
		if s.SecuritySpec.Set {
			e.FieldStart("securitySpec")
			s.SecuritySpec.Encode(e)
		}
	}
	{
		if s.ProxySpec.Set {
			e.FieldStart("proxySpec")
			s.ProxySpec.Encode(e)
		}
	}
	{
		if s.DeployWithoutLicenseKeys.Set {
			e.FieldStart("deployWithoutLicenseKeys")
			s.DeployWithoutLicenseKeys.Encode(e)
		}
	}
}

var jsonFieldsNameOfSddcSpec = [26]string{
	0:  "sddcId",
	1:  "taskName",
	2:  "workflowType",
	3:  "hostSpecs",
	4:  "vcenterSpec",
	5:  "clusterSpec",
	6:  "dvsSpecs",
	7:  "vsanSpec",
	8:  "nsxtSpec",
	9:  "networkSpecs",
	10: "dnsSpec",
	11: "ntpServers",
	12: "sddcManagerSpec",
	13: "pscSpecs",
	14: "vxManagerSpec",
	15: "managementPoolName",
	16: "excludedComponents",
	17: "dvSwitchVersion",
	18: "ceipEnabled",
	19: "fipsEnabled",
	20: "esxLicense",
	21: "skipEsxThumbprintValidation",
	22: "skipGatewayPingValidation",
	23: "securitySpec",
	24: "proxySpec",
	25: "deployWithoutLicenseKeys",
}

// Decode decodes SddcSpec from json.
func (s *SddcSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcSpec to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sddcId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SddcId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sddcId\"")
			}
		case "taskName":
			if err := func() error {
				s.TaskName.Reset()
				if err := s.TaskName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskName\"")
			}
		case "workflowType":
			if err := func() error {
				s.WorkflowType.Reset()
				if err := s.WorkflowType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflowType\"")
			}
		case "hostSpecs":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.HostSpecs = make([]SddcHostSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SddcHostSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HostSpecs = append(s.HostSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostSpecs\"")
			}
		case "vcenterSpec":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.VcenterSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcenterSpec\"")
			}
		case "clusterSpec":
			if err := func() error {
				s.ClusterSpec.Reset()
				if err := s.ClusterSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterSpec\"")
			}
		case "dvsSpecs":
			if err := func() error {
				s.DvsSpecs = make([]DvsSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DvsSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DvsSpecs = append(s.DvsSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dvsSpecs\"")
			}
		case "vsanSpec":
			if err := func() error {
				s.VsanSpec.Reset()
				if err := s.VsanSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanSpec\"")
			}
		case "nsxtSpec":
			if err := func() error {
				s.NsxtSpec.Reset()
				if err := s.NsxtSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtSpec\"")
			}
		case "networkSpecs":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.NetworkSpecs = make([]SddcNetworkSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SddcNetworkSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NetworkSpecs = append(s.NetworkSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkSpecs\"")
			}
		case "dnsSpec":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.DnsSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dnsSpec\"")
			}
		case "ntpServers":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.NtpServers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NtpServers = append(s.NtpServers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ntpServers\"")
			}
		case "sddcManagerSpec":
			if err := func() error {
				s.SddcManagerSpec.Reset()
				if err := s.SddcManagerSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sddcManagerSpec\"")
			}
		case "pscSpecs":
			if err := func() error {
				s.PscSpecs = make([]PscSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PscSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PscSpecs = append(s.PscSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pscSpecs\"")
			}
		case "vxManagerSpec":
			if err := func() error {
				s.VxManagerSpec.Reset()
				if err := s.VxManagerSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vxManagerSpec\"")
			}
		case "managementPoolName":
			if err := func() error {
				s.ManagementPoolName.Reset()
				if err := s.ManagementPoolName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"managementPoolName\"")
			}
		case "excludedComponents":
			if err := func() error {
				s.ExcludedComponents = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExcludedComponents = append(s.ExcludedComponents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludedComponents\"")
			}
		case "dvSwitchVersion":
			if err := func() error {
				s.DvSwitchVersion.Reset()
				if err := s.DvSwitchVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dvSwitchVersion\"")
			}
		case "ceipEnabled":
			if err := func() error {
				s.CeipEnabled.Reset()
				if err := s.CeipEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ceipEnabled\"")
			}
		case "fipsEnabled":
			if err := func() error {
				s.FipsEnabled.Reset()
				if err := s.FipsEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fipsEnabled\"")
			}
		case "esxLicense":
			if err := func() error {
				s.EsxLicense.Reset()
				if err := s.EsxLicense.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"esxLicense\"")
			}
		case "skipEsxThumbprintValidation":
			if err := func() error {
				s.SkipEsxThumbprintValidation.Reset()
				if err := s.SkipEsxThumbprintValidation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skipEsxThumbprintValidation\"")
			}
		case "skipGatewayPingValidation":
			if err := func() error {
				s.SkipGatewayPingValidation.Reset()
				if err := s.SkipGatewayPingValidation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skipGatewayPingValidation\"")
			}
		case "securitySpec":
			if err := func() error {
				s.SecuritySpec.Reset()
				if err := s.SecuritySpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securitySpec\"")
			}
		case "proxySpec":
			if err := func() error {
				s.ProxySpec.Reset()
				if err := s.ProxySpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxySpec\"")
			}
		case "deployWithoutLicenseKeys":
			if err := func() error {
				s.DeployWithoutLicenseKeys.Reset()
				if err := s.DeployWithoutLicenseKeys.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployWithoutLicenseKeys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00011001,
		0b00001110,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSddcSpec) {
					name = jsonFieldsNameOfSddcSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcSubTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcSubTask) encodeFields(e *jx.Encoder) {
	{
		if s.SddcId.Set {
			e.FieldStart("sddcId")
			s.SddcId.Encode(e)
		}
	}
	{
		if s.ProcessingStateName.Set {
			e.FieldStart("processingStateName")
			s.ProcessingStateName.Encode(e)
		}
	}
	{
		if s.ProcessingStateDescription.Set {
			e.FieldStart("processingStateDescription")
			s.ProcessingStateDescription.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.LocalizableNamePack.Set {
			e.FieldStart("localizableNamePack")
			s.LocalizableNamePack.Encode(e)
		}
	}
	{
		if s.LocalizableDescriptionPack.Set {
			e.FieldStart("localizableDescriptionPack")
			s.LocalizableDescriptionPack.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.CreationTimestamp.Set {
			e.FieldStart("creationTimestamp")
			s.CreationTimestamp.Encode(e)
		}
	}
	{
		if s.UpdateTimestamp.Set {
			e.FieldStart("updateTimestamp")
			s.UpdateTimestamp.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSddcSubTask = [11]string{
	0:  "sddcId",
	1:  "processingStateName",
	2:  "processingStateDescription",
	3:  "name",
	4:  "description",
	5:  "localizableNamePack",
	6:  "localizableDescriptionPack",
	7:  "status",
	8:  "creationTimestamp",
	9:  "updateTimestamp",
	10: "errors",
}

// Decode decodes SddcSubTask from json.
func (s *SddcSubTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcSubTask to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sddcId":
			if err := func() error {
				s.SddcId.Reset()
				if err := s.SddcId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sddcId\"")
			}
		case "processingStateName":
			if err := func() error {
				s.ProcessingStateName.Reset()
				if err := s.ProcessingStateName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processingStateName\"")
			}
		case "processingStateDescription":
			if err := func() error {
				s.ProcessingStateDescription.Reset()
				if err := s.ProcessingStateDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processingStateDescription\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "localizableNamePack":
			if err := func() error {
				s.LocalizableNamePack.Reset()
				if err := s.LocalizableNamePack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localizableNamePack\"")
			}
		case "localizableDescriptionPack":
			if err := func() error {
				s.LocalizableDescriptionPack.Reset()
				if err := s.LocalizableDescriptionPack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localizableDescriptionPack\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "creationTimestamp":
			if err := func() error {
				s.CreationTimestamp.Reset()
				if err := s.CreationTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "updateTimestamp":
			if err := func() error {
				s.UpdateTimestamp.Reset()
				if err := s.UpdateTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateTimestamp\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcSubTask")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcSubTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcSubTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcTask) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		if s.LocalizableNamePack.Set {
			e.FieldStart("localizableNamePack")
			s.LocalizableNamePack.Encode(e)
		}
	}
	{
		e.FieldStart("creationTimestamp")
		e.Str(s.CreationTimestamp)
	}
	{
		if s.SddcSubTasks != nil {
			e.FieldStart("sddcSubTasks")
			e.ArrStart()
			for _, elem := range s.SddcSubTasks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSddcTask = [6]string{
	0: "id",
	1: "name",
	2: "status",
	3: "localizableNamePack",
	4: "creationTimestamp",
	5: "sddcSubTasks",
}

// Decode decodes SddcTask from json.
func (s *SddcTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcTask to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "localizableNamePack":
			if err := func() error {
				s.LocalizableNamePack.Reset()
				if err := s.LocalizableNamePack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localizableNamePack\"")
			}
		case "creationTimestamp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CreationTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "sddcSubTasks":
			if err := func() error {
				s.SddcSubTasks = make([]SddcSubTask, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SddcSubTask
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SddcSubTasks = append(s.SddcSubTasks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sddcSubTasks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcTask")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSddcTask) {
					name = jsonFieldsNameOfSddcTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SddcVcenterSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SddcVcenterSpec) encodeFields(e *jx.Encoder) {
	{
		if s.LicenseFile.Set {
			e.FieldStart("licenseFile")
			s.LicenseFile.Encode(e)
		}
	}
	{
		if s.VcenterIp.Set {
			e.FieldStart("vcenterIp")
			s.VcenterIp.Encode(e)
		}
	}
	{
		e.FieldStart("vcenterHostname")
		e.Str(s.VcenterHostname)
	}
	{
		e.FieldStart("rootVcenterPassword")
		e.Str(s.RootVcenterPassword)
	}
	{
		if s.VmSize.Set {
			e.FieldStart("vmSize")
			s.VmSize.Encode(e)
		}
	}
	{
		if s.StorageSize.Set {
			e.FieldStart("storageSize")
			s.StorageSize.Encode(e)
		}
	}
	{
		if s.SshThumbprint.Set {
			e.FieldStart("sshThumbprint")
			s.SshThumbprint.Encode(e)
		}
	}
	{
		if s.SslThumbprint.Set {
			e.FieldStart("sslThumbprint")
			s.SslThumbprint.Encode(e)
		}
	}
}

var jsonFieldsNameOfSddcVcenterSpec = [8]string{
	0: "licenseFile",
	1: "vcenterIp",
	2: "vcenterHostname",
	3: "rootVcenterPassword",
	4: "vmSize",
	5: "storageSize",
	6: "sshThumbprint",
	7: "sslThumbprint",
}

// Decode decodes SddcVcenterSpec from json.
func (s *SddcVcenterSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SddcVcenterSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "licenseFile":
			if err := func() error {
				s.LicenseFile.Reset()
				if err := s.LicenseFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseFile\"")
			}
		case "vcenterIp":
			if err := func() error {
				s.VcenterIp.Reset()
				if err := s.VcenterIp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcenterIp\"")
			}
		case "vcenterHostname":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VcenterHostname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcenterHostname\"")
			}
		case "rootVcenterPassword":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.RootVcenterPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rootVcenterPassword\"")
			}
		case "vmSize":
			if err := func() error {
				s.VmSize.Reset()
				if err := s.VmSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmSize\"")
			}
		case "storageSize":
			if err := func() error {
				s.StorageSize.Reset()
				if err := s.StorageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageSize\"")
			}
		case "sshThumbprint":
			if err := func() error {
				s.SshThumbprint.Reset()
				if err := s.SshThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sshThumbprint\"")
			}
		case "sslThumbprint":
			if err := func() error {
				s.SslThumbprint.Reset()
				if err := s.SslThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sslThumbprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SddcVcenterSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSddcVcenterSpec) {
					name = jsonFieldsNameOfSddcVcenterSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SddcVcenterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SddcVcenterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecuritySpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecuritySpec) encodeFields(e *jx.Encoder) {
	{
		if s.EsxiCertsMode.Set {
			e.FieldStart("esxiCertsMode")
			s.EsxiCertsMode.Encode(e)
		}
	}
	{
		if s.RootCaCerts != nil {
			e.FieldStart("rootCaCerts")
			e.ArrStart()
			for _, elem := range s.RootCaCerts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSecuritySpec = [2]string{
	0: "esxiCertsMode",
	1: "rootCaCerts",
}

// Decode decodes SecuritySpec from json.
func (s *SecuritySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecuritySpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "esxiCertsMode":
			if err := func() error {
				s.EsxiCertsMode.Reset()
				if err := s.EsxiCertsMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"esxiCertsMode\"")
			}
		case "rootCaCerts":
			if err := func() error {
				s.RootCaCerts = make([]RootCaCerts, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RootCaCerts
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RootCaCerts = append(s.RootCaCerts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rootCaCerts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecuritySpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecuritySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecuritySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SelectedCheckSetCandidate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SelectedCheckSetCandidate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("checkSetId")
		e.Str(s.CheckSetId)
	}
}

var jsonFieldsNameOfSelectedCheckSetCandidate = [1]string{
	0: "checkSetId",
}

// Decode decodes SelectedCheckSetCandidate from json.
func (s *SelectedCheckSetCandidate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectedCheckSetCandidate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "checkSetId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CheckSetId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkSetId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SelectedCheckSetCandidate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSelectedCheckSetCandidate) {
					name = jsonFieldsNameOfSelectedCheckSetCandidate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectedCheckSetCandidate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectedCheckSetCandidate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetBackupConfigurationBadRequest as json.
func (s *SetBackupConfigurationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SetBackupConfigurationBadRequest from json.
func (s *SetBackupConfigurationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetBackupConfigurationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SetBackupConfigurationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetBackupConfigurationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetBackupConfigurationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetBackupConfigurationInternalServerError as json.
func (s *SetBackupConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SetBackupConfigurationInternalServerError from json.
func (s *SetBackupConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetBackupConfigurationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SetBackupConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetBackupConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetBackupConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetCeipStatusBadRequest as json.
func (s *SetCeipStatusBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SetCeipStatusBadRequest from json.
func (s *SetCeipStatusBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetCeipStatusBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SetCeipStatusBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetCeipStatusBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetCeipStatusBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetCeipStatusConflict as json.
func (s *SetCeipStatusConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SetCeipStatusConflict from json.
func (s *SetCeipStatusConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetCeipStatusConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SetCeipStatusConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetCeipStatusConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetCeipStatusConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetCeipStatusInternalServerError as json.
func (s *SetCeipStatusInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SetCeipStatusInternalServerError from json.
func (s *SetCeipStatusInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetCeipStatusInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SetCeipStatusInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetCeipStatusInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetCeipStatusInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetCeipStatusReq as json.
func (s SetCeipStatusReq) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SetCeipStatusReq from json.
func (s *SetCeipStatusReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetCeipStatusReq to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SetCeipStatusReq(v) {
	case SetCeipStatusReqENABLED:
		*s = SetCeipStatusReqENABLED
	case SetCeipStatusReqDISABLED:
		*s = SetCeipStatusReqDISABLED
	case SetCeipStatusReqDISABLING:
		*s = SetCeipStatusReqDISABLING
	case SetCeipStatusReqENABLING:
		*s = SetCeipStatusReqENABLING
	case SetCeipStatusReqENABLINGFAILED:
		*s = SetCeipStatusReqENABLINGFAILED
	case SetCeipStatusReqDISABLINGFAILED:
		*s = SetCeipStatusReqDISABLINGFAILED
	default:
		*s = SetCeipStatusReq(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SetCeipStatusReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetCeipStatusReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetLicenseKeyForResourceBadRequest as json.
func (s *SetLicenseKeyForResourceBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SetLicenseKeyForResourceBadRequest from json.
func (s *SetLicenseKeyForResourceBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetLicenseKeyForResourceBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SetLicenseKeyForResourceBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetLicenseKeyForResourceBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetLicenseKeyForResourceBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetLicenseKeyForResourceInternalServerError as json.
func (s *SetLicenseKeyForResourceInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes SetLicenseKeyForResourceInternalServerError from json.
func (s *SetLicenseKeyForResourceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetLicenseKeyForResourceInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SetLicenseKeyForResourceInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetLicenseKeyForResourceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetLicenseKeyForResourceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SharesInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SharesInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Shares.Set {
			e.FieldStart("shares")
			s.Shares.Encode(e)
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
}

var jsonFieldsNameOfSharesInfo = [2]string{
	0: "shares",
	1: "level",
}

// Decode decodes SharesInfo from json.
func (s *SharesInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SharesInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shares":
			if err := func() error {
				s.Shares.Reset()
				if err := s.Shares.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shares\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SharesInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SharesInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SharesInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkuBomDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkuBomDetails) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.SkuSpecificPatchBundles != nil {
			e.FieldStart("skuSpecificPatchBundles")
			e.ArrStart()
			for _, elem := range s.SkuSpecificPatchBundles {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("bom")
		e.ArrStart()
		for _, elem := range s.Bom {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSkuBomDetails = [4]string{
	0: "name",
	1: "description",
	2: "skuSpecificPatchBundles",
	3: "bom",
}

// Decode decodes SkuBomDetails from json.
func (s *SkuBomDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkuBomDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "skuSpecificPatchBundles":
			if err := func() error {
				s.SkuSpecificPatchBundles = make([]SkuSpecificPatchBundles, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SkuSpecificPatchBundles
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SkuSpecificPatchBundles = append(s.SkuSpecificPatchBundles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skuSpecificPatchBundles\"")
			}
		case "bom":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Bom = make([]ProductVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProductVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Bom = append(s.Bom, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bom\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkuBomDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkuBomDetails) {
					name = jsonFieldsNameOfSkuBomDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkuBomDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkuBomDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkuSpecificPatchBundles) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkuSpecificPatchBundles) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bundleType")
		e.Str(s.BundleType)
	}
	{
		e.FieldStart("bundleVersion")
		e.Str(s.BundleVersion)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfSkuSpecificPatchBundles = [3]string{
	0: "bundleType",
	1: "bundleVersion",
	2: "version",
}

// Decode decodes SkuSpecificPatchBundles from json.
func (s *SkuSpecificPatchBundles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkuSpecificPatchBundles to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bundleType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BundleType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleType\"")
			}
		case "bundleVersion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BundleVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleVersion\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkuSpecificPatchBundles")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkuSpecificPatchBundles) {
					name = jsonFieldsNameOfSkuSpecificPatchBundles[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkuSpecificPatchBundles) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkuSpecificPatchBundles) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SmartNicInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SmartNicInfo) encodeFields(e *jx.Encoder) {
	{
		if s.VendorName.Set {
			e.FieldStart("vendorName")
			s.VendorName.Encode(e)
		}
	}
	{
		if s.DpuId.Set {
			e.FieldStart("dpuId")
			s.DpuId.Encode(e)
		}
	}
}

var jsonFieldsNameOfSmartNicInfo = [2]string{
	0: "vendorName",
	1: "dpuId",
}

// Decode decodes SmartNicInfo from json.
func (s *SmartNicInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SmartNicInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vendorName":
			if err := func() error {
				s.VendorName.Reset()
				if err := s.VendorName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vendorName\"")
			}
		case "dpuId":
			if err := func() error {
				s.DpuId.Reset()
				if err := s.DpuId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dpuId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SmartNicInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SmartNicInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SmartNicInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SoftwareComponent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SoftwareComponent) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfSoftwareComponent = [2]string{
	0: "id",
	1: "type",
}

// Decode decodes SoftwareComponent from json.
func (s *SoftwareComponent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SoftwareComponent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SoftwareComponent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SoftwareComponent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SoftwareComponent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SoftwareInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SoftwareInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("baseImage")
		s.BaseImage.Encode(e)
	}
	{
		if s.AddOn.Set {
			e.FieldStart("addOn")
			s.AddOn.Encode(e)
		}
	}
	{
		if s.Components.Set {
			e.FieldStart("components")
			s.Components.Encode(e)
		}
	}
	{
		if s.HardwareSupport.Set {
			e.FieldStart("hardwareSupport")
			s.HardwareSupport.Encode(e)
		}
	}
}

var jsonFieldsNameOfSoftwareInfo = [4]string{
	0: "baseImage",
	1: "addOn",
	2: "components",
	3: "hardwareSupport",
}

// Decode decodes SoftwareInfo from json.
func (s *SoftwareInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SoftwareInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "baseImage":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.BaseImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"baseImage\"")
			}
		case "addOn":
			if err := func() error {
				s.AddOn.Reset()
				if err := s.AddOn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addOn\"")
			}
		case "components":
			if err := func() error {
				s.Components.Reset()
				if err := s.Components.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"components\"")
			}
		case "hardwareSupport":
			if err := func() error {
				s.HardwareSupport.Reset()
				if err := s.HardwareSupport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hardwareSupport\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SoftwareInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSoftwareInfo) {
					name = jsonFieldsNameOfSoftwareInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SoftwareInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SoftwareInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SoftwareInfoComponents) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SoftwareInfoComponents) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes SoftwareInfoComponents from json.
func (s *SoftwareInfoComponents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SoftwareInfoComponents to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ComponentInfo
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SoftwareInfoComponents")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SoftwareInfoComponents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SoftwareInfoComponents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SourceDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SourceDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("usersBaseDn")
		e.Str(s.UsersBaseDn)
	}
	{
		e.FieldStart("groupsBaseDn")
		e.Str(s.GroupsBaseDn)
	}
	{
		if s.CertChain != nil {
			e.FieldStart("certChain")
			e.ArrStart()
			for _, elem := range s.CertChain {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("serverEndpoints")
		e.ArrStart()
		for _, elem := range s.ServerEndpoints {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSourceDetails = [4]string{
	0: "usersBaseDn",
	1: "groupsBaseDn",
	2: "certChain",
	3: "serverEndpoints",
}

// Decode decodes SourceDetails from json.
func (s *SourceDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SourceDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "usersBaseDn":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UsersBaseDn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersBaseDn\"")
			}
		case "groupsBaseDn":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GroupsBaseDn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groupsBaseDn\"")
			}
		case "certChain":
			if err := func() error {
				s.CertChain = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CertChain = append(s.CertChain, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certChain\"")
			}
		case "serverEndpoints":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.ServerEndpoints = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ServerEndpoints = append(s.ServerEndpoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverEndpoints\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SourceDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSourceDetails) {
					name = jsonFieldsNameOfSourceDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SourceDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SourceDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SsoDomainEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SsoDomainEntity) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfSsoDomainEntity = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes SsoDomainEntity from json.
func (s *SsoDomainEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SsoDomainEntity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SsoDomainEntity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSsoDomainEntity) {
					name = jsonFieldsNameOfSsoDomainEntity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SsoDomainEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SsoDomainEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SsoDomainSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SsoDomainSpec) encodeFields(e *jx.Encoder) {
	{
		if s.SsoDomainPassword.Set {
			e.FieldStart("ssoDomainPassword")
			s.SsoDomainPassword.Encode(e)
		}
	}
	{
		if s.SsoDomainName.Set {
			e.FieldStart("ssoDomainName")
			s.SsoDomainName.Encode(e)
		}
	}
}

var jsonFieldsNameOfSsoDomainSpec = [2]string{
	0: "ssoDomainPassword",
	1: "ssoDomainName",
}

// Decode decodes SsoDomainSpec from json.
func (s *SsoDomainSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SsoDomainSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ssoDomainPassword":
			if err := func() error {
				s.SsoDomainPassword.Reset()
				if err := s.SsoDomainPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssoDomainPassword\"")
			}
		case "ssoDomainName":
			if err := func() error {
				s.SsoDomainName.Reset()
				if err := s.SsoDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssoDomainName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SsoDomainSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SsoDomainSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SsoDomainSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Stage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Stage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("creationTimestamp")
		e.Str(s.CreationTimestamp)
	}
	{
		e.FieldStart("completionTimestamp")
		e.Str(s.CompletionTimestamp)
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfStage = [7]string{
	0: "name",
	1: "type",
	2: "description",
	3: "status",
	4: "creationTimestamp",
	5: "completionTimestamp",
	6: "errors",
}

// Decode decodes Stage from json.
func (s *Stage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Stage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "creationTimestamp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CreationTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "completionTimestamp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CompletionTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTimestamp\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Stage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStage) {
					name = jsonFieldsNameOfStage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Stage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Stage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartBackupBadRequest as json.
func (s *StartBackupBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartBackupBadRequest from json.
func (s *StartBackupBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartBackupBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartBackupBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartBackupBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartBackupBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartBackupInternalServerError as json.
func (s *StartBackupInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartBackupInternalServerError from json.
func (s *StartBackupInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartBackupInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartBackupInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartBackupInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartBackupInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartBringupBadRequest as json.
func (s *StartBringupBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartBringupBadRequest from json.
func (s *StartBringupBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartBringupBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartBringupBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartBringupBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartBringupBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartBringupInternalServerError as json.
func (s *StartBringupInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartBringupInternalServerError from json.
func (s *StartBringupInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartBringupInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartBringupInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartBringupInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartBringupInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartBringupSpecConversionBadRequest as json.
func (s *StartBringupSpecConversionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartBringupSpecConversionBadRequest from json.
func (s *StartBringupSpecConversionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartBringupSpecConversionBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartBringupSpecConversionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartBringupSpecConversionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartBringupSpecConversionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartBringupSpecConversionInternalServerError as json.
func (s *StartBringupSpecConversionInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartBringupSpecConversionInternalServerError from json.
func (s *StartBringupSpecConversionInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartBringupSpecConversionInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartBringupSpecConversionInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartBringupSpecConversionInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartBringupSpecConversionInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartBringupSpecConversionNotFound as json.
func (s *StartBringupSpecConversionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartBringupSpecConversionNotFound from json.
func (s *StartBringupSpecConversionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartBringupSpecConversionNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartBringupSpecConversionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartBringupSpecConversionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartBringupSpecConversionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartBringupSpecConversionNotImplemented as json.
func (s *StartBringupSpecConversionNotImplemented) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartBringupSpecConversionNotImplemented from json.
func (s *StartBringupSpecConversionNotImplemented) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartBringupSpecConversionNotImplemented to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartBringupSpecConversionNotImplemented(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartBringupSpecConversionNotImplemented) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartBringupSpecConversionNotImplemented) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartBundleDownloadByIDBadRequest as json.
func (s *StartBundleDownloadByIDBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartBundleDownloadByIDBadRequest from json.
func (s *StartBundleDownloadByIDBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartBundleDownloadByIDBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartBundleDownloadByIDBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartBundleDownloadByIDBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartBundleDownloadByIDBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartBundleDownloadByIDConflict as json.
func (s *StartBundleDownloadByIDConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartBundleDownloadByIDConflict from json.
func (s *StartBundleDownloadByIDConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartBundleDownloadByIDConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartBundleDownloadByIDConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartBundleDownloadByIDConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartBundleDownloadByIDConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartBundleDownloadByIDInternalServerError as json.
func (s *StartBundleDownloadByIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartBundleDownloadByIDInternalServerError from json.
func (s *StartBundleDownloadByIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartBundleDownloadByIDInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartBundleDownloadByIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartBundleDownloadByIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartBundleDownloadByIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartHealthCheckBadRequest as json.
func (s *StartHealthCheckBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartHealthCheckBadRequest from json.
func (s *StartHealthCheckBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartHealthCheckBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartHealthCheckBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartHealthCheckBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartHealthCheckBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartHealthCheckConflict as json.
func (s *StartHealthCheckConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartHealthCheckConflict from json.
func (s *StartHealthCheckConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartHealthCheckConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartHealthCheckConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartHealthCheckConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartHealthCheckConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartHealthCheckInternalServerError as json.
func (s *StartHealthCheckInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartHealthCheckInternalServerError from json.
func (s *StartHealthCheckInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartHealthCheckInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartHealthCheckInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartHealthCheckInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartHealthCheckInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartHealthCheckUnauthorized as json.
func (s *StartHealthCheckUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartHealthCheckUnauthorized from json.
func (s *StartHealthCheckUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartHealthCheckUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartHealthCheckUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartHealthCheckUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartHealthCheckUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartNsxCriteriaQueryBadRequest as json.
func (s *StartNsxCriteriaQueryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartNsxCriteriaQueryBadRequest from json.
func (s *StartNsxCriteriaQueryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartNsxCriteriaQueryBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartNsxCriteriaQueryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartNsxCriteriaQueryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartNsxCriteriaQueryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartNsxCriteriaQueryInternalServerError as json.
func (s *StartNsxCriteriaQueryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartNsxCriteriaQueryInternalServerError from json.
func (s *StartNsxCriteriaQueryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartNsxCriteriaQueryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartNsxCriteriaQueryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartNsxCriteriaQueryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartNsxCriteriaQueryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartPrecheckBadRequest as json.
func (s *StartPrecheckBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartPrecheckBadRequest from json.
func (s *StartPrecheckBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartPrecheckBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartPrecheckBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartPrecheckBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartPrecheckBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartPrecheckInternalServerError as json.
func (s *StartPrecheckInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartPrecheckInternalServerError from json.
func (s *StartPrecheckInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartPrecheckInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartPrecheckInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartPrecheckInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartPrecheckInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRestoreBadRequest as json.
func (s *StartRestoreBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartRestoreBadRequest from json.
func (s *StartRestoreBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRestoreBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartRestoreBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartRestoreBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRestoreBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRestoreInternalServerError as json.
func (s *StartRestoreInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartRestoreInternalServerError from json.
func (s *StartRestoreInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRestoreInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartRestoreInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartRestoreInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRestoreInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartSupportBundleBadRequest as json.
func (s *StartSupportBundleBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartSupportBundleBadRequest from json.
func (s *StartSupportBundleBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartSupportBundleBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartSupportBundleBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartSupportBundleBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartSupportBundleBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartSupportBundleConflict as json.
func (s *StartSupportBundleConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartSupportBundleConflict from json.
func (s *StartSupportBundleConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartSupportBundleConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartSupportBundleConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartSupportBundleConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartSupportBundleConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartSupportBundleInternalServerError as json.
func (s *StartSupportBundleInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartSupportBundleInternalServerError from json.
func (s *StartSupportBundleInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartSupportBundleInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartSupportBundleInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartSupportBundleInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartSupportBundleInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartSupportBundleUnauthorized as json.
func (s *StartSupportBundleUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartSupportBundleUnauthorized from json.
func (s *StartSupportBundleUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartSupportBundleUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartSupportBundleUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartSupportBundleUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartSupportBundleUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartUpgradePrecheckBadRequest as json.
func (s *StartUpgradePrecheckBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartUpgradePrecheckBadRequest from json.
func (s *StartUpgradePrecheckBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartUpgradePrecheckBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartUpgradePrecheckBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartUpgradePrecheckBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartUpgradePrecheckBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartUpgradePrecheckForbidden as json.
func (s *StartUpgradePrecheckForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartUpgradePrecheckForbidden from json.
func (s *StartUpgradePrecheckForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartUpgradePrecheckForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartUpgradePrecheckForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartUpgradePrecheckForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartUpgradePrecheckForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartUpgradePrecheckInternalServerError as json.
func (s *StartUpgradePrecheckInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartUpgradePrecheckInternalServerError from json.
func (s *StartUpgradePrecheckInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartUpgradePrecheckInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartUpgradePrecheckInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartUpgradePrecheckInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartUpgradePrecheckInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Storage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Storage) encodeFields(e *jx.Encoder) {
	{
		if s.TotalCapacityMB.Set {
			e.FieldStart("totalCapacityMB")
			s.TotalCapacityMB.Encode(e)
		}
	}
	{
		if s.UsedCapacityMB.Set {
			e.FieldStart("usedCapacityMB")
			s.UsedCapacityMB.Encode(e)
		}
	}
	{
		if s.Disks != nil {
			e.FieldStart("disks")
			e.ArrStart()
			for _, elem := range s.Disks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfStorage = [3]string{
	0: "totalCapacityMB",
	1: "usedCapacityMB",
	2: "disks",
}

// Decode decodes Storage from json.
func (s *Storage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Storage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalCapacityMB":
			if err := func() error {
				s.TotalCapacityMB.Reset()
				if err := s.TotalCapacityMB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalCapacityMB\"")
			}
		case "usedCapacityMB":
			if err := func() error {
				s.UsedCapacityMB.Reset()
				if err := s.UsedCapacityMB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedCapacityMB\"")
			}
		case "disks":
			if err := func() error {
				s.Disks = make([]Disk, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Disk
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Disks = append(s.Disks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Storage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Storage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Storage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StorageContainer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StorageContainer) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("protocolType")
		e.Str(s.ProtocolType)
	}
	{
		if s.ClusterId.Set {
			e.FieldStart("clusterId")
			s.ClusterId.Encode(e)
		}
	}
}

var jsonFieldsNameOfStorageContainer = [4]string{
	0: "id",
	1: "name",
	2: "protocolType",
	3: "clusterId",
}

// Decode decodes StorageContainer from json.
func (s *StorageContainer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StorageContainer to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "protocolType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ProtocolType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocolType\"")
			}
		case "clusterId":
			if err := func() error {
				s.ClusterId.Reset()
				if err := s.ClusterId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StorageContainer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStorageContainer) {
					name = jsonFieldsNameOfStorageContainer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StorageContainer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StorageContainer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StorageContainerUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StorageContainerUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfStorageContainerUpdateSpec = [1]string{
	0: "name",
}

// Decode decodes StorageContainerUpdateSpec from json.
func (s *StorageContainerUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StorageContainerUpdateSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StorageContainerUpdateSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStorageContainerUpdateSpec) {
					name = jsonFieldsNameOfStorageContainerUpdateSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StorageContainerUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StorageContainerUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StorageInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StorageInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Used.Set {
			e.FieldStart("used")
			s.Used.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfStorageInfo = [2]string{
	0: "used",
	1: "total",
}

// Decode decodes StorageInfo from json.
func (s *StorageInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StorageInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "used":
			if err := func() error {
				s.Used.Reset()
				if err := s.Used.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StorageInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StorageInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StorageInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StretchClusterNetworkProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StretchClusterNetworkProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("nsxtHostSwitchConfigs")
		e.ArrStart()
		for _, elem := range s.NsxtHostSwitchConfigs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfStretchClusterNetworkProfile = [3]string{
	0: "name",
	1: "description",
	2: "nsxtHostSwitchConfigs",
}

// Decode decodes StretchClusterNetworkProfile from json.
func (s *StretchClusterNetworkProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StretchClusterNetworkProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "nsxtHostSwitchConfigs":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.NsxtHostSwitchConfigs = make([]NsxtHostSwitchConfig, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtHostSwitchConfig
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxtHostSwitchConfigs = append(s.NsxtHostSwitchConfigs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtHostSwitchConfigs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StretchClusterNetworkProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStretchClusterNetworkProfile) {
					name = jsonFieldsNameOfStretchClusterNetworkProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StretchClusterNetworkProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StretchClusterNetworkProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubTask) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("creationTimestamp")
		e.Str(s.CreationTimestamp)
	}
	{
		e.FieldStart("completionTimestamp")
		e.Str(s.CompletionTimestamp)
	}
	{
		if s.Stages != nil {
			e.FieldStart("stages")
			e.ArrStart()
			for _, elem := range s.Stages {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SubTasks != nil {
			e.FieldStart("subTasks")
			e.ArrStart()
			for _, elem := range s.SubTasks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubTask = [10]string{
	0: "name",
	1: "type",
	2: "description",
	3: "status",
	4: "creationTimestamp",
	5: "completionTimestamp",
	6: "stages",
	7: "errors",
	8: "resources",
	9: "subTasks",
}

// Decode decodes SubTask from json.
func (s *SubTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubTask to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "creationTimestamp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CreationTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "completionTimestamp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CompletionTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTimestamp\"")
			}
		case "stages":
			if err := func() error {
				s.Stages = make([]Stage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Stage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Stages = append(s.Stages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stages\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]Resource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Resource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "subTasks":
			if err := func() error {
				s.SubTasks = make([]SubTask, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubTask
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SubTasks = append(s.SubTasks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subTasks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubTask")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubTask) {
					name = jsonFieldsNameOfSubTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SupportBundle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SupportBundle) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.CreationTimestamp.Set {
			e.FieldStart("creationTimestamp")
			s.CreationTimestamp.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.BundleAvailable.Set {
			e.FieldStart("bundleAvailable")
			s.BundleAvailable.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CompletionTimestamp.Set {
			e.FieldStart("completionTimestamp")
			s.CompletionTimestamp.Encode(e)
		}
	}
	{
		if s.BundleName.Set {
			e.FieldStart("bundleName")
			s.BundleName.Encode(e)
		}
	}
}

var jsonFieldsNameOfSupportBundle = [7]string{
	0: "status",
	1: "creationTimestamp",
	2: "description",
	3: "bundleAvailable",
	4: "id",
	5: "completionTimestamp",
	6: "bundleName",
}

// Decode decodes SupportBundle from json.
func (s *SupportBundle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SupportBundle to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "creationTimestamp":
			if err := func() error {
				s.CreationTimestamp.Reset()
				if err := s.CreationTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "bundleAvailable":
			if err := func() error {
				s.BundleAvailable.Reset()
				if err := s.BundleAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleAvailable\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "completionTimestamp":
			if err := func() error {
				s.CompletionTimestamp.Reset()
				if err := s.CompletionTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTimestamp\"")
			}
		case "bundleName":
			if err := func() error {
				s.BundleName.Reset()
				if err := s.BundleName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SupportBundle")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SupportBundle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SupportBundle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SupportBundleConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SupportBundleConfig) encodeFields(e *jx.Encoder) {
	{
		if s.SkipKnownHostCheck.Set {
			e.FieldStart("skipKnownHostCheck")
			s.SkipKnownHostCheck.Encode(e)
		}
	}
	{
		if s.Force.Set {
			e.FieldStart("force")
			s.Force.Encode(e)
		}
	}
}

var jsonFieldsNameOfSupportBundleConfig = [2]string{
	0: "skipKnownHostCheck",
	1: "force",
}

// Decode decodes SupportBundleConfig from json.
func (s *SupportBundleConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SupportBundleConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "skipKnownHostCheck":
			if err := func() error {
				s.SkipKnownHostCheck.Reset()
				if err := s.SkipKnownHostCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skipKnownHostCheck\"")
			}
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SupportBundleConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SupportBundleConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SupportBundleConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SupportBundleIncludeItems) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SupportBundleIncludeItems) encodeFields(e *jx.Encoder) {
	{
		if s.SummaryReport.Set {
			e.FieldStart("summaryReport")
			s.SummaryReport.Encode(e)
		}
	}
	{
		if s.HealthCheck.Set {
			e.FieldStart("healthCheck")
			s.HealthCheck.Encode(e)
		}
	}
}

var jsonFieldsNameOfSupportBundleIncludeItems = [2]string{
	0: "summaryReport",
	1: "healthCheck",
}

// Decode decodes SupportBundleIncludeItems from json.
func (s *SupportBundleIncludeItems) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SupportBundleIncludeItems to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "summaryReport":
			if err := func() error {
				s.SummaryReport.Reset()
				if err := s.SummaryReport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summaryReport\"")
			}
		case "healthCheck":
			if err := func() error {
				s.HealthCheck.Reset()
				if err := s.HealthCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthCheck\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SupportBundleIncludeItems")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SupportBundleIncludeItems) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SupportBundleIncludeItems) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SupportBundleOption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SupportBundleOption) encodeFields(e *jx.Encoder) {
	{
		if s.Config.Set {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
	{
		if s.Include.Set {
			e.FieldStart("include")
			s.Include.Encode(e)
		}
	}
}

var jsonFieldsNameOfSupportBundleOption = [2]string{
	0: "config",
	1: "include",
}

// Decode decodes SupportBundleOption from json.
func (s *SupportBundleOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SupportBundleOption to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "include":
			if err := func() error {
				s.Include.Reset()
				if err := s.Include.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SupportBundleOption")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SupportBundleOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SupportBundleOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SupportBundleScope) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SupportBundleScope) encodeFields(e *jx.Encoder) {
	{
		if s.IncludeFreeHosts.Set {
			e.FieldStart("includeFreeHosts")
			s.IncludeFreeHosts.Encode(e)
		}
	}
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSupportBundleScope = [2]string{
	0: "includeFreeHosts",
	1: "domains",
}

// Decode decodes SupportBundleScope from json.
func (s *SupportBundleScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SupportBundleScope to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "includeFreeHosts":
			if err := func() error {
				s.IncludeFreeHosts.Reset()
				if err := s.IncludeFreeHosts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeFreeHosts\"")
			}
		case "domains":
			if err := func() error {
				s.Domains = make([]Domains, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Domains
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SupportBundleScope")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SupportBundleScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SupportBundleScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SupportBundleSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SupportBundleSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Options.Set {
			e.FieldStart("options")
			s.Options.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
	{
		if s.Logs.Set {
			e.FieldStart("logs")
			s.Logs.Encode(e)
		}
	}
}

var jsonFieldsNameOfSupportBundleSpec = [3]string{
	0: "options",
	1: "scope",
	2: "logs",
}

// Decode decodes SupportBundleSpec from json.
func (s *SupportBundleSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SupportBundleSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "options":
			if err := func() error {
				s.Options.Reset()
				if err := s.Options.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "logs":
			if err := func() error {
				s.Logs.Reset()
				if err := s.Logs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SupportBundleSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SupportBundleSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SupportBundleSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SyncClientTokenInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SyncClientTokenInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("expireIn")
		e.Int64(s.ExpireIn)
	}
	{
		e.FieldStart("expireAt")
		e.Str(s.ExpireAt)
	}
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("scimUrl")
		e.Str(s.ScimUrl)
	}
}

var jsonFieldsNameOfSyncClientTokenInfo = [4]string{
	0: "expireIn",
	1: "expireAt",
	2: "token",
	3: "scimUrl",
}

// Decode decodes SyncClientTokenInfo from json.
func (s *SyncClientTokenInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SyncClientTokenInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expireIn":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ExpireIn = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireIn\"")
			}
		case "expireAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ExpireAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "scimUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ScimUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scimUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SyncClientTokenInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSyncClientTokenInfo) {
					name = jsonFieldsNameOfSyncClientTokenInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SyncClientTokenInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SyncClientTokenInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *System) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *System) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.MaxAllowedDomainsInSubscription.Set {
			e.FieldStart("maxAllowedDomainsInSubscription")
			s.MaxAllowedDomainsInSubscription.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystem = [2]string{
	0: "id",
	1: "maxAllowedDomainsInSubscription",
}

// Decode decodes System from json.
func (s *System) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode System to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "maxAllowedDomainsInSubscription":
			if err := func() error {
				s.MaxAllowedDomainsInSubscription.Reset()
				if err := s.MaxAllowedDomainsInSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxAllowedDomainsInSubscription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode System")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *System) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *System) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("maxAllowedDomainsInSubscription")
		e.Int32(s.MaxAllowedDomainsInSubscription)
	}
}

var jsonFieldsNameOfSystemUpdateSpec = [1]string{
	0: "maxAllowedDomainsInSubscription",
}

// Decode decodes SystemUpdateSpec from json.
func (s *SystemUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemUpdateSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxAllowedDomainsInSubscription":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MaxAllowedDomainsInSubscription = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxAllowedDomainsInSubscription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemUpdateSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemUpdateSpec) {
					name = jsonFieldsNameOfSystemUpdateSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Tag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Tag) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.CategoryId.Set {
			e.FieldStart("categoryId")
			s.CategoryId.Encode(e)
		}
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("categoryName")
			s.CategoryName.Encode(e)
		}
	}
}

var jsonFieldsNameOfTag = [4]string{
	0: "id",
	1: "name",
	2: "categoryId",
	3: "categoryName",
}

// Decode decodes Tag from json.
func (s *Tag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tag to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "categoryId":
			if err := func() error {
				s.CategoryId.Reset()
				if err := s.CategoryId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categoryId\"")
			}
		case "categoryName":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categoryName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Tag")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Tag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagAssignmentResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagAssignmentResult) encodeFields(e *jx.Encoder) {
	{
		if s.Success.Set {
			e.FieldStart("success")
			s.Success.Encode(e)
		}
	}
	{
		if s.DefaultErrorMessages != nil {
			e.FieldStart("defaultErrorMessages")
			e.ArrStart()
			for _, elem := range s.DefaultErrorMessages {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTagAssignmentResult = [2]string{
	0: "success",
	1: "defaultErrorMessages",
}

// Decode decodes TagAssignmentResult from json.
func (s *TagAssignmentResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagAssignmentResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "defaultErrorMessages":
			if err := func() error {
				s.DefaultErrorMessages = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DefaultErrorMessages = append(s.DefaultErrorMessages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultErrorMessages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagAssignmentResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagAssignmentResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagAssignmentResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagManagerModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagManagerModel) encodeFields(e *jx.Encoder) {
	{
		if s.TagManagerUrl.Set {
			e.FieldStart("tagManagerUrl")
			s.TagManagerUrl.Encode(e)
		}
	}
}

var jsonFieldsNameOfTagManagerModel = [1]string{
	0: "tagManagerUrl",
}

// Decode decodes TagManagerModel from json.
func (s *TagManagerModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagManagerModel to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tagManagerUrl":
			if err := func() error {
				s.TagManagerUrl.Reset()
				if err := s.TagManagerUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagManagerUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagManagerModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagManagerModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagManagerModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaggedResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaggedResource) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfTaggedResource = [2]string{
	0: "id",
	1: "type",
}

// Decode decodes TaggedResource from json.
func (s *TaggedResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaggedResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaggedResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaggedResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaggedResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagsForResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagsForResource) encodeFields(e *jx.Encoder) {
	{
		if s.Resource.Set {
			e.FieldStart("resource")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTagsForResource = [2]string{
	0: "resource",
	1: "tags",
}

// Decode decodes TagsForResource from json.
func (s *TagsForResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagsForResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagsForResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagsForResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagsForResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagsSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagsSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tagIds")
		e.ArrStart()
		for _, elem := range s.TagIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTagsSpec = [1]string{
	0: "tagIds",
}

// Decode decodes TagsSpec from json.
func (s *TagsSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagsSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tagIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.TagIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TagIds = append(s.TagIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagsSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagsSpec) {
					name = jsonFieldsNameOfTagsSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagsSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagsSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TargetProductVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TargetProductVersion) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("productType")
		e.Str(s.ProductType)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfTargetProductVersion = [2]string{
	0: "productType",
	1: "version",
}

// Decode decodes TargetProductVersion from json.
func (s *TargetProductVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TargetProductVersion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "productType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ProductType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productType\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TargetProductVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTargetProductVersion) {
					name = jsonFieldsNameOfTargetProductVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TargetProductVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TargetProductVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Task) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Task) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.LocalizableDescriptionPack.Set {
			e.FieldStart("localizableDescriptionPack")
			s.LocalizableDescriptionPack.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("creationTimestamp")
		e.Str(s.CreationTimestamp)
	}
	{
		if s.CompletionTimestamp.Set {
			e.FieldStart("completionTimestamp")
			s.CompletionTimestamp.Encode(e)
		}
	}
	{
		if s.SubTasks != nil {
			e.FieldStart("subTasks")
			e.ArrStart()
			for _, elem := range s.SubTasks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResolutionStatus.Set {
			e.FieldStart("resolutionStatus")
			s.ResolutionStatus.Encode(e)
		}
	}
	{
		if s.IsCancellable.Set {
			e.FieldStart("isCancellable")
			s.IsCancellable.Encode(e)
		}
	}
	{
		if s.IsRetryable.Set {
			e.FieldStart("isRetryable")
			s.IsRetryable.Encode(e)
		}
	}
}

var jsonFieldsNameOfTask = [13]string{
	0:  "id",
	1:  "name",
	2:  "localizableDescriptionPack",
	3:  "type",
	4:  "status",
	5:  "creationTimestamp",
	6:  "completionTimestamp",
	7:  "subTasks",
	8:  "errors",
	9:  "resources",
	10: "resolutionStatus",
	11: "isCancellable",
	12: "isRetryable",
}

// Decode decodes Task from json.
func (s *Task) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Task to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "localizableDescriptionPack":
			if err := func() error {
				s.LocalizableDescriptionPack.Reset()
				if err := s.LocalizableDescriptionPack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localizableDescriptionPack\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "creationTimestamp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreationTimestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "completionTimestamp":
			if err := func() error {
				s.CompletionTimestamp.Reset()
				if err := s.CompletionTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTimestamp\"")
			}
		case "subTasks":
			if err := func() error {
				s.SubTasks = make([]SubTask, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubTask
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SubTasks = append(s.SubTasks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subTasks\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]Resource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Resource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "resolutionStatus":
			if err := func() error {
				s.ResolutionStatus.Reset()
				if err := s.ResolutionStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolutionStatus\"")
			}
		case "isCancellable":
			if err := func() error {
				s.IsCancellable.Reset()
				if err := s.IsCancellable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isCancellable\"")
			}
		case "isRetryable":
			if err := func() error {
				s.IsRetryable.Reset()
				if err := s.IsRetryable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isRetryable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Task")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTask) {
					name = jsonFieldsNameOfTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Task) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Task) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamingSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamingSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("policy")
		e.Str(s.Policy)
	}
	{
		e.FieldStart("activeUplinks")
		e.ArrStart()
		for _, elem := range s.ActiveUplinks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.StandByUplinks != nil {
			e.FieldStart("standByUplinks")
			e.ArrStart()
			for _, elem := range s.StandByUplinks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTeamingSpec = [3]string{
	0: "policy",
	1: "activeUplinks",
	2: "standByUplinks",
}

// Decode decodes TeamingSpec from json.
func (s *TeamingSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamingSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "policy":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Policy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policy\"")
			}
		case "activeUplinks":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveUplinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ActiveUplinks = append(s.ActiveUplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUplinks\"")
			}
		case "standByUplinks":
			if err := func() error {
				s.StandByUplinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StandByUplinks = append(s.StandByUplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standByUplinks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamingSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamingSpec) {
					name = jsonFieldsNameOfTeamingSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamingSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamingSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TemporaryNetwork) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TemporaryNetwork) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ipAddress")
		e.Str(s.IpAddress)
	}
	{
		e.FieldStart("subnetMask")
		e.Str(s.SubnetMask)
	}
	{
		e.FieldStart("gateway")
		e.Str(s.Gateway)
	}
}

var jsonFieldsNameOfTemporaryNetwork = [3]string{
	0: "ipAddress",
	1: "subnetMask",
	2: "gateway",
}

// Decode decodes TemporaryNetwork from json.
func (s *TemporaryNetwork) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TemporaryNetwork to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAddress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IpAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "subnetMask":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SubnetMask = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subnetMask\"")
			}
		case "gateway":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Gateway = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TemporaryNetwork")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTemporaryNetwork) {
					name = jsonFieldsNameOfTemporaryNetwork[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TemporaryNetwork) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TemporaryNetwork) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TokenCreationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TokenCreationSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.ApiKey.Set {
			e.FieldStart("apiKey")
			s.ApiKey.Encode(e)
		}
	}
	{
		if s.IdToken.Set {
			e.FieldStart("idToken")
			s.IdToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfTokenCreationSpec = [4]string{
	0: "username",
	1: "password",
	2: "apiKey",
	3: "idToken",
}

// Decode decodes TokenCreationSpec from json.
func (s *TokenCreationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenCreationSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "apiKey":
			if err := func() error {
				s.ApiKey.Reset()
				if err := s.ApiKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKey\"")
			}
		case "idToken":
			if err := func() error {
				s.IdToken.Reset()
				if err := s.IdToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"idToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenCreationSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TokenCreationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenCreationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TokenPair) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TokenPair) encodeFields(e *jx.Encoder) {
	{
		if s.AccessToken.Set {
			e.FieldStart("accessToken")
			s.AccessToken.Encode(e)
		}
	}
	{
		if s.RefreshToken.Set {
			e.FieldStart("refreshToken")
			s.RefreshToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfTokenPair = [2]string{
	0: "accessToken",
	1: "refreshToken",
}

// Decode decodes TokenPair from json.
func (s *TokenPair) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenPair to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			if err := func() error {
				s.AccessToken.Reset()
				if err := s.AccessToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		case "refreshToken":
			if err := func() error {
				s.RefreshToken.Reset()
				if err := s.RefreshToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refreshToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenPair")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TokenPair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenPair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransportZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransportZone) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("transportType")
		e.Str(s.TransportType)
	}
}

var jsonFieldsNameOfTransportZone = [2]string{
	0: "name",
	1: "transportType",
}

// Decode decodes TransportZone from json.
func (s *TransportZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransportZone to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "transportType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TransportType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transportType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransportZone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransportZone) {
					name = jsonFieldsNameOfTransportZone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransportZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransportZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TriggerCheckRunBadRequest as json.
func (s *TriggerCheckRunBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes TriggerCheckRunBadRequest from json.
func (s *TriggerCheckRunBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TriggerCheckRunBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TriggerCheckRunBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TriggerCheckRunBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TriggerCheckRunBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TriggerCheckRunInternalServerError as json.
func (s *TriggerCheckRunInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes TriggerCheckRunInternalServerError from json.
func (s *TriggerCheckRunInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TriggerCheckRunInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TriggerCheckRunInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TriggerCheckRunInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TriggerCheckRunInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TriggerPartialRetryOfCheckRunBadRequest as json.
func (s *TriggerPartialRetryOfCheckRunBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes TriggerPartialRetryOfCheckRunBadRequest from json.
func (s *TriggerPartialRetryOfCheckRunBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TriggerPartialRetryOfCheckRunBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TriggerPartialRetryOfCheckRunBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TriggerPartialRetryOfCheckRunBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TriggerPartialRetryOfCheckRunBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TriggerPartialRetryOfCheckRunInternalServerError as json.
func (s *TriggerPartialRetryOfCheckRunInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes TriggerPartialRetryOfCheckRunInternalServerError from json.
func (s *TriggerPartialRetryOfCheckRunInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TriggerPartialRetryOfCheckRunInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TriggerPartialRetryOfCheckRunInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TriggerPartialRetryOfCheckRunInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TriggerPartialRetryOfCheckRunInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrustedCertificate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrustedCertificate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("alias")
		e.Str(s.Alias)
	}
	{
		e.FieldStart("certificate")
		e.Str(s.Certificate)
	}
}

var jsonFieldsNameOfTrustedCertificate = [2]string{
	0: "alias",
	1: "certificate",
}

// Decode decodes TrustedCertificate from json.
func (s *TrustedCertificate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrustedCertificate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alias":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Alias = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		case "certificate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Certificate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrustedCertificate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTrustedCertificate) {
					name = jsonFieldsNameOfTrustedCertificate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrustedCertificate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrustedCertificate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnmanagedResourceCredential) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnmanagedResourceCredential) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("credentialType")
		e.Str(s.CredentialType)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnmanagedResourceCredential = [3]string{
	0: "credentialType",
	1: "username",
	2: "password",
}

// Decode decodes UnmanagedResourceCredential from json.
func (s *UnmanagedResourceCredential) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnmanagedResourceCredential to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "credentialType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CredentialType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentialType\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnmanagedResourceCredential")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnmanagedResourceCredential) {
					name = jsonFieldsNameOfUnmanagedResourceCredential[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnmanagedResourceCredential) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnmanagedResourceCredential) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateBackupConfigurationBadRequest as json.
func (s *UpdateBackupConfigurationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateBackupConfigurationBadRequest from json.
func (s *UpdateBackupConfigurationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateBackupConfigurationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateBackupConfigurationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateBackupConfigurationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateBackupConfigurationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateBackupConfigurationInternalServerError as json.
func (s *UpdateBackupConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateBackupConfigurationInternalServerError from json.
func (s *UpdateBackupConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateBackupConfigurationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateBackupConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateBackupConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateBackupConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateBundleCompatibilitySetsBadRequest as json.
func (s *UpdateBundleCompatibilitySetsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateBundleCompatibilitySetsBadRequest from json.
func (s *UpdateBundleCompatibilitySetsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateBundleCompatibilitySetsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateBundleCompatibilitySetsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateBundleCompatibilitySetsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateBundleCompatibilitySetsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateBundleCompatibilitySetsConflict as json.
func (s *UpdateBundleCompatibilitySetsConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateBundleCompatibilitySetsConflict from json.
func (s *UpdateBundleCompatibilitySetsConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateBundleCompatibilitySetsConflict to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateBundleCompatibilitySetsConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateBundleCompatibilitySetsConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateBundleCompatibilitySetsConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateBundleCompatibilitySetsInternalServerError as json.
func (s *UpdateBundleCompatibilitySetsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateBundleCompatibilitySetsInternalServerError from json.
func (s *UpdateBundleCompatibilitySetsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateBundleCompatibilitySetsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateBundleCompatibilitySetsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateBundleCompatibilitySetsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateBundleCompatibilitySetsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateClusterBadRequest as json.
func (s *UpdateClusterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateClusterBadRequest from json.
func (s *UpdateClusterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateClusterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateClusterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateClusterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateClusterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateClusterInternalServerError as json.
func (s *UpdateClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateClusterInternalServerError from json.
func (s *UpdateClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateClusterNotFound as json.
func (s *UpdateClusterNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateClusterNotFound from json.
func (s *UpdateClusterNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateClusterNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateClusterNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateClusterNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateClusterNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDepotSettingsBadRequest as json.
func (s *UpdateDepotSettingsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDepotSettingsBadRequest from json.
func (s *UpdateDepotSettingsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDepotSettingsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDepotSettingsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDepotSettingsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDepotSettingsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDepotSettingsInternalServerError as json.
func (s *UpdateDepotSettingsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDepotSettingsInternalServerError from json.
func (s *UpdateDepotSettingsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDepotSettingsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDepotSettingsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDepotSettingsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDepotSettingsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDomainAccepted as json.
func (s *UpdateDomainAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*Task)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDomainAccepted from json.
func (s *UpdateDomainAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDomainAccepted to nil")
	}
	var unwrapped Task
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDomainAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDomainAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDomainAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDomainBadRequest as json.
func (s *UpdateDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDomainBadRequest from json.
func (s *UpdateDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDomainBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDomainInternalServerError as json.
func (s *UpdateDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDomainInternalServerError from json.
func (s *UpdateDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDomainNotFound as json.
func (s *UpdateDomainNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDomainNotFound from json.
func (s *UpdateDomainNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDomainNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDomainNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDomainNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDomainNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDomainOK as json.
func (s *UpdateDomainOK) Encode(e *jx.Encoder) {
	unwrapped := (*Task)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDomainOK from json.
func (s *UpdateDomainOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDomainOK to nil")
	}
	var unwrapped Task
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDomainOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDomainOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDomainOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEdgeClusterBadRequest as json.
func (s *UpdateEdgeClusterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateEdgeClusterBadRequest from json.
func (s *UpdateEdgeClusterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEdgeClusterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateEdgeClusterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEdgeClusterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEdgeClusterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEdgeClusterInternalServerError as json.
func (s *UpdateEdgeClusterInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateEdgeClusterInternalServerError from json.
func (s *UpdateEdgeClusterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEdgeClusterInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateEdgeClusterInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEdgeClusterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEdgeClusterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateEdgeClusterNotImplemented as json.
func (s *UpdateEdgeClusterNotImplemented) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateEdgeClusterNotImplemented from json.
func (s *UpdateEdgeClusterNotImplemented) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateEdgeClusterNotImplemented to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateEdgeClusterNotImplemented(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateEdgeClusterNotImplemented) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateEdgeClusterNotImplemented) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLicenseKeyBadRequest as json.
func (s *UpdateLicenseKeyBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLicenseKeyBadRequest from json.
func (s *UpdateLicenseKeyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLicenseKeyBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLicenseKeyBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLicenseKeyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLicenseKeyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLicenseKeyInternalServerError as json.
func (s *UpdateLicenseKeyInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLicenseKeyInternalServerError from json.
func (s *UpdateLicenseKeyInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLicenseKeyInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLicenseKeyInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLicenseKeyInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLicenseKeyInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLicenseKeyNotFound as json.
func (s *UpdateLicenseKeyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLicenseKeyNotFound from json.
func (s *UpdateLicenseKeyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLicenseKeyNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLicenseKeyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLicenseKeyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLicenseKeyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNetworkPoolInternalServerError as json.
func (s *UpdateNetworkPoolInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateNetworkPoolInternalServerError from json.
func (s *UpdateNetworkPoolInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNetworkPoolInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateNetworkPoolInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNetworkPoolInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNetworkPoolInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNetworkPoolNotFound as json.
func (s *UpdateNetworkPoolNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateNetworkPoolNotFound from json.
func (s *UpdateNetworkPoolNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNetworkPoolNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateNetworkPoolNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNetworkPoolNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNetworkPoolNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOrRotatePasswordsBadRequest as json.
func (s *UpdateOrRotatePasswordsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateOrRotatePasswordsBadRequest from json.
func (s *UpdateOrRotatePasswordsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOrRotatePasswordsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateOrRotatePasswordsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateOrRotatePasswordsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOrRotatePasswordsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOrRotatePasswordsForbidden as json.
func (s *UpdateOrRotatePasswordsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateOrRotatePasswordsForbidden from json.
func (s *UpdateOrRotatePasswordsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOrRotatePasswordsForbidden to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateOrRotatePasswordsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateOrRotatePasswordsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOrRotatePasswordsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOrRotatePasswordsInternalServerError as json.
func (s *UpdateOrRotatePasswordsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateOrRotatePasswordsInternalServerError from json.
func (s *UpdateOrRotatePasswordsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOrRotatePasswordsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateOrRotatePasswordsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateOrRotatePasswordsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOrRotatePasswordsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOrRotatePasswordsUnauthorized as json.
func (s *UpdateOrRotatePasswordsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateOrRotatePasswordsUnauthorized from json.
func (s *UpdateOrRotatePasswordsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOrRotatePasswordsUnauthorized to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateOrRotatePasswordsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateOrRotatePasswordsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOrRotatePasswordsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateReleaseByDomainIDInternalServerError as json.
func (s *UpdateReleaseByDomainIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateReleaseByDomainIDInternalServerError from json.
func (s *UpdateReleaseByDomainIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateReleaseByDomainIDInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateReleaseByDomainIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateReleaseByDomainIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateReleaseByDomainIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateReleaseByDomainIDNotFound as json.
func (s *UpdateReleaseByDomainIDNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateReleaseByDomainIDNotFound from json.
func (s *UpdateReleaseByDomainIDNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateReleaseByDomainIDNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateReleaseByDomainIDNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateReleaseByDomainIDNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateReleaseByDomainIDNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateResourcesFunctionalities1BadRequest as json.
func (s *UpdateResourcesFunctionalities1BadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateResourcesFunctionalities1BadRequest from json.
func (s *UpdateResourcesFunctionalities1BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateResourcesFunctionalities1BadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateResourcesFunctionalities1BadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateResourcesFunctionalities1BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateResourcesFunctionalities1BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateResourcesFunctionalities1InternalServerError as json.
func (s *UpdateResourcesFunctionalities1InternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateResourcesFunctionalities1InternalServerError from json.
func (s *UpdateResourcesFunctionalities1InternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateResourcesFunctionalities1InternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateResourcesFunctionalities1InternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateResourcesFunctionalities1InternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateResourcesFunctionalities1InternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateResourcesFunctionalitiesBadRequest as json.
func (s *UpdateResourcesFunctionalitiesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateResourcesFunctionalitiesBadRequest from json.
func (s *UpdateResourcesFunctionalitiesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateResourcesFunctionalitiesBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateResourcesFunctionalitiesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateResourcesFunctionalitiesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateResourcesFunctionalitiesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateResourcesFunctionalitiesInternalServerError as json.
func (s *UpdateResourcesFunctionalitiesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateResourcesFunctionalitiesInternalServerError from json.
func (s *UpdateResourcesFunctionalitiesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateResourcesFunctionalitiesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateResourcesFunctionalitiesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateResourcesFunctionalitiesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateResourcesFunctionalitiesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSystemConfigurationBadRequest as json.
func (s *UpdateSystemConfigurationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateSystemConfigurationBadRequest from json.
func (s *UpdateSystemConfigurationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSystemConfigurationBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateSystemConfigurationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSystemConfigurationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSystemConfigurationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSystemConfigurationInternalServerError as json.
func (s *UpdateSystemConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateSystemConfigurationInternalServerError from json.
func (s *UpdateSystemConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSystemConfigurationInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateSystemConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSystemConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSystemConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUpgradeScheduleInternalServerError as json.
func (s *UpdateUpgradeScheduleInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUpgradeScheduleInternalServerError from json.
func (s *UpdateUpgradeScheduleInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUpgradeScheduleInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUpgradeScheduleInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUpgradeScheduleInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUpgradeScheduleInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUpgradeScheduleNotFound as json.
func (s *UpdateUpgradeScheduleNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUpgradeScheduleNotFound from json.
func (s *UpdateUpgradeScheduleNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUpgradeScheduleNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUpgradeScheduleNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUpgradeScheduleNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUpgradeScheduleNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVasaProviderBadRequest as json.
func (s *UpdateVasaProviderBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVasaProviderBadRequest from json.
func (s *UpdateVasaProviderBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVasaProviderBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVasaProviderBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVasaProviderBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVasaProviderBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVasaProviderInternalServerError as json.
func (s *UpdateVasaProviderInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVasaProviderInternalServerError from json.
func (s *UpdateVasaProviderInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVasaProviderInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVasaProviderInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVasaProviderInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVasaProviderInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVasaProviderNotFound as json.
func (s *UpdateVasaProviderNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVasaProviderNotFound from json.
func (s *UpdateVasaProviderNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVasaProviderNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVasaProviderNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVasaProviderNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVasaProviderNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVasaProviderStorageContainerBadRequest as json.
func (s *UpdateVasaProviderStorageContainerBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVasaProviderStorageContainerBadRequest from json.
func (s *UpdateVasaProviderStorageContainerBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVasaProviderStorageContainerBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVasaProviderStorageContainerBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVasaProviderStorageContainerBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVasaProviderStorageContainerBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVasaProviderStorageContainerInternalServerError as json.
func (s *UpdateVasaProviderStorageContainerInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVasaProviderStorageContainerInternalServerError from json.
func (s *UpdateVasaProviderStorageContainerInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVasaProviderStorageContainerInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVasaProviderStorageContainerInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVasaProviderStorageContainerInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVasaProviderStorageContainerInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVasaProviderStorageContainerNotFound as json.
func (s *UpdateVasaProviderStorageContainerNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVasaProviderStorageContainerNotFound from json.
func (s *UpdateVasaProviderStorageContainerNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVasaProviderStorageContainerNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVasaProviderStorageContainerNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVasaProviderStorageContainerNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVasaProviderStorageContainerNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVasaProviderUserBadRequest as json.
func (s *UpdateVasaProviderUserBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVasaProviderUserBadRequest from json.
func (s *UpdateVasaProviderUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVasaProviderUserBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVasaProviderUserBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVasaProviderUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVasaProviderUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVasaProviderUserInternalServerError as json.
func (s *UpdateVasaProviderUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVasaProviderUserInternalServerError from json.
func (s *UpdateVasaProviderUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVasaProviderUserInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVasaProviderUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVasaProviderUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVasaProviderUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVasaProviderUserNotFound as json.
func (s *UpdateVasaProviderUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVasaProviderUserNotFound from json.
func (s *UpdateVasaProviderUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVasaProviderUserNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVasaProviderUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVasaProviderUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVasaProviderUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVersionAliasConfigurationBadRequest as json.
func (s *UpdateVersionAliasConfigurationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVersionAliasConfigurationBadRequest from json.
func (s *UpdateVersionAliasConfigurationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVersionAliasConfigurationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVersionAliasConfigurationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVersionAliasConfigurationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVersionAliasConfigurationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVersionAliasConfigurationInternalServerError as json.
func (s *UpdateVersionAliasConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVersionAliasConfigurationInternalServerError from json.
func (s *UpdateVersionAliasConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVersionAliasConfigurationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVersionAliasConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVersionAliasConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVersionAliasConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVersionAliasConfigurationsBadRequest as json.
func (s *UpdateVersionAliasConfigurationsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVersionAliasConfigurationsBadRequest from json.
func (s *UpdateVersionAliasConfigurationsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVersionAliasConfigurationsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVersionAliasConfigurationsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVersionAliasConfigurationsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVersionAliasConfigurationsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVersionAliasConfigurationsInternalServerError as json.
func (s *UpdateVersionAliasConfigurationsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVersionAliasConfigurationsInternalServerError from json.
func (s *UpdateVersionAliasConfigurationsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVersionAliasConfigurationsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVersionAliasConfigurationsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVersionAliasConfigurationsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVersionAliasConfigurationsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVrslcmVersionByIdInInventoryBadRequest as json.
func (s *UpdateVrslcmVersionByIdInInventoryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVrslcmVersionByIdInInventoryBadRequest from json.
func (s *UpdateVrslcmVersionByIdInInventoryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVrslcmVersionByIdInInventoryBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVrslcmVersionByIdInInventoryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVrslcmVersionByIdInInventoryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVrslcmVersionByIdInInventoryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVrslcmVersionByIdInInventoryInternalServerError as json.
func (s *UpdateVrslcmVersionByIdInInventoryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVrslcmVersionByIdInInventoryInternalServerError from json.
func (s *UpdateVrslcmVersionByIdInInventoryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVrslcmVersionByIdInInventoryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVrslcmVersionByIdInInventoryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVrslcmVersionByIdInInventoryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVrslcmVersionByIdInInventoryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVrslcmVersionByIdInInventoryMethodNotAllowed as json.
func (s *UpdateVrslcmVersionByIdInInventoryMethodNotAllowed) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVrslcmVersionByIdInInventoryMethodNotAllowed from json.
func (s *UpdateVrslcmVersionByIdInInventoryMethodNotAllowed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVrslcmVersionByIdInInventoryMethodNotAllowed to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVrslcmVersionByIdInInventoryMethodNotAllowed(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVrslcmVersionByIdInInventoryMethodNotAllowed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVrslcmVersionByIdInInventoryMethodNotAllowed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVrslcmVersionByIdInInventoryNotFound as json.
func (s *UpdateVrslcmVersionByIdInInventoryNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVrslcmVersionByIdInInventoryNotFound from json.
func (s *UpdateVrslcmVersionByIdInInventoryNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVrslcmVersionByIdInInventoryNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVrslcmVersionByIdInInventoryNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVrslcmVersionByIdInInventoryNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVrslcmVersionByIdInInventoryNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVrslcmVersionInInventoryBadRequest as json.
func (s *UpdateVrslcmVersionInInventoryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVrslcmVersionInInventoryBadRequest from json.
func (s *UpdateVrslcmVersionInInventoryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVrslcmVersionInInventoryBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVrslcmVersionInInventoryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVrslcmVersionInInventoryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVrslcmVersionInInventoryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVrslcmVersionInInventoryInternalServerError as json.
func (s *UpdateVrslcmVersionInInventoryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVrslcmVersionInInventoryInternalServerError from json.
func (s *UpdateVrslcmVersionInInventoryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVrslcmVersionInInventoryInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVrslcmVersionInInventoryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVrslcmVersionInInventoryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVrslcmVersionInInventoryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVrslcmVersionInInventoryMethodNotAllowed as json.
func (s *UpdateVrslcmVersionInInventoryMethodNotAllowed) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVrslcmVersionInInventoryMethodNotAllowed from json.
func (s *UpdateVrslcmVersionInInventoryMethodNotAllowed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVrslcmVersionInInventoryMethodNotAllowed to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVrslcmVersionInInventoryMethodNotAllowed(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVrslcmVersionInInventoryMethodNotAllowed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVrslcmVersionInInventoryMethodNotAllowed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVrslcmVersionInInventoryNotFound as json.
func (s *UpdateVrslcmVersionInInventoryNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVrslcmVersionInInventoryNotFound from json.
func (s *UpdateVrslcmVersionInInventoryNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVrslcmVersionInInventoryNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVrslcmVersionInInventoryNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVrslcmVersionInInventoryNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVrslcmVersionInInventoryNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVsanHclConfigurationAccepted as json.
func (s *UpdateVsanHclConfigurationAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*VsanHclConfiguration)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVsanHclConfigurationAccepted from json.
func (s *UpdateVsanHclConfigurationAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVsanHclConfigurationAccepted to nil")
	}
	var unwrapped VsanHclConfiguration
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVsanHclConfigurationAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVsanHclConfigurationAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVsanHclConfigurationAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVsanHclConfigurationInternalServerError as json.
func (s *UpdateVsanHclConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVsanHclConfigurationInternalServerError from json.
func (s *UpdateVsanHclConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVsanHclConfigurationInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVsanHclConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVsanHclConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVsanHclConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVsanHclConfigurationNotFound as json.
func (s *UpdateVsanHclConfigurationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVsanHclConfigurationNotFound from json.
func (s *UpdateVsanHclConfigurationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVsanHclConfigurationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVsanHclConfigurationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVsanHclConfigurationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVsanHclConfigurationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVsanHclConfigurationOK as json.
func (s *UpdateVsanHclConfigurationOK) Encode(e *jx.Encoder) {
	unwrapped := (*VsanHclConfiguration)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVsanHclConfigurationOK from json.
func (s *UpdateVsanHclConfigurationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVsanHclConfigurationOK to nil")
	}
	var unwrapped VsanHclConfiguration
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVsanHclConfigurationOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVsanHclConfigurationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVsanHclConfigurationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVsanHealthCheckByDomainBadRequest as json.
func (s *UpdateVsanHealthCheckByDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVsanHealthCheckByDomainBadRequest from json.
func (s *UpdateVsanHealthCheckByDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVsanHealthCheckByDomainBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVsanHealthCheckByDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVsanHealthCheckByDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVsanHealthCheckByDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVsanHealthCheckByDomainInternalServerError as json.
func (s *UpdateVsanHealthCheckByDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateVsanHealthCheckByDomainInternalServerError from json.
func (s *UpdateVsanHealthCheckByDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVsanHealthCheckByDomainInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateVsanHealthCheckByDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVsanHealthCheckByDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVsanHealthCheckByDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Upgradable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Upgradable) encodeFields(e *jx.Encoder) {
	{
		if s.BundleId.Set {
			e.FieldStart("bundleId")
			s.BundleId.Encode(e)
		}
	}
	{
		if s.BundleType.Set {
			e.FieldStart("bundleType")
			s.BundleType.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			e.FieldStart("resource")
			s.Resource.Encode(e)
		}
	}
	{
		if s.SoftwareComponents != nil {
			e.FieldStart("softwareComponents")
			e.ArrStart()
			for _, elem := range s.SoftwareComponents {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpgradable = [6]string{
	0: "bundleId",
	1: "bundleType",
	2: "resource",
	3: "softwareComponents",
	4: "status",
	5: "errors",
}

// Decode decodes Upgradable from json.
func (s *Upgradable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Upgradable to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bundleId":
			if err := func() error {
				s.BundleId.Reset()
				if err := s.BundleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleId\"")
			}
		case "bundleType":
			if err := func() error {
				s.BundleType.Reset()
				if err := s.BundleType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleType\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "softwareComponents":
			if err := func() error {
				s.SoftwareComponents = make([]SoftwareComponent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SoftwareComponent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SoftwareComponents = append(s.SoftwareComponents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"softwareComponents\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Upgradable")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Upgradable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Upgradable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpgradablesClusterResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpgradablesClusterResource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceId")
		e.Str(s.ResourceId)
	}
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		if s.PrimaryCluster.Set {
			e.FieldStart("primaryCluster")
			s.PrimaryCluster.Encode(e)
		}
	}
	{
		if s.SoftwareInfo.Set {
			e.FieldStart("softwareInfo")
			s.SoftwareInfo.Encode(e)
		}
	}
	{
		if s.VlcmEnabled.Set {
			e.FieldStart("vlcmEnabled")
			s.VlcmEnabled.Encode(e)
		}
	}
	{
		if s.ConfiguredHardwareSupportManagers != nil {
			e.FieldStart("configuredHardwareSupportManagers")
			e.ArrStart()
			for _, elem := range s.ConfiguredHardwareSupportManagers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AvailableHardwareSupportManagers != nil {
			e.FieldStart("availableHardwareSupportManagers")
			e.ArrStart()
			for _, elem := range s.AvailableHardwareSupportManagers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpgradablesClusterResource = [7]string{
	0: "resourceId",
	1: "resourceType",
	2: "primaryCluster",
	3: "softwareInfo",
	4: "vlcmEnabled",
	5: "configuredHardwareSupportManagers",
	6: "availableHardwareSupportManagers",
}

// Decode decodes UpgradablesClusterResource from json.
func (s *UpgradablesClusterResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpgradablesClusterResource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "primaryCluster":
			if err := func() error {
				s.PrimaryCluster.Reset()
				if err := s.PrimaryCluster.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryCluster\"")
			}
		case "softwareInfo":
			if err := func() error {
				s.SoftwareInfo.Reset()
				if err := s.SoftwareInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"softwareInfo\"")
			}
		case "vlcmEnabled":
			if err := func() error {
				s.VlcmEnabled.Reset()
				if err := s.VlcmEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlcmEnabled\"")
			}
		case "configuredHardwareSupportManagers":
			if err := func() error {
				s.ConfiguredHardwareSupportManagers = make([]HardwareSupportPackage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HardwareSupportPackage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ConfiguredHardwareSupportManagers = append(s.ConfiguredHardwareSupportManagers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configuredHardwareSupportManagers\"")
			}
		case "availableHardwareSupportManagers":
			if err := func() error {
				s.AvailableHardwareSupportManagers = make([]HardwareSupportPackages, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HardwareSupportPackages
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AvailableHardwareSupportManagers = append(s.AvailableHardwareSupportManagers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableHardwareSupportManagers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpgradablesClusterResource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpgradablesClusterResource) {
					name = jsonFieldsNameOfUpgradablesClusterResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpgradablesClusterResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpgradablesClusterResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Upgrade) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Upgrade) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("bundleId")
		e.Str(s.BundleId)
	}
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		if s.ParallelUpgrade.Set {
			e.FieldStart("parallelUpgrade")
			s.ParallelUpgrade.Encode(e)
		}
	}
	{
		e.FieldStart("resourceUpgradeSpecs")
		e.ArrStart()
		for _, elem := range s.ResourceUpgradeSpecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("taskId")
		e.Str(s.TaskId)
	}
	{
		if s.NsxtUpgradeUserInputSpec.Set {
			e.FieldStart("nsxtUpgradeUserInputSpec")
			s.NsxtUpgradeUserInputSpec.Encode(e)
		}
	}
	{
		if s.Bundle.Set {
			e.FieldStart("bundle")
			s.Bundle.Encode(e)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("endTime")
			s.EndTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpgrade = [10]string{
	0: "id",
	1: "bundleId",
	2: "resourceType",
	3: "parallelUpgrade",
	4: "resourceUpgradeSpecs",
	5: "status",
	6: "taskId",
	7: "nsxtUpgradeUserInputSpec",
	8: "bundle",
	9: "endTime",
}

// Decode decodes Upgrade from json.
func (s *Upgrade) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Upgrade to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "bundleId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BundleId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleId\"")
			}
		case "resourceType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "parallelUpgrade":
			if err := func() error {
				s.ParallelUpgrade.Reset()
				if err := s.ParallelUpgrade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parallelUpgrade\"")
			}
		case "resourceUpgradeSpecs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.ResourceUpgradeSpecs = make([]ResourceUpgradeSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourceUpgradeSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResourceUpgradeSpecs = append(s.ResourceUpgradeSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceUpgradeSpecs\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "taskId":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskId\"")
			}
		case "nsxtUpgradeUserInputSpec":
			if err := func() error {
				s.NsxtUpgradeUserInputSpec.Reset()
				if err := s.NsxtUpgradeUserInputSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtUpgradeUserInputSpec\"")
			}
		case "bundle":
			if err := func() error {
				s.Bundle.Reset()
				if err := s.Bundle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundle\"")
			}
		case "endTime":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Upgrade")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpgrade) {
					name = jsonFieldsNameOfUpgrade[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Upgrade) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Upgrade) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpgradeCommitSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpgradeCommitSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ScheduledTimestamp.Set {
			e.FieldStart("scheduledTimestamp")
			s.ScheduledTimestamp.Encode(e)
		}
	}
	{
		if s.UpgradeNow.Set {
			e.FieldStart("upgradeNow")
			s.UpgradeNow.Encode(e)
		}
	}
	{
		if s.MarkForCancellation.Set {
			e.FieldStart("markForCancellation")
			s.MarkForCancellation.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpgradeCommitSpec = [3]string{
	0: "scheduledTimestamp",
	1: "upgradeNow",
	2: "markForCancellation",
}

// Decode decodes UpgradeCommitSpec from json.
func (s *UpgradeCommitSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpgradeCommitSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scheduledTimestamp":
			if err := func() error {
				s.ScheduledTimestamp.Reset()
				if err := s.ScheduledTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduledTimestamp\"")
			}
		case "upgradeNow":
			if err := func() error {
				s.UpgradeNow.Reset()
				if err := s.UpgradeNow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upgradeNow\"")
			}
		case "markForCancellation":
			if err := func() error {
				s.MarkForCancellation.Reset()
				if err := s.MarkForCancellation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"markForCancellation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpgradeCommitSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpgradeCommitSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpgradeCommitSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpgradeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpgradeSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bundleId")
		e.Str(s.BundleId)
	}
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		if s.ParallelUpgrade.Set {
			e.FieldStart("parallelUpgrade")
			s.ParallelUpgrade.Encode(e)
		}
	}
	{
		if s.DraftMode.Set {
			e.FieldStart("draftMode")
			s.DraftMode.Encode(e)
		}
	}
	{
		e.FieldStart("resourceUpgradeSpecs")
		e.ArrStart()
		for _, elem := range s.ResourceUpgradeSpecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.NsxtUpgradeUserInputSpecs != nil {
			e.FieldStart("nsxtUpgradeUserInputSpecs")
			e.ArrStart()
			for _, elem := range s.NsxtUpgradeUserInputSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VcenterUpgradeUserInputSpecs != nil {
			e.FieldStart("vcenterUpgradeUserInputSpecs")
			e.ArrStart()
			for _, elem := range s.VcenterUpgradeUserInputSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpgradeSpec = [7]string{
	0: "bundleId",
	1: "resourceType",
	2: "parallelUpgrade",
	3: "draftMode",
	4: "resourceUpgradeSpecs",
	5: "nsxtUpgradeUserInputSpecs",
	6: "vcenterUpgradeUserInputSpecs",
}

// Decode decodes UpgradeSpec from json.
func (s *UpgradeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpgradeSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bundleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BundleId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleId\"")
			}
		case "resourceType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "parallelUpgrade":
			if err := func() error {
				s.ParallelUpgrade.Reset()
				if err := s.ParallelUpgrade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parallelUpgrade\"")
			}
		case "draftMode":
			if err := func() error {
				s.DraftMode.Reset()
				if err := s.DraftMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draftMode\"")
			}
		case "resourceUpgradeSpecs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.ResourceUpgradeSpecs = make([]ResourceUpgradeSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourceUpgradeSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResourceUpgradeSpecs = append(s.ResourceUpgradeSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceUpgradeSpecs\"")
			}
		case "nsxtUpgradeUserInputSpecs":
			if err := func() error {
				s.NsxtUpgradeUserInputSpecs = make([]NsxtUpgradeUserInputSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NsxtUpgradeUserInputSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NsxtUpgradeUserInputSpecs = append(s.NsxtUpgradeUserInputSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtUpgradeUserInputSpecs\"")
			}
		case "vcenterUpgradeUserInputSpecs":
			if err := func() error {
				s.VcenterUpgradeUserInputSpecs = make([]VcenterUpgradeUserInputSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VcenterUpgradeUserInputSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VcenterUpgradeUserInputSpecs = append(s.VcenterUpgradeUserInputSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcenterUpgradeUserInputSpecs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpgradeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpgradeSpec) {
					name = jsonFieldsNameOfUpgradeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpgradeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpgradeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpgradeStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpgradeStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.CompletedResources.Set {
			e.FieldStart("completedResources")
			s.CompletedResources.Encode(e)
		}
	}
	{
		if s.TotalResources.Set {
			e.FieldStart("totalResources")
			s.TotalResources.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpgradeStatus = [3]string{
	0: "status",
	1: "completedResources",
	2: "totalResources",
}

// Decode decodes UpgradeStatus from json.
func (s *UpgradeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpgradeStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "completedResources":
			if err := func() error {
				s.CompletedResources.Reset()
				if err := s.CompletedResources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedResources\"")
			}
		case "totalResources":
			if err := func() error {
				s.TotalResources.Reset()
				if err := s.TotalResources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalResources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpgradeStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpgradeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpgradeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UplinkMapping) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UplinkMapping) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vdsUplinkName")
		e.Str(s.VdsUplinkName)
	}
	{
		e.FieldStart("nsxUplinkName")
		e.Str(s.NsxUplinkName)
	}
}

var jsonFieldsNameOfUplinkMapping = [2]string{
	0: "vdsUplinkName",
	1: "nsxUplinkName",
}

// Decode decodes UplinkMapping from json.
func (s *UplinkMapping) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UplinkMapping to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vdsUplinkName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VdsUplinkName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsUplinkName\"")
			}
		case "nsxUplinkName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NsxUplinkName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxUplinkName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UplinkMapping")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUplinkMapping) {
					name = jsonFieldsNameOfUplinkMapping[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UplinkMapping) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UplinkMapping) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UplinkProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UplinkProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("teamings")
		e.ArrStart()
		for _, elem := range s.Teamings {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.TransportVlan.Set {
			e.FieldStart("transportVlan")
			s.TransportVlan.Encode(e)
		}
	}
	{
		if s.SupportedTeamingPolicies.Set {
			e.FieldStart("supportedTeamingPolicies")
			s.SupportedTeamingPolicies.Encode(e)
		}
	}
}

var jsonFieldsNameOfUplinkProfile = [4]string{
	0: "name",
	1: "teamings",
	2: "transportVlan",
	3: "supportedTeamingPolicies",
}

// Decode decodes UplinkProfile from json.
func (s *UplinkProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UplinkProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "teamings":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Teamings = make([]TeamingSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TeamingSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teamings = append(s.Teamings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamings\"")
			}
		case "transportVlan":
			if err := func() error {
				s.TransportVlan.Reset()
				if err := s.TransportVlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transportVlan\"")
			}
		case "supportedTeamingPolicies":
			if err := func() error {
				s.SupportedTeamingPolicies.Reset()
				if err := s.SupportedTeamingPolicies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportedTeamingPolicies\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UplinkProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUplinkProfile) {
					name = jsonFieldsNameOfUplinkProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UplinkProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UplinkProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UplinkProfileSupportedTeamingPolicies) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UplinkProfileSupportedTeamingPolicies) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes UplinkProfileSupportedTeamingPolicies from json.
func (s *UplinkProfileSupportedTeamingPolicies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UplinkProfileSupportedTeamingPolicies to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UplinkProfileSupportedTeamingPolicies")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UplinkProfileSupportedTeamingPolicies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UplinkProfileSupportedTeamingPolicies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadBundleBadRequest as json.
func (s *UploadBundleBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadBundleBadRequest from json.
func (s *UploadBundleBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadBundleBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadBundleBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadBundleBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadBundleBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadBundleInternalServerError as json.
func (s *UploadBundleInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadBundleInternalServerError from json.
func (s *UploadBundleInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadBundleInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadBundleInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadBundleInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadBundleInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadCertificatesBadRequest as json.
func (s *UploadCertificatesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadCertificatesBadRequest from json.
func (s *UploadCertificatesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadCertificatesBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadCertificatesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadCertificatesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadCertificatesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadCertificatesInternalServerError as json.
func (s *UploadCertificatesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadCertificatesInternalServerError from json.
func (s *UploadCertificatesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadCertificatesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadCertificatesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadCertificatesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadCertificatesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadCertificatesNotFound as json.
func (s *UploadCertificatesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadCertificatesNotFound from json.
func (s *UploadCertificatesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadCertificatesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadCertificatesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadCertificatesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadCertificatesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadCustomIsoBadRequest as json.
func (s *UploadCustomIsoBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadCustomIsoBadRequest from json.
func (s *UploadCustomIsoBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadCustomIsoBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadCustomIsoBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadCustomIsoBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadCustomIsoBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadCustomIsoInternalServerError as json.
func (s *UploadCustomIsoInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadCustomIsoInternalServerError from json.
func (s *UploadCustomIsoInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadCustomIsoInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadCustomIsoInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadCustomIsoInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadCustomIsoInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadPersonalityBadRequest as json.
func (s *UploadPersonalityBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadPersonalityBadRequest from json.
func (s *UploadPersonalityBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadPersonalityBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadPersonalityBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadPersonalityBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadPersonalityBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadPersonalityFilesBadRequest as json.
func (s *UploadPersonalityFilesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadPersonalityFilesBadRequest from json.
func (s *UploadPersonalityFilesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadPersonalityFilesBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadPersonalityFilesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadPersonalityFilesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadPersonalityFilesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadPersonalityFilesInternalServerError as json.
func (s *UploadPersonalityFilesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadPersonalityFilesInternalServerError from json.
func (s *UploadPersonalityFilesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadPersonalityFilesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadPersonalityFilesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadPersonalityFilesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadPersonalityFilesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadPersonalityFilesOKApplicationJSON as json.
func (s UploadPersonalityFilesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes UploadPersonalityFilesOKApplicationJSON from json.
func (s *UploadPersonalityFilesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadPersonalityFilesOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadPersonalityFilesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UploadPersonalityFilesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadPersonalityFilesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadPersonalityInternalServerError as json.
func (s *UploadPersonalityInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadPersonalityInternalServerError from json.
func (s *UploadPersonalityInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadPersonalityInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadPersonalityInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadPersonalityInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadPersonalityInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadProductVersionCatalogBadRequest as json.
func (s *UploadProductVersionCatalogBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadProductVersionCatalogBadRequest from json.
func (s *UploadProductVersionCatalogBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadProductVersionCatalogBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadProductVersionCatalogBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadProductVersionCatalogBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadProductVersionCatalogBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UploadProductVersionCatalogInternalServerError as json.
func (s *UploadProductVersionCatalogInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UploadProductVersionCatalogInternalServerError from json.
func (s *UploadProductVersionCatalogInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadProductVersionCatalogInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UploadProductVersionCatalogInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadProductVersionCatalogInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadProductVersionCatalogInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *User) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *User) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.ApiKey.Set {
			e.FieldStart("apiKey")
			s.ApiKey.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		if s.CreationTimestamp.Set {
			e.FieldStart("creationTimestamp")
			s.CreationTimestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfUser = [7]string{
	0: "id",
	1: "name",
	2: "domain",
	3: "type",
	4: "apiKey",
	5: "role",
	6: "creationTimestamp",
}

// Decode decodes User from json.
func (s *User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode User to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "apiKey":
			if err := func() error {
				s.ApiKey.Reset()
				if err := s.ApiKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKey\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "creationTimestamp":
			if err := func() error {
				s.CreationTimestamp.Reset()
				if err := s.CreationTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode User")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUser) {
					name = jsonFieldsNameOfUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *User) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *User) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VMNicInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VMNicInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.LinkSpeedMB.Set {
			e.FieldStart("linkSpeedMB")
			s.LinkSpeedMB.Encode(e)
		}
	}
	{
		if s.IsInUse.Set {
			e.FieldStart("isInUse")
			s.IsInUse.Encode(e)
		}
	}
	{
		if s.IsAutoNegotiateSupported.Set {
			e.FieldStart("isAutoNegotiateSupported")
			s.IsAutoNegotiateSupported.Encode(e)
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("isActive")
			s.IsActive.Encode(e)
		}
	}
}

var jsonFieldsNameOfVMNicInfo = [5]string{
	0: "name",
	1: "linkSpeedMB",
	2: "isInUse",
	3: "isAutoNegotiateSupported",
	4: "isActive",
}

// Decode decodes VMNicInfo from json.
func (s *VMNicInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMNicInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "linkSpeedMB":
			if err := func() error {
				s.LinkSpeedMB.Reset()
				if err := s.LinkSpeedMB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkSpeedMB\"")
			}
		case "isInUse":
			if err := func() error {
				s.IsInUse.Reset()
				if err := s.IsInUse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isInUse\"")
			}
		case "isAutoNegotiateSupported":
			if err := func() error {
				s.IsAutoNegotiateSupported.Reset()
				if err := s.IsAutoNegotiateSupported.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAutoNegotiateSupported\"")
			}
		case "isActive":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VMNicInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMNicInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMNicInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VSANNetworkSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VSANNetworkSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vsanGatewayIP")
		e.Str(s.VsanGatewayIP)
	}
	{
		e.FieldStart("vsanCidr")
		e.Str(s.VsanCidr)
	}
}

var jsonFieldsNameOfVSANNetworkSpec = [2]string{
	0: "vsanGatewayIP",
	1: "vsanCidr",
}

// Decode decodes VSANNetworkSpec from json.
func (s *VSANNetworkSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VSANNetworkSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vsanGatewayIP":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VsanGatewayIP = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanGatewayIP\"")
			}
		case "vsanCidr":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VsanCidr = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanCidr\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VSANNetworkSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVSANNetworkSpec) {
					name = jsonFieldsNameOfVSANNetworkSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VSANNetworkSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VSANNetworkSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateALBClusterCreationSpecBadRequest as json.
func (s *ValidateALBClusterCreationSpecBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateALBClusterCreationSpecBadRequest from json.
func (s *ValidateALBClusterCreationSpecBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateALBClusterCreationSpecBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateALBClusterCreationSpecBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateALBClusterCreationSpecBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateALBClusterCreationSpecBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateALBClusterCreationSpecInternalServerError as json.
func (s *ValidateALBClusterCreationSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateALBClusterCreationSpecInternalServerError from json.
func (s *ValidateALBClusterCreationSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateALBClusterCreationSpecInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateALBClusterCreationSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateALBClusterCreationSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateALBClusterCreationSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateBackupConfigurationsOperationsBadRequest as json.
func (s *ValidateBackupConfigurationsOperationsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateBackupConfigurationsOperationsBadRequest from json.
func (s *ValidateBackupConfigurationsOperationsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateBackupConfigurationsOperationsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateBackupConfigurationsOperationsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateBackupConfigurationsOperationsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateBackupConfigurationsOperationsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateBackupConfigurationsOperationsInternalServerError as json.
func (s *ValidateBackupConfigurationsOperationsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateBackupConfigurationsOperationsInternalServerError from json.
func (s *ValidateBackupConfigurationsOperationsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateBackupConfigurationsOperationsInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateBackupConfigurationsOperationsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateBackupConfigurationsOperationsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateBackupConfigurationsOperationsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateBringupSpecAccepted as json.
func (s *ValidateBringupSpecAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateBringupSpecAccepted from json.
func (s *ValidateBringupSpecAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateBringupSpecAccepted to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateBringupSpecAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateBringupSpecAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateBringupSpecAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateBringupSpecForbidden as json.
func (s *ValidateBringupSpecForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateBringupSpecForbidden from json.
func (s *ValidateBringupSpecForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateBringupSpecForbidden to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateBringupSpecForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateBringupSpecForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateBringupSpecForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateBringupSpecInternalServerError as json.
func (s *ValidateBringupSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateBringupSpecInternalServerError from json.
func (s *ValidateBringupSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateBringupSpecInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateBringupSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateBringupSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateBringupSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateBringupSpecNotFound as json.
func (s *ValidateBringupSpecNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateBringupSpecNotFound from json.
func (s *ValidateBringupSpecNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateBringupSpecNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateBringupSpecNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateBringupSpecNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateBringupSpecNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateBringupSpecOK as json.
func (s *ValidateBringupSpecOK) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateBringupSpecOK from json.
func (s *ValidateBringupSpecOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateBringupSpecOK to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateBringupSpecOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateBringupSpecOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateBringupSpecOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateClusterCreationSpecBadRequest as json.
func (s *ValidateClusterCreationSpecBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateClusterCreationSpecBadRequest from json.
func (s *ValidateClusterCreationSpecBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateClusterCreationSpecBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateClusterCreationSpecBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateClusterCreationSpecBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateClusterCreationSpecBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateClusterCreationSpecInternalServerError as json.
func (s *ValidateClusterCreationSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateClusterCreationSpecInternalServerError from json.
func (s *ValidateClusterCreationSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateClusterCreationSpecInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateClusterCreationSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateClusterCreationSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateClusterCreationSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateClusterUpdateSpecBadRequest as json.
func (s *ValidateClusterUpdateSpecBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateClusterUpdateSpecBadRequest from json.
func (s *ValidateClusterUpdateSpecBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateClusterUpdateSpecBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateClusterUpdateSpecBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateClusterUpdateSpecBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateClusterUpdateSpecBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateClusterUpdateSpecInternalServerError as json.
func (s *ValidateClusterUpdateSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateClusterUpdateSpecInternalServerError from json.
func (s *ValidateClusterUpdateSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateClusterUpdateSpecInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateClusterUpdateSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateClusterUpdateSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateClusterUpdateSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateClusterUpdateSpecNotFound as json.
func (s *ValidateClusterUpdateSpecNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateClusterUpdateSpecNotFound from json.
func (s *ValidateClusterUpdateSpecNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateClusterUpdateSpecNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateClusterUpdateSpecNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateClusterUpdateSpecNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateClusterUpdateSpecNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateCommissionHostsAccepted as json.
func (s *ValidateCommissionHostsAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateCommissionHostsAccepted from json.
func (s *ValidateCommissionHostsAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateCommissionHostsAccepted to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateCommissionHostsAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateCommissionHostsAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateCommissionHostsAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateCommissionHostsInternalServerError as json.
func (s *ValidateCommissionHostsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateCommissionHostsInternalServerError from json.
func (s *ValidateCommissionHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateCommissionHostsInternalServerError to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateCommissionHostsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateCommissionHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateCommissionHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateDnsConfigurationAccepted as json.
func (s *ValidateDnsConfigurationAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateDnsConfigurationAccepted from json.
func (s *ValidateDnsConfigurationAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateDnsConfigurationAccepted to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateDnsConfigurationAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateDnsConfigurationAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateDnsConfigurationAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateDnsConfigurationInternalServerError as json.
func (s *ValidateDnsConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateDnsConfigurationInternalServerError from json.
func (s *ValidateDnsConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateDnsConfigurationInternalServerError to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateDnsConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateDnsConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateDnsConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateDomainCreationSpecBadRequest as json.
func (s *ValidateDomainCreationSpecBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateDomainCreationSpecBadRequest from json.
func (s *ValidateDomainCreationSpecBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateDomainCreationSpecBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateDomainCreationSpecBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateDomainCreationSpecBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateDomainCreationSpecBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateDomainCreationSpecInternalServerError as json.
func (s *ValidateDomainCreationSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateDomainCreationSpecInternalServerError from json.
func (s *ValidateDomainCreationSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateDomainCreationSpecInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateDomainCreationSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateDomainCreationSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateDomainCreationSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateDomainUpdateSpecBadRequest as json.
func (s *ValidateDomainUpdateSpecBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateDomainUpdateSpecBadRequest from json.
func (s *ValidateDomainUpdateSpecBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateDomainUpdateSpecBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateDomainUpdateSpecBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateDomainUpdateSpecBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateDomainUpdateSpecBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateDomainUpdateSpecInternalServerError as json.
func (s *ValidateDomainUpdateSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateDomainUpdateSpecInternalServerError from json.
func (s *ValidateDomainUpdateSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateDomainUpdateSpecInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateDomainUpdateSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateDomainUpdateSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateDomainUpdateSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateEdgeClusterCreationSpecBadRequest as json.
func (s *ValidateEdgeClusterCreationSpecBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateEdgeClusterCreationSpecBadRequest from json.
func (s *ValidateEdgeClusterCreationSpecBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateEdgeClusterCreationSpecBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateEdgeClusterCreationSpecBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateEdgeClusterCreationSpecBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateEdgeClusterCreationSpecBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateEdgeClusterCreationSpecInternalServerError as json.
func (s *ValidateEdgeClusterCreationSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateEdgeClusterCreationSpecInternalServerError from json.
func (s *ValidateEdgeClusterCreationSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateEdgeClusterCreationSpecInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateEdgeClusterCreationSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateEdgeClusterCreationSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateEdgeClusterCreationSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateEdgeClusterUpdateSpecBadRequest as json.
func (s *ValidateEdgeClusterUpdateSpecBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateEdgeClusterUpdateSpecBadRequest from json.
func (s *ValidateEdgeClusterUpdateSpecBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateEdgeClusterUpdateSpecBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateEdgeClusterUpdateSpecBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateEdgeClusterUpdateSpecBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateEdgeClusterUpdateSpecBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateEdgeClusterUpdateSpecInternalServerError as json.
func (s *ValidateEdgeClusterUpdateSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateEdgeClusterUpdateSpecInternalServerError from json.
func (s *ValidateEdgeClusterUpdateSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateEdgeClusterUpdateSpecInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateEdgeClusterUpdateSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateEdgeClusterUpdateSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateEdgeClusterUpdateSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateHostCommissionSpecAccepted as json.
func (s *ValidateHostCommissionSpecAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateHostCommissionSpecAccepted from json.
func (s *ValidateHostCommissionSpecAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateHostCommissionSpecAccepted to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateHostCommissionSpecAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateHostCommissionSpecAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateHostCommissionSpecAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateHostCommissionSpecInternalServerError as json.
func (s *ValidateHostCommissionSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateHostCommissionSpecInternalServerError from json.
func (s *ValidateHostCommissionSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateHostCommissionSpecInternalServerError to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateHostCommissionSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateHostCommissionSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateHostCommissionSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateNsxALBCompatibilityBadRequest as json.
func (s *ValidateNsxALBCompatibilityBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateNsxALBCompatibilityBadRequest from json.
func (s *ValidateNsxALBCompatibilityBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateNsxALBCompatibilityBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateNsxALBCompatibilityBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateNsxALBCompatibilityBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateNsxALBCompatibilityBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateNsxALBCompatibilityInternalServerError as json.
func (s *ValidateNsxALBCompatibilityInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateNsxALBCompatibilityInternalServerError from json.
func (s *ValidateNsxALBCompatibilityInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateNsxALBCompatibilityInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateNsxALBCompatibilityInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateNsxALBCompatibilityInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateNsxALBCompatibilityInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateNtpConfigurationAccepted as json.
func (s *ValidateNtpConfigurationAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateNtpConfigurationAccepted from json.
func (s *ValidateNtpConfigurationAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateNtpConfigurationAccepted to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateNtpConfigurationAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateNtpConfigurationAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateNtpConfigurationAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateNtpConfigurationInternalServerError as json.
func (s *ValidateNtpConfigurationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateNtpConfigurationInternalServerError from json.
func (s *ValidateNtpConfigurationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateNtpConfigurationInternalServerError to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateNtpConfigurationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateNtpConfigurationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateNtpConfigurationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateReleaseByDomainIDBadRequest as json.
func (s *ValidateReleaseByDomainIDBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateReleaseByDomainIDBadRequest from json.
func (s *ValidateReleaseByDomainIDBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateReleaseByDomainIDBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateReleaseByDomainIDBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateReleaseByDomainIDBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateReleaseByDomainIDBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateReleaseByDomainIDInternalServerError as json.
func (s *ValidateReleaseByDomainIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateReleaseByDomainIDInternalServerError from json.
func (s *ValidateReleaseByDomainIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateReleaseByDomainIDInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateReleaseByDomainIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateReleaseByDomainIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateReleaseByDomainIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateResourceCertificatesInternalServerError as json.
func (s *ValidateResourceCertificatesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateResourceCertificatesInternalServerError from json.
func (s *ValidateResourceCertificatesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateResourceCertificatesInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateResourceCertificatesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateResourceCertificatesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateResourceCertificatesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateResourceCertificatesNotFound as json.
func (s *ValidateResourceCertificatesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateResourceCertificatesNotFound from json.
func (s *ValidateResourceCertificatesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateResourceCertificatesNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateResourceCertificatesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateResourceCertificatesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateResourceCertificatesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateVasaProviderSpecAccepted as json.
func (s *ValidateVasaProviderSpecAccepted) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateVasaProviderSpecAccepted from json.
func (s *ValidateVasaProviderSpecAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateVasaProviderSpecAccepted to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateVasaProviderSpecAccepted(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateVasaProviderSpecAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateVasaProviderSpecAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateVasaProviderSpecInternalServerError as json.
func (s *ValidateVasaProviderSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Validation)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateVasaProviderSpecInternalServerError from json.
func (s *ValidateVasaProviderSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateVasaProviderSpecInternalServerError to nil")
	}
	var unwrapped Validation
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateVasaProviderSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateVasaProviderSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateVasaProviderSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateVsanRemoteDatastoreMountSpecBadRequest as json.
func (s *ValidateVsanRemoteDatastoreMountSpecBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateVsanRemoteDatastoreMountSpecBadRequest from json.
func (s *ValidateVsanRemoteDatastoreMountSpecBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateVsanRemoteDatastoreMountSpecBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateVsanRemoteDatastoreMountSpecBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateVsanRemoteDatastoreMountSpecBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateVsanRemoteDatastoreMountSpecBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateVsanRemoteDatastoreMountSpecInternalServerError as json.
func (s *ValidateVsanRemoteDatastoreMountSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateVsanRemoteDatastoreMountSpecInternalServerError from json.
func (s *ValidateVsanRemoteDatastoreMountSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateVsanRemoteDatastoreMountSpecInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateVsanRemoteDatastoreMountSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateVsanRemoteDatastoreMountSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateVsanRemoteDatastoreMountSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateVsanRemoteDatastoreSpecBadRequest as json.
func (s *ValidateVsanRemoteDatastoreSpecBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateVsanRemoteDatastoreSpecBadRequest from json.
func (s *ValidateVsanRemoteDatastoreSpecBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateVsanRemoteDatastoreSpecBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateVsanRemoteDatastoreSpecBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateVsanRemoteDatastoreSpecBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateVsanRemoteDatastoreSpecBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidateVsanRemoteDatastoreSpecInternalServerError as json.
func (s *ValidateVsanRemoteDatastoreSpecInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes ValidateVsanRemoteDatastoreSpecInternalServerError from json.
func (s *ValidateVsanRemoteDatastoreSpecInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateVsanRemoteDatastoreSpecInternalServerError to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ValidateVsanRemoteDatastoreSpecInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateVsanRemoteDatastoreSpecInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateVsanRemoteDatastoreSpecInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Validation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Validation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("executionStatus")
		e.Str(s.ExecutionStatus)
	}
	{
		e.FieldStart("resultStatus")
		e.Str(s.ResultStatus)
	}
	{
		if s.ValidationChecks != nil {
			e.FieldStart("validationChecks")
			e.ArrStart()
			for _, elem := range s.ValidationChecks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
}

var jsonFieldsNameOfValidation = [6]string{
	0: "id",
	1: "description",
	2: "executionStatus",
	3: "resultStatus",
	4: "validationChecks",
	5: "additionalProperties",
}

// Decode decodes Validation from json.
func (s *Validation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Validation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "executionStatus":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ExecutionStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executionStatus\"")
			}
		case "resultStatus":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ResultStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resultStatus\"")
			}
		case "validationChecks":
			if err := func() error {
				s.ValidationChecks = make([]ValidationCheck, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationCheck
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ValidationChecks = append(s.ValidationChecks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validationChecks\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Validation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidation) {
					name = jsonFieldsNameOfValidation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Validation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Validation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ValidationAdditionalProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ValidationAdditionalProperties) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ValidationAdditionalProperties from json.
func (s *ValidationAdditionalProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationAdditionalProperties to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationAdditionalProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValidationAdditionalProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationAdditionalProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationCheck) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationCheck) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("severity")
		e.Str(s.Severity)
	}
	{
		e.FieldStart("resultStatus")
		e.Str(s.ResultStatus)
	}
	{
		if s.ErrorResponse.Set {
			e.FieldStart("errorResponse")
			s.ErrorResponse.Encode(e)
		}
	}
}

var jsonFieldsNameOfValidationCheck = [4]string{
	0: "description",
	1: "severity",
	2: "resultStatus",
	3: "errorResponse",
}

// Decode decodes ValidationCheck from json.
func (s *ValidationCheck) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationCheck to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Severity = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "resultStatus":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ResultStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resultStatus\"")
			}
		case "errorResponse":
			if err := func() error {
				s.ErrorResponse.Reset()
				if err := s.ErrorResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorResponse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationCheck")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationCheck) {
					name = jsonFieldsNameOfValidationCheck[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationCheck) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationCheck) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VasaProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VasaProvider) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("storageContainers")
		e.ArrStart()
		for _, elem := range s.StorageContainers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfVasaProvider = [5]string{
	0: "id",
	1: "name",
	2: "url",
	3: "storageContainers",
	4: "users",
}

// Decode decodes VasaProvider from json.
func (s *VasaProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VasaProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "storageContainers":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.StorageContainers = make([]StorageContainer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StorageContainer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.StorageContainers = append(s.StorageContainers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageContainers\"")
			}
		case "users":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Users = make([]VasaUser, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VasaUser
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VasaProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVasaProvider) {
					name = jsonFieldsNameOfVasaProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VasaProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VasaProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VasaProviderSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VasaProviderSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vasaProviderId")
		e.Str(s.VasaProviderId)
	}
	{
		e.FieldStart("storageContainerId")
		e.Str(s.StorageContainerId)
	}
	{
		e.FieldStart("storageProtocolType")
		e.Str(s.StorageProtocolType)
	}
	{
		e.FieldStart("userId")
		e.Str(s.UserId)
	}
}

var jsonFieldsNameOfVasaProviderSpec = [4]string{
	0: "vasaProviderId",
	1: "storageContainerId",
	2: "storageProtocolType",
	3: "userId",
}

// Decode decodes VasaProviderSpec from json.
func (s *VasaProviderSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VasaProviderSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vasaProviderId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VasaProviderId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vasaProviderId\"")
			}
		case "storageContainerId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.StorageContainerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageContainerId\"")
			}
		case "storageProtocolType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StorageProtocolType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageProtocolType\"")
			}
		case "userId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.UserId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VasaProviderSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVasaProviderSpec) {
					name = jsonFieldsNameOfVasaProviderSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VasaProviderSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VasaProviderSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VasaProviderUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VasaProviderUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfVasaProviderUpdateSpec = [2]string{
	0: "name",
	1: "url",
}

// Decode decodes VasaProviderUpdateSpec from json.
func (s *VasaProviderUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VasaProviderUpdateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VasaProviderUpdateSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VasaProviderUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VasaProviderUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VasaUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VasaUser) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfVasaUser = [3]string{
	0: "id",
	1: "username",
	2: "password",
}

// Decode decodes VasaUser from json.
func (s *VasaUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VasaUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VasaUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVasaUser) {
					name = jsonFieldsNameOfVasaUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VasaUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VasaUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VasaUserUpdateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VasaUserUpdateSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfVasaUserUpdateSpec = [2]string{
	0: "username",
	1: "password",
}

// Decode decodes VasaUserUpdateSpec from json.
func (s *VasaUserUpdateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VasaUserUpdateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VasaUserUpdateSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VasaUserUpdateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VasaUserUpdateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VcIdentitySources) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VcIdentitySources) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.DomainNames != nil {
			e.FieldStart("domainNames")
			e.ArrStart()
			for _, elem := range s.DomainNames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ldap.Set {
			e.FieldStart("ldap")
			s.Ldap.Encode(e)
		}
	}
}

var jsonFieldsNameOfVcIdentitySources = [4]string{
	0: "name",
	1: "type",
	2: "domainNames",
	3: "ldap",
}

// Decode decodes VcIdentitySources from json.
func (s *VcIdentitySources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VcIdentitySources to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "domainNames":
			if err := func() error {
				s.DomainNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DomainNames = append(s.DomainNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainNames\"")
			}
		case "ldap":
			if err := func() error {
				s.Ldap.Reset()
				if err := s.Ldap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ldap\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VcIdentitySources")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VcIdentitySources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VcIdentitySources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vcenter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vcenter) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Fqdn.Set {
			e.FieldStart("fqdn")
			s.Fqdn.Encode(e)
		}
	}
	{
		if s.IpAddress.Set {
			e.FieldStart("ipAddress")
			s.IpAddress.Encode(e)
		}
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfVcenter = [5]string{
	0: "id",
	1: "fqdn",
	2: "ipAddress",
	3: "domain",
	4: "version",
}

// Decode decodes Vcenter from json.
func (s *Vcenter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vcenter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "fqdn":
			if err := func() error {
				s.Fqdn.Reset()
				if err := s.Fqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "ipAddress":
			if err := func() error {
				s.IpAddress.Reset()
				if err := s.IpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vcenter")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vcenter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vcenter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VcenterReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VcenterReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Fqdn.Set {
			e.FieldStart("fqdn")
			s.Fqdn.Encode(e)
		}
	}
	{
		if s.VcInstanceId.Set {
			e.FieldStart("vcInstanceId")
			s.VcInstanceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfVcenterReference = [3]string{
	0: "id",
	1: "fqdn",
	2: "vcInstanceId",
}

// Decode decodes VcenterReference from json.
func (s *VcenterReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VcenterReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "fqdn":
			if err := func() error {
				s.Fqdn.Reset()
				if err := s.Fqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "vcInstanceId":
			if err := func() error {
				s.VcInstanceId.Reset()
				if err := s.VcInstanceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcInstanceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VcenterReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVcenterReference) {
					name = jsonFieldsNameOfVcenterReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VcenterReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VcenterReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VcenterSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VcenterSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("networkDetailsSpec")
		s.NetworkDetailsSpec.Encode(e)
	}
	{
		if s.RootPassword.Set {
			e.FieldStart("rootPassword")
			s.RootPassword.Encode(e)
		}
	}
	{
		if s.DatacenterName.Set {
			e.FieldStart("datacenterName")
			s.DatacenterName.Encode(e)
		}
	}
	{
		if s.VmSize.Set {
			e.FieldStart("vmSize")
			s.VmSize.Encode(e)
		}
	}
	{
		if s.StorageSize.Set {
			e.FieldStart("storageSize")
			s.StorageSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfVcenterSpec = [6]string{
	0: "name",
	1: "networkDetailsSpec",
	2: "rootPassword",
	3: "datacenterName",
	4: "vmSize",
	5: "storageSize",
}

// Decode decodes VcenterSpec from json.
func (s *VcenterSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VcenterSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "networkDetailsSpec":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NetworkDetailsSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkDetailsSpec\"")
			}
		case "rootPassword":
			if err := func() error {
				s.RootPassword.Reset()
				if err := s.RootPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rootPassword\"")
			}
		case "datacenterName":
			if err := func() error {
				s.DatacenterName.Reset()
				if err := s.DatacenterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datacenterName\"")
			}
		case "vmSize":
			if err := func() error {
				s.VmSize.Reset()
				if err := s.VmSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmSize\"")
			}
		case "storageSize":
			if err := func() error {
				s.StorageSize.Reset()
				if err := s.StorageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageSize\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VcenterSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVcenterSpec) {
					name = jsonFieldsNameOfVcenterSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VcenterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VcenterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VcenterUpgradeUserInputSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VcenterUpgradeUserInputSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("temporaryNetwork")
		s.TemporaryNetwork.Encode(e)
	}
}

var jsonFieldsNameOfVcenterUpgradeUserInputSpec = [1]string{
	0: "temporaryNetwork",
}

// Decode decodes VcenterUpgradeUserInputSpec from json.
func (s *VcenterUpgradeUserInputSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VcenterUpgradeUserInputSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "temporaryNetwork":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.TemporaryNetwork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temporaryNetwork\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VcenterUpgradeUserInputSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVcenterUpgradeUserInputSpec) {
					name = jsonFieldsNameOfVcenterUpgradeUserInputSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VcenterUpgradeUserInputSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VcenterUpgradeUserInputSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VcfService) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VcfService) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfVcfService = [4]string{
	0: "id",
	1: "name",
	2: "version",
	3: "status",
}

// Decode decodes VcfService from json.
func (s *VcfService) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VcfService to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VcfService")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VcfService) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VcfService) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vds) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vds) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.IsUsedByNsxt.Set {
			e.FieldStart("isUsedByNsxt")
			s.IsUsedByNsxt.Encode(e)
		}
	}
	{
		if s.Mtu.Set {
			e.FieldStart("mtu")
			s.Mtu.Encode(e)
		}
	}
	{
		if s.PortGroups != nil {
			e.FieldStart("portGroups")
			e.ArrStart()
			for _, elem := range s.PortGroups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NiocBandwidthAllocations != nil {
			e.FieldStart("niocBandwidthAllocations")
			e.ArrStart()
			for _, elem := range s.NiocBandwidthAllocations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.NsxtSwitchConfig.Set {
			e.FieldStart("nsxtSwitchConfig")
			s.NsxtSwitchConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfVds = [8]string{
	0: "id",
	1: "name",
	2: "isUsedByNsxt",
	3: "mtu",
	4: "portGroups",
	5: "niocBandwidthAllocations",
	6: "version",
	7: "nsxtSwitchConfig",
}

// Decode decodes Vds from json.
func (s *Vds) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vds to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "isUsedByNsxt":
			if err := func() error {
				s.IsUsedByNsxt.Reset()
				if err := s.IsUsedByNsxt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isUsedByNsxt\"")
			}
		case "mtu":
			if err := func() error {
				s.Mtu.Reset()
				if err := s.Mtu.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mtu\"")
			}
		case "portGroups":
			if err := func() error {
				s.PortGroups = make([]Portgroup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Portgroup
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PortGroups = append(s.PortGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portGroups\"")
			}
		case "niocBandwidthAllocations":
			if err := func() error {
				s.NiocBandwidthAllocations = make([]NiocBandwidthAllocation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NiocBandwidthAllocation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NiocBandwidthAllocations = append(s.NiocBandwidthAllocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"niocBandwidthAllocations\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "nsxtSwitchConfig":
			if err := func() error {
				s.NsxtSwitchConfig.Reset()
				if err := s.NsxtSwitchConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtSwitchConfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vds")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVds) {
					name = jsonFieldsNameOfVds[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VdsConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VdsConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.PortGroups != nil {
			e.FieldStart("portGroups")
			e.ArrStart()
			for _, elem := range s.PortGroups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NsxtSwitchConfig.Set {
			e.FieldStart("nsxtSwitchConfig")
			s.NsxtSwitchConfig.Encode(e)
		}
	}
	{
		if s.InventoryMismatchInfo != nil {
			e.FieldStart("inventoryMismatchInfo")
			e.ArrStart()
			for _, elem := range s.InventoryMismatchInfo {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Uplinks != nil {
			e.FieldStart("uplinks")
			e.ArrStart()
			for _, elem := range s.Uplinks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Mtu.Set {
			e.FieldStart("mtu")
			s.Mtu.Encode(e)
		}
	}
}

var jsonFieldsNameOfVdsConfiguration = [6]string{
	0: "name",
	1: "portGroups",
	2: "nsxtSwitchConfig",
	3: "inventoryMismatchInfo",
	4: "uplinks",
	5: "mtu",
}

// Decode decodes VdsConfiguration from json.
func (s *VdsConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VdsConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "portGroups":
			if err := func() error {
				s.PortGroups = make([]PortgroupConfig, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PortgroupConfig
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PortGroups = append(s.PortGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portGroups\"")
			}
		case "nsxtSwitchConfig":
			if err := func() error {
				s.NsxtSwitchConfig.Reset()
				if err := s.NsxtSwitchConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtSwitchConfig\"")
			}
		case "inventoryMismatchInfo":
			if err := func() error {
				s.InventoryMismatchInfo = make([]InventoryMismatchInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventoryMismatchInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InventoryMismatchInfo = append(s.InventoryMismatchInfo, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventoryMismatchInfo\"")
			}
		case "uplinks":
			if err := func() error {
				s.Uplinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Uplinks = append(s.Uplinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplinks\"")
			}
		case "mtu":
			if err := func() error {
				s.Mtu.Reset()
				if err := s.Mtu.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mtu\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VdsConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VdsConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VdsConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VdsDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VdsDetail) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vdsName")
		e.Str(s.VdsName)
	}
}

var jsonFieldsNameOfVdsDetail = [1]string{
	0: "vdsName",
}

// Decode decodes VdsDetail from json.
func (s *VdsDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VdsDetail to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vdsName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VdsName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VdsDetail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVdsDetail) {
					name = jsonFieldsNameOfVdsDetail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VdsDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VdsDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VdsSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VdsSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.IsUsedByNsxt.Set {
			e.FieldStart("isUsedByNsxt")
			s.IsUsedByNsxt.Encode(e)
		}
	}
	{
		if s.NsxtSwitchConfig.Set {
			e.FieldStart("nsxtSwitchConfig")
			s.NsxtSwitchConfig.Encode(e)
		}
	}
	{
		if s.PortGroupSpecs != nil {
			e.FieldStart("portGroupSpecs")
			e.ArrStart()
			for _, elem := range s.PortGroupSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NiocBandwidthAllocationSpecs != nil {
			e.FieldStart("niocBandwidthAllocationSpecs")
			e.ArrStart()
			for _, elem := range s.NiocBandwidthAllocationSpecs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Mtu.Set {
			e.FieldStart("mtu")
			s.Mtu.Encode(e)
		}
	}
}

var jsonFieldsNameOfVdsSpec = [6]string{
	0: "name",
	1: "isUsedByNsxt",
	2: "nsxtSwitchConfig",
	3: "portGroupSpecs",
	4: "niocBandwidthAllocationSpecs",
	5: "mtu",
}

// Decode decodes VdsSpec from json.
func (s *VdsSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VdsSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "isUsedByNsxt":
			if err := func() error {
				s.IsUsedByNsxt.Reset()
				if err := s.IsUsedByNsxt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isUsedByNsxt\"")
			}
		case "nsxtSwitchConfig":
			if err := func() error {
				s.NsxtSwitchConfig.Reset()
				if err := s.NsxtSwitchConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtSwitchConfig\"")
			}
		case "portGroupSpecs":
			if err := func() error {
				s.PortGroupSpecs = make([]PortgroupSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PortgroupSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PortGroupSpecs = append(s.PortGroupSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portGroupSpecs\"")
			}
		case "niocBandwidthAllocationSpecs":
			if err := func() error {
				s.NiocBandwidthAllocationSpecs = make([]NiocBandwidthAllocationSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NiocBandwidthAllocationSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NiocBandwidthAllocationSpecs = append(s.NiocBandwidthAllocationSpecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"niocBandwidthAllocationSpecs\"")
			}
		case "mtu":
			if err := func() error {
				s.Mtu.Reset()
				if err := s.Mtu.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mtu\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VdsSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVdsSpec) {
					name = jsonFieldsNameOfVdsSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VdsSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VdsSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VdsUplinkToNsxUplinkConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VdsUplinkToNsxUplinkConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.VdsUplinkName.Set {
			e.FieldStart("vdsUplinkName")
			s.VdsUplinkName.Encode(e)
		}
	}
	{
		if s.NsxUplinkName.Set {
			e.FieldStart("nsxUplinkName")
			s.NsxUplinkName.Encode(e)
		}
	}
}

var jsonFieldsNameOfVdsUplinkToNsxUplinkConfiguration = [2]string{
	0: "vdsUplinkName",
	1: "nsxUplinkName",
}

// Decode decodes VdsUplinkToNsxUplinkConfiguration from json.
func (s *VdsUplinkToNsxUplinkConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VdsUplinkToNsxUplinkConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vdsUplinkName":
			if err := func() error {
				s.VdsUplinkName.Reset()
				if err := s.VdsUplinkName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsUplinkName\"")
			}
		case "nsxUplinkName":
			if err := func() error {
				s.NsxUplinkName.Reset()
				if err := s.NsxUplinkName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxUplinkName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VdsUplinkToNsxUplinkConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VdsUplinkToNsxUplinkConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VdsUplinkToNsxUplinkConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Version) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Version) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("displayVersion")
		e.Str(s.DisplayVersion)
	}
}

var jsonFieldsNameOfVersion = [2]string{
	0: "version",
	1: "displayVersion",
}

// Decode decodes Version from json.
func (s *Version) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Version to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "displayVersion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DisplayVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Version")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVersion) {
					name = jsonFieldsNameOfVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Version) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Version) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VersionAliasesForBundleComponentType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VersionAliasesForBundleComponentType) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bundleComponentType")
		e.Str(s.BundleComponentType)
	}
	{
		e.FieldStart("versionAliases")
		e.ArrStart()
		for _, elem := range s.VersionAliases {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfVersionAliasesForBundleComponentType = [2]string{
	0: "bundleComponentType",
	1: "versionAliases",
}

// Decode decodes VersionAliasesForBundleComponentType from json.
func (s *VersionAliasesForBundleComponentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionAliasesForBundleComponentType to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bundleComponentType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BundleComponentType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundleComponentType\"")
			}
		case "versionAliases":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.VersionAliases = make([]BaseAlias, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BaseAlias
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VersionAliases = append(s.VersionAliases, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versionAliases\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VersionAliasesForBundleComponentType")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVersionAliasesForBundleComponentType) {
					name = jsonFieldsNameOfVersionAliasesForBundleComponentType[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VersionAliasesForBundleComponentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionAliasesForBundleComponentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VersionAliasesForBundleComponentTypeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VersionAliasesForBundleComponentTypeSpec) encodeFields(e *jx.Encoder) {
	{
		if s.VersionAliasesForBundleComponentTypes != nil {
			e.FieldStart("versionAliasesForBundleComponentTypes")
			e.ArrStart()
			for _, elem := range s.VersionAliasesForBundleComponentTypes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ForceUpdate.Set {
			e.FieldStart("forceUpdate")
			s.ForceUpdate.Encode(e)
		}
	}
	{
		if s.TargetVcfVersion.Set {
			e.FieldStart("targetVcfVersion")
			s.TargetVcfVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfVersionAliasesForBundleComponentTypeSpec = [3]string{
	0: "versionAliasesForBundleComponentTypes",
	1: "forceUpdate",
	2: "targetVcfVersion",
}

// Decode decodes VersionAliasesForBundleComponentTypeSpec from json.
func (s *VersionAliasesForBundleComponentTypeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionAliasesForBundleComponentTypeSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "versionAliasesForBundleComponentTypes":
			if err := func() error {
				s.VersionAliasesForBundleComponentTypes = make([]VersionAliasesForBundleComponentType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VersionAliasesForBundleComponentType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VersionAliasesForBundleComponentTypes = append(s.VersionAliasesForBundleComponentTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versionAliasesForBundleComponentTypes\"")
			}
		case "forceUpdate":
			if err := func() error {
				s.ForceUpdate.Reset()
				if err := s.ForceUpdate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forceUpdate\"")
			}
		case "targetVcfVersion":
			if err := func() error {
				s.TargetVcfVersion.Reset()
				if err := s.TargetVcfVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetVcfVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VersionAliasesForBundleComponentTypeSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VersionAliasesForBundleComponentTypeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionAliasesForBundleComponentTypeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VersionApplicability) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VersionApplicability) encodeFields(e *jx.Encoder) {
	{
		if s.ProductType.Set {
			e.FieldStart("productType")
			s.ProductType.Encode(e)
		}
	}
	{
		if s.MinVersion.Set {
			e.FieldStart("minVersion")
			s.MinVersion.Encode(e)
		}
	}
	{
		if s.MaxVersion.Set {
			e.FieldStart("maxVersion")
			s.MaxVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfVersionApplicability = [3]string{
	0: "productType",
	1: "minVersion",
	2: "maxVersion",
}

// Decode decodes VersionApplicability from json.
func (s *VersionApplicability) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionApplicability to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "productType":
			if err := func() error {
				s.ProductType.Reset()
				if err := s.ProductType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productType\"")
			}
		case "minVersion":
			if err := func() error {
				s.MinVersion.Reset()
				if err := s.MinVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minVersion\"")
			}
		case "maxVersion":
			if err := func() error {
				s.MaxVersion.Reset()
				if err := s.MaxVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VersionApplicability")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VersionApplicability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionApplicability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VmNic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VmNic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("vdsName")
		e.Str(s.VdsName)
	}
	{
		if s.MoveToNvds.Set {
			e.FieldStart("moveToNvds")
			s.MoveToNvds.Encode(e)
		}
	}
	{
		if s.Uplink.Set {
			e.FieldStart("uplink")
			s.Uplink.Encode(e)
		}
	}
}

var jsonFieldsNameOfVmNic = [4]string{
	0: "id",
	1: "vdsName",
	2: "moveToNvds",
	3: "uplink",
}

// Decode decodes VmNic from json.
func (s *VmNic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VmNic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "vdsName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VdsName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vdsName\"")
			}
		case "moveToNvds":
			if err := func() error {
				s.MoveToNvds.Reset()
				if err := s.MoveToNvds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moveToNvds\"")
			}
		case "uplink":
			if err := func() error {
				s.Uplink.Reset()
				if err := s.Uplink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VmNic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVmNic) {
					name = jsonFieldsNameOfVmNic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VmNic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VmNic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VmfsDatastoreSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VmfsDatastoreSpec) encodeFields(e *jx.Encoder) {
	{
		if s.FcSpec != nil {
			e.FieldStart("fcSpec")
			e.ArrStart()
			for _, elem := range s.FcSpec {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfVmfsDatastoreSpec = [1]string{
	0: "fcSpec",
}

// Decode decodes VmfsDatastoreSpec from json.
func (s *VmfsDatastoreSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VmfsDatastoreSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fcSpec":
			if err := func() error {
				s.FcSpec = make([]FcSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FcSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FcSpec = append(s.FcSpec, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fcSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VmfsDatastoreSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VmfsDatastoreSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VmfsDatastoreSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VmnicToUplink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VmnicToUplink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("uplink")
		e.Str(s.Uplink)
	}
}

var jsonFieldsNameOfVmnicToUplink = [2]string{
	0: "id",
	1: "uplink",
}

// Decode decodes VmnicToUplink from json.
func (s *VmnicToUplink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VmnicToUplink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "uplink":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Uplink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VmnicToUplink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVmnicToUplink) {
					name = jsonFieldsNameOfVmnicToUplink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VmnicToUplink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VmnicToUplink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vra) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vra) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.LoadBalancerFqdn.Set {
			e.FieldStart("loadBalancerFqdn")
			s.LoadBalancerFqdn.Encode(e)
		}
	}
	{
		if s.LoadBalancerIpAddress.Set {
			e.FieldStart("loadBalancerIpAddress")
			s.LoadBalancerIpAddress.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Nodes != nil {
			e.FieldStart("nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfVra = [6]string{
	0: "id",
	1: "version",
	2: "loadBalancerFqdn",
	3: "loadBalancerIpAddress",
	4: "status",
	5: "nodes",
}

// Decode decodes Vra from json.
func (s *Vra) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vra to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "loadBalancerFqdn":
			if err := func() error {
				s.LoadBalancerFqdn.Reset()
				if err := s.LoadBalancerFqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerFqdn\"")
			}
		case "loadBalancerIpAddress":
			if err := func() error {
				s.LoadBalancerIpAddress.Reset()
				if err := s.LoadBalancerIpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerIpAddress\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "nodes":
			if err := func() error {
				s.Nodes = make([]VrealizeProductNode, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VrealizeProductNode
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vra")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vra) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vra) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VrealizeProductNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VrealizeProductNode) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("fqdn")
		e.Str(s.Fqdn)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("ipAddress")
		e.Str(s.IpAddress)
	}
}

var jsonFieldsNameOfVrealizeProductNode = [4]string{
	0: "id",
	1: "fqdn",
	2: "type",
	3: "ipAddress",
}

// Decode decodes VrealizeProductNode from json.
func (s *VrealizeProductNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VrealizeProductNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "fqdn":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Fqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "ipAddress":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.IpAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VrealizeProductNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVrealizeProductNode) {
					name = jsonFieldsNameOfVrealizeProductNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VrealizeProductNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VrealizeProductNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VrealizeProductNodeType as json.
func (s VrealizeProductNodeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VrealizeProductNodeType from json.
func (s *VrealizeProductNodeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VrealizeProductNodeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VrealizeProductNodeType(v) {
	case VrealizeProductNodeTypeMASTER:
		*s = VrealizeProductNodeTypeMASTER
	case VrealizeProductNodeTypeREPLICA:
		*s = VrealizeProductNodeTypeREPLICA
	case VrealizeProductNodeTypeDATA:
		*s = VrealizeProductNodeTypeDATA
	case VrealizeProductNodeTypeREMOTECOLLECTOR:
		*s = VrealizeProductNodeTypeREMOTECOLLECTOR
	case VrealizeProductNodeTypeWORKER:
		*s = VrealizeProductNodeTypeWORKER
	default:
		*s = VrealizeProductNodeType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VrealizeProductNodeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VrealizeProductNodeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vrli) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vrli) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.LoadBalancerFqdn.Set {
			e.FieldStart("loadBalancerFqdn")
			s.LoadBalancerFqdn.Encode(e)
		}
	}
	{
		if s.LoadBalancerIpAddress.Set {
			e.FieldStart("loadBalancerIpAddress")
			s.LoadBalancerIpAddress.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Nodes != nil {
			e.FieldStart("nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfVrli = [6]string{
	0: "id",
	1: "version",
	2: "loadBalancerFqdn",
	3: "loadBalancerIpAddress",
	4: "status",
	5: "nodes",
}

// Decode decodes Vrli from json.
func (s *Vrli) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vrli to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "loadBalancerFqdn":
			if err := func() error {
				s.LoadBalancerFqdn.Reset()
				if err := s.LoadBalancerFqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerFqdn\"")
			}
		case "loadBalancerIpAddress":
			if err := func() error {
				s.LoadBalancerIpAddress.Reset()
				if err := s.LoadBalancerIpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerIpAddress\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "nodes":
			if err := func() error {
				s.Nodes = make([]VrealizeProductNode, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VrealizeProductNode
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vrli")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vrli) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vrli) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vrops) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vrops) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("loadBalancerFqdn")
		e.Str(s.LoadBalancerFqdn)
	}
	{
		e.FieldStart("loadBalancerIp")
		e.Str(s.LoadBalancerIp)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfVrops = [6]string{
	0: "id",
	1: "version",
	2: "nodes",
	3: "loadBalancerFqdn",
	4: "loadBalancerIp",
	5: "status",
}

// Decode decodes Vrops from json.
func (s *Vrops) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vrops to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "nodes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Nodes = make([]VropsNode, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VropsNode
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "loadBalancerFqdn":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LoadBalancerFqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerFqdn\"")
			}
		case "loadBalancerIp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LoadBalancerIp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerIp\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vrops")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVrops) {
					name = jsonFieldsNameOfVrops[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vrops) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vrops) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VropsNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VropsNode) encodeFields(e *jx.Encoder) {
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("fqdn")
		e.Str(s.Fqdn)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("ipAddress")
		e.Str(s.IpAddress)
	}
}

var jsonFieldsNameOfVropsNode = [7]string{
	0: "username",
	1: "password",
	2: "status",
	3: "id",
	4: "fqdn",
	5: "type",
	6: "ipAddress",
}

// Decode decodes VropsNode from json.
func (s *VropsNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VropsNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "fqdn":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Fqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "ipAddress":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IpAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VropsNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01010100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVropsNode) {
					name = jsonFieldsNameOfVropsNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VropsNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VropsNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VropsNodeType as json.
func (s VropsNodeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VropsNodeType from json.
func (s *VropsNodeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VropsNodeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VropsNodeType(v) {
	case VropsNodeTypeMASTER:
		*s = VropsNodeTypeMASTER
	case VropsNodeTypeREPLICA:
		*s = VropsNodeTypeREPLICA
	case VropsNodeTypeDATA:
		*s = VropsNodeTypeDATA
	case VropsNodeTypeREMOTECOLLECTOR:
		*s = VropsNodeTypeREMOTECOLLECTOR
	case VropsNodeTypeWORKER:
		*s = VropsNodeTypeWORKER
	default:
		*s = VropsNodeType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VropsNodeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VropsNodeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vrslcm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vrslcm) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("fqdn")
		e.Str(s.Fqdn)
	}
	{
		e.FieldStart("ipAddress")
		e.Str(s.IpAddress)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfVrslcm = [5]string{
	0: "id",
	1: "fqdn",
	2: "ipAddress",
	3: "version",
	4: "status",
}

// Decode decodes Vrslcm from json.
func (s *Vrslcm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vrslcm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "fqdn":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Fqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "ipAddress":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IpAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vrslcm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVrslcm) {
					name = jsonFieldsNameOfVrslcm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vrslcm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vrslcm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VrslcmDeploymentSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VrslcmDeploymentSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fqdn")
		e.Str(s.Fqdn)
	}
	{
		e.FieldStart("sshPassword")
		e.Str(s.SshPassword)
	}
	{
		e.FieldStart("apiPassword")
		e.Str(s.ApiPassword)
	}
	{
		e.FieldStart("nsxtStandaloneTier1Ip")
		e.Str(s.NsxtStandaloneTier1Ip)
	}
}

var jsonFieldsNameOfVrslcmDeploymentSpec = [4]string{
	0: "fqdn",
	1: "sshPassword",
	2: "apiPassword",
	3: "nsxtStandaloneTier1Ip",
}

// Decode decodes VrslcmDeploymentSpec from json.
func (s *VrslcmDeploymentSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VrslcmDeploymentSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fqdn":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Fqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "sshPassword":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SshPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sshPassword\"")
			}
		case "apiPassword":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ApiPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiPassword\"")
			}
		case "nsxtStandaloneTier1Ip":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NsxtStandaloneTier1Ip = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsxtStandaloneTier1Ip\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VrslcmDeploymentSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVrslcmDeploymentSpec) {
					name = jsonFieldsNameOfVrslcmDeploymentSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VrslcmDeploymentSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VrslcmDeploymentSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VrslcmOperationStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VrslcmOperationStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("operationState")
		e.Str(s.OperationState)
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfVrslcmOperationStatus = [4]string{
	0: "name",
	1: "operationState",
	2: "errorCode",
	3: "message",
}

// Decode decodes VrslcmOperationStatus from json.
func (s *VrslcmOperationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VrslcmOperationStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "operationState":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OperationState = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationState\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VrslcmOperationStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVrslcmOperationStatus) {
					name = jsonFieldsNameOfVrslcmOperationStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VrslcmOperationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VrslcmOperationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VrslcmStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VrslcmStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		if s.Operations != nil {
			e.FieldStart("operations")
			e.ArrStart()
			for _, elem := range s.Operations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfVrslcmStatus = [2]string{
	0: "state",
	1: "operations",
}

// Decode decodes VrslcmStatus from json.
func (s *VrslcmStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VrslcmStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "operations":
			if err := func() error {
				s.Operations = make([]VrslcmOperationStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VrslcmOperationStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VrslcmStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVrslcmStatus) {
					name = jsonFieldsNameOfVrslcmStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VrslcmStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VrslcmStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VsanDatastoreSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VsanDatastoreSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("datastoreName")
		e.Str(s.DatastoreName)
	}
	{
		if s.FailuresToTolerate.Set {
			e.FieldStart("failuresToTolerate")
			s.FailuresToTolerate.Encode(e)
		}
	}
	{
		if s.LicenseKey.Set {
			e.FieldStart("licenseKey")
			s.LicenseKey.Encode(e)
		}
	}
	{
		if s.DedupAndCompressionEnabled.Set {
			e.FieldStart("dedupAndCompressionEnabled")
			s.DedupAndCompressionEnabled.Encode(e)
		}
	}
	{
		if s.EsaConfig.Set {
			e.FieldStart("esaConfig")
			s.EsaConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfVsanDatastoreSpec = [5]string{
	0: "datastoreName",
	1: "failuresToTolerate",
	2: "licenseKey",
	3: "dedupAndCompressionEnabled",
	4: "esaConfig",
}

// Decode decodes VsanDatastoreSpec from json.
func (s *VsanDatastoreSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VsanDatastoreSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "datastoreName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatastoreName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datastoreName\"")
			}
		case "failuresToTolerate":
			if err := func() error {
				s.FailuresToTolerate.Reset()
				if err := s.FailuresToTolerate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failuresToTolerate\"")
			}
		case "licenseKey":
			if err := func() error {
				s.LicenseKey.Reset()
				if err := s.LicenseKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKey\"")
			}
		case "dedupAndCompressionEnabled":
			if err := func() error {
				s.DedupAndCompressionEnabled.Reset()
				if err := s.DedupAndCompressionEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dedupAndCompressionEnabled\"")
			}
		case "esaConfig":
			if err := func() error {
				s.EsaConfig.Reset()
				if err := s.EsaConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"esaConfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VsanDatastoreSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVsanDatastoreSpec) {
					name = jsonFieldsNameOfVsanDatastoreSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VsanDatastoreSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VsanDatastoreSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VsanEsaConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VsanEsaConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfVsanEsaConfig = [1]string{
	0: "enabled",
}

// Decode decodes VsanEsaConfig from json.
func (s *VsanEsaConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VsanEsaConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VsanEsaConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VsanEsaConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VsanEsaConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VsanHclAttributes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VsanHclAttributes) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("remoteDataTimestamp")
		e.Int64(s.RemoteDataTimestamp)
	}
	{
		e.FieldStart("localDataTimestamp")
		e.Int64(s.LocalDataTimestamp)
	}
	{
		if s.LastError.Set {
			e.FieldStart("lastError")
			s.LastError.Encode(e)
		}
	}
	{
		if s.IsLocalDataMissing.Set {
			e.FieldStart("isLocalDataMissing")
			s.IsLocalDataMissing.Encode(e)
		}
	}
	{
		if s.IsNewDataAvailable.Set {
			e.FieldStart("isNewDataAvailable")
			s.IsNewDataAvailable.Encode(e)
		}
	}
	{
		if s.IsWarningThresholdExceeded.Set {
			e.FieldStart("isWarningThresholdExceeded")
			s.IsWarningThresholdExceeded.Encode(e)
		}
	}
	{
		if s.IsErrorThresholdExceeded.Set {
			e.FieldStart("isErrorThresholdExceeded")
			s.IsErrorThresholdExceeded.Encode(e)
		}
	}
	{
		if s.LocalDataTime.Set {
			e.FieldStart("localDataTime")
			s.LocalDataTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfVsanHclAttributes = [8]string{
	0: "remoteDataTimestamp",
	1: "localDataTimestamp",
	2: "lastError",
	3: "isLocalDataMissing",
	4: "isNewDataAvailable",
	5: "isWarningThresholdExceeded",
	6: "isErrorThresholdExceeded",
	7: "localDataTime",
}

// Decode decodes VsanHclAttributes from json.
func (s *VsanHclAttributes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VsanHclAttributes to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remoteDataTimestamp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.RemoteDataTimestamp = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remoteDataTimestamp\"")
			}
		case "localDataTimestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.LocalDataTimestamp = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localDataTimestamp\"")
			}
		case "lastError":
			if err := func() error {
				s.LastError.Reset()
				if err := s.LastError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastError\"")
			}
		case "isLocalDataMissing":
			if err := func() error {
				s.IsLocalDataMissing.Reset()
				if err := s.IsLocalDataMissing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isLocalDataMissing\"")
			}
		case "isNewDataAvailable":
			if err := func() error {
				s.IsNewDataAvailable.Reset()
				if err := s.IsNewDataAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNewDataAvailable\"")
			}
		case "isWarningThresholdExceeded":
			if err := func() error {
				s.IsWarningThresholdExceeded.Reset()
				if err := s.IsWarningThresholdExceeded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isWarningThresholdExceeded\"")
			}
		case "isErrorThresholdExceeded":
			if err := func() error {
				s.IsErrorThresholdExceeded.Reset()
				if err := s.IsErrorThresholdExceeded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isErrorThresholdExceeded\"")
			}
		case "localDataTime":
			if err := func() error {
				s.LocalDataTime.Reset()
				if err := s.LocalDataTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localDataTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VsanHclAttributes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVsanHclAttributes) {
					name = jsonFieldsNameOfVsanHclAttributes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VsanHclAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VsanHclAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VsanHclConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VsanHclConfiguration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("autoDownloadEnabled")
		e.Bool(s.AutoDownloadEnabled)
	}
	{
		e.FieldStart("outOfDateErrorThreshold")
		e.Int32(s.OutOfDateErrorThreshold)
	}
	{
		e.FieldStart("outOfDateWarningThreshold")
		e.Int32(s.OutOfDateWarningThreshold)
	}
	{
		e.FieldStart("pollingInterval")
		e.Int64(s.PollingInterval)
	}
	{
		e.FieldStart("pollingEnabled")
		e.Bool(s.PollingEnabled)
	}
}

var jsonFieldsNameOfVsanHclConfiguration = [5]string{
	0: "autoDownloadEnabled",
	1: "outOfDateErrorThreshold",
	2: "outOfDateWarningThreshold",
	3: "pollingInterval",
	4: "pollingEnabled",
}

// Decode decodes VsanHclConfiguration from json.
func (s *VsanHclConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VsanHclConfiguration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "autoDownloadEnabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.AutoDownloadEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoDownloadEnabled\"")
			}
		case "outOfDateErrorThreshold":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.OutOfDateErrorThreshold = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outOfDateErrorThreshold\"")
			}
		case "outOfDateWarningThreshold":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.OutOfDateWarningThreshold = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outOfDateWarningThreshold\"")
			}
		case "pollingInterval":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.PollingInterval = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pollingInterval\"")
			}
		case "pollingEnabled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.PollingEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pollingEnabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VsanHclConfiguration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVsanHclConfiguration) {
					name = jsonFieldsNameOfVsanHclConfiguration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VsanHclConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VsanHclConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VsanMaxConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VsanMaxConfig) encodeFields(e *jx.Encoder) {
	{
		if s.EnableVsanMax.Set {
			e.FieldStart("enableVsanMax")
			s.EnableVsanMax.Encode(e)
		}
	}
}

var jsonFieldsNameOfVsanMaxConfig = [1]string{
	0: "enableVsanMax",
}

// Decode decodes VsanMaxConfig from json.
func (s *VsanMaxConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VsanMaxConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enableVsanMax":
			if err := func() error {
				s.EnableVsanMax.Reset()
				if err := s.EnableVsanMax.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enableVsanMax\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VsanMaxConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VsanMaxConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VsanMaxConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VsanRemoteDatastoreClusterSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VsanRemoteDatastoreClusterSpec) encodeFields(e *jx.Encoder) {
	{
		if s.VsanRemoteDatastoreSpec != nil {
			e.FieldStart("vsanRemoteDatastoreSpec")
			e.ArrStart()
			for _, elem := range s.VsanRemoteDatastoreSpec {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfVsanRemoteDatastoreClusterSpec = [1]string{
	0: "vsanRemoteDatastoreSpec",
}

// Decode decodes VsanRemoteDatastoreClusterSpec from json.
func (s *VsanRemoteDatastoreClusterSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VsanRemoteDatastoreClusterSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vsanRemoteDatastoreSpec":
			if err := func() error {
				s.VsanRemoteDatastoreSpec = make([]VsanRemoteDatastoreSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VsanRemoteDatastoreSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VsanRemoteDatastoreSpec = append(s.VsanRemoteDatastoreSpec, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanRemoteDatastoreSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VsanRemoteDatastoreClusterSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VsanRemoteDatastoreClusterSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VsanRemoteDatastoreClusterSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VsanRemoteDatastoreSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VsanRemoteDatastoreSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("datastoreUuid")
		e.Str(s.DatastoreUuid)
	}
}

var jsonFieldsNameOfVsanRemoteDatastoreSpec = [1]string{
	0: "datastoreUuid",
}

// Decode decodes VsanRemoteDatastoreSpec from json.
func (s *VsanRemoteDatastoreSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VsanRemoteDatastoreSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "datastoreUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatastoreUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datastoreUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VsanRemoteDatastoreSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVsanRemoteDatastoreSpec) {
					name = jsonFieldsNameOfVsanRemoteDatastoreSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VsanRemoteDatastoreSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VsanRemoteDatastoreSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VsanSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VsanSpec) encodeFields(e *jx.Encoder) {
	{
		if s.LicenseFile.Set {
			e.FieldStart("licenseFile")
			s.LicenseFile.Encode(e)
		}
	}
	{
		if s.HclFile.Set {
			e.FieldStart("hclFile")
			s.HclFile.Encode(e)
		}
	}
	{
		if s.DatastoreName.Set {
			e.FieldStart("datastoreName")
			s.DatastoreName.Encode(e)
		}
	}
	{
		if s.VsanDedup.Set {
			e.FieldStart("vsanDedup")
			s.VsanDedup.Encode(e)
		}
	}
	{
		if s.EsaConfig.Set {
			e.FieldStart("esaConfig")
			s.EsaConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfVsanSpec = [5]string{
	0: "licenseFile",
	1: "hclFile",
	2: "datastoreName",
	3: "vsanDedup",
	4: "esaConfig",
}

// Decode decodes VsanSpec from json.
func (s *VsanSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VsanSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "licenseFile":
			if err := func() error {
				s.LicenseFile.Reset()
				if err := s.LicenseFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseFile\"")
			}
		case "hclFile":
			if err := func() error {
				s.HclFile.Reset()
				if err := s.HclFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hclFile\"")
			}
		case "datastoreName":
			if err := func() error {
				s.DatastoreName.Reset()
				if err := s.DatastoreName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datastoreName\"")
			}
		case "vsanDedup":
			if err := func() error {
				s.VsanDedup.Reset()
				if err := s.VsanDedup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanDedup\"")
			}
		case "esaConfig":
			if err := func() error {
				s.EsaConfig.Reset()
				if err := s.EsaConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"esaConfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VsanSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VsanSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VsanSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VvolDatastoreSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VvolDatastoreSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("vasaProviderSpec")
		s.VasaProviderSpec.Encode(e)
	}
}

var jsonFieldsNameOfVvolDatastoreSpec = [2]string{
	0: "name",
	1: "vasaProviderSpec",
}

// Decode decodes VvolDatastoreSpec from json.
func (s *VvolDatastoreSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VvolDatastoreSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "vasaProviderSpec":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.VasaProviderSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vasaProviderSpec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VvolDatastoreSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVvolDatastoreSpec) {
					name = jsonFieldsNameOfVvolDatastoreSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VvolDatastoreSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VvolDatastoreSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VxManagerSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VxManagerSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vxManagerHostName")
		e.Str(s.VxManagerHostName)
	}
	{
		e.FieldStart("defaultRootUserCredentials")
		s.DefaultRootUserCredentials.Encode(e)
	}
	{
		e.FieldStart("defaultAdminUserCredentials")
		s.DefaultAdminUserCredentials.Encode(e)
	}
	{
		if s.SshThumbprint.Set {
			e.FieldStart("sshThumbprint")
			s.SshThumbprint.Encode(e)
		}
	}
	{
		if s.SslThumbprint.Set {
			e.FieldStart("sslThumbprint")
			s.SslThumbprint.Encode(e)
		}
	}
}

var jsonFieldsNameOfVxManagerSpec = [5]string{
	0: "vxManagerHostName",
	1: "defaultRootUserCredentials",
	2: "defaultAdminUserCredentials",
	3: "sshThumbprint",
	4: "sslThumbprint",
}

// Decode decodes VxManagerSpec from json.
func (s *VxManagerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VxManagerSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vxManagerHostName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VxManagerHostName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vxManagerHostName\"")
			}
		case "defaultRootUserCredentials":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DefaultRootUserCredentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultRootUserCredentials\"")
			}
		case "defaultAdminUserCredentials":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DefaultAdminUserCredentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultAdminUserCredentials\"")
			}
		case "sshThumbprint":
			if err := func() error {
				s.SshThumbprint.Reset()
				if err := s.SshThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sshThumbprint\"")
			}
		case "sslThumbprint":
			if err := func() error {
				s.SslThumbprint.Reset()
				if err := s.SslThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sslThumbprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VxManagerSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVxManagerSpec) {
					name = jsonFieldsNameOfVxManagerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VxManagerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VxManagerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VxRailArrayAssociationContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VxRailArrayAssociationContext) encodeFields(e *jx.Encoder) {
	{
		if s.Parent != nil {
			e.FieldStart("parent")
			s.Parent.Encode(e)
		}
	}
	{
		if s.ArrayAttributeIdsKeyValue.Set {
			e.FieldStart("arrayAttributeIdsKeyValue")
			s.ArrayAttributeIdsKeyValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfVxRailArrayAssociationContext = [2]string{
	0: "parent",
	1: "arrayAttributeIdsKeyValue",
}

// Decode decodes VxRailArrayAssociationContext from json.
func (s *VxRailArrayAssociationContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VxRailArrayAssociationContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parent":
			if err := func() error {
				s.Parent = nil
				var elem VxRailArrayAssociationContext
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parent = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent\"")
			}
		case "arrayAttributeIdsKeyValue":
			if err := func() error {
				s.ArrayAttributeIdsKeyValue.Reset()
				if err := s.ArrayAttributeIdsKeyValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arrayAttributeIdsKeyValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VxRailArrayAssociationContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VxRailArrayAssociationContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VxRailArrayAssociationContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s VxRailArrayAssociationContextArrayAttributeIdsKeyValue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s VxRailArrayAssociationContextArrayAttributeIdsKeyValue) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes VxRailArrayAssociationContextArrayAttributeIdsKeyValue from json.
func (s *VxRailArrayAssociationContextArrayAttributeIdsKeyValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VxRailArrayAssociationContextArrayAttributeIdsKeyValue to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VxRailArrayAssociationContextArrayAttributeIdsKeyValue")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VxRailArrayAssociationContextArrayAttributeIdsKeyValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VxRailArrayAssociationContextArrayAttributeIdsKeyValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VxRailContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VxRailContext) encodeFields(e *jx.Encoder) {
	{
		if s.AttributeName.Set {
			e.FieldStart("attributeName")
			s.AttributeName.Encode(e)
		}
	}
	{
		if s.Datatype.Set {
			e.FieldStart("datatype")
			s.Datatype.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfVxRailContext = [3]string{
	0: "attributeName",
	1: "datatype",
	2: "value",
}

// Decode decodes VxRailContext from json.
func (s *VxRailContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VxRailContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attributeName":
			if err := func() error {
				s.AttributeName.Reset()
				if err := s.AttributeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributeName\"")
			}
		case "datatype":
			if err := func() error {
				s.Datatype.Reset()
				if err := s.Datatype.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datatype\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VxRailContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VxRailContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VxRailContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VxRailContextDatatype as json.
func (s VxRailContextDatatype) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VxRailContextDatatype from json.
func (s *VxRailContextDatatype) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VxRailContextDatatype to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VxRailContextDatatype(v) {
	case VxRailContextDatatypeINTEGER:
		*s = VxRailContextDatatypeINTEGER
	case VxRailContextDatatypeBOOLEAN:
		*s = VxRailContextDatatypeBOOLEAN
	case VxRailContextDatatypeSTRING:
		*s = VxRailContextDatatypeSTRING
	default:
		*s = VxRailContextDatatype(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VxRailContextDatatype) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VxRailContextDatatype) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VxRailCustomArrayContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VxRailCustomArrayContext) encodeFields(e *jx.Encoder) {
	{
		if s.ArrayAssociationContext.Set {
			e.FieldStart("arrayAssociationContext")
			s.ArrayAssociationContext.Encode(e)
		}
	}
	{
		if s.SimpleAttributes != nil {
			e.FieldStart("simpleAttributes")
			e.ArrStart()
			for _, elem := range s.SimpleAttributes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfVxRailCustomArrayContext = [2]string{
	0: "arrayAssociationContext",
	1: "simpleAttributes",
}

// Decode decodes VxRailCustomArrayContext from json.
func (s *VxRailCustomArrayContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VxRailCustomArrayContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "arrayAssociationContext":
			if err := func() error {
				s.ArrayAssociationContext.Reset()
				if err := s.ArrayAssociationContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arrayAssociationContext\"")
			}
		case "simpleAttributes":
			if err := func() error {
				s.SimpleAttributes = make([]VxRailContext, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VxRailContext
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SimpleAttributes = append(s.SimpleAttributes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"simpleAttributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VxRailCustomArrayContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VxRailCustomArrayContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VxRailCustomArrayContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VxRailDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VxRailDetails) encodeFields(e *jx.Encoder) {
	{
		if s.RootCredentials.Set {
			e.FieldStart("rootCredentials")
			s.RootCredentials.Encode(e)
		}
	}
	{
		if s.AdminCredentials.Set {
			e.FieldStart("adminCredentials")
			s.AdminCredentials.Encode(e)
		}
	}
	{
		if s.SshThumbprint.Set {
			e.FieldStart("sshThumbprint")
			s.SshThumbprint.Encode(e)
		}
	}
	{
		if s.SslThumbprint.Set {
			e.FieldStart("sslThumbprint")
			s.SslThumbprint.Encode(e)
		}
	}
	{
		e.FieldStart("networks")
		e.ArrStart()
		for _, elem := range s.Networks {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.IpAddress.Set {
			e.FieldStart("ipAddress")
			s.IpAddress.Encode(e)
		}
	}
	{
		if s.DnsName.Set {
			e.FieldStart("dnsName")
			s.DnsName.Encode(e)
		}
	}
	{
		if s.NicProfile.Set {
			e.FieldStart("nicProfile")
			s.NicProfile.Encode(e)
		}
	}
	{
		if s.ContextWithKeyValuePair.Set {
			e.FieldStart("contextWithKeyValuePair")
			s.ContextWithKeyValuePair.Encode(e)
		}
	}
	{
		if s.ArrayContextWithKeyValuePair.Set {
			e.FieldStart("arrayContextWithKeyValuePair")
			s.ArrayContextWithKeyValuePair.Encode(e)
		}
	}
}

var jsonFieldsNameOfVxRailDetails = [10]string{
	0: "rootCredentials",
	1: "adminCredentials",
	2: "sshThumbprint",
	3: "sslThumbprint",
	4: "networks",
	5: "ipAddress",
	6: "dnsName",
	7: "nicProfile",
	8: "contextWithKeyValuePair",
	9: "arrayContextWithKeyValuePair",
}

// Decode decodes VxRailDetails from json.
func (s *VxRailDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VxRailDetails to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rootCredentials":
			if err := func() error {
				s.RootCredentials.Reset()
				if err := s.RootCredentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rootCredentials\"")
			}
		case "adminCredentials":
			if err := func() error {
				s.AdminCredentials.Reset()
				if err := s.AdminCredentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adminCredentials\"")
			}
		case "sshThumbprint":
			if err := func() error {
				s.SshThumbprint.Reset()
				if err := s.SshThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sshThumbprint\"")
			}
		case "sslThumbprint":
			if err := func() error {
				s.SslThumbprint.Reset()
				if err := s.SslThumbprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sslThumbprint\"")
			}
		case "networks":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Networks = make([]Network, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Network
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Networks = append(s.Networks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networks\"")
			}
		case "ipAddress":
			if err := func() error {
				s.IpAddress.Reset()
				if err := s.IpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAddress\"")
			}
		case "dnsName":
			if err := func() error {
				s.DnsName.Reset()
				if err := s.DnsName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dnsName\"")
			}
		case "nicProfile":
			if err := func() error {
				s.NicProfile.Reset()
				if err := s.NicProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nicProfile\"")
			}
		case "contextWithKeyValuePair":
			if err := func() error {
				s.ContextWithKeyValuePair.Reset()
				if err := s.ContextWithKeyValuePair.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextWithKeyValuePair\"")
			}
		case "arrayContextWithKeyValuePair":
			if err := func() error {
				s.ArrayContextWithKeyValuePair.Reset()
				if err := s.ArrayContextWithKeyValuePair.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arrayContextWithKeyValuePair\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VxRailDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVxRailDetails) {
					name = jsonFieldsNameOfVxRailDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VxRailDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VxRailDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s VxRailDetailsArrayContextWithKeyValuePair) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s VxRailDetailsArrayContextWithKeyValuePair) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes VxRailDetailsArrayContextWithKeyValuePair from json.
func (s *VxRailDetailsArrayContextWithKeyValuePair) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VxRailDetailsArrayContextWithKeyValuePair to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []VxRailCustomArrayContext
		if err := func() error {
			elem = make([]VxRailCustomArrayContext, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem VxRailCustomArrayContext
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VxRailDetailsArrayContextWithKeyValuePair")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VxRailDetailsArrayContextWithKeyValuePair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VxRailDetailsArrayContextWithKeyValuePair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s VxRailDetailsContextWithKeyValuePair) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s VxRailDetailsContextWithKeyValuePair) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes VxRailDetailsContextWithKeyValuePair from json.
func (s *VxRailDetailsContextWithKeyValuePair) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VxRailDetailsContextWithKeyValuePair to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []VxRailContext
		if err := func() error {
			elem = make([]VxRailContext, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem VxRailContext
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VxRailDetailsContextWithKeyValuePair")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VxRailDetailsContextWithKeyValuePair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VxRailDetailsContextWithKeyValuePair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WitnessSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WitnessSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vsanIp")
		e.Str(s.VsanIp)
	}
	{
		e.FieldStart("fqdn")
		e.Str(s.Fqdn)
	}
	{
		e.FieldStart("vsanCidr")
		e.Str(s.VsanCidr)
	}
}

var jsonFieldsNameOfWitnessSpec = [3]string{
	0: "vsanIp",
	1: "fqdn",
	2: "vsanCidr",
}

// Decode decodes WitnessSpec from json.
func (s *WitnessSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WitnessSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vsanIp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VsanIp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanIp\"")
			}
		case "fqdn":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Fqdn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fqdn\"")
			}
		case "vsanCidr":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VsanCidr = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsanCidr\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WitnessSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWitnessSpec) {
					name = jsonFieldsNameOfWitnessSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WitnessSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WitnessSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Wsa) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Wsa) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.LoadBalancerFqdn.Set {
			e.FieldStart("loadBalancerFqdn")
			s.LoadBalancerFqdn.Encode(e)
		}
	}
	{
		if s.LoadBalancerIpAddress.Set {
			e.FieldStart("loadBalancerIpAddress")
			s.LoadBalancerIpAddress.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Nodes != nil {
			e.FieldStart("nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfWsa = [6]string{
	0: "id",
	1: "version",
	2: "loadBalancerFqdn",
	3: "loadBalancerIpAddress",
	4: "status",
	5: "nodes",
}

// Decode decodes Wsa from json.
func (s *Wsa) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Wsa to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "loadBalancerFqdn":
			if err := func() error {
				s.LoadBalancerFqdn.Reset()
				if err := s.LoadBalancerFqdn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerFqdn\"")
			}
		case "loadBalancerIpAddress":
			if err := func() error {
				s.LoadBalancerIpAddress.Reset()
				if err := s.LoadBalancerIpAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerIpAddress\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "nodes":
			if err := func() error {
				s.Nodes = make([]VrealizeProductNode, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VrealizeProductNode
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Wsa")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Wsa) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Wsa) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
