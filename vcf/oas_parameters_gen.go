// Code generated by ogen, DO NOT EDIT.

package vcf

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// AddDatastoreToClusterParams is parameters of addDatastoreToCluster operation.
type AddDatastoreToClusterParams struct {
	// Cluster ID.
	ID string
}

func unpackAddDatastoreToClusterParams(packed middleware.Parameters) (params AddDatastoreToClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeAddDatastoreToClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params AddDatastoreToClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// AddIpPoolToNetworkOfNetworkPoolParams is parameters of addIpPoolToNetworkOfNetworkPool operation.
type AddIpPoolToNetworkOfNetworkPoolParams struct {
	// Id of the networkpoolk.
	ID string
	// Id of the network.
	NetworkId string
}

func unpackAddIpPoolToNetworkOfNetworkPoolParams(packed middleware.Parameters) (params AddIpPoolToNetworkOfNetworkPoolParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "networkId",
			In:   "path",
		}
		params.NetworkId = packed[key].(string)
	}
	return params
}

func decodeAddIpPoolToNetworkOfNetworkPoolParams(args [2]string, argsEscaped bool, r *http.Request) (params AddIpPoolToNetworkOfNetworkPoolParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: networkId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "networkId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.NetworkId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "networkId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// AddVasaProviderStorageContainerParams is parameters of addVasaProviderStorageContainer operation.
type AddVasaProviderStorageContainerParams struct {
	// VASA Provider ID.
	ID string
}

func unpackAddVasaProviderStorageContainerParams(packed middleware.Parameters) (params AddVasaProviderStorageContainerParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeAddVasaProviderStorageContainerParams(args [1]string, argsEscaped bool, r *http.Request) (params AddVasaProviderStorageContainerParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// AddVasaProviderUserParams is parameters of addVasaProviderUser operation.
type AddVasaProviderUserParams struct {
	// VASA Provider ID.
	ID string
}

func unpackAddVasaProviderUserParams(packed middleware.Parameters) (params AddVasaProviderUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeAddVasaProviderUserParams(args [1]string, argsEscaped bool, r *http.Request) (params AddVasaProviderUserParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// AssignTagsToClusterParams is parameters of assignTagsToCluster operation.
type AssignTagsToClusterParams struct {
	// Cluster ID.
	ID string
}

func unpackAssignTagsToClusterParams(packed middleware.Parameters) (params AssignTagsToClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeAssignTagsToClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params AssignTagsToClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// AssignTagsToDomainParams is parameters of assignTagsToDomain operation.
type AssignTagsToDomainParams struct {
	// Domain ID.
	ID string
}

func unpackAssignTagsToDomainParams(packed middleware.Parameters) (params AssignTagsToDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeAssignTagsToDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params AssignTagsToDomainParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// AssignTagsToHostParams is parameters of assignTagsToHost operation.
type AssignTagsToHostParams struct {
	// Host ID.
	ID string
}

func unpackAssignTagsToHostParams(packed middleware.Parameters) (params AssignTagsToHostParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeAssignTagsToHostParams(args [1]string, argsEscaped bool, r *http.Request) (params AssignTagsToHostParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CancelCredentialsTaskParams is parameters of cancelCredentialsTask operation.
type CancelCredentialsTaskParams struct {
	// Task ID of the failed operation required to be cancelled.
	ID string
}

func unpackCancelCredentialsTaskParams(packed middleware.Parameters) (params CancelCredentialsTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeCancelCredentialsTaskParams(args [1]string, argsEscaped bool, r *http.Request) (params CancelCredentialsTaskParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CancelTaskParams is parameters of cancelTask operation.
type CancelTaskParams struct {
	// Task id for cancelling.
	ID string
}

func unpackCancelTaskParams(packed middleware.Parameters) (params CancelTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeCancelTaskParams(args [1]string, argsEscaped bool, r *http.Request) (params CancelTaskParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ComplianceAuditParams is parameters of complianceAudit operation.
type ComplianceAuditParams struct {
	// ID of the domain.
	ID string
}

func unpackComplianceAuditParams(packed middleware.Parameters) (params ComplianceAuditParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeComplianceAuditParams(args [1]string, argsEscaped bool, r *http.Request) (params ComplianceAuditParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteALBClusterParams is parameters of deleteALBCluster operation.
type DeleteALBClusterParams struct {
	// ALB Cluster ID.
	ID string
	// Force Delete ALB Cluster.
	ForceDelete OptBool
}

func unpackDeleteALBClusterParams(packed middleware.Parameters) (params DeleteALBClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "forceDelete",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceDelete = v.(OptBool)
		}
	}
	return params
}

func decodeDeleteALBClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteALBClusterParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: forceDelete.
	{
		val := bool(false)
		params.ForceDelete.SetTo(val)
	}
	// Decode query: forceDelete.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceDelete",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceDeleteVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceDeleteVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceDelete.SetTo(paramsDotForceDeleteVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceDelete",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteAliasVersionsBySoftwareTypeAndBaseVersionParams is parameters of deleteAliasVersionsBySoftwareTypeAndBaseVersion operation.
type DeleteAliasVersionsBySoftwareTypeAndBaseVersionParams struct {
	// Bundle Component Type.
	BundleComponentType string
	// Version.
	Version string
}

func unpackDeleteAliasVersionsBySoftwareTypeAndBaseVersionParams(packed middleware.Parameters) (params DeleteAliasVersionsBySoftwareTypeAndBaseVersionParams) {
	{
		key := middleware.ParameterKey{
			Name: "bundleComponentType",
			In:   "path",
		}
		params.BundleComponentType = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "version",
			In:   "path",
		}
		params.Version = packed[key].(string)
	}
	return params
}

func decodeDeleteAliasVersionsBySoftwareTypeAndBaseVersionParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteAliasVersionsBySoftwareTypeAndBaseVersionParams, _ error) {
	// Decode path: bundleComponentType.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "bundleComponentType",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BundleComponentType = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "bundleComponentType",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: version.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "version",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Version = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "version",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteBundleParams is parameters of deleteBundle operation.
type DeleteBundleParams struct {
	// Bundle ID.
	ID string
}

func unpackDeleteBundleParams(packed middleware.Parameters) (params DeleteBundleParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteBundleParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteBundleParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteClusterParams is parameters of deleteCluster operation.
type DeleteClusterParams struct {
	// Cluster ID.
	ID string
	// Force deletion of the cluster. Please note when passed true, deletion will ignore vCenter Server
	// connection issues and could possible leave cluster related resources in the vCenter Server if a
	// connection cannot be established.
	Force OptBool
}

func unpackDeleteClusterParams(packed middleware.Parameters) (params DeleteClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "force",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Force = v.(OptBool)
		}
	}
	return params
}

func decodeDeleteClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteClusterParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: force.
	{
		val := bool(false)
		params.Force.SetTo(val)
	}
	// Decode query: force.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "force",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Force.SetTo(paramsDotForceVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "force",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteCustomIsoByIdParams is parameters of deleteCustomIsoById operation.
type DeleteCustomIsoByIdParams struct {
	// Custom ISO image ID.
	CustomIsoID string
}

func unpackDeleteCustomIsoByIdParams(packed middleware.Parameters) (params DeleteCustomIsoByIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "custom_iso_id",
			In:   "path",
		}
		params.CustomIsoID = packed[key].(string)
	}
	return params
}

func decodeDeleteCustomIsoByIdParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteCustomIsoByIdParams, _ error) {
	// Decode path: custom_iso_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "custom_iso_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CustomIsoID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "custom_iso_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteDepotSettingsParams is parameters of deleteDepotSettings operation.
type DeleteDepotSettingsParams struct {
	// Depot type.
	DepotType OptString
}

func unpackDeleteDepotSettingsParams(packed middleware.Parameters) (params DeleteDepotSettingsParams) {
	{
		key := middleware.ParameterKey{
			Name: "depotType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DepotType = v.(OptString)
		}
	}
	return params
}

func decodeDeleteDepotSettingsParams(args [0]string, argsEscaped bool, r *http.Request) (params DeleteDepotSettingsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: depotType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "depotType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDepotTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDepotTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DepotType.SetTo(paramsDotDepotTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "depotType",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteDomainParams is parameters of deleteDomain operation.
type DeleteDomainParams struct {
	// Domain ID.
	ID string
}

func unpackDeleteDomainParams(packed middleware.Parameters) (params DeleteDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDeleteDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteDomainParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteIpPoolFromNetworkOfNetworkPoolParams is parameters of deleteIpPoolFromNetworkOfNetworkPool operation.
type DeleteIpPoolFromNetworkOfNetworkPoolParams struct {
	// ID of the networkpool.
	ID string
	// ID of the network.
	NetworkId string
}

func unpackDeleteIpPoolFromNetworkOfNetworkPoolParams(packed middleware.Parameters) (params DeleteIpPoolFromNetworkOfNetworkPoolParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "networkId",
			In:   "path",
		}
		params.NetworkId = packed[key].(string)
	}
	return params
}

func decodeDeleteIpPoolFromNetworkOfNetworkPoolParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteIpPoolFromNetworkOfNetworkPoolParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: networkId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "networkId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.NetworkId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "networkId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteNetworkPoolParams is parameters of deleteNetworkPool operation.
type DeleteNetworkPoolParams struct {
	// ID of the network pool.
	ID string
	// Force removal of Network Pool.
	Force OptBool
}

func unpackDeleteNetworkPoolParams(packed middleware.Parameters) (params DeleteNetworkPoolParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "force",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Force = v.(OptBool)
		}
	}
	return params
}

func decodeDeleteNetworkPoolParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteNetworkPoolParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: force.
	{
		val := bool(false)
		params.Force.SetTo(val)
	}
	// Decode query: force.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "force",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Force.SetTo(paramsDotForceVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "force",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeletePersonalityParams is parameters of deletePersonality operation.
type DeletePersonalityParams struct {
	// The personality id.
	PersonalityId OptString
	// The personality name.
	PersonalityName OptString
}

func unpackDeletePersonalityParams(packed middleware.Parameters) (params DeletePersonalityParams) {
	{
		key := middleware.ParameterKey{
			Name: "personalityId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PersonalityId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "personalityName",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PersonalityName = v.(OptString)
		}
	}
	return params
}

func decodeDeletePersonalityParams(args [0]string, argsEscaped bool, r *http.Request) (params DeletePersonalityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: personalityId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "personalityId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPersonalityIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPersonalityIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PersonalityId.SetTo(paramsDotPersonalityIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "personalityId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: personalityName.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "personalityName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPersonalityNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPersonalityNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PersonalityName.SetTo(paramsDotPersonalityNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "personalityName",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteReleaseByDomainIDParams is parameters of deleteReleaseByDomainID operation.
type DeleteReleaseByDomainIDParams struct {
	// Domain ID.
	DomainId string
}

func unpackDeleteReleaseByDomainIDParams(packed middleware.Parameters) (params DeleteReleaseByDomainIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodeDeleteReleaseByDomainIDParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteReleaseByDomainIDParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteTrustedCertificateParams is parameters of deleteTrustedCertificate operation.
type DeleteTrustedCertificateParams struct {
	// Certificate Alias.
	Alias string
}

func unpackDeleteTrustedCertificateParams(packed middleware.Parameters) (params DeleteTrustedCertificateParams) {
	{
		key := middleware.ParameterKey{
			Name: "alias",
			In:   "path",
		}
		params.Alias = packed[key].(string)
	}
	return params
}

func decodeDeleteTrustedCertificateParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteTrustedCertificateParams, _ error) {
	// Decode path: alias.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alias",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Alias = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "alias",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteVersionAliasBySoftwareTypeParams is parameters of deleteVersionAliasBySoftwareType operation.
type DeleteVersionAliasBySoftwareTypeParams struct {
	// Bundle Component Type.
	BundleComponentType string
}

func unpackDeleteVersionAliasBySoftwareTypeParams(packed middleware.Parameters) (params DeleteVersionAliasBySoftwareTypeParams) {
	{
		key := middleware.ParameterKey{
			Name: "bundleComponentType",
			In:   "path",
		}
		params.BundleComponentType = packed[key].(string)
	}
	return params
}

func decodeDeleteVersionAliasBySoftwareTypeParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteVersionAliasBySoftwareTypeParams, _ error) {
	// Decode path: bundleComponentType.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "bundleComponentType",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BundleComponentType = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "bundleComponentType",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DomainCreateValidationParams is parameters of domainCreateValidation operation.
type DomainCreateValidationParams struct {
	// VxRail Domain validation id.
	ID uuid.UUID
}

func unpackDomainCreateValidationParams(packed middleware.Parameters) (params DomainCreateValidationParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeDomainCreateValidationParams(args [1]string, argsEscaped bool, r *http.Request) (params DomainCreateValidationParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DownloadCSRParams is parameters of downloadCSR operation.
type DownloadCSRParams struct {
	// Domain ID or Name.
	ID string
}

func unpackDownloadCSRParams(packed middleware.Parameters) (params DownloadCSRParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeDownloadCSRParams(args [1]string, argsEscaped bool, r *http.Request) (params DownloadCSRParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ExportBringupDetailReportParams is parameters of exportBringupDetailReport operation.
type ExportBringupDetailReportParams struct {
	// SDDC ID.
	ID int
	// One among: PDF, CSV.
	Format OptExportBringupDetailReportFormat
}

func unpackExportBringupDetailReportParams(packed middleware.Parameters) (params ExportBringupDetailReportParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "format",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Format = v.(OptExportBringupDetailReportFormat)
		}
	}
	return params
}

func decodeExportBringupDetailReportParams(args [1]string, argsEscaped bool, r *http.Request) (params ExportBringupDetailReportParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           36,
					MaxSet:        true,
					Max:           36,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.ID)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: format.
	{
		val := ExportBringupDetailReportFormat("pdf")
		params.Format.SetTo(val)
	}
	// Decode query: format.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFormatVal ExportBringupDetailReportFormat
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFormatVal = ExportBringupDetailReportFormat(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Format.SetTo(paramsDotFormatVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Format.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "format",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ExportBringupValidationReportParams is parameters of exportBringupValidationReport operation.
type ExportBringupValidationReportParams struct {
	// Bringup validation ID.
	ValidationId int
	// Start time of validation to be put in the report.
	StartTime OptString
	// Current client local time of the the report generation.
	CurClientTime OptString
}

func unpackExportBringupValidationReportParams(packed middleware.Parameters) (params ExportBringupValidationReportParams) {
	{
		key := middleware.ParameterKey{
			Name: "validationId",
			In:   "path",
		}
		params.ValidationId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "startTime",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTime = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "curClientTime",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.CurClientTime = v.(OptString)
		}
	}
	return params
}

func decodeExportBringupValidationReportParams(args [1]string, argsEscaped bool, r *http.Request) (params ExportBringupValidationReportParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: validationId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "validationId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ValidationId = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           36,
					MaxSet:        true,
					Max:           36,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.ValidationId)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "validationId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: startTime.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStartTimeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTime.SetTo(paramsDotStartTimeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startTime",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: curClientTime.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "curClientTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCurClientTimeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCurClientTimeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CurClientTime.SetTo(paramsDotCurClientTimeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "curClientTime",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GenerateCertificatesParams is parameters of generateCertificates operation.
type GenerateCertificatesParams struct {
	// Domain ID or Name.
	ID string
}

func unpackGenerateCertificatesParams(packed middleware.Parameters) (params GenerateCertificatesParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGenerateCertificatesParams(args [1]string, argsEscaped bool, r *http.Request) (params GenerateCertificatesParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GenerateSyncClientTokenParams is parameters of generateSyncClientToken operation.
type GenerateSyncClientTokenParams struct {
	// ID of Identity Provider.
	ID string
	// TTL of the sync client token.
	SyncClientTokenTTL OptInt64
}

func unpackGenerateSyncClientTokenParams(packed middleware.Parameters) (params GenerateSyncClientTokenParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "syncClientTokenTTL",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SyncClientTokenTTL = v.(OptInt64)
		}
	}
	return params
}

func decodeGenerateSyncClientTokenParams(args [1]string, argsEscaped bool, r *http.Request) (params GenerateSyncClientTokenParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: syncClientTokenTTL.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "syncClientTokenTTL",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSyncClientTokenTTLVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotSyncClientTokenTTLVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SyncClientTokenTTL.SetTo(paramsDotSyncClientTokenTTLVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "syncClientTokenTTL",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GeneratesCSRsParams is parameters of generatesCSRs operation.
type GeneratesCSRsParams struct {
	// Domain ID or Name.
	ID string
}

func unpackGeneratesCSRsParams(packed middleware.Parameters) (params GeneratesCSRsParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGeneratesCSRsParams(args [1]string, argsEscaped bool, r *http.Request) (params GeneratesCSRsParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetALBClusterParams is parameters of getALBCluster operation.
type GetALBClusterParams struct {
	// ALB Cluster ID.
	ID string
}

func unpackGetALBClusterParams(packed middleware.Parameters) (params GetALBClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetALBClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params GetALBClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetALBClustersParams is parameters of getALBClusters operation.
type GetALBClustersParams struct {
	// Domain Id.
	DomainId OptString
}

func unpackGetALBClustersParams(packed middleware.Parameters) (params GetALBClustersParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DomainId = v.(OptString)
		}
	}
	return params
}

func decodeGetALBClustersParams(args [0]string, argsEscaped bool, r *http.Request) (params GetALBClustersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: domainId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDomainIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDomainIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DomainId.SetTo(paramsDotDomainIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAssignableTagForHostParams is parameters of getAssignableTagForHost operation.
type GetAssignableTagForHostParams struct {
	// Host ID.
	ID string
}

func unpackGetAssignableTagForHostParams(packed middleware.Parameters) (params GetAssignableTagForHostParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetAssignableTagForHostParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAssignableTagForHostParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAssignableTagsForDomainParams is parameters of getAssignableTagsForDomain operation.
type GetAssignableTagsForDomainParams struct {
	// Domain ID.
	ID string
}

func unpackGetAssignableTagsForDomainParams(packed middleware.Parameters) (params GetAssignableTagsForDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetAssignableTagsForDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAssignableTagsForDomainParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetAvnsParams is parameters of getAvns operation.
type GetAvnsParams struct {
	// Pass an optional AVN region type matching either Region-A or X-Region.
	RegionType OptString
}

func unpackGetAvnsParams(packed middleware.Parameters) (params GetAvnsParams) {
	{
		key := middleware.ParameterKey{
			Name: "regionType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.RegionType = v.(OptString)
		}
	}
	return params
}

func decodeGetAvnsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetAvnsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: regionType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "regionType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRegionTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRegionTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.RegionType.SetTo(paramsDotRegionTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "regionType",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetBackupLocationParams is parameters of getBackupLocation operation.
type GetBackupLocationParams struct {
	// Backup server IP.
	ServerIP string
	// Backup server port.
	Port string
}

func unpackGetBackupLocationParams(packed middleware.Parameters) (params GetBackupLocationParams) {
	{
		key := middleware.ParameterKey{
			Name: "serverIP",
			In:   "query",
		}
		params.ServerIP = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "port",
			In:   "query",
		}
		params.Port = packed[key].(string)
	}
	return params
}

func decodeGetBackupLocationParams(args [0]string, argsEscaped bool, r *http.Request) (params GetBackupLocationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: serverIP.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "serverIP",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ServerIP = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "serverIP",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: port.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "port",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Port = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "port",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetBringupTaskByIDParams is parameters of getBringupTaskByID operation.
type GetBringupTaskByIDParams struct {
	// SDDC ID.
	ID int
}

func unpackGetBringupTaskByIDParams(packed middleware.Parameters) (params GetBringupTaskByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(int)
	}
	return params
}

func decodeGetBringupTaskByIDParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBringupTaskByIDParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           36,
					MaxSet:        true,
					Max:           36,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.ID)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBringupValidationParams is parameters of getBringupValidation operation.
type GetBringupValidationParams struct {
	// SDDC validation ID.
	ID int
}

func unpackGetBringupValidationParams(packed middleware.Parameters) (params GetBringupValidationParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(int)
	}
	return params
}

func decodeGetBringupValidationParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBringupValidationParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           36,
					MaxSet:        true,
					Max:           36,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.ID)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBundleParams is parameters of getBundle operation.
type GetBundleParams struct {
	// Bundle ID.
	ID string
}

func unpackGetBundleParams(packed middleware.Parameters) (params GetBundleParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetBundleParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBundleParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBundlesParams is parameters of getBundles operation.
type GetBundlesParams struct {
	// The type of the product.
	ProductType OptString
	// Is compliant with the current VCF version.
	IsCompliant OptBool
	// The type of the bundle.
	BundleType OptString
}

func unpackGetBundlesParams(packed middleware.Parameters) (params GetBundlesParams) {
	{
		key := middleware.ParameterKey{
			Name: "productType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProductType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "isCompliant",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IsCompliant = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "bundleType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BundleType = v.(OptString)
		}
	}
	return params
}

func decodeGetBundlesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetBundlesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: productType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "productType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProductTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProductTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ProductType.SetTo(paramsDotProductTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "productType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: isCompliant.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "isCompliant",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIsCompliantVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIsCompliantVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IsCompliant.SetTo(paramsDotIsCompliantVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "isCompliant",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: bundleType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "bundleType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBundleTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBundleTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BundleType.SetTo(paramsDotBundleTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "bundleType",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetBundlesForSkipUpgradeParams is parameters of getBundlesForSkipUpgrade operation.
type GetBundlesForSkipUpgradeParams struct {
	// Domain ID.
	ID string
	// [Deprecated] Target domain VCF version.
	TargetVersion OptString
}

func unpackGetBundlesForSkipUpgradeParams(packed middleware.Parameters) (params GetBundlesForSkipUpgradeParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "targetVersion",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TargetVersion = v.(OptString)
		}
	}
	return params
}

func decodeGetBundlesForSkipUpgradeParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBundlesForSkipUpgradeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: targetVersion.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "targetVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTargetVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTargetVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TargetVersion.SetTo(paramsDotTargetVersionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "targetVersion",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetCSRsParams is parameters of getCSRs operation.
type GetCSRsParams struct {
	// Domain ID or Name.
	ID string
}

func unpackGetCSRsParams(packed middleware.Parameters) (params GetCSRsParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetCSRsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCSRsParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCertificateAuthorityByIdParams is parameters of getCertificateAuthorityById operation.
type GetCertificateAuthorityByIdParams struct {
	// The CA type.
	ID string
}

func unpackGetCertificateAuthorityByIdParams(packed middleware.Parameters) (params GetCertificateAuthorityByIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetCertificateAuthorityByIdParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCertificateAuthorityByIdParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCertificatesByDomainParams is parameters of getCertificatesByDomain operation.
type GetCertificatesByDomainParams struct {
	// Domain ID or Name.
	ID string
}

func unpackGetCertificatesByDomainParams(packed middleware.Parameters) (params GetCertificatesByDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetCertificatesByDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCertificatesByDomainParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetClusterParams is parameters of getCluster operation.
type GetClusterParams struct {
	// Cluster ID.
	ID string
}

func unpackGetClusterParams(packed middleware.Parameters) (params GetClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params GetClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetClusterCreateValidationParams is parameters of getClusterCreateValidation operation.
type GetClusterCreateValidationParams struct {
	// Cluster validation workflow id.
	ID uuid.UUID
}

func unpackGetClusterCreateValidationParams(packed middleware.Parameters) (params GetClusterCreateValidationParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetClusterCreateValidationParams(args [1]string, argsEscaped bool, r *http.Request) (params GetClusterCreateValidationParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetClusterCriteriaParams is parameters of getClusterCriteria operation.
type GetClusterCriteriaParams struct {
	// Domain ID.
	DomainId string
}

func unpackGetClusterCriteriaParams(packed middleware.Parameters) (params GetClusterCriteriaParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodeGetClusterCriteriaParams(args [1]string, argsEscaped bool, r *http.Request) (params GetClusterCriteriaParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetClusterCriterionParams is parameters of getClusterCriterion operation.
type GetClusterCriterionParams struct {
	// Domain ID.
	DomainId string
	// Criteria Name.
	Name string
}

func unpackGetClusterCriterionParams(packed middleware.Parameters) (params GetClusterCriterionParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "path",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeGetClusterCriterionParams(args [2]string, argsEscaped bool, r *http.Request) (params GetClusterCriterionParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: name.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetClusterDatastoresParams is parameters of getClusterDatastores operation.
type GetClusterDatastoresParams struct {
	// Cluster ID.
	ID string
}

func unpackGetClusterDatastoresParams(packed middleware.Parameters) (params GetClusterDatastoresParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetClusterDatastoresParams(args [1]string, argsEscaped bool, r *http.Request) (params GetClusterDatastoresParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetClusterNetworkConfigurationParams is parameters of getClusterNetworkConfiguration operation.
type GetClusterNetworkConfigurationParams struct {
	// Cluster ID.
	ID string
}

func unpackGetClusterNetworkConfigurationParams(packed middleware.Parameters) (params GetClusterNetworkConfigurationParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetClusterNetworkConfigurationParams(args [1]string, argsEscaped bool, r *http.Request) (params GetClusterNetworkConfigurationParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetClusterNetworkConfigurationQueryResponseParams is parameters of getClusterNetworkConfigurationQueryResponse operation.
type GetClusterNetworkConfigurationQueryResponseParams struct {
	// Cluster ID.
	ID string
	// Query ID.
	QueryId string
}

func unpackGetClusterNetworkConfigurationQueryResponseParams(packed middleware.Parameters) (params GetClusterNetworkConfigurationQueryResponseParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "queryId",
			In:   "path",
		}
		params.QueryId = packed[key].(string)
	}
	return params
}

func decodeGetClusterNetworkConfigurationQueryResponseParams(args [2]string, argsEscaped bool, r *http.Request) (params GetClusterNetworkConfigurationQueryResponseParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: queryId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "queryId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.QueryId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "queryId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetClusterQueryResponseParams is parameters of getClusterQueryResponse operation.
type GetClusterQueryResponseParams struct {
	// Domain ID.
	DomainId string
	// Cluster Name.
	ClusterName string
	// Query ID.
	QueryId string
}

func unpackGetClusterQueryResponseParams(packed middleware.Parameters) (params GetClusterQueryResponseParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "clusterName",
			In:   "path",
		}
		params.ClusterName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "queryId",
			In:   "path",
		}
		params.QueryId = packed[key].(string)
	}
	return params
}

func decodeGetClusterQueryResponseParams(args [3]string, argsEscaped bool, r *http.Request) (params GetClusterQueryResponseParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: clusterName.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "clusterName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClusterName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "clusterName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: queryId.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "queryId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.QueryId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "queryId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetClusterTagManagerUrlParams is parameters of getClusterTagManagerUrl operation.
type GetClusterTagManagerUrlParams struct {
	// Cluster ID.
	ID string
}

func unpackGetClusterTagManagerUrlParams(packed middleware.Parameters) (params GetClusterTagManagerUrlParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetClusterTagManagerUrlParams(args [1]string, argsEscaped bool, r *http.Request) (params GetClusterTagManagerUrlParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetClusterUpdateValidationParams is parameters of getClusterUpdateValidation operation.
type GetClusterUpdateValidationParams struct {
	// Cluster ID.
	ID uuid.UUID
	// Cluster validation workflow id.
	ValidationId uuid.UUID
	// Cluster validation result for async validations.
	UseAsyncValidation OptBool
}

func unpackGetClusterUpdateValidationParams(packed middleware.Parameters) (params GetClusterUpdateValidationParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(uuid.UUID)
	}
	{
		key := middleware.ParameterKey{
			Name: "validationId",
			In:   "path",
		}
		params.ValidationId = packed[key].(uuid.UUID)
	}
	{
		key := middleware.ParameterKey{
			Name: "useAsyncValidation",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.UseAsyncValidation = v.(OptBool)
		}
	}
	return params
}

func decodeGetClusterUpdateValidationParams(args [2]string, argsEscaped bool, r *http.Request) (params GetClusterUpdateValidationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: validationId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "validationId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ValidationId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "validationId",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: useAsyncValidation.
	{
		val := bool(false)
		params.UseAsyncValidation.SetTo(val)
	}
	// Decode query: useAsyncValidation.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "useAsyncValidation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUseAsyncValidationVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotUseAsyncValidationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.UseAsyncValidation.SetTo(paramsDotUseAsyncValidationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "useAsyncValidation",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetClustersParams is parameters of getClusters operation.
type GetClustersParams struct {
	// Is cluster vSAN stretched.
	IsStretched OptBool
	// Is cluster managed using vSphere lifecycle Manager Images.
	IsImageBased OptBool
	// ID of the Domain.
	DomainId OptString
}

func unpackGetClustersParams(packed middleware.Parameters) (params GetClustersParams) {
	{
		key := middleware.ParameterKey{
			Name: "isStretched",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IsStretched = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "isImageBased",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IsImageBased = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DomainId = v.(OptString)
		}
	}
	return params
}

func decodeGetClustersParams(args [0]string, argsEscaped bool, r *http.Request) (params GetClustersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: isStretched.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "isStretched",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIsStretchedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIsStretchedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IsStretched.SetTo(paramsDotIsStretchedVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "isStretched",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: isImageBased.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "isImageBased",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIsImageBasedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIsImageBasedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IsImageBased.SetTo(paramsDotIsImageBasedVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "isImageBased",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: domainId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDomainIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDomainIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DomainId.SetTo(paramsDotDomainIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetClustersQueryResponseParams is parameters of getClustersQueryResponse operation.
type GetClustersQueryResponseParams struct {
	// Domain ID.
	DomainId string
	// Query ID.
	QueryId string
}

func unpackGetClustersQueryResponseParams(packed middleware.Parameters) (params GetClustersQueryResponseParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "queryId",
			In:   "path",
		}
		params.QueryId = packed[key].(string)
	}
	return params
}

func decodeGetClustersQueryResponseParams(args [2]string, argsEscaped bool, r *http.Request) (params GetClustersQueryResponseParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: queryId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "queryId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.QueryId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "queryId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCompatibilityMatrixParams is parameters of getCompatibilityMatrix operation.
type GetCompatibilityMatrixParams struct {
	// CompatibilityMatrixSource of compatibility data.
	CompatibilityMatrixSource string
}

func unpackGetCompatibilityMatrixParams(packed middleware.Parameters) (params GetCompatibilityMatrixParams) {
	{
		key := middleware.ParameterKey{
			Name: "compatibilityMatrixSource",
			In:   "path",
		}
		params.CompatibilityMatrixSource = packed[key].(string)
	}
	return params
}

func decodeGetCompatibilityMatrixParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCompatibilityMatrixParams, _ error) {
	// Decode path: compatibilityMatrixSource.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "compatibilityMatrixSource",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CompatibilityMatrixSource = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "compatibilityMatrixSource",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCompatibilityMatrixContentParams is parameters of getCompatibilityMatrixContent operation.
type GetCompatibilityMatrixContentParams struct {
	// CompatibilityMatrixSource of compatibility data.
	CompatibilityMatrixSource string
}

func unpackGetCompatibilityMatrixContentParams(packed middleware.Parameters) (params GetCompatibilityMatrixContentParams) {
	{
		key := middleware.ParameterKey{
			Name: "compatibilityMatrixSource",
			In:   "path",
		}
		params.CompatibilityMatrixSource = packed[key].(string)
	}
	return params
}

func decodeGetCompatibilityMatrixContentParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCompatibilityMatrixContentParams, _ error) {
	// Decode path: compatibilityMatrixSource.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "compatibilityMatrixSource",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CompatibilityMatrixSource = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "compatibilityMatrixSource",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCompatibilityMatrixMetadataParams is parameters of getCompatibilityMatrixMetadata operation.
type GetCompatibilityMatrixMetadataParams struct {
	// CompatibilityMatrixSource of compatibility data.
	CompatibilityMatrixSource string
}

func unpackGetCompatibilityMatrixMetadataParams(packed middleware.Parameters) (params GetCompatibilityMatrixMetadataParams) {
	{
		key := middleware.ParameterKey{
			Name: "compatibilityMatrixSource",
			In:   "path",
		}
		params.CompatibilityMatrixSource = packed[key].(string)
	}
	return params
}

func decodeGetCompatibilityMatrixMetadataParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCompatibilityMatrixMetadataParams, _ error) {
	// Decode path: compatibilityMatrixSource.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "compatibilityMatrixSource",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CompatibilityMatrixSource = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "compatibilityMatrixSource",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetComplianceAuditParams is parameters of getComplianceAudit operation.
type GetComplianceAuditParams struct {
	// Compliance Audit ID.
	ComplianceAuditId string
}

func unpackGetComplianceAuditParams(packed middleware.Parameters) (params GetComplianceAuditParams) {
	{
		key := middleware.ParameterKey{
			Name: "complianceAuditId",
			In:   "path",
		}
		params.ComplianceAuditId = packed[key].(string)
	}
	return params
}

func decodeGetComplianceAuditParams(args [1]string, argsEscaped bool, r *http.Request) (params GetComplianceAuditParams, _ error) {
	// Decode path: complianceAuditId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "complianceAuditId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ComplianceAuditId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "complianceAuditId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetComplianceAuditForADomainParams is parameters of getComplianceAuditForADomain operation.
type GetComplianceAuditForADomainParams struct {
	// Domain ID.
	ID string
	// Compliance Audit ID.
	ComplianceAuditId string
}

func unpackGetComplianceAuditForADomainParams(packed middleware.Parameters) (params GetComplianceAuditForADomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "complianceAuditId",
			In:   "path",
		}
		params.ComplianceAuditId = packed[key].(string)
	}
	return params
}

func decodeGetComplianceAuditForADomainParams(args [2]string, argsEscaped bool, r *http.Request) (params GetComplianceAuditForADomainParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: complianceAuditId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "complianceAuditId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ComplianceAuditId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "complianceAuditId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetComplianceAuditHistoryForADomainParams is parameters of getComplianceAuditHistoryForADomain operation.
type GetComplianceAuditHistoryForADomainParams struct {
	// Domain ID.
	ID string
}

func unpackGetComplianceAuditHistoryForADomainParams(packed middleware.Parameters) (params GetComplianceAuditHistoryForADomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetComplianceAuditHistoryForADomainParams(args [1]string, argsEscaped bool, r *http.Request) (params GetComplianceAuditHistoryForADomainParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetComplianceAuditItemsParams is parameters of getComplianceAuditItems operation.
type GetComplianceAuditItemsParams struct {
	// Compliance Audit ID.
	ComplianceAuditId string
}

func unpackGetComplianceAuditItemsParams(packed middleware.Parameters) (params GetComplianceAuditItemsParams) {
	{
		key := middleware.ParameterKey{
			Name: "complianceAuditId",
			In:   "path",
		}
		params.ComplianceAuditId = packed[key].(string)
	}
	return params
}

func decodeGetComplianceAuditItemsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetComplianceAuditItemsParams, _ error) {
	// Decode path: complianceAuditId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "complianceAuditId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ComplianceAuditId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "complianceAuditId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetComplianceAuditItemsForADomainParams is parameters of getComplianceAuditItemsForADomain operation.
type GetComplianceAuditItemsForADomainParams struct {
	// Domain ID.
	ID string
	// Compliance Audit ID.
	ComplianceAuditId string
}

func unpackGetComplianceAuditItemsForADomainParams(packed middleware.Parameters) (params GetComplianceAuditItemsForADomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "complianceAuditId",
			In:   "path",
		}
		params.ComplianceAuditId = packed[key].(string)
	}
	return params
}

func decodeGetComplianceAuditItemsForADomainParams(args [2]string, argsEscaped bool, r *http.Request) (params GetComplianceAuditItemsForADomainParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: complianceAuditId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "complianceAuditId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ComplianceAuditId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "complianceAuditId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetComplianceAuditTaskParams is parameters of getComplianceAuditTask operation.
type GetComplianceAuditTaskParams struct {
	// Domain ID.
	ID string
	// Audit task ID.
	TaskId string
}

func unpackGetComplianceAuditTaskParams(packed middleware.Parameters) (params GetComplianceAuditTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "taskId",
			In:   "path",
		}
		params.TaskId = packed[key].(string)
	}
	return params
}

func decodeGetComplianceAuditTaskParams(args [2]string, argsEscaped bool, r *http.Request) (params GetComplianceAuditTaskParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: taskId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "taskId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TaskId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "taskId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetComplianceConfigurationsParams is parameters of getComplianceConfigurations operation.
type GetComplianceConfigurationsParams struct {
	// The standard type.
	StandardType OptString
	// The standard version, use in combination with standardType.
	StandardVersion OptString
	// The resource type One among: SDDC_MANAGER.
	ResourceType OptString
	// The resource version, use in combination with resourceType).
	ResourceVersion OptString
}

func unpackGetComplianceConfigurationsParams(packed middleware.Parameters) (params GetComplianceConfigurationsParams) {
	{
		key := middleware.ParameterKey{
			Name: "standardType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StandardType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "standardVersion",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StandardVersion = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resourceType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resourceVersion",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceVersion = v.(OptString)
		}
	}
	return params
}

func decodeGetComplianceConfigurationsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetComplianceConfigurationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: standardType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "standardType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStandardTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStandardTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StandardType.SetTo(paramsDotStandardTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "standardType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: standardVersion.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "standardVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStandardVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStandardVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StandardVersion.SetTo(paramsDotStandardVersionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "standardVersion",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resourceType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceType.SetTo(paramsDotResourceTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resourceVersion.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceVersion",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetConfigsParams is parameters of getConfigs operation.
type GetConfigsParams struct {
	// Resource Id.
	ResourceId OptString
	// Resource Type.
	ResourceType OptString
	// Config Id.
	ConfigId OptString
	// Drift Type.
	DriftType OptString
	// Size of the page to retrieve. Default page size is 10. Optional.
	Size OptInt
	// Page number to retrieve. Default page 0 will retrieve all elements. Optional.
	Page OptInt
}

func unpackGetConfigsParams(packed middleware.Parameters) (params GetConfigsParams) {
	{
		key := middleware.ParameterKey{
			Name: "resourceId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resourceType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "configId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ConfigId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "driftType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DriftType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "size",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Size = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "page",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Page = v.(OptInt)
		}
	}
	return params
}

func decodeGetConfigsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetConfigsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: resourceId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceId.SetTo(paramsDotResourceIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resourceType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceType.SetTo(paramsDotResourceTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: configId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "configId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotConfigIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotConfigIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ConfigId.SetTo(paramsDotConfigIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "configId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: driftType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "driftType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDriftTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDriftTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DriftType.SetTo(paramsDotDriftTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "driftType",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: size.
	{
		val := int(10)
		params.Size.SetTo(val)
	}
	// Decode query: size.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSizeVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSizeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Size.SetTo(paramsDotSizeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "size",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: page.
	{
		val := int(0)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "page",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetCredentialParams is parameters of getCredential operation.
type GetCredentialParams struct {
	// The ID of the credential.
	ID string
}

func unpackGetCredentialParams(packed middleware.Parameters) (params GetCredentialParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetCredentialParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCredentialParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCredentialTaskByResourceIDParams is parameters of getCredentialTaskByResourceID operation.
type GetCredentialTaskByResourceIDParams struct {
	// The ID of the credentials task.
	ID string
}

func unpackGetCredentialTaskByResourceIDParams(packed middleware.Parameters) (params GetCredentialTaskByResourceIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetCredentialTaskByResourceIDParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCredentialTaskByResourceIDParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCredentialsParams is parameters of getCredentials operation.
type GetCredentialsParams struct {
	// The name of the resource.
	ResourceName OptString
	// The IP address of the resource.
	ResourceIp OptString
	// The type of the resource. One among: ESXI, VCENTER, PSC, NSX_MANAGER, NSX_CONTROLLER, NSX_EDGE,
	// NSXT_MANAGER, NSXT_EDGE, VRLI, VROPS, VRA, WSA, VRSLCM, VXRAIL_MANAGER, NSX_ALB, BACKUP.
	ResourceType OptString
	// The name of the domain to which the resource belongs to (may be null in case there is no
	// associated domain).
	DomainName OptString
	// The page number (must be a positive number), starts with 0.
	PageNumber OptString
	// The page size (must be a positive number, 0 as page size returns all records in one page.
	PageSize OptString
	// Type of the account that needs to be fetched by filtering.
	AccountType OptString
}

func unpackGetCredentialsParams(packed middleware.Parameters) (params GetCredentialsParams) {
	{
		key := middleware.ParameterKey{
			Name: "resourceName",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceName = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resourceIp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceIp = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resourceType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "domainName",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DomainName = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "pageNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageNumber = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "pageSize",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageSize = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "accountType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AccountType = v.(OptString)
		}
	}
	return params
}

func decodeGetCredentialsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetCredentialsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: resourceName.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceName.SetTo(paramsDotResourceNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceName",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resourceIp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceIp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceIpVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceIpVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceIp.SetTo(paramsDotResourceIpVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceIp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resourceType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceType.SetTo(paramsDotResourceTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: domainName.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "domainName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDomainNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDomainNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DomainName.SetTo(paramsDotDomainNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainName",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: pageNumber.
	{
		val := string("0")
		params.PageNumber.SetTo(val)
	}
	// Decode query: pageNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pageNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageNumberVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageNumber.SetTo(paramsDotPageNumberVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "pageNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: pageSize.
	{
		val := string("0")
		params.PageSize.SetTo(val)
	}
	// Decode query: pageSize.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageSizeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageSizeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageSize.SetTo(paramsDotPageSizeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "pageSize",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: accountType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "accountType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAccountTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAccountTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AccountType.SetTo(paramsDotAccountTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "accountType",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetCredentialsSubTaskParams is parameters of getCredentialsSubTask operation.
type GetCredentialsSubTaskParams struct {
	// The ID of the credentials task.
	ID string
	// The ID of the credentials sub-task.
	SubtaskId string
}

func unpackGetCredentialsSubTaskParams(packed middleware.Parameters) (params GetCredentialsSubTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "subtaskId",
			In:   "path",
		}
		params.SubtaskId = packed[key].(string)
	}
	return params
}

func decodeGetCredentialsSubTaskParams(args [2]string, argsEscaped bool, r *http.Request) (params GetCredentialsSubTaskParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: subtaskId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "subtaskId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SubtaskId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "subtaskId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCredentialsTaskParams is parameters of getCredentialsTask operation.
type GetCredentialsTaskParams struct {
	// The ID of the credentials task.
	ID string
}

func unpackGetCredentialsTaskParams(packed middleware.Parameters) (params GetCredentialsTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetCredentialsTaskParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCredentialsTaskParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCredentialsTasksParams is parameters of getCredentialsTasks operation.
type GetCredentialsTasksParams struct {
	// The number of elements to be returned in the result.
	Limit OptInt32
}

func unpackGetCredentialsTasksParams(packed middleware.Parameters) (params GetCredentialsTasksParams) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	return params
}

func decodeGetCredentialsTasksParams(args [0]string, argsEscaped bool, r *http.Request) (params GetCredentialsTasksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetCriterionParams is parameters of getCriterion operation.
type GetCriterionParams struct {
	Name string
}

func unpackGetCriterionParams(packed middleware.Parameters) (params GetCriterionParams) {
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "path",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeGetCriterionParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCriterionParams, _ error) {
	// Decode path: name.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCustomIsoByIdParams is parameters of getCustomIsoById operation.
type GetCustomIsoByIdParams struct {
	// Custom ISO ID.
	CustomIsoID string
}

func unpackGetCustomIsoByIdParams(packed middleware.Parameters) (params GetCustomIsoByIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "custom_iso_id",
			In:   "path",
		}
		params.CustomIsoID = packed[key].(string)
	}
	return params
}

func decodeGetCustomIsoByIdParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCustomIsoByIdParams, _ error) {
	// Decode path: custom_iso_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "custom_iso_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CustomIsoID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "custom_iso_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCustomIsosParams is parameters of getCustomIsos operation.
type GetCustomIsosParams struct {
	// The name of the Custom ISO.
	Name OptString
	// The vendor name of the Custom ISO.
	Vendor OptString
	// The domain resource ID.
	DomainId OptString
	// The ESXi target version.
	TargetVersion OptString
}

func unpackGetCustomIsosParams(packed middleware.Parameters) (params GetCustomIsosParams) {
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "vendor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Vendor = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DomainId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "targetVersion",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TargetVersion = v.(OptString)
		}
	}
	return params
}

func decodeGetCustomIsosParams(args [0]string, argsEscaped bool, r *http.Request) (params GetCustomIsosParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: vendor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "vendor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVendorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVendorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Vendor.SetTo(paramsDotVendorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "vendor",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: domainId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDomainIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDomainIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DomainId.SetTo(paramsDotDomainIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: targetVersion.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "targetVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTargetVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTargetVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TargetVersion.SetTo(paramsDotTargetVersionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "targetVersion",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetCustomPatchesParams is parameters of getCustomPatches operation.
type GetCustomPatchesParams struct {
	// Domain ID.
	DomainId string
	// VCF release.
	VcfRelease OptString
	// Vxrail release version.
	VxrailReleaseVersion OptString
	// Product Type.
	ProductType OptString
}

func unpackGetCustomPatchesParams(packed middleware.Parameters) (params GetCustomPatchesParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "vcfRelease",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VcfRelease = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "vxrailReleaseVersion",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VxrailReleaseVersion = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "productType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProductType = v.(OptString)
		}
	}
	return params
}

func decodeGetCustomPatchesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCustomPatchesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: vcfRelease.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "vcfRelease",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVcfReleaseVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVcfReleaseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VcfRelease.SetTo(paramsDotVcfReleaseVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "vcfRelease",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: vxrailReleaseVersion.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "vxrailReleaseVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVxrailReleaseVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVxrailReleaseVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VxrailReleaseVersion.SetTo(paramsDotVxrailReleaseVersionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "vxrailReleaseVersion",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: productType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "productType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProductTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProductTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ProductType.SetTo(paramsDotProductTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "productType",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatastoreCriterionParams is parameters of getDatastoreCriterion operation.
type GetDatastoreCriterionParams struct {
	// Domain ID.
	DomainId string
	// Criteria Name.
	Name string
}

func unpackGetDatastoreCriterionParams(packed middleware.Parameters) (params GetDatastoreCriterionParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "path",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeGetDatastoreCriterionParams(args [2]string, argsEscaped bool, r *http.Request) (params GetDatastoreCriterionParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: name.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatastoreCriterion1Params is parameters of getDatastoreCriterion_1 operation.
type GetDatastoreCriterion1Params struct {
	// Cluster ID.
	ID string
	// Criteria Name.
	Name string
}

func unpackGetDatastoreCriterion1Params(packed middleware.Parameters) (params GetDatastoreCriterion1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "path",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeGetDatastoreCriterion1Params(args [2]string, argsEscaped bool, r *http.Request) (params GetDatastoreCriterion1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: name.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatastoreQueryResponseParams is parameters of getDatastoreQueryResponse operation.
type GetDatastoreQueryResponseParams struct {
	// Domain ID.
	DomainId string
	// Query ID.
	QueryId string
}

func unpackGetDatastoreQueryResponseParams(packed middleware.Parameters) (params GetDatastoreQueryResponseParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "queryId",
			In:   "path",
		}
		params.QueryId = packed[key].(string)
	}
	return params
}

func decodeGetDatastoreQueryResponseParams(args [2]string, argsEscaped bool, r *http.Request) (params GetDatastoreQueryResponseParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: queryId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "queryId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.QueryId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "queryId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatastoreQueryResponse1Params is parameters of getDatastoreQueryResponse_1 operation.
type GetDatastoreQueryResponse1Params struct {
	// Cluster ID.
	ClusterId string
	// Query ID.
	QueryId string
}

func unpackGetDatastoreQueryResponse1Params(packed middleware.Parameters) (params GetDatastoreQueryResponse1Params) {
	{
		key := middleware.ParameterKey{
			Name: "clusterId",
			In:   "path",
		}
		params.ClusterId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "queryId",
			In:   "path",
		}
		params.QueryId = packed[key].(string)
	}
	return params
}

func decodeGetDatastoreQueryResponse1Params(args [2]string, argsEscaped bool, r *http.Request) (params GetDatastoreQueryResponse1Params, _ error) {
	// Decode path: clusterId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "clusterId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClusterId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "clusterId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: queryId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "queryId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.QueryId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "queryId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatastoresCriteriaParams is parameters of getDatastoresCriteria operation.
type GetDatastoresCriteriaParams struct {
	// Domain ID.
	DomainId string
}

func unpackGetDatastoresCriteriaParams(packed middleware.Parameters) (params GetDatastoresCriteriaParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodeGetDatastoresCriteriaParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDatastoresCriteriaParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatastoresCriteria1Params is parameters of getDatastoresCriteria_1 operation.
type GetDatastoresCriteria1Params struct {
	// Cluster ID.
	ID string
}

func unpackGetDatastoresCriteria1Params(packed middleware.Parameters) (params GetDatastoresCriteria1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetDatastoresCriteria1Params(args [1]string, argsEscaped bool, r *http.Request) (params GetDatastoresCriteria1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDomainParams is parameters of getDomain operation.
type GetDomainParams struct {
	// Domain ID.
	ID string
}

func unpackGetDomainParams(packed middleware.Parameters) (params GetDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDomainParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDomainCertificatesParams is parameters of getDomainCertificates operation.
type GetDomainCertificatesParams struct {
	// Domain ID or Name.
	ID string
}

func unpackGetDomainCertificatesParams(packed middleware.Parameters) (params GetDomainCertificatesParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetDomainCertificatesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDomainCertificatesParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDomainEndpointsParams is parameters of getDomainEndpoints operation.
type GetDomainEndpointsParams struct {
	// Domain ID.
	ID string
}

func unpackGetDomainEndpointsParams(packed middleware.Parameters) (params GetDomainEndpointsParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetDomainEndpointsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDomainEndpointsParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDomainIsolationPrecheckStatusParams is parameters of getDomainIsolationPrecheckStatus operation.
type GetDomainIsolationPrecheckStatusParams struct {
	// Domain ID.
	DomainId string
	// Precheck ID.
	PrecheckId string
}

func unpackGetDomainIsolationPrecheckStatusParams(packed middleware.Parameters) (params GetDomainIsolationPrecheckStatusParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "precheckId",
			In:   "path",
		}
		params.PrecheckId = packed[key].(string)
	}
	return params
}

func decodeGetDomainIsolationPrecheckStatusParams(args [2]string, argsEscaped bool, r *http.Request) (params GetDomainIsolationPrecheckStatusParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: precheckId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "precheckId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PrecheckId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "precheckId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDomainReleaseViewValidationParams is parameters of getDomainReleaseViewValidation operation.
type GetDomainReleaseViewValidationParams struct {
	// Domain Target State Validation ID.
	ValidationId string
}

func unpackGetDomainReleaseViewValidationParams(packed middleware.Parameters) (params GetDomainReleaseViewValidationParams) {
	{
		key := middleware.ParameterKey{
			Name: "validationId",
			In:   "path",
		}
		params.ValidationId = packed[key].(string)
	}
	return params
}

func decodeGetDomainReleaseViewValidationParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDomainReleaseViewValidationParams, _ error) {
	// Decode path: validationId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "validationId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ValidationId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "validationId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDomainTagManagerUrlParams is parameters of getDomainTagManagerUrl operation.
type GetDomainTagManagerUrlParams struct {
	// Domain ID.
	ID string
}

func unpackGetDomainTagManagerUrlParams(packed middleware.Parameters) (params GetDomainTagManagerUrlParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetDomainTagManagerUrlParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDomainTagManagerUrlParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDomainUpdateValidationParams is parameters of getDomainUpdateValidation operation.
type GetDomainUpdateValidationParams struct {
	// VxRail Domain ID.
	ID uuid.UUID
	// VxRail Domain validation id.
	ValidationId uuid.UUID
}

func unpackGetDomainUpdateValidationParams(packed middleware.Parameters) (params GetDomainUpdateValidationParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(uuid.UUID)
	}
	{
		key := middleware.ParameterKey{
			Name: "validationId",
			In:   "path",
		}
		params.ValidationId = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetDomainUpdateValidationParams(args [2]string, argsEscaped bool, r *http.Request) (params GetDomainUpdateValidationParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: validationId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "validationId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ValidationId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "validationId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDomainsParams is parameters of getDomains operation.
type GetDomainsParams struct {
	// The type of the domain.
	Type OptString
}

func unpackGetDomainsParams(packed middleware.Parameters) (params GetDomainsParams) {
	{
		key := middleware.ParameterKey{
			Name: "type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Type = v.(OptString)
		}
	}
	return params
}

func decodeGetDomainsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetDomainsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "type",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetEdgeClusterParams is parameters of getEdgeCluster operation.
type GetEdgeClusterParams struct {
	// Edge Cluster ID.
	ID string
}

func unpackGetEdgeClusterParams(packed middleware.Parameters) (params GetEdgeClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetEdgeClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params GetEdgeClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetEdgeClusterQueryCriteriaParams is parameters of getEdgeClusterQueryCriteria operation.
type GetEdgeClusterQueryCriteriaParams struct {
	// Edge Cluster ID.
	EdgeClusterId string
}

func unpackGetEdgeClusterQueryCriteriaParams(packed middleware.Parameters) (params GetEdgeClusterQueryCriteriaParams) {
	{
		key := middleware.ParameterKey{
			Name: "edgeClusterId",
			In:   "path",
		}
		params.EdgeClusterId = packed[key].(string)
	}
	return params
}

func decodeGetEdgeClusterQueryCriteriaParams(args [1]string, argsEscaped bool, r *http.Request) (params GetEdgeClusterQueryCriteriaParams, _ error) {
	// Decode path: edgeClusterId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "edgeClusterId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EdgeClusterId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "edgeClusterId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetEdgeClusterValidationByIDParams is parameters of getEdgeClusterValidationByID operation.
type GetEdgeClusterValidationByIDParams struct {
	// The validation ID.
	ID string
}

func unpackGetEdgeClusterValidationByIDParams(packed middleware.Parameters) (params GetEdgeClusterValidationByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetEdgeClusterValidationByIDParams(args [1]string, argsEscaped bool, r *http.Request) (params GetEdgeClusterValidationByIDParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetEdgeClustersParams is parameters of getEdgeClusters operation.
type GetEdgeClustersParams struct {
	// Pass an optional vSphere Cluster ID to fetch edge clusters associated with the vSphere Cluster.
	ClusterId OptString
}

func unpackGetEdgeClustersParams(packed middleware.Parameters) (params GetEdgeClustersParams) {
	{
		key := middleware.ParameterKey{
			Name: "clusterId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ClusterId = v.(OptString)
		}
	}
	return params
}

func decodeGetEdgeClustersParams(args [0]string, argsEscaped bool, r *http.Request) (params GetEdgeClustersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: clusterId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "clusterId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotClusterIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotClusterIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ClusterId.SetTo(paramsDotClusterIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "clusterId",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetFutureReleasesParams is parameters of getFutureReleases operation.
type GetFutureReleasesParams struct {
	// Domain ID to get all feature target versions.
	DomainId string
}

func unpackGetFutureReleasesParams(packed middleware.Parameters) (params GetFutureReleasesParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodeGetFutureReleasesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetFutureReleasesParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetHealthCheckStatusParams is parameters of getHealthCheckStatus operation.
type GetHealthCheckStatusParams struct {
	// The Health Summary Id.
	ID string
}

func unpackGetHealthCheckStatusParams(packed middleware.Parameters) (params GetHealthCheckStatusParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetHealthCheckStatusParams(args [1]string, argsEscaped bool, r *http.Request) (params GetHealthCheckStatusParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetHostParams is parameters of getHost operation.
type GetHostParams struct {
	ID string
}

func unpackGetHostParams(packed middleware.Parameters) (params GetHostParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetHostParams(args [1]string, argsEscaped bool, r *http.Request) (params GetHostParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetHostCommissionValidationByIDParams is parameters of getHostCommissionValidationByID operation.
type GetHostCommissionValidationByIDParams struct {
	// The validation ID.
	ID string
}

func unpackGetHostCommissionValidationByIDParams(packed middleware.Parameters) (params GetHostCommissionValidationByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetHostCommissionValidationByIDParams(args [1]string, argsEscaped bool, r *http.Request) (params GetHostCommissionValidationByIDParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetHostCriteriaParams is parameters of getHostCriteria operation.
type GetHostCriteriaParams struct {
	// Cluster ID.
	ID string
}

func unpackGetHostCriteriaParams(packed middleware.Parameters) (params GetHostCriteriaParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetHostCriteriaParams(args [1]string, argsEscaped bool, r *http.Request) (params GetHostCriteriaParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetHostCriterionParams is parameters of getHostCriterion operation.
type GetHostCriterionParams struct {
	// Cluster ID.
	ID string
	// Criteria Name.
	Name string
}

func unpackGetHostCriterionParams(packed middleware.Parameters) (params GetHostCriterionParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "path",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeGetHostCriterionParams(args [2]string, argsEscaped bool, r *http.Request) (params GetHostCriterionParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: name.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetHostQueryResponseParams is parameters of getHostQueryResponse operation.
type GetHostQueryResponseParams struct {
	ID string
}

func unpackGetHostQueryResponseParams(packed middleware.Parameters) (params GetHostQueryResponseParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetHostQueryResponseParams(args [1]string, argsEscaped bool, r *http.Request) (params GetHostQueryResponseParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetHostQueryResponse1Params is parameters of getHostQueryResponse_1 operation.
type GetHostQueryResponse1Params struct {
	// Cluster ID.
	ClusterId string
	// Query ID.
	QueryId string
}

func unpackGetHostQueryResponse1Params(packed middleware.Parameters) (params GetHostQueryResponse1Params) {
	{
		key := middleware.ParameterKey{
			Name: "clusterId",
			In:   "path",
		}
		params.ClusterId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "queryId",
			In:   "path",
		}
		params.QueryId = packed[key].(string)
	}
	return params
}

func decodeGetHostQueryResponse1Params(args [2]string, argsEscaped bool, r *http.Request) (params GetHostQueryResponse1Params, _ error) {
	// Decode path: clusterId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "clusterId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClusterId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "clusterId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: queryId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "queryId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.QueryId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "queryId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetHostTagManagerUrlParams is parameters of getHostTagManagerUrl operation.
type GetHostTagManagerUrlParams struct {
	// Host ID.
	ID string
}

func unpackGetHostTagManagerUrlParams(packed middleware.Parameters) (params GetHostTagManagerUrlParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetHostTagManagerUrlParams(args [1]string, argsEscaped bool, r *http.Request) (params GetHostTagManagerUrlParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetHostsParams is parameters of getHosts operation.
type GetHostsParams struct {
	// Status of the Host.One among: ASSIGNED, UNASSIGNED_USEABLE, UNASSIGNED_UNUSEABLE.
	Status OptString
	// ID of the Domain.
	DomainId OptString
	// ID of the Cluster.
	ClusterId OptString
	// ID of the Network pool.
	NetworkpoolId OptString
	// Type of the Storage.VMFS_FC.
	StorageType OptString
	// Name of the datastore.
	DatastoreName OptString
}

func unpackGetHostsParams(packed middleware.Parameters) (params GetHostsParams) {
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DomainId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "clusterId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ClusterId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "networkpoolId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.NetworkpoolId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "storageType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StorageType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "datastoreName",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DatastoreName = v.(OptString)
		}
	}
	return params
}

func decodeGetHostsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetHostsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: domainId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDomainIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDomainIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DomainId.SetTo(paramsDotDomainIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: clusterId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "clusterId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotClusterIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotClusterIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ClusterId.SetTo(paramsDotClusterIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "clusterId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: networkpoolId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "networkpoolId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNetworkpoolIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNetworkpoolIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.NetworkpoolId.SetTo(paramsDotNetworkpoolIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "networkpoolId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: storageType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "storageType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStorageTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStorageTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StorageType.SetTo(paramsDotStorageTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "storageType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: datastoreName.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "datastoreName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDatastoreNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDatastoreNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DatastoreName.SetTo(paramsDotDatastoreNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "datastoreName",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetHostsPrechecksResponseParams is parameters of getHostsPrechecksResponse operation.
type GetHostsPrechecksResponseParams struct {
	// Execution ID returned by post hostsprecheks.
	ID string
}

func unpackGetHostsPrechecksResponseParams(packed middleware.Parameters) (params GetHostsPrechecksResponseParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetHostsPrechecksResponseParams(args [1]string, argsEscaped bool, r *http.Request) (params GetHostsPrechecksResponseParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetIdentityPrecheckResultParams is parameters of getIdentityPrecheckResult operation.
type GetIdentityPrecheckResultParams struct {
	// IDP type for which Precheck needs to be run.
	Type OptString
}

func unpackGetIdentityPrecheckResultParams(packed middleware.Parameters) (params GetIdentityPrecheckResultParams) {
	{
		key := middleware.ParameterKey{
			Name: "type",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Type = v.(OptString)
		}
	}
	return params
}

func decodeGetIdentityPrecheckResultParams(args [0]string, argsEscaped bool, r *http.Request) (params GetIdentityPrecheckResultParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "type",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetIdentityProviderByIdParams is parameters of getIdentityProviderById operation.
type GetIdentityProviderByIdParams struct {
	// ID of the Identity Provider.
	ID string
}

func unpackGetIdentityProviderByIdParams(packed middleware.Parameters) (params GetIdentityProviderByIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetIdentityProviderByIdParams(args [1]string, argsEscaped bool, r *http.Request) (params GetIdentityProviderByIdParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetLastAssessmentRunInfoParams is parameters of getLastAssessmentRunInfo operation.
type GetLastAssessmentRunInfoParams struct {
	// Id of the domain to filter tasks for, accepts multiple values as comma separated.
	DomainId OptString
}

func unpackGetLastAssessmentRunInfoParams(packed middleware.Parameters) (params GetLastAssessmentRunInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DomainId = v.(OptString)
		}
	}
	return params
}

func decodeGetLastAssessmentRunInfoParams(args [0]string, argsEscaped bool, r *http.Request) (params GetLastAssessmentRunInfoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: domainId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDomainIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDomainIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DomainId.SetTo(paramsDotDomainIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetLicenseKeyParams is parameters of getLicenseKey operation.
type GetLicenseKeyParams struct {
	// The 29 alpha numeric character license key with hyphens.
	Key string
}

func unpackGetLicenseKeyParams(packed middleware.Parameters) (params GetLicenseKeyParams) {
	{
		key := middleware.ParameterKey{
			Name: "key",
			In:   "path",
		}
		params.Key = packed[key].(string)
	}
	return params
}

func decodeGetLicenseKeyParams(args [1]string, argsEscaped bool, r *http.Request) (params GetLicenseKeyParams, _ error) {
	// Decode path: key.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Key = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "key",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetLicenseKeysParams is parameters of getLicenseKeys operation.
type GetLicenseKeysParams struct {
	// Type of a Product.
	ProductType []string
	// Status of a License Key.
	LicenseKeyStatus []string
	// Unit of a license.
	LicenseUnit []string
	// Product Version, gets the license keys matching the major version of the product version.
	ProductVersion OptString
}

func unpackGetLicenseKeysParams(packed middleware.Parameters) (params GetLicenseKeysParams) {
	{
		key := middleware.ParameterKey{
			Name: "productType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProductType = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "licenseKeyStatus",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.LicenseKeyStatus = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "licenseUnit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.LicenseUnit = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "productVersion",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProductVersion = v.(OptString)
		}
	}
	return params
}

func decodeGetLicenseKeysParams(args [0]string, argsEscaped bool, r *http.Request) (params GetLicenseKeysParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: productType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "productType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotProductTypeVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotProductTypeVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.ProductType = append(params.ProductType, paramsDotProductTypeVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "productType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: licenseKeyStatus.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "licenseKeyStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotLicenseKeyStatusVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotLicenseKeyStatusVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.LicenseKeyStatus = append(params.LicenseKeyStatus, paramsDotLicenseKeyStatusVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "licenseKeyStatus",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: licenseUnit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "licenseUnit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotLicenseUnitVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotLicenseUnitVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.LicenseUnit = append(params.LicenseUnit, paramsDotLicenseUnitVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "licenseUnit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: productVersion.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "productVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProductVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProductVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ProductVersion.SetTo(paramsDotProductVersionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "productVersion",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetNetworkOfNetworkPoolParams is parameters of getNetworkOfNetworkPool operation.
type GetNetworkOfNetworkPoolParams struct {
	// Id of the Network pool.
	ID string
	// Id of the Network.
	NetworkId string
}

func unpackGetNetworkOfNetworkPoolParams(packed middleware.Parameters) (params GetNetworkOfNetworkPoolParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "networkId",
			In:   "path",
		}
		params.NetworkId = packed[key].(string)
	}
	return params
}

func decodeGetNetworkOfNetworkPoolParams(args [2]string, argsEscaped bool, r *http.Request) (params GetNetworkOfNetworkPoolParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: networkId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "networkId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.NetworkId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "networkId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNetworkPoolByIDParams is parameters of getNetworkPoolByID operation.
type GetNetworkPoolByIDParams struct {
	// ID of the network pool to fetch.
	ID string
}

func unpackGetNetworkPoolByIDParams(packed middleware.Parameters) (params GetNetworkPoolByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetNetworkPoolByIDParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNetworkPoolByIDParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNetworksOfNetworkPoolParams is parameters of getNetworksOfNetworkPool operation.
type GetNetworksOfNetworkPoolParams struct {
	// ID for Networkpool to get the networks from.
	ID string
}

func unpackGetNetworksOfNetworkPoolParams(packed middleware.Parameters) (params GetNetworksOfNetworkPoolParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetNetworksOfNetworkPoolParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNetworksOfNetworkPoolParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNsxClusterParams is parameters of getNsxCluster operation.
type GetNsxClusterParams struct {
	// NSX cluster ID.
	ID string
}

func unpackGetNsxClusterParams(packed middleware.Parameters) (params GetNsxClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetNsxClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNsxClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNsxClusterQueryResponseParams is parameters of getNsxClusterQueryResponse operation.
type GetNsxClusterQueryResponseParams struct {
	ID string
}

func unpackGetNsxClusterQueryResponseParams(packed middleware.Parameters) (params GetNsxClusterQueryResponseParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetNsxClusterQueryResponseParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNsxClusterQueryResponseParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNsxClustersParams is parameters of getNsxClusters operation.
type GetNsxClustersParams struct {
	// Filter NSX clusters which can be shared for domain creation.
	IsShareable OptBool
}

func unpackGetNsxClustersParams(packed middleware.Parameters) (params GetNsxClustersParams) {
	{
		key := middleware.ParameterKey{
			Name: "isShareable",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IsShareable = v.(OptBool)
		}
	}
	return params
}

func decodeGetNsxClustersParams(args [0]string, argsEscaped bool, r *http.Request) (params GetNsxClustersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: isShareable.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "isShareable",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIsShareableVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIsShareableVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IsShareable.SetTo(paramsDotIsShareableVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "isShareable",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetNsxCriterionParams is parameters of getNsxCriterion operation.
type GetNsxCriterionParams struct {
	Name string
}

func unpackGetNsxCriterionParams(packed middleware.Parameters) (params GetNsxCriterionParams) {
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "path",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeGetNsxCriterionParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNsxCriterionParams, _ error) {
	// Decode path: name.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNsxIpAddressPoolParams is parameters of getNsxIpAddressPool operation.
type GetNsxIpAddressPoolParams struct {
	// NSX cluster ID.
	NsxtClusterID string
	// IP address pool name.
	Name string
}

func unpackGetNsxIpAddressPoolParams(packed middleware.Parameters) (params GetNsxIpAddressPoolParams) {
	{
		key := middleware.ParameterKey{
			Name: "nsxt-cluster-id",
			In:   "path",
		}
		params.NsxtClusterID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "path",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeGetNsxIpAddressPoolParams(args [2]string, argsEscaped bool, r *http.Request) (params GetNsxIpAddressPoolParams, _ error) {
	// Decode path: nsxt-cluster-id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "nsxt-cluster-id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.NsxtClusterID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "nsxt-cluster-id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: name.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNsxIpAddressPoolsParams is parameters of getNsxIpAddressPools operation.
type GetNsxIpAddressPoolsParams struct {
	// NSX cluster ID.
	NsxtClusterID string
}

func unpackGetNsxIpAddressPoolsParams(packed middleware.Parameters) (params GetNsxIpAddressPoolsParams) {
	{
		key := middleware.ParameterKey{
			Name: "nsxt-cluster-id",
			In:   "path",
		}
		params.NsxtClusterID = packed[key].(string)
	}
	return params
}

func decodeGetNsxIpAddressPoolsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNsxIpAddressPoolsParams, _ error) {
	// Decode path: nsxt-cluster-id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "nsxt-cluster-id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.NsxtClusterID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "nsxt-cluster-id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNsxTransportZonesParams is parameters of getNsxTransportZones operation.
type GetNsxTransportZonesParams struct {
	// NSX cluster ID.
	NsxtClusterID string
}

func unpackGetNsxTransportZonesParams(packed middleware.Parameters) (params GetNsxTransportZonesParams) {
	{
		key := middleware.ParameterKey{
			Name: "nsxt-cluster-id",
			In:   "path",
		}
		params.NsxtClusterID = packed[key].(string)
	}
	return params
}

func decodeGetNsxTransportZonesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNsxTransportZonesParams, _ error) {
	// Decode path: nsxt-cluster-id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "nsxt-cluster-id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.NsxtClusterID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "nsxt-cluster-id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNsxUpgradeResourcesParams is parameters of getNsxUpgradeResources operation.
type GetNsxUpgradeResourcesParams struct {
	// Domain ID.
	DomainId string
	// Bundle Id of the upgrade bundle applicable on the domain.
	BundleId OptString
}

func unpackGetNsxUpgradeResourcesParams(packed middleware.Parameters) (params GetNsxUpgradeResourcesParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "bundleId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BundleId = v.(OptString)
		}
	}
	return params
}

func decodeGetNsxUpgradeResourcesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNsxUpgradeResourcesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: bundleId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "bundleId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBundleIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBundleIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BundleId.SetTo(paramsDotBundleIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "bundleId",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetPasswordExpirationByTaskIDParams is parameters of getPasswordExpirationByTaskID operation.
type GetPasswordExpirationByTaskIDParams struct {
	// The expiration fetch workflow ID.
	ID string
}

func unpackGetPasswordExpirationByTaskIDParams(packed middleware.Parameters) (params GetPasswordExpirationByTaskIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetPasswordExpirationByTaskIDParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPasswordExpirationByTaskIDParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetPersonalitiesParams is parameters of getPersonalities operation.
type GetPersonalitiesParams struct {
	// The base OS version.
	BaseOSVersion OptString
	// The add on name.
	AddOnName OptString
	// The add on vendor name.
	AddOnVendorName OptString
	// The component name.
	ComponentName OptString
	// The component vendor name.
	ComponentVendorName OptString
	PersonalityName     OptString
}

func unpackGetPersonalitiesParams(packed middleware.Parameters) (params GetPersonalitiesParams) {
	{
		key := middleware.ParameterKey{
			Name: "baseOSVersion",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BaseOSVersion = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "addOnName",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AddOnName = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "addOnVendorName",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AddOnVendorName = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "componentName",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ComponentName = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "componentVendorName",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ComponentVendorName = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "personalityName",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PersonalityName = v.(OptString)
		}
	}
	return params
}

func decodeGetPersonalitiesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetPersonalitiesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: baseOSVersion.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "baseOSVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBaseOSVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBaseOSVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BaseOSVersion.SetTo(paramsDotBaseOSVersionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "baseOSVersion",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: addOnName.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "addOnName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAddOnNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAddOnNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AddOnName.SetTo(paramsDotAddOnNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "addOnName",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: addOnVendorName.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "addOnVendorName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAddOnVendorNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAddOnVendorNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AddOnVendorName.SetTo(paramsDotAddOnVendorNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "addOnVendorName",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: componentName.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "componentName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotComponentNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotComponentNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ComponentName.SetTo(paramsDotComponentNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "componentName",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: componentVendorName.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "componentVendorName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotComponentVendorNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotComponentVendorNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ComponentVendorName.SetTo(paramsDotComponentVendorNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "componentVendorName",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: personalityName.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "personalityName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPersonalityNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPersonalityNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PersonalityName.SetTo(paramsDotPersonalityNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "personalityName",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetPersonalityParams is parameters of getPersonality operation.
type GetPersonalityParams struct {
	// Personality ID.
	PersonalityId string
}

func unpackGetPersonalityParams(packed middleware.Parameters) (params GetPersonalityParams) {
	{
		key := middleware.ParameterKey{
			Name: "personalityId",
			In:   "path",
		}
		params.PersonalityId = packed[key].(string)
	}
	return params
}

func decodeGetPersonalityParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPersonalityParams, _ error) {
	// Decode path: personalityId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "personalityId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PersonalityId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "personalityId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetPrecheckTaskParams is parameters of getPrecheckTask operation.
type GetPrecheckTaskParams struct {
	// Precheck Task ID.
	ID string
}

func unpackGetPrecheckTaskParams(packed middleware.Parameters) (params GetPrecheckTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetPrecheckTaskParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPrecheckTaskParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetPscParams is parameters of getPsc operation.
type GetPscParams struct {
	// PSC ID.
	ID string
}

func unpackGetPscParams(packed middleware.Parameters) (params GetPscParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetPscParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPscParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetReconciliationTaskParams is parameters of getReconciliationTask operation.
type GetReconciliationTaskParams struct {
	// Task Id.
	TaskId string
}

func unpackGetReconciliationTaskParams(packed middleware.Parameters) (params GetReconciliationTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "taskId",
			In:   "path",
		}
		params.TaskId = packed[key].(string)
	}
	return params
}

func decodeGetReconciliationTaskParams(args [1]string, argsEscaped bool, r *http.Request) (params GetReconciliationTaskParams, _ error) {
	// Decode path: taskId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "taskId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TaskId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "taskId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetReleaseByDomainParams is parameters of getReleaseByDomain operation.
type GetReleaseByDomainParams struct {
	// Domain ID to get target version of the domain.
	DomainId string
}

func unpackGetReleaseByDomainParams(packed middleware.Parameters) (params GetReleaseByDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodeGetReleaseByDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params GetReleaseByDomainParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetReleasesParams is parameters of getReleases operation.
type GetReleasesParams struct {
	// Domain ID to get current release of the domain.
	DomainId OptString
	// Release version to get its release.
	VersionEq OptString
	// Release VxRail version to get its release.
	VxRailVersionEq OptString
	// Release version to get its future releases.
	VersionGt OptString
	// Release vxrail version to get its future releases.
	VxRailVersionGt OptString
	// Release version to get applicable releases.
	ApplicableForVersion OptString
	// Release VxRail version to get applicable releases.
	ApplicableForVxRailVersion OptString
	// [Deprecated] Get all future releases for a given domain.
	GetFutureReleases OptBool
}

func unpackGetReleasesParams(packed middleware.Parameters) (params GetReleasesParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DomainId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "versionEq",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VersionEq = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "vxRailVersionEq",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VxRailVersionEq = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "versionGt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VersionGt = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "vxRailVersionGt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VxRailVersionGt = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "applicableForVersion",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ApplicableForVersion = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "applicableForVxRailVersion",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ApplicableForVxRailVersion = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "getFutureReleases",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.GetFutureReleases = v.(OptBool)
		}
	}
	return params
}

func decodeGetReleasesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetReleasesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: domainId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDomainIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDomainIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DomainId.SetTo(paramsDotDomainIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: versionEq.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "versionEq",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVersionEqVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVersionEqVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VersionEq.SetTo(paramsDotVersionEqVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "versionEq",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: vxRailVersionEq.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "vxRailVersionEq",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVxRailVersionEqVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVxRailVersionEqVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VxRailVersionEq.SetTo(paramsDotVxRailVersionEqVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "vxRailVersionEq",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: versionGt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "versionGt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVersionGtVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVersionGtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VersionGt.SetTo(paramsDotVersionGtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "versionGt",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: vxRailVersionGt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "vxRailVersionGt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVxRailVersionGtVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVxRailVersionGtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VxRailVersionGt.SetTo(paramsDotVxRailVersionGtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "vxRailVersionGt",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: applicableForVersion.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "applicableForVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotApplicableForVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotApplicableForVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ApplicableForVersion.SetTo(paramsDotApplicableForVersionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "applicableForVersion",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: applicableForVxRailVersion.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "applicableForVxRailVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotApplicableForVxRailVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotApplicableForVxRailVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ApplicableForVxRailVersion.SetTo(paramsDotApplicableForVxRailVersionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "applicableForVxRailVersion",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: getFutureReleases.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "getFutureReleases",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotGetFutureReleasesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotGetFutureReleasesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.GetFutureReleases.SetTo(paramsDotGetFutureReleasesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "getFutureReleases",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetResourceCertificatesValidationByIDParams is parameters of getResourceCertificatesValidationByID operation.
type GetResourceCertificatesValidationByIDParams struct {
	// Domain ID.
	ID string
	// Validation ID.
	ValidationId string
}

func unpackGetResourceCertificatesValidationByIDParams(packed middleware.Parameters) (params GetResourceCertificatesValidationByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "validationId",
			In:   "path",
		}
		params.ValidationId = packed[key].(string)
	}
	return params
}

func decodeGetResourceCertificatesValidationByIDParams(args [2]string, argsEscaped bool, r *http.Request) (params GetResourceCertificatesValidationByIDParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: validationId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "validationId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ValidationId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "validationId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetResourceFunctionalitiesParams is parameters of getResourceFunctionalities operation.
type GetResourceFunctionalitiesParams struct {
	// Resource type.
	ResourceType OptString
	// Functionality type.
	FunctionalityType OptString
	// Resource IDs.
	ResourceIds []string
	// Allowed or disallowed resource functionalities.
	IsAllowed OptBool
	// Parent resource type.
	ParentResourceType OptString
}

func unpackGetResourceFunctionalitiesParams(packed middleware.Parameters) (params GetResourceFunctionalitiesParams) {
	{
		key := middleware.ParameterKey{
			Name: "resourceType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "functionalityType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FunctionalityType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resourceIds",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceIds = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "isAllowed",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IsAllowed = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "parentResourceType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ParentResourceType = v.(OptString)
		}
	}
	return params
}

func decodeGetResourceFunctionalitiesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetResourceFunctionalitiesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: resourceType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceType.SetTo(paramsDotResourceTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: functionalityType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "functionalityType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFunctionalityTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFunctionalityTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FunctionalityType.SetTo(paramsDotFunctionalityTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "functionalityType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resourceIds.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceIds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotResourceIdsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotResourceIdsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.ResourceIds = append(params.ResourceIds, paramsDotResourceIdsVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceIds",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: isAllowed.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "isAllowed",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIsAllowedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIsAllowedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IsAllowed.SetTo(paramsDotIsAllowedVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "isAllowed",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: parentResourceType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "parentResourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotParentResourceTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotParentResourceTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ParentResourceType.SetTo(paramsDotParentResourceTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "parentResourceType",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetResourceWarningParams is parameters of getResourceWarning operation.
type GetResourceWarningParams struct {
	ID string
}

func unpackGetResourceWarningParams(packed middleware.Parameters) (params GetResourceWarningParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetResourceWarningParams(args [1]string, argsEscaped bool, r *http.Request) (params GetResourceWarningParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetResourceWarningsParams is parameters of getResourceWarnings operation.
type GetResourceWarningsParams struct {
	// Resource type.
	ResourceType OptString
	// Resource IDs.
	ResourceIds []string
	// Resource Names.
	ResourceNames []string
}

func unpackGetResourceWarningsParams(packed middleware.Parameters) (params GetResourceWarningsParams) {
	{
		key := middleware.ParameterKey{
			Name: "resourceType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resourceIds",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceIds = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resourceNames",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceNames = v.([]string)
		}
	}
	return params
}

func decodeGetResourceWarningsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetResourceWarningsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: resourceType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceType.SetTo(paramsDotResourceTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resourceIds.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceIds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotResourceIdsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotResourceIdsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.ResourceIds = append(params.ResourceIds, paramsDotResourceIdsVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceIds",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resourceNames.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceNames",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotResourceNamesVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotResourceNamesVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.ResourceNames = append(params.ResourceNames, paramsDotResourceNamesVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceNames",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRestoreTaskParams is parameters of getRestoreTask operation.
type GetRestoreTaskParams struct {
	// The restore task ID.
	ID string
}

func unpackGetRestoreTaskParams(packed middleware.Parameters) (params GetRestoreTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetRestoreTaskParams(args [1]string, argsEscaped bool, r *http.Request) (params GetRestoreTaskParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetResultParams is parameters of getResult operation.
type GetResultParams struct {
	// UUID of the task.
	RunId uuid.UUID
}

func unpackGetResultParams(packed middleware.Parameters) (params GetResultParams) {
	{
		key := middleware.ParameterKey{
			Name: "runId",
			In:   "path",
		}
		params.RunId = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetResultParams(args [1]string, argsEscaped bool, r *http.Request) (params GetResultParams, _ error) {
	// Decode path: runId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.RunId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "runId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSSODomainEntitiesParams is parameters of getSSODomainEntities operation.
type GetSSODomainEntitiesParams struct {
	// SSO Domain Name.
	SSODomain string
	// Search Criteria for the users and groups.
	EntityName OptString
}

func unpackGetSSODomainEntitiesParams(packed middleware.Parameters) (params GetSSODomainEntitiesParams) {
	{
		key := middleware.ParameterKey{
			Name: "sso-domain",
			In:   "path",
		}
		params.SSODomain = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "entityName",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EntityName = v.(OptString)
		}
	}
	return params
}

func decodeGetSSODomainEntitiesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSSODomainEntitiesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: sso-domain.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sso-domain",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SSODomain = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sso-domain",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: entityName.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "entityName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEntityNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEntityNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EntityName.SetTo(paramsDotEntityNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "entityName",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetSddcManagerParams is parameters of getSddcManager operation.
type GetSddcManagerParams struct {
	// Sddc Manager ID.
	ID string
}

func unpackGetSddcManagerParams(packed middleware.Parameters) (params GetSddcManagerParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetSddcManagerParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSddcManagerParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSddcManagerHistoryParams is parameters of getSddcManagerHistory operation.
type GetSddcManagerHistoryParams struct {
	// SDDC Manager ID.
	ID string
}

func unpackGetSddcManagerHistoryParams(packed middleware.Parameters) (params GetSddcManagerHistoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetSddcManagerHistoryParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSddcManagerHistoryParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSddcManagerInfoParams is parameters of getSddcManagerInfo operation.
type GetSddcManagerInfoParams struct {
	// SDDC ID.
	ID int
}

func unpackGetSddcManagerInfoParams(packed middleware.Parameters) (params GetSddcManagerInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(int)
	}
	return params
}

func decodeGetSddcManagerInfoParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSddcManagerInfoParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           36,
					MaxSet:        true,
					Max:           36,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.ID)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSupportBundleStatusParams is parameters of getSupportBundleStatus operation.
type GetSupportBundleStatusParams struct {
	// The Support Bundle ID.
	ID string
}

func unpackGetSupportBundleStatusParams(packed middleware.Parameters) (params GetSupportBundleStatusParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetSupportBundleStatusParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSupportBundleStatusParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetTagAssignableForClusterParams is parameters of getTagAssignableForCluster operation.
type GetTagAssignableForClusterParams struct {
	// Cluster ID.
	ID string
}

func unpackGetTagAssignableForClusterParams(packed middleware.Parameters) (params GetTagAssignableForClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetTagAssignableForClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params GetTagAssignableForClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetTagsAssignedToClusterParams is parameters of getTagsAssignedToCluster operation.
type GetTagsAssignedToClusterParams struct {
	// Cluster ID.
	ID string
}

func unpackGetTagsAssignedToClusterParams(packed middleware.Parameters) (params GetTagsAssignedToClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetTagsAssignedToClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params GetTagsAssignedToClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetTagsAssignedToDomainParams is parameters of getTagsAssignedToDomain operation.
type GetTagsAssignedToDomainParams struct {
	// Domain ID.
	ID string
}

func unpackGetTagsAssignedToDomainParams(packed middleware.Parameters) (params GetTagsAssignedToDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetTagsAssignedToDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params GetTagsAssignedToDomainParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetTagsAssignedToHostParams is parameters of getTagsAssignedToHost operation.
type GetTagsAssignedToHostParams struct {
	// Host ID.
	ID string
}

func unpackGetTagsAssignedToHostParams(packed middleware.Parameters) (params GetTagsAssignedToHostParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetTagsAssignedToHostParams(args [1]string, argsEscaped bool, r *http.Request) (params GetTagsAssignedToHostParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetTaskParams is parameters of getTask operation.
type GetTaskParams struct {
	// Task id to retrieve.
	ID string
}

func unpackGetTaskParams(packed middleware.Parameters) (params GetTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetTaskParams(args [1]string, argsEscaped bool, r *http.Request) (params GetTaskParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetTasksParams is parameters of getTasks operation.
type GetTasksParams struct {
	// The number of elements to be returned in the result.
	Limit        OptInt32
	TaskStatus   OptString
	TaskType     OptString
	ResourceId   OptString
	ResourceType OptString
	// A time based filter to get tasks which are completed after the given timestamp. A task is
	// completed if its status is 'Successful' or 'Failed'. Time is in milliseconds.
	CompletedAfter OptInt64
	// Page number.
	PageNumber OptInt32
	// Size of the page you want to retrieve. Max page size allowed is 100.
	PageSize       OptInt32
	OrderDirection OptString
	OrderBy        OptString
	// Search filter when task name contains text.
	TaskName OptString
}

func unpackGetTasksParams(packed middleware.Parameters) (params GetTasksParams) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "taskStatus",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TaskStatus = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "taskType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TaskType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resourceId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "resourceType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResourceType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "completedAfter",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.CompletedAfter = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "pageNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageNumber = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "pageSize",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.PageSize = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "orderDirection",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.OrderDirection = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "orderBy",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.OrderBy = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "taskName",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TaskName = v.(OptString)
		}
	}
	return params
}

func decodeGetTasksParams(args [0]string, argsEscaped bool, r *http.Request) (params GetTasksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: taskStatus.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "taskStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTaskStatusVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTaskStatusVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TaskStatus.SetTo(paramsDotTaskStatusVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "taskStatus",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: taskType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "taskType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTaskTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTaskTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TaskType.SetTo(paramsDotTaskTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "taskType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resourceId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceId.SetTo(paramsDotResourceIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: resourceType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceType.SetTo(paramsDotResourceTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resourceType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: completedAfter.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "completedAfter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCompletedAfterVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotCompletedAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CompletedAfter.SetTo(paramsDotCompletedAfterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "completedAfter",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: pageNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pageNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageNumberVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotPageNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageNumber.SetTo(paramsDotPageNumberVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "pageNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: pageSize.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageSizeVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotPageSizeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PageSize.SetTo(paramsDotPageSizeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "pageSize",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: orderDirection.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orderDirection",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderDirectionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderDirectionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.OrderDirection.SetTo(paramsDotOrderDirectionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "orderDirection",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: orderBy.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orderBy",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderByVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderByVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.OrderBy.SetTo(paramsDotOrderByVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "orderBy",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: taskName.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "taskName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTaskNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTaskNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TaskName.SetTo(paramsDotTaskNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "taskName",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetUpgradablesByDomainParams is parameters of getUpgradablesByDomain operation.
type GetUpgradablesByDomainParams struct {
	// Domain ID.
	DomainId string
	// Target Version to get Upgradables for a given Target Release.
	TargetVersion OptString
}

func unpackGetUpgradablesByDomainParams(packed middleware.Parameters) (params GetUpgradablesByDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "targetVersion",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TargetVersion = v.(OptString)
		}
	}
	return params
}

func decodeGetUpgradablesByDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params GetUpgradablesByDomainParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: targetVersion.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "targetVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTargetVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTargetVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TargetVersion.SetTo(paramsDotTargetVersionVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "targetVersion",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetUpgradablesClustersParams is parameters of getUpgradablesClusters operation.
type GetUpgradablesClustersParams struct {
	// Domain ID.
	DomainId string
}

func unpackGetUpgradablesClustersParams(packed middleware.Parameters) (params GetUpgradablesClustersParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodeGetUpgradablesClustersParams(args [1]string, argsEscaped bool, r *http.Request) (params GetUpgradablesClustersParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetUpgradeByIdParams is parameters of getUpgradeById operation.
type GetUpgradeByIdParams struct {
	UpgradeId string
}

func unpackGetUpgradeByIdParams(packed middleware.Parameters) (params GetUpgradeByIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "upgradeId",
			In:   "path",
		}
		params.UpgradeId = packed[key].(string)
	}
	return params
}

func decodeGetUpgradeByIdParams(args [1]string, argsEscaped bool, r *http.Request) (params GetUpgradeByIdParams, _ error) {
	// Decode path: upgradeId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "upgradeId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UpgradeId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "upgradeId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetUpgradePrecheckByIDParams is parameters of getUpgradePrecheckByID operation.
type GetUpgradePrecheckByIDParams struct {
	UpgradeId  string
	PrecheckId string
}

func unpackGetUpgradePrecheckByIDParams(packed middleware.Parameters) (params GetUpgradePrecheckByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "upgradeId",
			In:   "path",
		}
		params.UpgradeId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "precheckId",
			In:   "path",
		}
		params.PrecheckId = packed[key].(string)
	}
	return params
}

func decodeGetUpgradePrecheckByIDParams(args [2]string, argsEscaped bool, r *http.Request) (params GetUpgradePrecheckByIDParams, _ error) {
	// Decode path: upgradeId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "upgradeId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UpgradeId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "upgradeId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: precheckId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "precheckId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PrecheckId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "precheckId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetUpgradesParams is parameters of getUpgrades operation.
type GetUpgradesParams struct {
	// Status of the upgrades you want to retrieve.
	Status OptString
	// Bundle Id for the upgrade.
	BundleId OptString
	// Bundle type of the upgrades you want to retrieve.
	BundleType OptString
}

func unpackGetUpgradesParams(packed middleware.Parameters) (params GetUpgradesParams) {
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "bundleId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BundleId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "bundleType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BundleType = v.(OptString)
		}
	}
	return params
}

func decodeGetUpgradesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetUpgradesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: bundleId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "bundleId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBundleIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBundleIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BundleId.SetTo(paramsDotBundleIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "bundleId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: bundleType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "bundleType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBundleTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBundleTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BundleType.SetTo(paramsDotBundleTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "bundleType",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetValidationOfDnsConfigurationParams is parameters of getValidationOfDnsConfiguration operation.
type GetValidationOfDnsConfigurationParams struct {
	// The validation ID.
	ID string
}

func unpackGetValidationOfDnsConfigurationParams(packed middleware.Parameters) (params GetValidationOfDnsConfigurationParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetValidationOfDnsConfigurationParams(args [1]string, argsEscaped bool, r *http.Request) (params GetValidationOfDnsConfigurationParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetValidationOfNtpConfigurationParams is parameters of getValidationOfNtpConfiguration operation.
type GetValidationOfNtpConfigurationParams struct {
	// The validation ID.
	ID string
}

func unpackGetValidationOfNtpConfigurationParams(packed middleware.Parameters) (params GetValidationOfNtpConfigurationParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetValidationOfNtpConfigurationParams(args [1]string, argsEscaped bool, r *http.Request) (params GetValidationOfNtpConfigurationParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetValidationResultParams is parameters of getValidationResult operation.
type GetValidationResultParams struct {
	ID string
}

func unpackGetValidationResultParams(packed middleware.Parameters) (params GetValidationResultParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetValidationResultParams(args [1]string, argsEscaped bool, r *http.Request) (params GetValidationResultParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetValidationsOfDNSConfigurationParams is parameters of getValidationsOfDNSConfiguration operation.
type GetValidationsOfDNSConfigurationParams struct {
	// ExecutionStatus.
	ExecutionStatus OptString
}

func unpackGetValidationsOfDNSConfigurationParams(packed middleware.Parameters) (params GetValidationsOfDNSConfigurationParams) {
	{
		key := middleware.ParameterKey{
			Name: "executionStatus",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ExecutionStatus = v.(OptString)
		}
	}
	return params
}

func decodeGetValidationsOfDNSConfigurationParams(args [0]string, argsEscaped bool, r *http.Request) (params GetValidationsOfDNSConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: executionStatus.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "executionStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotExecutionStatusVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotExecutionStatusVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ExecutionStatus.SetTo(paramsDotExecutionStatusVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "executionStatus",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetValidationsOfNtpConfigurationParams is parameters of getValidationsOfNtpConfiguration operation.
type GetValidationsOfNtpConfigurationParams struct {
	// ExecutionStatus.
	ExecutionStatus OptString
}

func unpackGetValidationsOfNtpConfigurationParams(packed middleware.Parameters) (params GetValidationsOfNtpConfigurationParams) {
	{
		key := middleware.ParameterKey{
			Name: "executionStatus",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ExecutionStatus = v.(OptString)
		}
	}
	return params
}

func decodeGetValidationsOfNtpConfigurationParams(args [0]string, argsEscaped bool, r *http.Request) (params GetValidationsOfNtpConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: executionStatus.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "executionStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotExecutionStatusVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotExecutionStatusVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ExecutionStatus.SetTo(paramsDotExecutionStatusVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "executionStatus",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetVasaProviderParams is parameters of getVasaProvider operation.
type GetVasaProviderParams struct {
	// VASA Provider ID.
	ID string
}

func unpackGetVasaProviderParams(packed middleware.Parameters) (params GetVasaProviderParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetVasaProviderParams(args [1]string, argsEscaped bool, r *http.Request) (params GetVasaProviderParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetVasaProviderStorageContainersParams is parameters of getVasaProviderStorageContainers operation.
type GetVasaProviderStorageContainersParams struct {
	// Pass an optional Storage Protocol type.
	ProtocolType OptString
	// VASA Provider ID.
	ID string
}

func unpackGetVasaProviderStorageContainersParams(packed middleware.Parameters) (params GetVasaProviderStorageContainersParams) {
	{
		key := middleware.ParameterKey{
			Name: "protocolType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProtocolType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetVasaProviderStorageContainersParams(args [1]string, argsEscaped bool, r *http.Request) (params GetVasaProviderStorageContainersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: protocolType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "protocolType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProtocolTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProtocolTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ProtocolType.SetTo(paramsDotProtocolTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "protocolType",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetVasaProviderUserParams is parameters of getVasaProviderUser operation.
type GetVasaProviderUserParams struct {
	// VASA Provider ID.
	ID string
}

func unpackGetVasaProviderUserParams(packed middleware.Parameters) (params GetVasaProviderUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetVasaProviderUserParams(args [1]string, argsEscaped bool, r *http.Request) (params GetVasaProviderUserParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetVasaProviderValidationParams is parameters of getVasaProviderValidation operation.
type GetVasaProviderValidationParams struct {
	// The validation ID.
	ID string
}

func unpackGetVasaProviderValidationParams(packed middleware.Parameters) (params GetVasaProviderValidationParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetVasaProviderValidationParams(args [1]string, argsEscaped bool, r *http.Request) (params GetVasaProviderValidationParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetVcenterParams is parameters of getVcenter operation.
type GetVcenterParams struct {
	// VCenter ID.
	ID string
}

func unpackGetVcenterParams(packed middleware.Parameters) (params GetVcenterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetVcenterParams(args [1]string, argsEscaped bool, r *http.Request) (params GetVcenterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetVcentersParams is parameters of getVcenters operation.
type GetVcentersParams struct {
	// ID of the domain.
	DomainId OptString
}

func unpackGetVcentersParams(packed middleware.Parameters) (params GetVcentersParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DomainId = v.(OptString)
		}
	}
	return params
}

func decodeGetVcentersParams(args [0]string, argsEscaped bool, r *http.Request) (params GetVcentersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: domainId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDomainIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDomainIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DomainId.SetTo(paramsDotDomainIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetVcfServiceParams is parameters of getVcfService operation.
type GetVcfServiceParams struct {
	// VcfService ID.
	ID string
}

func unpackGetVcfServiceParams(packed middleware.Parameters) (params GetVcfServiceParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetVcfServiceParams(args [1]string, argsEscaped bool, r *http.Request) (params GetVcfServiceParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetVdsesParams is parameters of getVdses operation.
type GetVdsesParams struct {
	// Cluster ID.
	ClusterId string
}

func unpackGetVdsesParams(packed middleware.Parameters) (params GetVdsesParams) {
	{
		key := middleware.ParameterKey{
			Name: "clusterId",
			In:   "path",
		}
		params.ClusterId = packed[key].(string)
	}
	return params
}

func decodeGetVdsesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetVdsesParams, _ error) {
	// Decode path: clusterId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "clusterId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClusterId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "clusterId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetVrslcmValidationParams is parameters of getVrslcmValidation operation.
type GetVrslcmValidationParams struct {
	// VMware Aria validation ID.
	ID uuid.UUID
}

func unpackGetVrslcmValidationParams(packed middleware.Parameters) (params GetVrslcmValidationParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(uuid.UUID)
	}
	return params
}

func decodeGetVrslcmValidationParams(args [1]string, argsEscaped bool, r *http.Request) (params GetVrslcmValidationParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetVsanHealthCheckByDomainParams is parameters of getVsanHealthCheckByDomain operation.
type GetVsanHealthCheckByDomainParams struct {
	// Domain ID.
	DomainId string
	// Status of health check to filter by.
	Status OptString
}

func unpackGetVsanHealthCheckByDomainParams(packed middleware.Parameters) (params GetVsanHealthCheckByDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "status",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Status = v.(OptString)
		}
	}
	return params
}

func decodeGetVsanHealthCheckByDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params GetVsanHealthCheckByDomainParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: status.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "status",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetVsanHealthCheckByQueryIDParams is parameters of getVsanHealthCheckByQueryID operation.
type GetVsanHealthCheckByQueryIDParams struct {
	// Domain ID.
	DomainId string
	// Query ID.
	QueryId string
}

func unpackGetVsanHealthCheckByQueryIDParams(packed middleware.Parameters) (params GetVsanHealthCheckByQueryIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "queryId",
			In:   "path",
		}
		params.QueryId = packed[key].(string)
	}
	return params
}

func decodeGetVsanHealthCheckByQueryIDParams(args [2]string, argsEscaped bool, r *http.Request) (params GetVsanHealthCheckByQueryIDParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: queryId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "queryId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.QueryId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "queryId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetVsanHealthCheckByTaskIDParams is parameters of getVsanHealthCheckByTaskID operation.
type GetVsanHealthCheckByTaskIDParams struct {
	// Domain ID.
	DomainId string
	// Health check task id.
	TaskId string
}

func unpackGetVsanHealthCheckByTaskIDParams(packed middleware.Parameters) (params GetVsanHealthCheckByTaskIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "taskId",
			In:   "path",
		}
		params.TaskId = packed[key].(string)
	}
	return params
}

func decodeGetVsanHealthCheckByTaskIDParams(args [2]string, argsEscaped bool, r *http.Request) (params GetVsanHealthCheckByTaskIDParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: taskId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "taskId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TaskId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "taskId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ImportVdsToInventoryParams is parameters of importVdsToInventory operation.
type ImportVdsToInventoryParams struct {
	// Cluster ID.
	ClusterId string
}

func unpackImportVdsToInventoryParams(packed middleware.Parameters) (params ImportVdsToInventoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "clusterId",
			In:   "path",
		}
		params.ClusterId = packed[key].(string)
	}
	return params
}

func decodeImportVdsToInventoryParams(args [1]string, argsEscaped bool, r *http.Request) (params ImportVdsToInventoryParams, _ error) {
	// Decode path: clusterId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "clusterId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClusterId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "clusterId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// PerformDomainIsolationPrecheckParams is parameters of performDomainIsolationPrecheck operation.
type PerformDomainIsolationPrecheckParams struct {
	// Domain ID.
	DomainId string
}

func unpackPerformDomainIsolationPrecheckParams(packed middleware.Parameters) (params PerformDomainIsolationPrecheckParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodePerformDomainIsolationPrecheckParams(args [1]string, argsEscaped bool, r *http.Request) (params PerformDomainIsolationPrecheckParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// PostClusterQueryParams is parameters of postClusterQuery operation.
type PostClusterQueryParams struct {
	// Domain ID.
	DomainId string
	// Cluster Name.
	ClusterName string
}

func unpackPostClusterQueryParams(packed middleware.Parameters) (params PostClusterQueryParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "clusterName",
			In:   "path",
		}
		params.ClusterName = packed[key].(string)
	}
	return params
}

func decodePostClusterQueryParams(args [2]string, argsEscaped bool, r *http.Request) (params PostClusterQueryParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: clusterName.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "clusterName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClusterName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "clusterName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// PostClustersQueryParams is parameters of postClustersQuery operation.
type PostClustersQueryParams struct {
	// Domain ID.
	DomainId string
}

func unpackPostClustersQueryParams(packed middleware.Parameters) (params PostClustersQueryParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodePostClustersQueryParams(args [1]string, argsEscaped bool, r *http.Request) (params PostClustersQueryParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// PostDatastoreQueryParams is parameters of postDatastoreQuery operation.
type PostDatastoreQueryParams struct {
	// Domain ID.
	DomainId string
}

func unpackPostDatastoreQueryParams(packed middleware.Parameters) (params PostDatastoreQueryParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodePostDatastoreQueryParams(args [1]string, argsEscaped bool, r *http.Request) (params PostDatastoreQueryParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// PostDatastoreQuery1Params is parameters of postDatastoreQuery_1 operation.
type PostDatastoreQuery1Params struct {
	// Cluster ID.
	ID string
}

func unpackPostDatastoreQuery1Params(packed middleware.Parameters) (params PostDatastoreQuery1Params) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodePostDatastoreQuery1Params(args [1]string, argsEscaped bool, r *http.Request) (params PostDatastoreQuery1Params, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// PostHostQueryParams is parameters of postHostQuery operation.
type PostHostQueryParams struct {
	// Cluster ID.
	ID string
}

func unpackPostHostQueryParams(packed middleware.Parameters) (params PostHostQueryParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodePostHostQueryParams(args [1]string, argsEscaped bool, r *http.Request) (params PostHostQueryParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveCertificateAuthorityParams is parameters of removeCertificateAuthority operation.
type RemoveCertificateAuthorityParams struct {
	// The CA type.
	ID string
}

func unpackRemoveCertificateAuthorityParams(packed middleware.Parameters) (params RemoveCertificateAuthorityParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRemoveCertificateAuthorityParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveCertificateAuthorityParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveDatastoreFromClusterParams is parameters of removeDatastoreFromCluster operation.
type RemoveDatastoreFromClusterParams struct {
	// Cluster ID.
	ID string
	// Datastore ID.
	DatastoreId string
}

func unpackRemoveDatastoreFromClusterParams(packed middleware.Parameters) (params RemoveDatastoreFromClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "datastoreId",
			In:   "path",
		}
		params.DatastoreId = packed[key].(string)
	}
	return params
}

func decodeRemoveDatastoreFromClusterParams(args [2]string, argsEscaped bool, r *http.Request) (params RemoveDatastoreFromClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: datastoreId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "datastoreId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DatastoreId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "datastoreId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveLicenseKeyParams is parameters of removeLicenseKey operation.
type RemoveLicenseKeyParams struct {
	// The 29 alpha numeric character license key with hyphens.
	Key string
}

func unpackRemoveLicenseKeyParams(packed middleware.Parameters) (params RemoveLicenseKeyParams) {
	{
		key := middleware.ParameterKey{
			Name: "key",
			In:   "path",
		}
		params.Key = packed[key].(string)
	}
	return params
}

func decodeRemoveLicenseKeyParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveLicenseKeyParams, _ error) {
	// Decode path: key.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Key = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "key",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveTagsFromClusterParams is parameters of removeTagsFromCluster operation.
type RemoveTagsFromClusterParams struct {
	// Cluster ID.
	ID string
}

func unpackRemoveTagsFromClusterParams(packed middleware.Parameters) (params RemoveTagsFromClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRemoveTagsFromClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveTagsFromClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveTagsFromDomainParams is parameters of removeTagsFromDomain operation.
type RemoveTagsFromDomainParams struct {
	// Domain ID.
	ID string
}

func unpackRemoveTagsFromDomainParams(packed middleware.Parameters) (params RemoveTagsFromDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRemoveTagsFromDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveTagsFromDomainParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveTagsFromHostParams is parameters of removeTagsFromHost operation.
type RemoveTagsFromHostParams struct {
	// Host ID.
	ID string
}

func unpackRemoveTagsFromHostParams(packed middleware.Parameters) (params RemoveTagsFromHostParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRemoveTagsFromHostParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveTagsFromHostParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveUserParams is parameters of removeUser operation.
type RemoveUserParams struct {
	// ID of the user.
	ID string
}

func unpackRemoveUserParams(packed middleware.Parameters) (params RemoveUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRemoveUserParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveUserParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveVasaProviderParams is parameters of removeVasaProvider operation.
type RemoveVasaProviderParams struct {
	// VASA Provider ID.
	ID string
}

func unpackRemoveVasaProviderParams(packed middleware.Parameters) (params RemoveVasaProviderParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRemoveVasaProviderParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveVasaProviderParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveVasaProviderStorageContainerParams is parameters of removeVasaProviderStorageContainer operation.
type RemoveVasaProviderStorageContainerParams struct {
	// VASA Provider ID.
	ID string
	// Storage container ID.
	StorageContainerId string
}

func unpackRemoveVasaProviderStorageContainerParams(packed middleware.Parameters) (params RemoveVasaProviderStorageContainerParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "storageContainerId",
			In:   "path",
		}
		params.StorageContainerId = packed[key].(string)
	}
	return params
}

func decodeRemoveVasaProviderStorageContainerParams(args [2]string, argsEscaped bool, r *http.Request) (params RemoveVasaProviderStorageContainerParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: storageContainerId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "storageContainerId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.StorageContainerId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "storageContainerId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RenameCustomIsoByIdParams is parameters of renameCustomIsoById operation.
type RenameCustomIsoByIdParams struct {
	// Custom ISO ID.
	CustomIsoID string
}

func unpackRenameCustomIsoByIdParams(packed middleware.Parameters) (params RenameCustomIsoByIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "custom_iso_id",
			In:   "path",
		}
		params.CustomIsoID = packed[key].(string)
	}
	return params
}

func decodeRenameCustomIsoByIdParams(args [1]string, argsEscaped bool, r *http.Request) (params RenameCustomIsoByIdParams, _ error) {
	// Decode path: custom_iso_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "custom_iso_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CustomIsoID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "custom_iso_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RenamePersonalityByIdParams is parameters of renamePersonalityById operation.
type RenamePersonalityByIdParams struct {
	// The personality id.
	PersonalityId string
}

func unpackRenamePersonalityByIdParams(packed middleware.Parameters) (params RenamePersonalityByIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "personalityId",
			In:   "path",
		}
		params.PersonalityId = packed[key].(string)
	}
	return params
}

func decodeRenamePersonalityByIdParams(args [1]string, argsEscaped bool, r *http.Request) (params RenamePersonalityByIdParams, _ error) {
	// Decode path: personalityId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "personalityId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PersonalityId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "personalityId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReplaceCertificatesParams is parameters of replaceCertificates operation.
type ReplaceCertificatesParams struct {
	// Domain ID or Name.
	ID string
}

func unpackReplaceCertificatesParams(packed middleware.Parameters) (params ReplaceCertificatesParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeReplaceCertificatesParams(args [1]string, argsEscaped bool, r *http.Request) (params ReplaceCertificatesParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReplaceResourceCertificatesParams is parameters of replaceResourceCertificates operation.
type ReplaceResourceCertificatesParams struct {
	// Domain ID.
	ID string
}

func unpackReplaceResourceCertificatesParams(packed middleware.Parameters) (params ReplaceResourceCertificatesParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeReplaceResourceCertificatesParams(args [1]string, argsEscaped bool, r *http.Request) (params ReplaceResourceCertificatesParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RetryComplianceAuditTaskParams is parameters of retryComplianceAuditTask operation.
type RetryComplianceAuditTaskParams struct {
	// Domain ID.
	ID string
	// Audit task ID.
	TaskId string
}

func unpackRetryComplianceAuditTaskParams(packed middleware.Parameters) (params RetryComplianceAuditTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "taskId",
			In:   "path",
		}
		params.TaskId = packed[key].(string)
	}
	return params
}

func decodeRetryComplianceAuditTaskParams(args [2]string, argsEscaped bool, r *http.Request) (params RetryComplianceAuditTaskParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: taskId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "taskId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TaskId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "taskId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RetryCredentialsTaskParams is parameters of retryCredentialsTask operation.
type RetryCredentialsTaskParams struct {
	// Task ID of the failed operation that is to be retried.
	ID string
}

func unpackRetryCredentialsTaskParams(packed middleware.Parameters) (params RetryCredentialsTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRetryCredentialsTaskParams(args [1]string, argsEscaped bool, r *http.Request) (params RetryCredentialsTaskParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RetrySddcParams is parameters of retrySddc operation.
type RetrySddcParams struct {
	// SDDC ID.
	ID int
}

func unpackRetrySddcParams(packed middleware.Parameters) (params RetrySddcParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(int)
	}
	return params
}

func decodeRetrySddcParams(args [1]string, argsEscaped bool, r *http.Request) (params RetrySddcParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           36,
					MaxSet:        true,
					Max:           36,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.ID)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RetryTaskParams is parameters of retryTask operation.
type RetryTaskParams struct {
	// Task id retry.
	ID string
}

func unpackRetryTaskParams(packed middleware.Parameters) (params RetryTaskParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeRetryTaskParams(args [1]string, argsEscaped bool, r *http.Request) (params RetryTaskParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// StartBringupSpecConversionParams is parameters of startBringupSpecConversion operation.
type StartBringupSpecConversionParams struct {
	// Supported bringup designs - EMS, VXRAIL.
	Design OptStartBringupSpecConversionDesign
}

func unpackStartBringupSpecConversionParams(packed middleware.Parameters) (params StartBringupSpecConversionParams) {
	{
		key := middleware.ParameterKey{
			Name: "design",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Design = v.(OptStartBringupSpecConversionDesign)
		}
	}
	return params
}

func decodeStartBringupSpecConversionParams(args [0]string, argsEscaped bool, r *http.Request) (params StartBringupSpecConversionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: design.
	{
		val := StartBringupSpecConversionDesign("EMS")
		params.Design.SetTo(val)
	}
	// Decode query: design.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "design",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDesignVal StartBringupSpecConversionDesign
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDesignVal = StartBringupSpecConversionDesign(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Design.SetTo(paramsDotDesignVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Design.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "design",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// StartBundleDownloadByIDParams is parameters of startBundleDownloadByID operation.
type StartBundleDownloadByIDParams struct {
	// Bundle ID.
	ID string
}

func unpackStartBundleDownloadByIDParams(packed middleware.Parameters) (params StartBundleDownloadByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeStartBundleDownloadByIDParams(args [1]string, argsEscaped bool, r *http.Request) (params StartBundleDownloadByIDParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// StartUpgradePrecheckParams is parameters of startUpgradePrecheck operation.
type StartUpgradePrecheckParams struct {
	UpgradeId string
}

func unpackStartUpgradePrecheckParams(packed middleware.Parameters) (params StartUpgradePrecheckParams) {
	{
		key := middleware.ParameterKey{
			Name: "upgradeId",
			In:   "path",
		}
		params.UpgradeId = packed[key].(string)
	}
	return params
}

func decodeStartUpgradePrecheckParams(args [1]string, argsEscaped bool, r *http.Request) (params StartUpgradePrecheckParams, _ error) {
	// Decode path: upgradeId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "upgradeId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UpgradeId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "upgradeId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TriggerPartialRetryOfCheckRunParams is parameters of triggerPartialRetryOfCheckRun operation.
type TriggerPartialRetryOfCheckRunParams struct {
	// UUID of the assessment to retry.
	RunId uuid.UUID
}

func unpackTriggerPartialRetryOfCheckRunParams(packed middleware.Parameters) (params TriggerPartialRetryOfCheckRunParams) {
	{
		key := middleware.ParameterKey{
			Name: "runId",
			In:   "path",
		}
		params.RunId = packed[key].(uuid.UUID)
	}
	return params
}

func decodeTriggerPartialRetryOfCheckRunParams(args [1]string, argsEscaped bool, r *http.Request) (params TriggerPartialRetryOfCheckRunParams, _ error) {
	// Decode path: runId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.RunId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "runId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateClusterParams is parameters of updateCluster operation.
type UpdateClusterParams struct {
	// Cluster ID.
	ID string
}

func unpackUpdateClusterParams(packed middleware.Parameters) (params UpdateClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateDomainParams is parameters of updateDomain operation.
type UpdateDomainParams struct {
	// Domain ID.
	ID string
}

func unpackUpdateDomainParams(packed middleware.Parameters) (params UpdateDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateDomainParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateEdgeClusterParams is parameters of updateEdgeCluster operation.
type UpdateEdgeClusterParams struct {
	// Edge Cluster ID.
	ID string
}

func unpackUpdateEdgeClusterParams(packed middleware.Parameters) (params UpdateEdgeClusterParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateEdgeClusterParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateEdgeClusterParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateLicenseKeyParams is parameters of updateLicenseKey operation.
type UpdateLicenseKeyParams struct {
	// The 29 alpha numeric character license key with hyphens.
	Key string
}

func unpackUpdateLicenseKeyParams(packed middleware.Parameters) (params UpdateLicenseKeyParams) {
	{
		key := middleware.ParameterKey{
			Name: "key",
			In:   "path",
		}
		params.Key = packed[key].(string)
	}
	return params
}

func decodeUpdateLicenseKeyParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateLicenseKeyParams, _ error) {
	// Decode path: key.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Key = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "key",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateNetworkPoolParams is parameters of updateNetworkPool operation.
type UpdateNetworkPoolParams struct {
	// Network Pool ID.
	ID string
}

func unpackUpdateNetworkPoolParams(packed middleware.Parameters) (params UpdateNetworkPoolParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateNetworkPoolParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateNetworkPoolParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateReleaseByDomainIDParams is parameters of updateReleaseByDomainID operation.
type UpdateReleaseByDomainIDParams struct {
	// Domain ID.
	DomainId string
}

func unpackUpdateReleaseByDomainIDParams(packed middleware.Parameters) (params UpdateReleaseByDomainIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodeUpdateReleaseByDomainIDParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateReleaseByDomainIDParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateUpgradeScheduleParams is parameters of updateUpgradeSchedule operation.
type UpdateUpgradeScheduleParams struct {
	UpgradeId string
}

func unpackUpdateUpgradeScheduleParams(packed middleware.Parameters) (params UpdateUpgradeScheduleParams) {
	{
		key := middleware.ParameterKey{
			Name: "upgradeId",
			In:   "path",
		}
		params.UpgradeId = packed[key].(string)
	}
	return params
}

func decodeUpdateUpgradeScheduleParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateUpgradeScheduleParams, _ error) {
	// Decode path: upgradeId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "upgradeId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UpgradeId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "upgradeId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateVasaProviderParams is parameters of updateVasaProvider operation.
type UpdateVasaProviderParams struct {
	// VASA Provider ID.
	ID string
}

func unpackUpdateVasaProviderParams(packed middleware.Parameters) (params UpdateVasaProviderParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateVasaProviderParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateVasaProviderParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateVasaProviderStorageContainerParams is parameters of updateVasaProviderStorageContainer operation.
type UpdateVasaProviderStorageContainerParams struct {
	// VASA Provider ID.
	ID string
	// Storage container ID.
	StorageContainerId string
}

func unpackUpdateVasaProviderStorageContainerParams(packed middleware.Parameters) (params UpdateVasaProviderStorageContainerParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "storageContainerId",
			In:   "path",
		}
		params.StorageContainerId = packed[key].(string)
	}
	return params
}

func decodeUpdateVasaProviderStorageContainerParams(args [2]string, argsEscaped bool, r *http.Request) (params UpdateVasaProviderStorageContainerParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: storageContainerId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "storageContainerId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.StorageContainerId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "storageContainerId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateVasaProviderUserParams is parameters of updateVasaProviderUser operation.
type UpdateVasaProviderUserParams struct {
	// VASA Provider ID.
	ID string
	// User ID.
	UserId string
}

func unpackUpdateVasaProviderUserParams(packed middleware.Parameters) (params UpdateVasaProviderUserParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	return params
}

func decodeUpdateVasaProviderUserParams(args [2]string, argsEscaped bool, r *http.Request) (params UpdateVasaProviderUserParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: userId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateVersionAliasConfigurationParams is parameters of updateVersionAliasConfiguration operation.
type UpdateVersionAliasConfigurationParams struct {
	// Bundle Component Type.
	BundleComponentType string
	// Version.
	Version string
}

func unpackUpdateVersionAliasConfigurationParams(packed middleware.Parameters) (params UpdateVersionAliasConfigurationParams) {
	{
		key := middleware.ParameterKey{
			Name: "bundleComponentType",
			In:   "path",
		}
		params.BundleComponentType = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "version",
			In:   "path",
		}
		params.Version = packed[key].(string)
	}
	return params
}

func decodeUpdateVersionAliasConfigurationParams(args [2]string, argsEscaped bool, r *http.Request) (params UpdateVersionAliasConfigurationParams, _ error) {
	// Decode path: bundleComponentType.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "bundleComponentType",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BundleComponentType = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "bundleComponentType",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: version.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "version",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Version = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "version",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateVrslcmVersionByIdInInventoryParams is parameters of updateVrslcmVersionByIdInInventory operation.
type UpdateVrslcmVersionByIdInInventoryParams struct {
	// The ID of VMware Aria Suite Lifecycle instance.
	ID string
}

func unpackUpdateVrslcmVersionByIdInInventoryParams(packed middleware.Parameters) (params UpdateVrslcmVersionByIdInInventoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUpdateVrslcmVersionByIdInInventoryParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateVrslcmVersionByIdInInventoryParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateVsanHealthCheckByDomainParams is parameters of updateVsanHealthCheckByDomain operation.
type UpdateVsanHealthCheckByDomainParams struct {
	// Domain ID.
	DomainId string
}

func unpackUpdateVsanHealthCheckByDomainParams(packed middleware.Parameters) (params UpdateVsanHealthCheckByDomainParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodeUpdateVsanHealthCheckByDomainParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateVsanHealthCheckByDomainParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UploadCertificatesParams is parameters of uploadCertificates operation.
type UploadCertificatesParams struct {
	// Domain ID or Name.
	ID string
}

func unpackUploadCertificatesParams(packed middleware.Parameters) (params UploadCertificatesParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeUploadCertificatesParams(args [1]string, argsEscaped bool, r *http.Request) (params UploadCertificatesParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UploadCustomIsoParams is parameters of uploadCustomIso operation.
type UploadCustomIsoParams struct {
	Name string
}

func unpackUploadCustomIsoParams(packed middleware.Parameters) (params UploadCustomIsoParams) {
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeUploadCustomIsoParams(args [0]string, argsEscaped bool, r *http.Request) (params UploadCustomIsoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ValidateALBClusterCreationSpecParams is parameters of validateALBClusterCreationSpec operation.
type ValidateALBClusterCreationSpecParams struct {
	// Pass an optional Skip compatibility checks.
	SkipCompatibilityCheck OptBool
}

func unpackValidateALBClusterCreationSpecParams(packed middleware.Parameters) (params ValidateALBClusterCreationSpecParams) {
	{
		key := middleware.ParameterKey{
			Name: "skipCompatibilityCheck",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SkipCompatibilityCheck = v.(OptBool)
		}
	}
	return params
}

func decodeValidateALBClusterCreationSpecParams(args [0]string, argsEscaped bool, r *http.Request) (params ValidateALBClusterCreationSpecParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: skipCompatibilityCheck.
	{
		val := bool(false)
		params.SkipCompatibilityCheck.SetTo(val)
	}
	// Decode query: skipCompatibilityCheck.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "skipCompatibilityCheck",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSkipCompatibilityCheckVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotSkipCompatibilityCheckVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SkipCompatibilityCheck.SetTo(paramsDotSkipCompatibilityCheckVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "skipCompatibilityCheck",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ValidateBringupSpecParams is parameters of validateBringupSpec operation.
type ValidateBringupSpecParams struct {
	Redo OptBool
	// Validation name
	// Deprecated: ESXI_VERSION_VALIDATION.
	Name OptValidateBringupSpecName
}

func unpackValidateBringupSpecParams(packed middleware.Parameters) (params ValidateBringupSpecParams) {
	{
		key := middleware.ParameterKey{
			Name: "redo",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Redo = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptValidateBringupSpecName)
		}
	}
	return params
}

func decodeValidateBringupSpecParams(args [0]string, argsEscaped bool, r *http.Request) (params ValidateBringupSpecParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: redo.
	{
		val := bool(true)
		params.Redo.SetTo(val)
	}
	// Decode query: redo.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "redo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRedoVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotRedoVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Redo.SetTo(paramsDotRedoVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "redo",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal ValidateBringupSpecName
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = ValidateBringupSpecName(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Name.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ValidateClusterCreationSpecParams is parameters of validateClusterCreationSpec operation.
type ValidateClusterCreationSpecParams struct {
	// Validate hosts only.
	HostsOnly OptBool
	// Skips host switch validation when hostOnly=true.
	SkipHostSwitchValidation OptBool
}

func unpackValidateClusterCreationSpecParams(packed middleware.Parameters) (params ValidateClusterCreationSpecParams) {
	{
		key := middleware.ParameterKey{
			Name: "hostsOnly",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.HostsOnly = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "skipHostSwitchValidation",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SkipHostSwitchValidation = v.(OptBool)
		}
	}
	return params
}

func decodeValidateClusterCreationSpecParams(args [0]string, argsEscaped bool, r *http.Request) (params ValidateClusterCreationSpecParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: hostsOnly.
	{
		val := bool(false)
		params.HostsOnly.SetTo(val)
	}
	// Decode query: hostsOnly.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "hostsOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotHostsOnlyVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotHostsOnlyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.HostsOnly.SetTo(paramsDotHostsOnlyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "hostsOnly",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: skipHostSwitchValidation.
	{
		val := bool(false)
		params.SkipHostSwitchValidation.SetTo(val)
	}
	// Decode query: skipHostSwitchValidation.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "skipHostSwitchValidation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSkipHostSwitchValidationVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotSkipHostSwitchValidationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SkipHostSwitchValidation.SetTo(paramsDotSkipHostSwitchValidationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "skipHostSwitchValidation",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ValidateClusterUpdateSpecParams is parameters of validateClusterUpdateSpec operation.
type ValidateClusterUpdateSpecParams struct {
	// Cluster ID.
	ID string
	// Cluster validations to be run async.
	UseAsyncValidation OptBool
}

func unpackValidateClusterUpdateSpecParams(packed middleware.Parameters) (params ValidateClusterUpdateSpecParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "useAsyncValidation",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.UseAsyncValidation = v.(OptBool)
		}
	}
	return params
}

func decodeValidateClusterUpdateSpecParams(args [1]string, argsEscaped bool, r *http.Request) (params ValidateClusterUpdateSpecParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: useAsyncValidation.
	{
		val := bool(false)
		params.UseAsyncValidation.SetTo(val)
	}
	// Decode query: useAsyncValidation.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "useAsyncValidation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUseAsyncValidationVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotUseAsyncValidationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.UseAsyncValidation.SetTo(paramsDotUseAsyncValidationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "useAsyncValidation",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ValidateDomainCreationSpecParams is parameters of validateDomainCreationSpec operation.
type ValidateDomainCreationSpecParams struct {
	// Validate hosts only.
	HostsOnly OptBool
	// Skips host switch validation when hostOnly=true.
	SkipHostSwitchValidation OptBool
}

func unpackValidateDomainCreationSpecParams(packed middleware.Parameters) (params ValidateDomainCreationSpecParams) {
	{
		key := middleware.ParameterKey{
			Name: "hostsOnly",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.HostsOnly = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "skipHostSwitchValidation",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SkipHostSwitchValidation = v.(OptBool)
		}
	}
	return params
}

func decodeValidateDomainCreationSpecParams(args [0]string, argsEscaped bool, r *http.Request) (params ValidateDomainCreationSpecParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: hostsOnly.
	{
		val := bool(false)
		params.HostsOnly.SetTo(val)
	}
	// Decode query: hostsOnly.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "hostsOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotHostsOnlyVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotHostsOnlyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.HostsOnly.SetTo(paramsDotHostsOnlyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "hostsOnly",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: skipHostSwitchValidation.
	{
		val := bool(false)
		params.SkipHostSwitchValidation.SetTo(val)
	}
	// Decode query: skipHostSwitchValidation.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "skipHostSwitchValidation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSkipHostSwitchValidationVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotSkipHostSwitchValidationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SkipHostSwitchValidation.SetTo(paramsDotSkipHostSwitchValidationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "skipHostSwitchValidation",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ValidateDomainUpdateSpecParams is parameters of validateDomainUpdateSpec operation.
type ValidateDomainUpdateSpecParams struct {
	// Domain ID.
	ID string
}

func unpackValidateDomainUpdateSpecParams(packed middleware.Parameters) (params ValidateDomainUpdateSpecParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeValidateDomainUpdateSpecParams(args [1]string, argsEscaped bool, r *http.Request) (params ValidateDomainUpdateSpecParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ValidateEdgeClusterUpdateSpecParams is parameters of validateEdgeClusterUpdateSpec operation.
type ValidateEdgeClusterUpdateSpecParams struct {
	// NSX Edge cluster id.
	ID string
}

func unpackValidateEdgeClusterUpdateSpecParams(packed middleware.Parameters) (params ValidateEdgeClusterUpdateSpecParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeValidateEdgeClusterUpdateSpecParams(args [1]string, argsEscaped bool, r *http.Request) (params ValidateEdgeClusterUpdateSpecParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ValidateReleaseByDomainIDParams is parameters of validateReleaseByDomainID operation.
type ValidateReleaseByDomainIDParams struct {
	// Domain ID of the domain under validation.
	DomainId string
}

func unpackValidateReleaseByDomainIDParams(packed middleware.Parameters) (params ValidateReleaseByDomainIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "domainId",
			In:   "path",
		}
		params.DomainId = packed[key].(string)
	}
	return params
}

func decodeValidateReleaseByDomainIDParams(args [1]string, argsEscaped bool, r *http.Request) (params ValidateReleaseByDomainIDParams, _ error) {
	// Decode path: domainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "domainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ValidateResourceCertificatesParams is parameters of validateResourceCertificates operation.
type ValidateResourceCertificatesParams struct {
	// Domain ID.
	ID string
}

func unpackValidateResourceCertificatesParams(packed middleware.Parameters) (params ValidateResourceCertificatesParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeValidateResourceCertificatesParams(args [1]string, argsEscaped bool, r *http.Request) (params ValidateResourceCertificatesParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ValidateVsanRemoteDatastoreMountSpecParams is parameters of validateVsanRemoteDatastoreMountSpec operation.
type ValidateVsanRemoteDatastoreMountSpecParams struct {
	// Cluster ID.
	ClusterId string
}

func unpackValidateVsanRemoteDatastoreMountSpecParams(packed middleware.Parameters) (params ValidateVsanRemoteDatastoreMountSpecParams) {
	{
		key := middleware.ParameterKey{
			Name: "clusterId",
			In:   "path",
		}
		params.ClusterId = packed[key].(string)
	}
	return params
}

func decodeValidateVsanRemoteDatastoreMountSpecParams(args [1]string, argsEscaped bool, r *http.Request) (params ValidateVsanRemoteDatastoreMountSpecParams, _ error) {
	// Decode path: clusterId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "clusterId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClusterId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "clusterId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ValidateVsanRemoteDatastoreSpecParams is parameters of validateVsanRemoteDatastoreSpec operation.
type ValidateVsanRemoteDatastoreSpecParams struct {
	// Cluster ID.
	ClusterId string
}

func unpackValidateVsanRemoteDatastoreSpecParams(packed middleware.Parameters) (params ValidateVsanRemoteDatastoreSpecParams) {
	{
		key := middleware.ParameterKey{
			Name: "clusterId",
			In:   "path",
		}
		params.ClusterId = packed[key].(string)
	}
	return params
}

func decodeValidateVsanRemoteDatastoreSpecParams(args [1]string, argsEscaped bool, r *http.Request) (params ValidateVsanRemoteDatastoreSpecParams, _ error) {
	// Decode path: clusterId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "clusterId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClusterId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "clusterId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}
