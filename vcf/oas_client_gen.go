// Code generated by ogen, DO NOT EDIT.

package vcf

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AddDatastoreToCluster invokes addDatastoreToCluster operation.
	//
	// Mount a datastore to a cluster.
	//
	// POST /v1/clusters/{id}/datastores
	AddDatastoreToCluster(ctx context.Context, request *DatastoreMountSpec, params AddDatastoreToClusterParams) (AddDatastoreToClusterRes, error)
	// AddIpPoolToNetworkOfNetworkPool invokes addIpPoolToNetworkOfNetworkPool operation.
	//
	// Add an IP Pool to a Network of a Network Pool.
	//
	// POST /v1/network-pools/{id}/networks/{networkId}/ip-pools
	AddIpPoolToNetworkOfNetworkPool(ctx context.Context, request *IpPool, params AddIpPoolToNetworkOfNetworkPoolParams) (AddIpPoolToNetworkOfNetworkPoolRes, error)
	// AddLicenseKey invokes addLicenseKey operation.
	//
	// Add a a new license key.
	//
	// POST /v1/license-keys
	AddLicenseKey(ctx context.Context, request *LicenseKey) (AddLicenseKeyRes, error)
	// AddUsers invokes addUsers operation.
	//
	// Add list of users.
	//
	// POST /v1/users
	AddUsers(ctx context.Context, request []User) (AddUsersRes, error)
	// AddVasaProvider invokes addVasaProvider operation.
	//
	// Add a VASA Provider.
	//
	// POST /v1/vasa-providers
	AddVasaProvider(ctx context.Context, request *VasaProvider) (AddVasaProviderRes, error)
	// AddVasaProviderStorageContainer invokes addVasaProviderStorageContainer operation.
	//
	// Add the storage containers to a VASA Provider.
	//
	// POST /v1/vasa-providers/{id}/storage-containers
	AddVasaProviderStorageContainer(ctx context.Context, request []StorageContainer, params AddVasaProviderStorageContainerParams) (AddVasaProviderStorageContainerRes, error)
	// AddVasaProviderUser invokes addVasaProviderUser operation.
	//
	// Add the users to a VASA Provider.
	//
	// POST /v1/vasa-providers/{id}/users
	AddVasaProviderUser(ctx context.Context, request []VasaUser, params AddVasaProviderUserParams) (AddVasaProviderUserRes, error)
	// AssignTagsToCluster invokes assignTagsToCluster operation.
	//
	// Assign Tags to Cluster.
	//
	// PUT /v1/clusters/{id}/tags
	AssignTagsToCluster(ctx context.Context, request *TagsSpec, params AssignTagsToClusterParams) (AssignTagsToClusterRes, error)
	// AssignTagsToDomain invokes assignTagsToDomain operation.
	//
	// Assign tags to a domain.
	//
	// PUT /v1/domains/{id}/tags
	AssignTagsToDomain(ctx context.Context, request *TagsSpec, params AssignTagsToDomainParams) (AssignTagsToDomainRes, error)
	// AssignTagsToHost invokes assignTagsToHost operation.
	//
	// Assign tags to a host.
	//
	// PUT /v1/hosts/{id}/tags
	AssignTagsToHost(ctx context.Context, request *TagsSpec, params AssignTagsToHostParams) (AssignTagsToHostRes, error)
	// CancelCredentialsTask invokes cancelCredentialsTask operation.
	//
	// Cancel a failed credential task by its ID.
	//
	// DELETE /v1/credentials/tasks/{id}
	CancelCredentialsTask(ctx context.Context, params CancelCredentialsTaskParams) (CancelCredentialsTaskRes, error)
	// CancelTask invokes cancelTask operation.
	//
	// Cancel a Task by ID, if it exists.
	//
	// DELETE /v1/tasks/{id}
	CancelTask(ctx context.Context, params CancelTaskParams) (CancelTaskRes, error)
	// CommissionHosts invokes commissionHosts operation.
	//
	// Commission the Hosts.
	//
	// POST /v1/hosts
	CommissionHosts(ctx context.Context, request []HostCommissionSpec) (CommissionHostsRes, error)
	// ComplianceAudit invokes complianceAudit operation.
	//
	// Compliance audit of resource.
	//
	// POST /v1/domains/{id}/compliance-audits
	ComplianceAudit(ctx context.Context, request *ComplianceAuditSpec, params ComplianceAuditParams) (ComplianceAuditRes, error)
	// ConfigureCertificateAuthority invokes configureCertificateAuthority operation.
	//
	// Update the configuration of a Certificate Authority.
	//
	// PATCH /v1/certificate-authorities
	ConfigureCertificateAuthority(ctx context.Context, request *CertificateAuthorityCreationSpec) (ConfigureCertificateAuthorityRes, error)
	// ConfigureDns invokes configureDns operation.
	//
	// Update the DNS configuration.
	//
	// PUT /v1/system/dns-configuration
	ConfigureDns(ctx context.Context, request *DnsConfiguration) (ConfigureDnsRes, error)
	// ConfigureNtp invokes configureNtp operation.
	//
	// Update the NTP configuration.
	//
	// PUT /v1/system/ntp-configuration
	ConfigureNtp(ctx context.Context, request *NtpConfiguration) (ConfigureNtpRes, error)
	// ConnectOpenId invokes connectOpenId operation.
	//
	// POST /v1/nsxt-clusters/oidcs
	ConnectOpenId(ctx context.Context, request *NsxtOidcSpec) error
	// ConnectVrliWithDomain invokes connectVrliWithDomain operation.
	//
	// Connect or disconnect a domain with VMware Aria Operations for Logs.
	//
	// PUT /v1/vrli/domains
	ConnectVrliWithDomain(ctx context.Context, request *DomainIntegration) (*Task, error)
	// ConnectVropsWithDomain invokes connectVropsWithDomain operation.
	//
	// Connects/disconnects a workload domains with VMware Aria Operations.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PUT /v1/vrops/domains
	ConnectVropsWithDomain(ctx context.Context, request *DomainIntegration) (ConnectVropsWithDomainRes, error)
	// CreateAvns invokes createAvns operation.
	//
	// Create Application Virtual Networks (AVN).
	//
	// POST /v1/avns
	CreateAvns(ctx context.Context, request *AvnsCreationSpec) (CreateAvnsRes, error)
	// CreateCertificateAuthority invokes createCertificateAuthority operation.
	//
	// Creates a certificate authority. This is required to generate signed certificates by supporting
	// CAs.
	//
	// PUT /v1/certificate-authorities
	CreateCertificateAuthority(ctx context.Context, request *CertificateAuthorityCreationSpec) (CreateCertificateAuthorityRes, error)
	// CreateCluster invokes createCluster operation.
	//
	// Create a cluster and add to an existing domain.
	//
	// POST /v1/clusters
	CreateCluster(ctx context.Context, request *ClusterCreationSpec) (CreateClusterRes, error)
	// CreateDomain invokes createDomain operation.
	//
	// Create a domain.
	//
	// POST /v1/domains
	CreateDomain(ctx context.Context, request *DomainCreationSpec) (CreateDomainRes, error)
	// CreateEdgeCluster invokes createEdgeCluster operation.
	//
	// Create an NSX Edge Cluster.
	//
	// POST /v1/edge-clusters
	CreateEdgeCluster(ctx context.Context, request *EdgeClusterCreationSpec) (CreateEdgeClusterRes, error)
	// CreateNetworkPool invokes createNetworkPool operation.
	//
	// Create a Network Pool.
	//
	// POST /v1/network-pools
	CreateNetworkPool(ctx context.Context, request *NetworkPool) (CreateNetworkPoolRes, error)
	// CreateResourceWarning invokes createResourceWarning operation.
	//
	// Create a new Resource Warning.
	//
	// POST /v1/resource-warnings
	CreateResourceWarning(ctx context.Context, request *ResourceWarningCreationSpec) (CreateResourceWarningRes, error)
	// CreateToken invokes createToken operation.
	//
	// Creates access token and refresh token for user access.
	//
	// POST /v1/tokens
	CreateToken(ctx context.Context, request *TokenCreationSpec) (CreateTokenRes, error)
	// DecommissionHosts invokes decommissionHosts operation.
	//
	// Decommission the Hosts.
	//
	// DELETE /v1/hosts
	DecommissionHosts(ctx context.Context, request []HostDecommissionSpec) (DecommissionHostsRes, error)
	// DeleteALBCluster invokes deleteALBCluster operation.
	//
	// Deletes an NSX ALB Cluster by its ID.
	//
	// DELETE /v1/nsx-alb-clusters/{id}
	DeleteALBCluster(ctx context.Context, params DeleteALBClusterParams) (DeleteALBClusterRes, error)
	// DeleteAliasVersionsBySoftwareTypeAndBaseVersion invokes deleteAliasVersionsBySoftwareTypeAndBaseVersion operation.
	//
	// Delete Version Alias Configuration by bundle component type, version, and aliases.
	//
	// DELETE /v1/system/settings/version-aliases/{bundleComponentType}/{version}
	DeleteAliasVersionsBySoftwareTypeAndBaseVersion(ctx context.Context, request []string, params DeleteAliasVersionsBySoftwareTypeAndBaseVersionParams) (DeleteAliasVersionsBySoftwareTypeAndBaseVersionRes, error)
	// DeleteBundle invokes deleteBundle operation.
	//
	// Delete a Bundle by bundle ID.
	//
	// DELETE /v1/bundles/{id}
	DeleteBundle(ctx context.Context, params DeleteBundleParams) (DeleteBundleRes, error)
	// DeleteCluster invokes deleteCluster operation.
	//
	// Delete a cluster from a domain if it has been previously initialized for deletion.
	//
	// DELETE /v1/clusters/{id}
	DeleteCluster(ctx context.Context, params DeleteClusterParams) (DeleteClusterRes, error)
	// DeleteCustomIsoById invokes deleteCustomIsoById operation.
	//
	// Delete the Custom ISO based on ID.
	//
	// DELETE /v1/custom-isos/{custom_iso_id}
	DeleteCustomIsoById(ctx context.Context, params DeleteCustomIsoByIdParams) (DeleteCustomIsoByIdRes, error)
	// DeleteDepotSettings invokes deleteDepotSettings operation.
	//
	// Delete the depot configuration if such is present within VCF.
	//
	// DELETE /v1/system/settings/depot
	DeleteDepotSettings(ctx context.Context, params DeleteDepotSettingsParams) (DeleteDepotSettingsRes, error)
	// DeleteDomain invokes deleteDomain operation.
	//
	// Remove a domain if it has been previously initialized for deletion.
	//
	// DELETE /v1/domains/{id}
	DeleteDomain(ctx context.Context, params DeleteDomainParams) (DeleteDomainRes, error)
	// DeleteIpPoolFromNetworkOfNetworkPool invokes deleteIpPoolFromNetworkOfNetworkPool operation.
	//
	// Delete an IP Pool from a Network of a Network Pool.
	//
	// DELETE /v1/network-pools/{id}/networks/{networkId}/ip-pools
	DeleteIpPoolFromNetworkOfNetworkPool(ctx context.Context, request *IpPool, params DeleteIpPoolFromNetworkOfNetworkPoolParams) (DeleteIpPoolFromNetworkOfNetworkPoolRes, error)
	// DeleteNetworkPool invokes deleteNetworkPool operation.
	//
	// Delete the Network Pool by the ID, if it exists and is unused.
	//
	// DELETE /v1/network-pools/{id}
	DeleteNetworkPool(ctx context.Context, params DeleteNetworkPoolParams) (DeleteNetworkPoolRes, error)
	// DeletePersonality invokes deletePersonality operation.
	//
	// Delete the personality based on either name or id.
	//
	// DELETE /v1/personalities
	DeletePersonality(ctx context.Context, params DeletePersonalityParams) (DeletePersonalityRes, error)
	// DeleteReleaseByDomainID invokes deleteReleaseByDomainID operation.
	//
	// Delete last selected upgrade version for the domain.
	//
	// DELETE /v1/releases/domains/{domainId}
	DeleteReleaseByDomainID(ctx context.Context, params DeleteReleaseByDomainIDParams) (DeleteReleaseByDomainIDRes, error)
	// DeleteTrustedCertificate invokes deleteTrustedCertificate operation.
	//
	// Delete a trusted certificate from the SDDC Manager.
	//
	// DELETE /v1/sddc-manager/trusted-certificates/{alias}
	DeleteTrustedCertificate(ctx context.Context, params DeleteTrustedCertificateParams) (DeleteTrustedCertificateRes, error)
	// DeleteVersionAliasBySoftwareType invokes deleteVersionAliasBySoftwareType operation.
	//
	// Removes Version Alias Configuration by component type.
	//
	// DELETE /v1/system/settings/version-aliases/{bundleComponentType}
	DeleteVersionAliasBySoftwareType(ctx context.Context, params DeleteVersionAliasBySoftwareTypeParams) (DeleteVersionAliasBySoftwareTypeRes, error)
	// DeployVrslcm invokes deployVrslcm operation.
	//
	// Triggers the VMware Aria Suite Lifecycle deployment operation and returns an URL in the headers to
	// track the operation status.
	//
	// POST /v1/vrslcms
	DeployVrslcm(ctx context.Context, request *VrslcmDeploymentSpec) (DeployVrslcmRes, error)
	// DisableLocalAccount invokes disableLocalAccount operation.
	//
	// Disable local account.
	//
	// DELETE /v1/users/local/admin
	DisableLocalAccount(ctx context.Context) (DisableLocalAccountRes, error)
	// DomainCreateValidation invokes domainCreateValidation operation.
	//
	// Gets the status of given domain create validation workflow by given validation id.
	//
	// GET /v1/domains/validations/{id}
	DomainCreateValidation(ctx context.Context, params DomainCreateValidationParams) (DomainCreateValidationRes, error)
	// DownloadCSR invokes downloadCSR operation.
	//
	// Download available CSR(s) in tar.gz format.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /v1/domains/{id}/csrs/downloads
	DownloadCSR(ctx context.Context, params DownloadCSRParams) (DownloadCSRRes, error)
	// DownloadVsanHcl invokes downloadVsanHcl operation.
	//
	// Download vSAN HCL if online connectivity is available. Timestamp of vSAN HCL on SDDC Manager is
	// checked with what is available online before download. vSAN HCL is downloaded only if new data is
	// available.
	//
	// PATCH /v1/vsan-hcl
	DownloadVsanHcl(ctx context.Context) (DownloadVsanHclRes, error)
	// ExportBringupDetailReport invokes exportBringupDetailReport operation.
	//
	// Returns the bringup report. Reports are generated in PDF and CSV formats.
	//
	// GET /v1/sddcs/{id}/detail-report
	ExportBringupDetailReport(ctx context.Context, params ExportBringupDetailReportParams) (ExportBringupDetailReportRes, error)
	// ExportBringupValidationReport invokes exportBringupValidationReport operation.
	//
	// Returns the bringup report for a validation. Reports are generated in PDF format.
	//
	// GET /v1/sddcs/validations/{validationId}/report
	ExportBringupValidationReport(ctx context.Context, params ExportBringupValidationReportParams) (ExportBringupValidationReportRes, error)
	// GenerateCertificates invokes generateCertificates operation.
	//
	// Generate certificate(s) for the selected resource(s) in a domain. CA must be configured and CSR
	// must be generated beforehand.
	//
	// PUT /v1/domains/{id}/certificates
	GenerateCertificates(ctx context.Context, request *CertificatesGenerationSpec, params GenerateCertificatesParams) (GenerateCertificatesRes, error)
	// GenerateSyncClientToken invokes generateSyncClientToken operation.
	//
	// Generates a new sync client token.
	//
	// POST /v1/identity-providers/{id}/sync-client
	GenerateSyncClientToken(ctx context.Context, params GenerateSyncClientTokenParams) (GenerateSyncClientTokenRes, error)
	// GeneratesCSRs invokes generatesCSRs operation.
	//
	// Generate CSR(s) for the selected resource(s) in the domain.
	// *Warning:*
	// _Avoid using wildcard certificates. Instead, use subdomain-specific certificates that are rotated
	// often. A compromised wildcard certificate can lead to security repercussions_.
	//
	// PUT /v1/domains/{id}/csrs
	GeneratesCSRs(ctx context.Context, request *CsrsGenerationSpec, params GeneratesCSRsParams) (GeneratesCSRsRes, error)
	// GetALBCluster invokes getALBCluster operation.
	//
	// Retrieve an NSX ALB Cluster by its ID.
	//
	// GET /v1/nsx-alb-clusters/{id}
	GetALBCluster(ctx context.Context, params GetALBClusterParams) (GetALBClusterRes, error)
	// GetALBClusters invokes getALBClusters operation.
	//
	// Retrieve a list of NSX ALB Clusters.
	//
	// GET /v1/nsx-alb-clusters
	GetALBClusters(ctx context.Context, params GetALBClustersParams) (GetALBClustersRes, error)
	// GetALBClustersFormFactors invokes getALBClustersFormFactors operation.
	//
	// Retrieve a list of NSX ALB Clusters Form Factors.
	//
	// GET /v1/nsx-alb-clusters/form-factors
	GetALBClustersFormFactors(ctx context.Context) (GetALBClustersFormFactorsRes, error)
	// GetAssignableTagForHost invokes getAssignableTagForHost operation.
	//
	// Get tags assignable to a host.
	//
	// GET /v1/hosts/{id}/tags/assignable-tags
	GetAssignableTagForHost(ctx context.Context, params GetAssignableTagForHostParams) (GetAssignableTagForHostRes, error)
	// GetAssignableTagsForDomain invokes getAssignableTagsForDomain operation.
	//
	// Get tags assignable to a domain.
	//
	// GET /v1/domains/{id}/tags/assignable-tags
	GetAssignableTagsForDomain(ctx context.Context, params GetAssignableTagsForDomainParams) (GetAssignableTagsForDomainRes, error)
	// GetAvns invokes getAvns operation.
	//
	// Returns all matching AVNs.
	//
	// GET /v1/avns
	GetAvns(ctx context.Context, params GetAvnsParams) (GetAvnsRes, error)
	// GetBackupConfiguration invokes getBackupConfiguration operation.
	//
	// Retrieve the backup configuration for SDDC Manager and NSX Manager.
	//
	// GET /v1/system/backup-configuration
	GetBackupConfiguration(ctx context.Context) (GetBackupConfigurationRes, error)
	// GetBackupLocation invokes getBackupLocation operation.
	//
	// Retrieve the backup location details.
	//
	// GET /v1/system/backup-configuration/backup-locations
	GetBackupLocation(ctx context.Context, params GetBackupLocationParams) (GetBackupLocationRes, error)
	// GetBringupAppInfo invokes getBringupAppInfo operation.
	//
	// GET Method to retrieve information about Bringup app.
	//
	// GET /v1/sddcs/about
	GetBringupAppInfo(ctx context.Context) (GetBringupAppInfoRes, error)
	// GetBringupTaskByID invokes getBringupTaskByID operation.
	//
	// Get a bringup task by its id.
	//
	// GET /v1/sddcs/{id}
	GetBringupTaskByID(ctx context.Context, params GetBringupTaskByIDParams) (GetBringupTaskByIDRes, error)
	// GetBringupTasks invokes getBringupTasks operation.
	//
	// Retrieve all bringup tasks.
	//
	// GET /v1/sddcs
	GetBringupTasks(ctx context.Context) (GetBringupTasksRes, error)
	// GetBringupValidation invokes getBringupValidation operation.
	//
	// Retrieve the results of a bringup validation by its ID.
	//
	// GET /v1/sddcs/validations/{id}
	GetBringupValidation(ctx context.Context, params GetBringupValidationParams) (GetBringupValidationRes, error)
	// GetBringupValidations invokes getBringupValidations operation.
	//
	// Retrieve a list of bringup validations.
	//
	// GET /v1/sddcs/validations
	GetBringupValidations(ctx context.Context) (GetBringupValidationsRes, error)
	// GetBundle invokes getBundle operation.
	//
	// Get a Bundle.
	//
	// GET /v1/bundles/{id}
	GetBundle(ctx context.Context, params GetBundleParams) (GetBundleRes, error)
	// GetBundles invokes getBundles operation.
	//
	// Get all Bundles i.e uploaded bundles and also bundles available via depot access.
	//
	// GET /v1/bundles
	GetBundles(ctx context.Context, params GetBundlesParams) (GetBundlesRes, error)
	// GetBundlesForSkipUpgrade invokes getBundlesForSkipUpgrade operation.
	//
	// Get bundles for skip upgrade a domain from current version to target version.
	//
	// GET /v1/bundles/domains/{id}
	GetBundlesForSkipUpgrade(ctx context.Context, params GetBundlesForSkipUpgradeParams) (GetBundlesForSkipUpgradeRes, error)
	// GetCSRs invokes getCSRs operation.
	//
	// Get available CSR(s) in json format.
	//
	// GET /v1/domains/{id}/csrs
	GetCSRs(ctx context.Context, params GetCSRsParams) (GetCSRsRes, error)
	// GetCeipStatus invokes getCeipStatus operation.
	//
	// Get CEIP status and instance id.
	//
	// GET /v1/system/ceip
	GetCeipStatus(ctx context.Context) (GetCeipStatusRes, error)
	// GetCertificateAuthorities invokes getCertificateAuthorities operation.
	//
	// Get certificate authorities information.
	//
	// GET /v1/certificate-authorities
	GetCertificateAuthorities(ctx context.Context) (GetCertificateAuthoritiesRes, error)
	// GetCertificateAuthorityById invokes getCertificateAuthorityById operation.
	//
	// Get certificate authority information.
	//
	// GET /v1/certificate-authorities/{id}
	GetCertificateAuthorityById(ctx context.Context, params GetCertificateAuthorityByIdParams) (GetCertificateAuthorityByIdRes, error)
	// GetCertificatesByDomain invokes getCertificatesByDomain operation.
	//
	// View detailed metadata about the certificate(s) of all the resources in a domain.
	//
	// GET /v1/domains/{id}/resource-certificates
	GetCertificatesByDomain(ctx context.Context, params GetCertificatesByDomainParams) (GetCertificatesByDomainRes, error)
	// GetCluster invokes getCluster operation.
	//
	// Get a cluster by its ID.
	//
	// GET /v1/clusters/{id}
	GetCluster(ctx context.Context, params GetClusterParams) (GetClusterRes, error)
	// GetClusterCreateValidation invokes getClusterCreateValidation operation.
	//
	// Gets the status of given cluster create validation workflow by given validation id.
	//
	// GET /v1/clusters/validations/{id}
	GetClusterCreateValidation(ctx context.Context, params GetClusterCreateValidationParams) (GetClusterCreateValidationRes, error)
	// GetClusterCriteria invokes getClusterCriteria operation.
	//
	// Get all cluster criteria.
	//
	// GET /v1/domains/{domainId}/clusters/criteria
	GetClusterCriteria(ctx context.Context, params GetClusterCriteriaParams) (*PageOfClusterCriterion, error)
	// GetClusterCriterion invokes getClusterCriterion operation.
	//
	// Get a criterion to query for cluster.
	//
	// GET /v1/domains/{domainId}/clusters/criteria/{name}
	GetClusterCriterion(ctx context.Context, params GetClusterCriterionParams) (GetClusterCriterionRes, error)
	// GetClusterDatastores invokes getClusterDatastores operation.
	//
	// Get the list of all datastores associated with the cluster.
	//
	// GET /v1/clusters/{id}/datastores
	GetClusterDatastores(ctx context.Context, params GetClusterDatastoresParams) (GetClusterDatastoresRes, error)
	// GetClusterNetworkConfiguration invokes getClusterNetworkConfiguration operation.
	//
	// Get cluster network configuration.
	//
	// POST /v1/clusters/{id}/network/queries
	GetClusterNetworkConfiguration(ctx context.Context, request *ClusterNetworkConfigurationCriterion, params GetClusterNetworkConfigurationParams) (GetClusterNetworkConfigurationRes, error)
	// GetClusterNetworkConfigurationQueryResponse invokes getClusterNetworkConfigurationQueryResponse operation.
	//
	// The response retrieved is only applicable for pure L2 domain clusters.
	//
	// GET /v1/clusters/{id}/network/queries/{queryId}
	GetClusterNetworkConfigurationQueryResponse(ctx context.Context, params GetClusterNetworkConfigurationQueryResponseParams) (GetClusterNetworkConfigurationQueryResponseRes, error)
	// GetClusterQueryResponse invokes getClusterQueryResponse operation.
	//
	// Get cluster query response.
	//
	// GET /v1/domains/{domainId}/clusters/{clusterName}/queries/{queryId}
	GetClusterQueryResponse(ctx context.Context, params GetClusterQueryResponseParams) (GetClusterQueryResponseRes, error)
	// GetClusterTagManagerUrl invokes getClusterTagManagerUrl operation.
	//
	// Get Cluster Tag Manager Url.
	//
	// GET /v1/clusters/{id}/tags/tag-manager
	GetClusterTagManagerUrl(ctx context.Context, params GetClusterTagManagerUrlParams) (GetClusterTagManagerUrlRes, error)
	// GetClusterUpdateValidation invokes getClusterUpdateValidation operation.
	//
	// Gets the status of given cluster updates validation workflow by given validation id.
	//
	// GET /v1/clusters/{id}/validations/{validationId}
	GetClusterUpdateValidation(ctx context.Context, params GetClusterUpdateValidationParams) (GetClusterUpdateValidationRes, error)
	// GetClusters invokes getClusters operation.
	//
	// Retrieve a list of clusters.
	//
	// GET /v1/clusters
	GetClusters(ctx context.Context, params GetClustersParams) (GetClustersRes, error)
	// GetClustersQueryResponse invokes getClustersQueryResponse operation.
	//
	// Get clusters query response.
	//
	// GET /v1/domains/{domainId}/clusters/queries/{queryId}
	GetClustersQueryResponse(ctx context.Context, params GetClustersQueryResponseParams) (GetClustersQueryResponseRes, error)
	// GetCompatibilityMatrices invokes getCompatibilityMatrices operation.
	//
	// Get Compatibility Matrices.
	//
	// GET /v1/compatibility-matrices
	GetCompatibilityMatrices(ctx context.Context) (GetCompatibilityMatricesRes, error)
	// GetCompatibilityMatrix invokes getCompatibilityMatrix operation.
	//
	// Get Compatibility Matrix.
	//
	// GET /v1/compatibility-matrices/{compatibilityMatrixSource}
	GetCompatibilityMatrix(ctx context.Context, params GetCompatibilityMatrixParams) (GetCompatibilityMatrixRes, error)
	// GetCompatibilityMatrixContent invokes getCompatibilityMatrixContent operation.
	//
	// Get Compatibility Matrix content.
	//
	// GET /v1/compatibility-matrices/{compatibilityMatrixSource}/content
	GetCompatibilityMatrixContent(ctx context.Context, params GetCompatibilityMatrixContentParams) (GetCompatibilityMatrixContentRes, error)
	// GetCompatibilityMatrixMetadata invokes getCompatibilityMatrixMetadata operation.
	//
	// Get Compatibility Matrix Metadata.
	//
	// GET /v1/compatibility-matrices/{compatibilityMatrixSource}/metadata
	GetCompatibilityMatrixMetadata(ctx context.Context, params GetCompatibilityMatrixMetadataParams) (GetCompatibilityMatrixMetadataRes, error)
	// GetComplianceAudit invokes getComplianceAudit operation.
	//
	// Get compliance audit.
	//
	// GET /v1/compliance-audits/{complianceAuditId}
	GetComplianceAudit(ctx context.Context, params GetComplianceAuditParams) (GetComplianceAuditRes, error)
	// GetComplianceAuditForADomain invokes getComplianceAuditForADomain operation.
	//
	// Get compliance audit for a domain.
	//
	// GET /v1/domains/{id}/compliance-audits/{complianceAuditId}
	GetComplianceAuditForADomain(ctx context.Context, params GetComplianceAuditForADomainParams) (GetComplianceAuditForADomainRes, error)
	// GetComplianceAuditHistory invokes getComplianceAuditHistory operation.
	//
	// Get compliance audit history.
	//
	// GET /v1/compliance-audits
	GetComplianceAuditHistory(ctx context.Context) (GetComplianceAuditHistoryRes, error)
	// GetComplianceAuditHistoryForADomain invokes getComplianceAuditHistoryForADomain operation.
	//
	// Get compliance audit history for a domain.
	//
	// GET /v1/domains/{id}/compliance-audits
	GetComplianceAuditHistoryForADomain(ctx context.Context, params GetComplianceAuditHistoryForADomainParams) (GetComplianceAuditHistoryForADomainRes, error)
	// GetComplianceAuditItems invokes getComplianceAuditItems operation.
	//
	// Get compliance audit items.
	//
	// GET /v1/compliance-audits/{complianceAuditId}/compliance-audit-items
	GetComplianceAuditItems(ctx context.Context, params GetComplianceAuditItemsParams) (GetComplianceAuditItemsRes, error)
	// GetComplianceAuditItemsForADomain invokes getComplianceAuditItemsForADomain operation.
	//
	// Get compliance audit items for a domain.
	//
	// GET /v1/domains/{id}/compliance-audits/{complianceAuditId}/compliance-audit-items
	GetComplianceAuditItemsForADomain(ctx context.Context, params GetComplianceAuditItemsForADomainParams) (GetComplianceAuditItemsForADomainRes, error)
	// GetComplianceAuditTask invokes getComplianceAuditTask operation.
	//
	// Get compliance audit task.
	//
	// GET /v1/domains/{id}/compliance-audits/tasks/{taskId}
	GetComplianceAuditTask(ctx context.Context, params GetComplianceAuditTaskParams) (GetComplianceAuditTaskRes, error)
	// GetComplianceConfigurations invokes getComplianceConfigurations operation.
	//
	// Get a list of all compliance configurations.
	//
	// GET /v1/compliance-configurations
	GetComplianceConfigurations(ctx context.Context, params GetComplianceConfigurationsParams) (GetComplianceConfigurationsRes, error)
	// GetComplianceStandards invokes getComplianceStandards operation.
	//
	// Get a list of all compliance standards.
	//
	// GET /v1/compliance-standards
	GetComplianceStandards(ctx context.Context) (GetComplianceStandardsRes, error)
	// GetConfigs invokes getConfigs operation.
	//
	// Get configs associated with the given criteria, all if no criteria is provided.
	//
	// GET /v1/config-drifts
	GetConfigs(ctx context.Context, params GetConfigsParams) (GetConfigsRes, error)
	// GetCredential invokes getCredential operation.
	//
	// Retrieve a credential by its ID.
	//
	// GET /v1/credentials/{id}
	GetCredential(ctx context.Context, params GetCredentialParams) (GetCredentialRes, error)
	// GetCredentialTaskByResourceID invokes getCredentialTaskByResourceID operation.
	//
	// Retriece a credential taks by resource ID.
	//
	// GET /v1/credentials/tasks/{id}/resource-credentials
	GetCredentialTaskByResourceID(ctx context.Context, params GetCredentialTaskByResourceIDParams) (GetCredentialTaskByResourceIDRes, error)
	// GetCredentials invokes getCredentials operation.
	//
	// Retrieve a list of credentials.
	//
	// GET /v1/credentials
	GetCredentials(ctx context.Context, params GetCredentialsParams) (GetCredentialsRes, error)
	// GetCredentialsSubTask invokes getCredentialsSubTask operation.
	//
	// Retrieve a credential sub task by its ID.
	//
	// GET /v1/credentials/tasks/{id}/subtasks/{subtaskId}
	GetCredentialsSubTask(ctx context.Context, params GetCredentialsSubTaskParams) (GetCredentialsSubTaskRes, error)
	// GetCredentialsTask invokes getCredentialsTask operation.
	//
	// Retrieve a credential task by ID.
	//
	// GET /v1/credentials/tasks/{id}
	GetCredentialsTask(ctx context.Context, params GetCredentialsTaskParams) (GetCredentialsTaskRes, error)
	// GetCredentialsTasks invokes getCredentialsTasks operation.
	//
	// Retrieve a list of credential tasks.
	//
	// GET /v1/credentials/tasks
	GetCredentialsTasks(ctx context.Context, params GetCredentialsTasksParams) (GetCredentialsTasksRes, error)
	// GetCriteria invokes getCriteria operation.
	//
	// Get all criteria.
	//
	// GET /v1/hosts/criteria
	GetCriteria(ctx context.Context) (*PageOfHostCriterion, error)
	// GetCriterion invokes getCriterion operation.
	//
	// Get a criterion.
	//
	// GET /v1/hosts/criteria/{name}
	GetCriterion(ctx context.Context, params GetCriterionParams) (GetCriterionRes, error)
	// GetCustomIsoById invokes getCustomIsoById operation.
	//
	// Get the Custom ISO based matching the ID.
	//
	// GET /v1/custom-isos/{custom_iso_id}
	GetCustomIsoById(ctx context.Context, params GetCustomIsoByIdParams) (GetCustomIsoByIdRes, error)
	// GetCustomIsos invokes getCustomIsos operation.
	//
	// Get all Custom ISOs or Custom ISOs that match specified parameters.
	//
	// GET /v1/custom-isos
	GetCustomIsos(ctx context.Context, params GetCustomIsosParams) (GetCustomIsosRes, error)
	// GetCustomPatches invokes getCustomPatches operation.
	//
	// Filter applicable patches (current/target vcf releases) per product type per domain.
	//
	// GET /v1/releases/domains/{domainId}/custom-patches
	GetCustomPatches(ctx context.Context, params GetCustomPatchesParams) (*FlexibleProductPatches, error)
	// GetDatastoreCriterion invokes getDatastoreCriterion operation.
	//
	// Get a criterion to query for datastore.
	//
	// GET /v1/domains/{domainId}/datastores/criteria/{name}
	GetDatastoreCriterion(ctx context.Context, params GetDatastoreCriterionParams) (GetDatastoreCriterionRes, error)
	// GetDatastoreCriterion1 invokes getDatastoreCriterion_1 operation.
	//
	// Get a criterion to query for datastore.
	//
	// GET /v1/clusters/{id}/datastores/criteria/{name}
	GetDatastoreCriterion1(ctx context.Context, params GetDatastoreCriterion1Params) (GetDatastoreCriterion1Res, error)
	// GetDatastoreQueryResponse invokes getDatastoreQueryResponse operation.
	//
	// Get Datastore query response.
	//
	// GET /v1/domains/{domainId}/datastores/queries/{queryId}
	GetDatastoreQueryResponse(ctx context.Context, params GetDatastoreQueryResponseParams) (GetDatastoreQueryResponseRes, error)
	// GetDatastoreQueryResponse1 invokes getDatastoreQueryResponse_1 operation.
	//
	// Get Datastore query response.
	//
	// GET /v1/clusters/{clusterId}/datastores/queries/{queryId}
	GetDatastoreQueryResponse1(ctx context.Context, params GetDatastoreQueryResponse1Params) (GetDatastoreQueryResponse1Res, error)
	// GetDatastoresCriteria invokes getDatastoresCriteria operation.
	//
	// Get all datastore criteria.
	//
	// GET /v1/domains/{domainId}/datastores/criteria
	GetDatastoresCriteria(ctx context.Context, params GetDatastoresCriteriaParams) (*PageOfDatastoreCriterion, error)
	// GetDatastoresCriteria1 invokes getDatastoresCriteria_1 operation.
	//
	// Get all datastore criteria.
	//
	// GET /v1/clusters/{id}/datastores/criteria
	GetDatastoresCriteria1(ctx context.Context, params GetDatastoresCriteria1Params) (*PageOfDatastoreCriterion, error)
	// GetDepotSettings invokes getDepotSettings operation.
	//
	// Get the depot configuration. In a fresh setup, this would be empty.
	//
	// GET /v1/system/settings/depot
	GetDepotSettings(ctx context.Context) (GetDepotSettingsRes, error)
	// GetDnsConfiguration invokes getDnsConfiguration operation.
	//
	// Retrieve the DNS configuration.
	//
	// GET /v1/system/dns-configuration
	GetDnsConfiguration(ctx context.Context) (GetDnsConfigurationRes, error)
	// GetDomain invokes getDomain operation.
	//
	// Get a domain by its ID.
	//
	// GET /v1/domains/{id}
	GetDomain(ctx context.Context, params GetDomainParams) (GetDomainRes, error)
	// GetDomainCertificates invokes getDomainCertificates operation.
	//
	// Get latest generated certificate(s) in a domain.
	//
	// GET /v1/domains/{id}/certificates
	GetDomainCertificates(ctx context.Context, params GetDomainCertificatesParams) (GetDomainCertificatesRes, error)
	// GetDomainEndpoints invokes getDomainEndpoints operation.
	//
	// Retrieve a list of endpoints or URLs for a domain by its ID.
	//
	// GET /v1/domains/{id}/endpoints
	GetDomainEndpoints(ctx context.Context, params GetDomainEndpointsParams) (GetDomainEndpointsRes, error)
	// GetDomainIsolationPrecheckStatus invokes getDomainIsolationPrecheckStatus operation.
	//
	// Get the status of the Domain Isolation Precheck.
	//
	// GET /v1/domains/{domainId}/isolation-prechecks/{precheckId}
	GetDomainIsolationPrecheckStatus(ctx context.Context, params GetDomainIsolationPrecheckStatusParams) (GetDomainIsolationPrecheckStatusRes, error)
	// GetDomainReleaseViewValidation invokes getDomainReleaseViewValidation operation.
	//
	// Monitor the progress of domain target state validation task by the validation id.
	//
	// GET /v1/releases/domains/validations/{validationId}
	GetDomainReleaseViewValidation(ctx context.Context, params GetDomainReleaseViewValidationParams) (GetDomainReleaseViewValidationRes, error)
	// GetDomainTagManagerUrl invokes getDomainTagManagerUrl operation.
	//
	// Get Domain Tag Manager Url.
	//
	// GET /v1/domains/{id}/tags/tag-manager
	GetDomainTagManagerUrl(ctx context.Context, params GetDomainTagManagerUrlParams) (GetDomainTagManagerUrlRes, error)
	// GetDomainUpdateValidation invokes getDomainUpdateValidation operation.
	//
	// Gets the status of given domain update validation workflow by given validation id.
	//
	// GET /v1/domains/{id}/validations/{validationId}
	GetDomainUpdateValidation(ctx context.Context, params GetDomainUpdateValidationParams) (GetDomainUpdateValidationRes, error)
	// GetDomains invokes getDomains operation.
	//
	// Retrieve a list of domains.
	//
	// GET /v1/domains
	GetDomains(ctx context.Context, params GetDomainsParams) (GetDomainsRes, error)
	// GetEdgeCluster invokes getEdgeCluster operation.
	//
	// Retrieve an NSX Edge Cluster by its ID.
	//
	// GET /v1/edge-clusters/{id}
	GetEdgeCluster(ctx context.Context, params GetEdgeClusterParams) (GetEdgeClusterRes, error)
	// GetEdgeClusterQueryCriteria invokes getEdgeClusterQueryCriteria operation.
	//
	// Get the Edge Cluster criterion list for the NSX query.
	//
	// GET /v1/edge-clusters/{edgeClusterId}/criteria
	GetEdgeClusterQueryCriteria(ctx context.Context, params GetEdgeClusterQueryCriteriaParams) (GetEdgeClusterQueryCriteriaRes, error)
	// GetEdgeClusterValidationByID invokes getEdgeClusterValidationByID operation.
	//
	// Retrieve the results of a NSX Edge Cluster validation by its ID.
	//
	// GET /v1/edge-clusters/validations/{id}
	GetEdgeClusterValidationByID(ctx context.Context, params GetEdgeClusterValidationByIDParams) (GetEdgeClusterValidationByIDRes, error)
	// GetEdgeClusters invokes getEdgeClusters operation.
	//
	// Retrieve a list of NSX Edge Clusters.
	//
	// GET /v1/edge-clusters
	GetEdgeClusters(ctx context.Context, params GetEdgeClustersParams) (GetEdgeClustersRes, error)
	// GetFIPSConfiguration invokes getFIPSConfiguration operation.
	//
	// Retrieve VCF security FIPS mode.
	//
	// GET /v1/system/security/fips
	GetFIPSConfiguration(ctx context.Context) (GetFIPSConfigurationRes, error)
	// GetFutureReleases invokes getFutureReleases operation.
	//
	// Returns all known to the system future target versions for a domain. If some of them are not
	// allowed (e.g. stepping stone) includes message why. If the domain does not have a product
	// configured at that point, that product will not be included in the BOM or patch bundle list in
	// each release.
	//
	// GET /v1/releases/domains/{domainId}/future-releases
	GetFutureReleases(ctx context.Context, params GetFutureReleasesParams) (GetFutureReleasesRes, error)
	// GetHealthCheckStatus invokes getHealthCheckStatus operation.
	//
	// Retrieve the status of the Health Check operations.
	//
	// GET /v1/system/health-summary/{id}
	GetHealthCheckStatus(ctx context.Context, params GetHealthCheckStatusParams) (GetHealthCheckStatusRes, error)
	// GetHealthCheckTask invokes getHealthCheckTask operation.
	//
	// Retieve a list of Health Check tasks.
	//
	// GET /v1/system/health-summary
	GetHealthCheckTask(ctx context.Context) (GetHealthCheckTaskRes, error)
	// GetHost invokes getHost operation.
	//
	// Get a host by its ID.
	//
	// GET /v1/hosts/{id}
	GetHost(ctx context.Context, params GetHostParams) (GetHostRes, error)
	// GetHostCommissionValidationByID invokes getHostCommissionValidationByID operation.
	//
	// Retrieve the results of a host commission validation by its ID.
	//
	// GET /v1/hosts/validations/{id}
	GetHostCommissionValidationByID(ctx context.Context, params GetHostCommissionValidationByIDParams) (GetHostCommissionValidationByIDRes, error)
	// GetHostCriteria invokes getHostCriteria operation.
	//
	// Get all host criteria.
	//
	// GET /v1/clusters/{id}/hosts/criteria
	GetHostCriteria(ctx context.Context, params GetHostCriteriaParams) (*PageOfHostCriterion, error)
	// GetHostCriterion invokes getHostCriterion operation.
	//
	// Get a criterion to query for host.
	//
	// GET /v1/clusters/{id}/hosts/criteria/{name}
	GetHostCriterion(ctx context.Context, params GetHostCriterionParams) (GetHostCriterionRes, error)
	// GetHostQueryResponse invokes getHostQueryResponse operation.
	//
	// Get query response.
	//
	// GET /v1/hosts/queries/{id}
	GetHostQueryResponse(ctx context.Context, params GetHostQueryResponseParams) (GetHostQueryResponseRes, error)
	// GetHostQueryResponse1 invokes getHostQueryResponse_1 operation.
	//
	// Get query response.
	//
	// GET /v1/clusters/{clusterId}/hosts/queries/{queryId}
	GetHostQueryResponse1(ctx context.Context, params GetHostQueryResponse1Params) (GetHostQueryResponse1Res, error)
	// GetHostTagManagerUrl invokes getHostTagManagerUrl operation.
	//
	// Get Host Tag Manager Url.
	//
	// GET /v1/hosts/{id}/tags/tag-manager
	GetHostTagManagerUrl(ctx context.Context, params GetHostTagManagerUrlParams) (GetHostTagManagerUrlRes, error)
	// GetHosts invokes getHosts operation.
	//
	// Get all hosts.
	//
	// GET /v1/hosts
	GetHosts(ctx context.Context, params GetHostsParams) (GetHostsRes, error)
	// GetHostsPrechecksResponse invokes getHostsPrechecksResponse operation.
	//
	// Get host(s) prechecks response.
	//
	// GET /v1/hosts/prechecks/{id}
	GetHostsPrechecksResponse(ctx context.Context, params GetHostsPrechecksResponseParams) (GetHostsPrechecksResponseRes, error)
	// GetIdentityPrecheckResult invokes getIdentityPrecheckResult operation.
	//
	// Get a list precheck result with warnings/errors.
	//
	// GET /v1/identity-broker/prechecks
	GetIdentityPrecheckResult(ctx context.Context, params GetIdentityPrecheckResultParams) (GetIdentityPrecheckResultRes, error)
	// GetIdentityProviderById invokes getIdentityProviderById operation.
	//
	// Get a specific identity irovider using its id.
	//
	// GET /v1/identity-providers/{id}
	GetIdentityProviderById(ctx context.Context, params GetIdentityProviderByIdParams) (GetIdentityProviderByIdRes, error)
	// GetIdentityProviders invokes getIdentityProviders operation.
	//
	// Get a list of all identity providers.
	//
	// GET /v1/identity-providers
	GetIdentityProviders(ctx context.Context) (GetIdentityProvidersRes, error)
	// GetLastAssessmentRunInfo invokes getLastAssessmentRunInfo operation.
	//
	// Get information about the last assessment run.
	//
	// GET /v1/system/check-sets
	GetLastAssessmentRunInfo(ctx context.Context, params GetLastAssessmentRunInfoParams) (GetLastAssessmentRunInfoRes, error)
	// GetLicenseKey invokes getLicenseKey operation.
	//
	// Retrieve a license key.
	//
	// GET /v1/license-keys/{key}
	GetLicenseKey(ctx context.Context, params GetLicenseKeyParams) (GetLicenseKeyRes, error)
	// GetLicenseKeys invokes getLicenseKeys operation.
	//
	// Retrieve a list of license keys.
	//
	// GET /v1/license-keys
	GetLicenseKeys(ctx context.Context, params GetLicenseKeysParams) (GetLicenseKeysRes, error)
	// GetLicenseProductTypes invokes getLicenseProductTypes operation.
	//
	// Get product types.
	//
	// GET /v1/license-keys/product-types
	GetLicenseProductTypes(ctx context.Context) (GetLicenseProductTypesRes, error)
	// GetLocalAccount invokes getLocalAccount operation.
	//
	// Get information on the local account.
	//
	// GET /v1/users/local/admin
	GetLocalAccount(ctx context.Context) (GetLocalAccountRes, error)
	// GetLocalOsUserAccounts invokes getLocalOsUserAccounts operation.
	//
	// Returns a list of local OS user accounts from the SDDC Manager appliance.
	//
	// GET /v1/sddc-manager/local-os-user-accounts
	GetLocalOsUserAccounts(ctx context.Context) (GetLocalOsUserAccountsRes, error)
	// GetNetworkOfNetworkPool invokes getNetworkOfNetworkPool operation.
	//
	// Get a Network that is part of a Network Pool.
	//
	// GET /v1/network-pools/{id}/networks/{networkId}
	GetNetworkOfNetworkPool(ctx context.Context, params GetNetworkOfNetworkPoolParams) (GetNetworkOfNetworkPoolRes, error)
	// GetNetworkPool invokes getNetworkPool operation.
	//
	// Get the Network Pools.
	//
	// GET /v1/network-pools
	GetNetworkPool(ctx context.Context) (GetNetworkPoolRes, error)
	// GetNetworkPoolByID invokes getNetworkPoolByID operation.
	//
	// Get a Network Pool by ID, if it exists.
	//
	// GET /v1/network-pools/{id}
	GetNetworkPoolByID(ctx context.Context, params GetNetworkPoolByIDParams) (GetNetworkPoolByIDRes, error)
	// GetNetworksOfNetworkPool invokes getNetworksOfNetworkPool operation.
	//
	// Get the Networks that are part of a Network Pool.
	//
	// GET /v1/network-pools/{id}/networks
	GetNetworksOfNetworkPool(ctx context.Context, params GetNetworksOfNetworkPoolParams) (GetNetworksOfNetworkPoolRes, error)
	// GetNsxCluster invokes getNsxCluster operation.
	//
	// Retrieve the details of an NSX cluster by its ID.
	//
	// GET /v1/nsxt-clusters/{id}
	GetNsxCluster(ctx context.Context, params GetNsxClusterParams) (GetNsxClusterRes, error)
	// GetNsxClusterQueryResponse invokes getNsxClusterQueryResponse operation.
	//
	// Get NSX cluster query response.
	//
	// GET /v1/nsxt-clusters/queries/{id}
	GetNsxClusterQueryResponse(ctx context.Context, params GetNsxClusterQueryResponseParams) (GetNsxClusterQueryResponseRes, error)
	// GetNsxClusters invokes getNsxClusters operation.
	//
	// Retrieve a list of NSX clusters.
	//
	// GET /v1/nsxt-clusters
	GetNsxClusters(ctx context.Context, params GetNsxClustersParams) (GetNsxClustersRes, error)
	// GetNsxCriteria invokes getNsxCriteria operation.
	//
	// Get all NSX criteria.
	//
	// GET /v1/nsxt-clusters/criteria
	GetNsxCriteria(ctx context.Context) (*PageOfNsxTCriterion, error)
	// GetNsxCriterion invokes getNsxCriterion operation.
	//
	// Get a NSX criterion.
	//
	// GET /v1/nsxt-clusters/criteria/{name}
	GetNsxCriterion(ctx context.Context, params GetNsxCriterionParams) (GetNsxCriterionRes, error)
	// GetNsxIpAddressPool invokes getNsxIpAddressPool operation.
	//
	// Retrieve an NSX IP Address Pool by its name.
	//
	// GET /v1/nsxt-clusters/{nsxt-cluster-id}/ip-address-pools/{name}
	GetNsxIpAddressPool(ctx context.Context, params GetNsxIpAddressPoolParams) (GetNsxIpAddressPoolRes, error)
	// GetNsxIpAddressPools invokes getNsxIpAddressPools operation.
	//
	// Retrive a list of NSX IP Address Pools by the NSX cluster ID.
	//
	// GET /v1/nsxt-clusters/{nsxt-cluster-id}/ip-address-pools
	GetNsxIpAddressPools(ctx context.Context, params GetNsxIpAddressPoolsParams) (GetNsxIpAddressPoolsRes, error)
	// GetNsxTransportZones invokes getNsxTransportZones operation.
	//
	// Retrieve list of all NSX transport zones.
	//
	// GET /v1/nsxt-clusters/{nsxt-cluster-id}/transport-zones
	GetNsxTransportZones(ctx context.Context, params GetNsxTransportZonesParams) (GetNsxTransportZonesRes, error)
	// GetNsxUpgradeResources invokes getNsxUpgradeResources operation.
	//
	// Get the list NSX upgradable reosurce with resource metadata info.
	//
	// GET /v1/upgradables/domains/{domainId}/nsxt
	GetNsxUpgradeResources(ctx context.Context, params GetNsxUpgradeResourcesParams) (GetNsxUpgradeResourcesRes, error)
	// GetNtpConfiguration invokes getNtpConfiguration operation.
	//
	// Retrieve the NTP configuration.
	//
	// GET /v1/system/ntp-configuration
	GetNtpConfiguration(ctx context.Context) (GetNtpConfigurationRes, error)
	// GetPasswordExpiration invokes getPasswordExpiration operation.
	//
	// Fetch expiration details of passwords for a list of credentials.
	//
	// POST /v1/credentials/expirations
	GetPasswordExpiration(ctx context.Context, request *CredentialsExpirationSpec) (GetPasswordExpirationRes, error)
	// GetPasswordExpirationByTaskID invokes getPasswordExpirationByTaskID operation.
	//
	// Retrive a password expiration task by ID.
	//
	// GET /v1/credentials/expirations/{id}
	GetPasswordExpirationByTaskID(ctx context.Context, params GetPasswordExpirationByTaskIDParams) (GetPasswordExpirationByTaskIDRes, error)
	// GetPersonalities invokes getPersonalities operation.
	//
	// Get the Personalities which are available via depot access.
	//
	// GET /v1/personalities
	GetPersonalities(ctx context.Context, params GetPersonalitiesParams) (GetPersonalitiesRes, error)
	// GetPersonality invokes getPersonality operation.
	//
	// Get the Personality for id.
	//
	// GET /v1/personalities/{personalityId}
	GetPersonality(ctx context.Context, params GetPersonalityParams) (GetPersonalityRes, error)
	// GetPrecheckTask invokes getPrecheckTask operation.
	//
	// Monitor the progress of precheck task by the precheck task ID. As this API is deprecated, please
	// use the new LCM Prechecks API - /v1/system/check-sets/{taskId}.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /v1/system/prechecks/tasks/{id}
	GetPrecheckTask(ctx context.Context, params GetPrecheckTaskParams) (GetPrecheckTaskRes, error)
	// GetProductVersionCatalog invokes getProductVersionCatalog operation.
	//
	// Get product version catalog. There should be only one valid product version catalog in the System.
	//
	// GET /v1/product-version-catalog
	GetProductVersionCatalog(ctx context.Context) (GetProductVersionCatalogRes, error)
	// GetProxyConfiguration invokes getProxyConfiguration operation.
	//
	// Get the current Proxy configuration.
	//
	// GET /v1/system/proxy-configuration
	GetProxyConfiguration(ctx context.Context) (GetProxyConfigurationRes, error)
	// GetPsc invokes getPsc operation.
	//
	// Retrieve details of a Platform Service Controller (PSC).
	//
	// GET /v1/pscs/{id}
	GetPsc(ctx context.Context, params GetPscParams) (GetPscRes, error)
	// GetPscs invokes getPscs operation.
	//
	// Retrieve a list of Platform Service Controller (PSC).
	//
	// GET /v1/pscs
	GetPscs(ctx context.Context) (GetPscsRes, error)
	// GetReconciliationTask invokes getReconciliationTask operation.
	//
	// Get config reconciliation task associated with the given task Id.
	//
	// GET /v1/config-drift-reconciliations/{taskId}
	GetReconciliationTask(ctx context.Context, params GetReconciliationTaskParams) (GetReconciliationTaskRes, error)
	// GetReleaseByDomain invokes getReleaseByDomain operation.
	//
	// Get last selected upgrade version for the domain.
	//
	// GET /v1/releases/domains/{domainId}
	GetReleaseByDomain(ctx context.Context, params GetReleaseByDomainParams) (GetReleaseByDomainRes, error)
	// GetReleaseByDomains invokes getReleaseByDomains operation.
	//
	// Get last selected upgrade version for WLDs.
	//
	// GET /v1/releases/domains
	GetReleaseByDomains(ctx context.Context) (GetReleaseByDomainsRes, error)
	// GetReleases invokes getReleases operation.
	//
	// Get all Releases, with option to get current release for a domain, get release by version or get
	// future releases for a versionor get all the applicable target release.
	//
	// GET /v1/releases
	GetReleases(ctx context.Context, params GetReleasesParams) (GetReleasesRes, error)
	// GetResourceCertificatesValidationByID invokes getResourceCertificatesValidationByID operation.
	//
	// Get the resource certificate validation result.
	//
	// GET /v1/domains/{id}/resource-certificates/validations/{validationId}
	GetResourceCertificatesValidationByID(ctx context.Context, params GetResourceCertificatesValidationByIDParams) (GetResourceCertificatesValidationByIDRes, error)
	// GetResourceFunctionalities invokes getResourceFunctionalities operation.
	//
	// Get Resource Functionalities.
	//
	// GET /v1/resource-functionalities
	GetResourceFunctionalities(ctx context.Context, params GetResourceFunctionalitiesParams) (GetResourceFunctionalitiesRes, error)
	// GetResourceWarning invokes getResourceWarning operation.
	//
	// Get a Resource Warning by ID.
	//
	// GET /v1/resource-warnings/{id}
	GetResourceWarning(ctx context.Context, params GetResourceWarningParams) (GetResourceWarningRes, error)
	// GetResourceWarnings invokes getResourceWarnings operation.
	//
	// Get Resource Warnings.
	//
	// GET /v1/resource-warnings
	GetResourceWarnings(ctx context.Context, params GetResourceWarningsParams) (GetResourceWarningsRes, error)
	// GetResourcesFunctionalitiesAllowedGlobal invokes getResourcesFunctionalitiesAllowedGlobal operation.
	//
	// Get Resource Functionalities Allowed Global Configuration.
	//
	// GET /v1/resource-functionalities/global
	GetResourcesFunctionalitiesAllowedGlobal(ctx context.Context) (GetResourcesFunctionalitiesAllowedGlobalRes, error)
	// GetRestoreTask invokes getRestoreTask operation.
	//
	// Retrieve the restore task.
	//
	// GET /v1/restores/tasks/{id}
	GetRestoreTask(ctx context.Context, params GetRestoreTaskParams) (GetRestoreTaskRes, error)
	// GetResult invokes getResult operation.
	//
	// Get the result for a given check run.
	//
	// GET /v1/system/check-sets/{runId}
	GetResult(ctx context.Context, params GetResultParams) (GetResultRes, error)
	// GetRoles invokes getRoles operation.
	//
	// Get a list of all roles.
	//
	// GET /v1/roles
	GetRoles(ctx context.Context) (GetRolesRes, error)
	// GetSSODomainEntities invokes getSSODomainEntities operation.
	//
	// Get a list of all entities in the SSO domain.
	//
	// GET /v1/sso-domains/{sso-domain}/entities
	GetSSODomainEntities(ctx context.Context, params GetSSODomainEntitiesParams) (GetSSODomainEntitiesRes, error)
	// GetSSODomains invokes getSSODomains operation.
	//
	// Get a list of all SSO domains.
	//
	// GET /v1/sso-domains
	GetSSODomains(ctx context.Context) (GetSSODomainsRes, error)
	// GetSddcManager invokes getSddcManager operation.
	//
	// Retrieve the details of an SDDC Manager by its id.
	//
	// GET /v1/sddc-managers/{id}
	GetSddcManager(ctx context.Context, params GetSddcManagerParams) (GetSddcManagerRes, error)
	// GetSddcManagerHistory invokes getSddcManagerHistory operation.
	//
	// Retrieve the history of SDDC Manager by its id.
	//
	// GET /v1/sddc-managers/{id}/history
	GetSddcManagerHistory(ctx context.Context, params GetSddcManagerHistoryParams) (GetSddcManagerHistoryRes, error)
	// GetSddcManagerInfo invokes getSddcManagerInfo operation.
	//
	// Retrieves the details of SDDC Manager VM.
	//
	// GET /v1/sddcs/{id}/sddc-manager
	GetSddcManagerInfo(ctx context.Context, params GetSddcManagerInfoParams) (GetSddcManagerInfoRes, error)
	// GetSddcManagers invokes getSddcManagers operation.
	//
	// Retrieve a list of SDDC Managers.
	//
	// GET /v1/sddc-managers
	GetSddcManagers(ctx context.Context) (GetSddcManagersRes, error)
	// GetSddcWs1bOidcInfo invokes getSddcWs1bOidcInfo operation.
	//
	// Get the SDDC Manager WS1B OIDC Information.
	//
	// GET /v1/identity-broker/sddc-manager-oidc
	GetSddcWs1bOidcInfo(ctx context.Context) (GetSddcWs1bOidcInfoRes, error)
	// GetSupportBundleStatus invokes getSupportBundleStatus operation.
	//
	// Retrive the status of the Support Bundle operation.
	//
	// GET /v1/system/support-bundles/{id}
	GetSupportBundleStatus(ctx context.Context, params GetSupportBundleStatusParams) (GetSupportBundleStatusRes, error)
	// GetSupportBundleTask invokes getSupportBundleTask operation.
	//
	// Retrieve a list of Support Bundle tasks.
	//
	// GET /v1/system/support-bundles
	GetSupportBundleTask(ctx context.Context) (GetSupportBundleTaskRes, error)
	// GetSystemConfiguration invokes getSystemConfiguration operation.
	//
	// Retrieve the system configuration.
	//
	// GET /v1/system
	GetSystemConfiguration(ctx context.Context) (GetSystemConfigurationRes, error)
	// GetSystemRelease invokes getSystemRelease operation.
	//
	// Returns release for the lowest deployed VCF version for a domain on the environment.If Management
	// domain is ahead of WLD domain, VCF BOM version for the WLDdomain will be returned.
	//
	// GET /v1/releases/system
	GetSystemRelease(ctx context.Context) (GetSystemReleaseRes, error)
	// GetTagAssignableForCluster invokes getTagAssignableForCluster operation.
	//
	// Get tags assignable to a cluster.
	//
	// GET /v1/clusters/{id}/tags/assignable-tags
	GetTagAssignableForCluster(ctx context.Context, params GetTagAssignableForClusterParams) (GetTagAssignableForClusterRes, error)
	// GetTagsAssignedToCluster invokes getTagsAssignedToCluster operation.
	//
	// Get tags assigned to a cluster by its ID.
	//
	// GET /v1/clusters/{id}/tags
	GetTagsAssignedToCluster(ctx context.Context, params GetTagsAssignedToClusterParams) (GetTagsAssignedToClusterRes, error)
	// GetTagsAssignedToClusters invokes getTagsAssignedToClusters operation.
	//
	// Get tags assigned to clusters.
	//
	// GET /v1/clusters/tags
	GetTagsAssignedToClusters(ctx context.Context) (GetTagsAssignedToClustersRes, error)
	// GetTagsAssignedToDomain invokes getTagsAssignedToDomain operation.
	//
	// Get tags assigned to a domain.
	//
	// GET /v1/domains/{id}/tags
	GetTagsAssignedToDomain(ctx context.Context, params GetTagsAssignedToDomainParams) (GetTagsAssignedToDomainRes, error)
	// GetTagsAssignedToDomains invokes getTagsAssignedToDomains operation.
	//
	// Get tags assigned to all domains.
	//
	// GET /v1/domains/tags
	GetTagsAssignedToDomains(ctx context.Context) (GetTagsAssignedToDomainsRes, error)
	// GetTagsAssignedToHost invokes getTagsAssignedToHost operation.
	//
	// Get Tags assigned to Host.
	//
	// GET /v1/hosts/{id}/tags
	GetTagsAssignedToHost(ctx context.Context, params GetTagsAssignedToHostParams) (GetTagsAssignedToHostRes, error)
	// GetTagsAssignedToHosts invokes getTagsAssignedToHosts operation.
	//
	// Get Tags assigned to Hosts.
	//
	// GET /v1/hosts/tags
	GetTagsAssignedToHosts(ctx context.Context) (GetTagsAssignedToHostsRes, error)
	// GetTask invokes getTask operation.
	//
	// Get a Task by ID, if it exists.
	//
	// GET /v1/tasks/{id}
	GetTask(ctx context.Context, params GetTaskParams) (GetTaskRes, error)
	// GetTasks invokes getTasks operation.
	//
	// Get the tasks.
	//
	// GET /v1/tasks
	GetTasks(ctx context.Context, params GetTasksParams) (GetTasksRes, error)
	// GetTrustedCertificates invokes getTrustedCertificates operation.
	//
	// Retrieve all trusted certificates from SDDC Manager.
	//
	// GET /v1/sddc-manager/trusted-certificates
	GetTrustedCertificates(ctx context.Context) (GetTrustedCertificatesRes, error)
	// GetUiUsers invokes getUiUsers operation.
	//
	// Retrieve a list of users assigned access via SDDC Manager.
	//
	// GET /v1/users/ui
	GetUiUsers(ctx context.Context) (GetUiUsersRes, error)
	// GetUpgradables invokes getUpgradables operation.
	//
	// Fetches the list of Upgradables in the System. Only one Upgradable becomes AVAILABLE for Upgrade.
	// The Upgradables provides information that can be use for Precheck API and also in the actual
	// Upgrade API call.
	//
	// GET /v1/system/upgradables
	GetUpgradables(ctx context.Context) (GetUpgradablesRes, error)
	// GetUpgradablesByDomain invokes getUpgradablesByDomain operation.
	//
	// Fetches the list of Upgradables for a given domain. If a target version is provided, Upgradables
	// that are required for given target version become Available. The Upgradables providesinformation
	// that can be use for Precheck API and also in the actual Upgrade API call.This API is used only for
	// management domain, for all cases please use v1/system/upgradables.
	//
	// GET /v1/upgradables/domains/{domainId}
	GetUpgradablesByDomain(ctx context.Context, params GetUpgradablesByDomainParams) (GetUpgradablesByDomainRes, error)
	// GetUpgradablesClusters invokes getUpgradablesClusters operation.
	//
	// Fetches the list of available hardware support managers and configured hardware support managers
	// for the give resource along with the hardware support packages and Software details.
	//
	// GET /v1/upgradables/domains/{domainId}/clusters
	GetUpgradablesClusters(ctx context.Context, params GetUpgradablesClustersParams) (GetUpgradablesClustersRes, error)
	// GetUpgradeById invokes getUpgradeById operation.
	//
	// Retrieve an upgrade by ID.
	//
	// GET /v1/upgrades/{upgradeId}
	GetUpgradeById(ctx context.Context, params GetUpgradeByIdParams) (GetUpgradeByIdRes, error)
	// GetUpgradePrecheckByID invokes getUpgradePrecheckByID operation.
	//
	// Gets upgrade precheck details.
	//
	// GET /v1/upgrades/{upgradeId}/prechecks/{precheckId}
	GetUpgradePrecheckByID(ctx context.Context, params GetUpgradePrecheckByIDParams) (GetUpgradePrecheckByIDRes, error)
	// GetUpgrades invokes getUpgrades operation.
	//
	// Retrieve a list of upgrades.
	//
	// GET /v1/upgrades
	GetUpgrades(ctx context.Context, params GetUpgradesParams) (GetUpgradesRes, error)
	// GetUsers invokes getUsers operation.
	//
	// Get a list of all users.
	//
	// GET /v1/users
	GetUsers(ctx context.Context) (GetUsersRes, error)
	// GetValidationOfDnsConfiguration invokes getValidationOfDnsConfiguration operation.
	//
	// Retrieve the results of a DNS configuration validation by its ID.
	//
	// GET /v1/system/dns-configuration/validations/{id}
	GetValidationOfDnsConfiguration(ctx context.Context, params GetValidationOfDnsConfigurationParams) (GetValidationOfDnsConfigurationRes, error)
	// GetValidationOfNtpConfiguration invokes getValidationOfNtpConfiguration operation.
	//
	// Retrieve the results of a NTP configuration  validation by its ID.
	//
	// GET /v1/system/ntp-configuration/validations/{id}
	GetValidationOfNtpConfiguration(ctx context.Context, params GetValidationOfNtpConfigurationParams) (GetValidationOfNtpConfigurationRes, error)
	// GetValidationResult invokes getValidationResult operation.
	//
	// GET /v1/nsxt-clusters/ip-address-pools/validations/{id}
	GetValidationResult(ctx context.Context, params GetValidationResultParams) (*Validation, error)
	// GetValidationsOfDNSConfiguration invokes getValidationsOfDNSConfiguration operation.
	//
	// Retrieve a list of DNS configuation validations.
	//
	// GET /v1/system/dns-configuration/validations
	GetValidationsOfDNSConfiguration(ctx context.Context, params GetValidationsOfDNSConfigurationParams) (GetValidationsOfDNSConfigurationRes, error)
	// GetValidationsOfNtpConfiguration invokes getValidationsOfNtpConfiguration operation.
	//
	// Retrieve a list of NTP configuation validations.
	//
	// GET /v1/system/ntp-configuration/validations
	GetValidationsOfNtpConfiguration(ctx context.Context, params GetValidationsOfNtpConfigurationParams) (GetValidationsOfNtpConfigurationRes, error)
	// GetVasaProvider invokes getVasaProvider operation.
	//
	// Get a VASA Provider.
	//
	// GET /v1/vasa-providers/{id}
	GetVasaProvider(ctx context.Context, params GetVasaProviderParams) (GetVasaProviderRes, error)
	// GetVasaProviderStorageContainers invokes getVasaProviderStorageContainers operation.
	//
	// Get the storage containers of a VASA Provider.
	//
	// GET /v1/vasa-providers/{id}/storage-containers
	GetVasaProviderStorageContainers(ctx context.Context, params GetVasaProviderStorageContainersParams) (GetVasaProviderStorageContainersRes, error)
	// GetVasaProviderUser invokes getVasaProviderUser operation.
	//
	// Get the users of a VASA Provider.
	//
	// GET /v1/vasa-providers/{id}/users
	GetVasaProviderUser(ctx context.Context, params GetVasaProviderUserParams) (GetVasaProviderUserRes, error)
	// GetVasaProviderValidation invokes getVasaProviderValidation operation.
	//
	// Get the status of the validation of the VASA Provider.
	//
	// GET /v1/vasa-providers/validations/{id}
	GetVasaProviderValidation(ctx context.Context, params GetVasaProviderValidationParams) (GetVasaProviderValidationRes, error)
	// GetVasaProviders invokes getVasaProviders operation.
	//
	// Get the VASA Providers.
	//
	// GET /v1/vasa-providers
	GetVasaProviders(ctx context.Context) (GetVasaProvidersRes, error)
	// GetVcenter invokes getVcenter operation.
	//
	// Retrieve a vCenter Server by its ID.
	//
	// GET /v1/vcenters/{id}
	GetVcenter(ctx context.Context, params GetVcenterParams) (GetVcenterRes, error)
	// GetVcenters invokes getVcenters operation.
	//
	// Retrieve a list of vCenter Servers.
	//
	// GET /v1/vcenters
	GetVcenters(ctx context.Context, params GetVcentersParams) (GetVcentersRes, error)
	// GetVcfService invokes getVcfService operation.
	//
	// Retrieve an SDDC Manager service by its ID.
	//
	// GET /v1/vcf-services/{id}
	GetVcfService(ctx context.Context, params GetVcfServiceParams) (GetVcfServiceRes, error)
	// GetVcfServices invokes getVcfServices operation.
	//
	// Retrieve a list of SDDC Manager services.
	//
	// GET /v1/vcf-services
	GetVcfServices(ctx context.Context) (GetVcfServicesRes, error)
	// GetVdses invokes getVdses operation.
	//
	// Get the list of VDSes of a cluster.
	//
	// GET /v1/clusters/{clusterId}/vdses
	GetVdses(ctx context.Context, params GetVdsesParams) (GetVdsesRes, error)
	// GetVersionAliasConfiguration invokes getVersionAliasConfiguration operation.
	//
	// Get the Version Alias Configuration.
	//
	// GET /v1/system/settings/version-aliases
	GetVersionAliasConfiguration(ctx context.Context) (GetVersionAliasConfigurationRes, error)
	// GetVras invokes getVras operation.
	//
	// Retrieve a list of VMware Aria Automation instances.
	//
	// GET /v1/vras
	GetVras(ctx context.Context) (*PageOfVra, error)
	// GetVrliIntegratedDomains invokes getVrliIntegratedDomains operation.
	//
	// Retrieve a list of VMware Aria Operations for Logs integration status for domains.
	//
	// GET /v1/vrli/domains
	GetVrliIntegratedDomains(ctx context.Context) (*PageOfDomainIntegration, error)
	// GetVrlis invokes getVrlis operation.
	//
	// Retrieve a list of VMware Aria Operations for Logs instances.
	//
	// GET /v1/vrlis
	GetVrlis(ctx context.Context) (*PageOfVrli, error)
	// GetVropsIntegratedDomains invokes getVropsIntegratedDomains operation.
	//
	// Retrieves the existing  domains and their connection status with Aria Operations.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /v1/vrops/domains
	GetVropsIntegratedDomains(ctx context.Context) (*PageOfDomainIntegration, error)
	// GetVropses invokes getVropses operation.
	//
	// Retrieve a list of VMware Aria Operations instances.
	//
	// GET /v1/vropses
	GetVropses(ctx context.Context) (*PageOfVrops, error)
	// GetVrslcm invokes getVrslcm operation.
	//
	// Gets the complete information about the existing VMware Aria Suite Lifecycle instance.
	//
	// GET /v1/vrslcm
	GetVrslcm(ctx context.Context) (GetVrslcmRes, error)
	// GetVrslcmStatus invokes getVrslcmStatus operation.
	//
	// Get status on the VMware Aria Suite Lifecycle product and availability of different actions.
	//
	// GET /v1/vrslcm/status
	GetVrslcmStatus(ctx context.Context) (GetVrslcmStatusRes, error)
	// GetVrslcmValidation invokes getVrslcmValidation operation.
	//
	// Gets the status of given VMware Aria Suite Lifecycle validation workflow by given validation id.
	//
	// GET /v1/vrslcms/validations/{id}
	GetVrslcmValidation(ctx context.Context, params GetVrslcmValidationParams) (GetVrslcmValidationRes, error)
	// GetVrslcms invokes getVrslcms operation.
	//
	// Get all existing VMware Aria Suite Lifecycle instances.
	//
	// GET /v1/vrslcms
	GetVrslcms(ctx context.Context) (*PageOfVrslcm, error)
	// GetVsanHclAttributes invokes getVsanHclAttributes operation.
	//
	// Attributes of vSAN HCL data such as timestamp of last update.
	//
	// GET /v1/vsan-hcl/attributes
	GetVsanHclAttributes(ctx context.Context) (GetVsanHclAttributesRes, error)
	// GetVsanHclConfiguration invokes getVsanHclConfiguration operation.
	//
	// Get vSAN HCL configuration.
	//
	// GET /v1/vsan-hcl/configuration
	GetVsanHclConfiguration(ctx context.Context) (GetVsanHclConfigurationRes, error)
	// GetVsanHealthCheckByDomain invokes getVsanHealthCheckByDomain operation.
	//
	// Get vSAN health check status for all cluster on the domain.
	//
	// GET /v1/domains/{domainId}/health-checks
	GetVsanHealthCheckByDomain(ctx context.Context, params GetVsanHealthCheckByDomainParams) (GetVsanHealthCheckByDomainRes, error)
	// GetVsanHealthCheckByQueryID invokes getVsanHealthCheckByQueryID operation.
	//
	// Get vSAN health check status for a given Query Id.
	//
	// GET /v1/domains/{domainId}/health-checks/queries/{queryId}
	GetVsanHealthCheckByQueryID(ctx context.Context, params GetVsanHealthCheckByQueryIDParams) (GetVsanHealthCheckByQueryIDRes, error)
	// GetVsanHealthCheckByTaskID invokes getVsanHealthCheckByTaskID operation.
	//
	// Get vSAN health check update task status for a given task Id.
	//
	// GET /v1/domains/{domainId}/health-checks/tasks/{taskId}
	GetVsanHealthCheckByTaskID(ctx context.Context, params GetVsanHealthCheckByTaskIDParams) (GetVsanHealthCheckByTaskIDRes, error)
	// GetWsas invokes getWsas operation.
	//
	// Retrieve a list of Workspace ONE Access instances.
	//
	// GET /v1/wsas
	GetWsas(ctx context.Context) (*PageOfWsa, error)
	// ImportVdsToInventory invokes importVdsToInventory operation.
	//
	// Import Vds to inventory for the given cluster.
	//
	// POST /v1/clusters/{clusterId}/vdses
	ImportVdsToInventory(ctx context.Context, request *ImportVdsSpec, params ImportVdsToInventoryParams) (ImportVdsToInventoryRes, error)
	// InvalidateRefreshToken invokes invalidateRefreshToken operation.
	//
	// Invalidate the provided refresh token.
	//
	// DELETE /v1/tokens/refresh-token
	InvalidateRefreshToken(ctx context.Context, request string) error
	// PerformDomainIsolationPrecheck invokes performDomainIsolationPrecheck operation.
	//
	// Perform Domain Isolation Prechecks.
	//
	// POST /v1/domains/{domainId}/isolation-prechecks
	PerformDomainIsolationPrecheck(ctx context.Context, request *IsolationSpec, params PerformDomainIsolationPrecheckParams) (PerformDomainIsolationPrecheckRes, error)
	// PerformUpgrade invokes performUpgrade operation.
	//
	// Schedule/Trigger Upgrade of a Resource. Ex: Resource can be DOMAIN, CLUSTER, UNMANAGED_HOST etc.
	// Performing upgrades are supported on VMware Cloud Foundation 3.5 BOM resources and above. Supports
	// scheduling/triggering of only 'parallel' upgrades and only Resource 'cluster' that are managed
	// using both vSphere Lifecycle Manager Baselines and vSphere Lifecycle Manager Images in the same
	// request.
	//
	// POST /v1/upgrades
	PerformUpgrade(ctx context.Context, request *UpgradeSpec) (PerformUpgradeRes, error)
	// PostClusterQuery invokes postClusterQuery operation.
	//
	// Post a cluster query.
	//
	// POST /v1/domains/{domainId}/clusters/{clusterName}/queries
	PostClusterQuery(ctx context.Context, request *ClusterCriterion, params PostClusterQueryParams) (PostClusterQueryRes, error)
	// PostClustersQuery invokes postClustersQuery operation.
	//
	// Post clusters query.
	//
	// POST /v1/domains/{domainId}/clusters/queries
	PostClustersQuery(ctx context.Context, request *ClusterCriterion, params PostClustersQueryParams) (PostClustersQueryRes, error)
	// PostDatastoreQuery invokes postDatastoreQuery operation.
	//
	// Post a datastore query.
	//
	// POST /v1/domains/{domainId}/datastores/queries
	PostDatastoreQuery(ctx context.Context, request *DatastoreCriterion, params PostDatastoreQueryParams) (PostDatastoreQueryRes, error)
	// PostDatastoreQuery1 invokes postDatastoreQuery_1 operation.
	//
	// Post a datastore query.
	//
	// POST /v1/clusters/{id}/datastores/queries
	PostDatastoreQuery1(ctx context.Context, request *DatastoreCriterion, params PostDatastoreQuery1Params) (PostDatastoreQuery1Res, error)
	// PostHostQuery invokes postHostQuery operation.
	//
	// Post a host query.
	//
	// POST /v1/clusters/{id}/hosts/queries
	PostHostQuery(ctx context.Context, request *HostCriterion, params PostHostQueryParams) (PostHostQueryRes, error)
	// PostHostsPrechecks1 invokes postHostsPrechecks_1 operation.
	//
	// Post host(s) prechecks.
	//
	// POST /v1/hosts/prechecks
	PostHostsPrechecks1(ctx context.Context, request PostHostsPrechecks1Req) (PostHostsPrechecks1Res, error)
	// PostQuery invokes postQuery operation.
	//
	// Post a query.
	//
	// POST /v1/hosts/queries
	PostQuery(ctx context.Context, request *HostCriterion) (PostQueryRes, error)
	// QueryCheckSets invokes queryCheckSets operation.
	//
	// Query for check-sets for the given resources.
	//
	// POST /v1/system/check-sets/queries
	QueryCheckSets(ctx context.Context, request *CheckSetQueryInput) (QueryCheckSetsRes, error)
	// ReconcileConfigs invokes reconcileConfigs operation.
	//
	// For selective reconciliation, provide a config spec.
	//
	// POST /v1/config-drift-reconciliations
	ReconcileConfigs(ctx context.Context, request *ConfigDriftApplySpec) (ReconcileConfigsRes, error)
	// RefreshAccessToken invokes refreshAccessToken operation.
	//
	// Refresh the access token associated with the given refresh token.
	//
	// PATCH /v1/tokens/access-token/refresh
	RefreshAccessToken(ctx context.Context, request string) (RefreshAccessTokenRes, error)
	// RemoveCertificateAuthority invokes removeCertificateAuthority operation.
	//
	// Deletes CA configuration file.
	//
	// DELETE /v1/certificate-authorities/{id}
	RemoveCertificateAuthority(ctx context.Context, params RemoveCertificateAuthorityParams) (RemoveCertificateAuthorityRes, error)
	// RemoveDatastoreFromCluster invokes removeDatastoreFromCluster operation.
	//
	// Unmount a datastore from a cluster.
	//
	// DELETE /v1/clusters/{id}/datastores/{datastoreId}
	RemoveDatastoreFromCluster(ctx context.Context, params RemoveDatastoreFromClusterParams) (RemoveDatastoreFromClusterRes, error)
	// RemoveLicenseKey invokes removeLicenseKey operation.
	//
	// Remove a license key.
	//
	// DELETE /v1/license-keys/{key}
	RemoveLicenseKey(ctx context.Context, params RemoveLicenseKeyParams) (RemoveLicenseKeyRes, error)
	// RemoveTagsFromCluster invokes removeTagsFromCluster operation.
	//
	// Remove tags from a cluster.
	//
	// DELETE /v1/clusters/{id}/tags
	RemoveTagsFromCluster(ctx context.Context, request *TagsSpec, params RemoveTagsFromClusterParams) (RemoveTagsFromClusterRes, error)
	// RemoveTagsFromDomain invokes removeTagsFromDomain operation.
	//
	// Remove Tags From Domain.
	//
	// DELETE /v1/domains/{id}/tags
	RemoveTagsFromDomain(ctx context.Context, request *TagsSpec, params RemoveTagsFromDomainParams) (RemoveTagsFromDomainRes, error)
	// RemoveTagsFromHost invokes removeTagsFromHost operation.
	//
	// Remove Tags From Host.
	//
	// DELETE /v1/hosts/{id}/tags
	RemoveTagsFromHost(ctx context.Context, request *TagsSpec, params RemoveTagsFromHostParams) (RemoveTagsFromHostRes, error)
	// RemoveUser invokes removeUser operation.
	//
	// Delete the user by the ID, if it exists.
	//
	// DELETE /v1/users/{id}
	RemoveUser(ctx context.Context, params RemoveUserParams) (RemoveUserRes, error)
	// RemoveVasaProvider invokes removeVasaProvider operation.
	//
	// Delete a VASA Provider.
	//
	// DELETE /v1/vasa-providers/{id}
	RemoveVasaProvider(ctx context.Context, params RemoveVasaProviderParams) (RemoveVasaProviderRes, error)
	// RemoveVasaProviderStorageContainer invokes removeVasaProviderStorageContainer operation.
	//
	// Delete a storage container of a VASA Provider.
	//
	// DELETE /v1/vasa-providers/{id}/storage-containers/{storageContainerId}
	RemoveVasaProviderStorageContainer(ctx context.Context, params RemoveVasaProviderStorageContainerParams) (RemoveVasaProviderStorageContainerRes, error)
	// RenameCustomIsoById invokes renameCustomIsoById operation.
	//
	// Rename the Custom ISO corresponding to the ID.
	//
	// PATCH /v1/custom-isos/{custom_iso_id}
	RenameCustomIsoById(ctx context.Context, request *CustomIsoRenameSpec, params RenameCustomIsoByIdParams) (RenameCustomIsoByIdRes, error)
	// RenamePersonalityById invokes renamePersonalityById operation.
	//
	// Rename personality with the ID passed in the URL.
	//
	// PATCH /v1/personalities/{personalityId}
	RenamePersonalityById(ctx context.Context, request *Personality, params RenamePersonalityByIdParams) (RenamePersonalityByIdRes, error)
	// ReplaceCertificates invokes replaceCertificates operation.
	//
	// Replace certificate(s) for the selected resource(s) in a domain.
	//
	// PATCH /v1/domains/{id}/certificates
	ReplaceCertificates(ctx context.Context, request *CertificateOperationSpec, params ReplaceCertificatesParams) (ReplaceCertificatesRes, error)
	// ReplaceResourceCertificates invokes replaceResourceCertificates operation.
	//
	// Replace resource certificates.
	//
	// PUT /v1/domains/{id}/resource-certificates
	ReplaceResourceCertificates(ctx context.Context, request []ResourceCertificateSpec, params ReplaceResourceCertificatesParams) (ReplaceResourceCertificatesRes, error)
	// RetryComplianceAuditTask invokes retryComplianceAuditTask operation.
	//
	// Retry compliance audit task.
	//
	// PATCH /v1/domains/{id}/compliance-audits/tasks/{taskId}
	RetryComplianceAuditTask(ctx context.Context, params RetryComplianceAuditTaskParams) (RetryComplianceAuditTaskRes, error)
	// RetryCredentialsTask invokes retryCredentialsTask operation.
	//
	// Retry a failed credentials task for a given ID.
	//
	// PATCH /v1/credentials/tasks/{id}
	RetryCredentialsTask(ctx context.Context, request *CredentialsUpdateSpec, params RetryCredentialsTaskParams) (RetryCredentialsTaskRes, error)
	// RetrySddc invokes retrySddc operation.
	//
	// Retry failed SDDC creation.
	//
	// PATCH /v1/sddcs/{id}
	RetrySddc(ctx context.Context, request OptSddcSpec, params RetrySddcParams) (RetrySddcRes, error)
	// RetryTask invokes retryTask operation.
	//
	// Retry a failed Task by ID, if it exists.
	//
	// PATCH /v1/tasks/{id}
	RetryTask(ctx context.Context, params RetryTaskParams) (RetryTaskRes, error)
	// RollbackVrslcm invokes rollbackVrslcm operation.
	//
	// Triggers the VMware Aria Suite Lifecycle rollback operation and returns an URL in the headers to
	// track the operation status.
	//
	// DELETE /v1/vrslcm
	RollbackVrslcm(ctx context.Context) (RollbackVrslcmRes, error)
	// SetBackupConfiguration invokes setBackupConfiguration operation.
	//
	// Configure the backup configuration for SDDC Manager and NSX Manager.
	//
	// PUT /v1/system/backup-configuration
	SetBackupConfiguration(ctx context.Context, request *BackupConfigurationSpec) (SetBackupConfigurationRes, error)
	// SetCeipStatus invokes setCeipStatus operation.
	//
	// Opt-in or Opt-out of CEIP.
	//
	// PATCH /v1/system/ceip
	SetCeipStatus(ctx context.Context, request SetCeipStatusReq) (SetCeipStatusRes, error)
	// SetLicenseKeyForResource invokes setLicenseKeyForResource operation.
	//
	// Update a license key for a resource.
	//
	// PUT /v1/resources/licensing-infos
	SetLicenseKeyForResource(ctx context.Context, request *LicensingSpec) (SetLicenseKeyForResourceRes, error)
	// StartBackup invokes startBackup operation.
	//
	// Start a backup operation.
	//
	// POST /v1/backups/tasks
	StartBackup(ctx context.Context, request *BackupSpec) (StartBackupRes, error)
	// StartBringup invokes startBringup operation.
	//
	// Deploy a management domain.
	//
	// POST /v1/sddcs
	StartBringup(ctx context.Context, request *SddcSpec) (StartBringupRes, error)
	// StartBringupSpecConversion invokes startBringupSpecConversion operation.
	//
	// SDDC specification incorporates all the client inputs regarding VMW component parameters
	// constituting the SDDC: NTP, DNS spec, ESXi, VC, VSAN, NSX spec et al.
	//
	// POST /v1/system/sddc-spec-converter
	StartBringupSpecConversion(ctx context.Context, request OptStartBringupSpecConversionReq, params StartBringupSpecConversionParams) (StartBringupSpecConversionRes, error)
	// StartBundleDownloadByID invokes startBundleDownloadByID operation.
	//
	// Update a Bundle for scheduling/triggering download. Only one download can triggered for a Bundle.
	//
	// PATCH /v1/bundles/{id}
	StartBundleDownloadByID(ctx context.Context, request *BundleUpdateSpec, params StartBundleDownloadByIDParams) (StartBundleDownloadByIDRes, error)
	// StartHealthCheck invokes startHealthCheck operation.
	//
	// Start a Health Check operation using SoS.
	//
	// POST /v1/system/health-summary
	StartHealthCheck(ctx context.Context, request *HealthSummarySpec) (StartHealthCheckRes, error)
	// StartNsxCriteriaQuery invokes startNsxCriteriaQuery operation.
	//
	// Start a query with NSX Criteria.
	//
	// POST /v1/nsxt-clusters/queries
	StartNsxCriteriaQuery(ctx context.Context, request *NsxTCriterion) (StartNsxCriteriaQueryRes, error)
	// StartPrecheck invokes startPrecheck operation.
	//
	// Perform precheck of resource(ex: Domain, Cluster). If only resource is specified, all
	// resources/software components under it are included. If resource(Domain, Cluster etc) and specific
	// resources/software components are provided, only those are included in precheck. As this API is
	// deprecated, please use the new LCM Prechecks API - /v1/system/check-sets/queries and
	// /v1/system/check-sets.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /v1/system/prechecks
	StartPrecheck(ctx context.Context, request *PrecheckSpec) (StartPrecheckRes, error)
	// StartRestore invokes startRestore operation.
	//
	// Start a restore operation.
	//
	// POST /v1/restores/tasks
	StartRestore(ctx context.Context, request *RestoreSpec) (StartRestoreRes, error)
	// StartSupportBundle invokes startSupportBundle operation.
	//
	// Start a Support Bundle operation using SoS.
	//
	// POST /v1/system/support-bundles
	StartSupportBundle(ctx context.Context, request *SupportBundleSpec) (StartSupportBundleRes, error)
	// StartUpgradePrecheck invokes startUpgradePrecheck operation.
	//
	// Perform Upgrade Prechecks.
	//
	// POST /v1/upgrades/{upgradeId}/prechecks
	StartUpgradePrecheck(ctx context.Context, params StartUpgradePrecheckParams) (StartUpgradePrecheckRes, error)
	// TriggerCheckRun invokes triggerCheckRun operation.
	//
	// Trigger a run of the selected checks.
	//
	// POST /v1/system/check-sets
	TriggerCheckRun(ctx context.Context, request *CheckSetRunInput) (TriggerCheckRunRes, error)
	// TriggerPartialRetryOfCheckRun invokes triggerPartialRetryOfCheckRun operation.
	//
	// Trigger partial retry of a completed check run.
	//
	// PATCH /v1/system/check-sets/{runId}
	TriggerPartialRetryOfCheckRun(ctx context.Context, request *AssessmentPartialRetryInput, params TriggerPartialRetryOfCheckRunParams) (TriggerPartialRetryOfCheckRunRes, error)
	// UpdateBackupConfiguration invokes updateBackupConfiguration operation.
	//
	// Update the backup configuration for SDDC Manager and NSX Manager.
	//
	// PATCH /v1/system/backup-configuration
	UpdateBackupConfiguration(ctx context.Context, request *BackupConfigurationSpec) (UpdateBackupConfigurationRes, error)
	// UpdateBundleCompatibilitySets invokes updateBundleCompatibilitySets operation.
	//
	// Update software compatibility sets for Bundles.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PATCH /v1/bundles/
	UpdateBundleCompatibilitySets(ctx context.Context, request *BundleUpdateSpec) (UpdateBundleCompatibilitySetsRes, error)
	// UpdateCluster invokes updateCluster operation.
	//
	// Update a Cluster by adding or removing Hosts, Stretching a standard vSAN cluster, Unstretching a
	// stretched cluster or by marking for deletion.
	//
	// PATCH /v1/clusters/{id}
	UpdateCluster(ctx context.Context, request *ClusterUpdateSpec, params UpdateClusterParams) (UpdateClusterRes, error)
	// UpdateDepotSettings invokes updateDepotSettings operation.
	//
	// Update depot settings. Depot settings can be updated with VMware Depot account.
	//
	// PUT /v1/system/settings/depot
	UpdateDepotSettings(ctx context.Context, request *DepotSettings) (UpdateDepotSettingsRes, error)
	// UpdateDomain invokes updateDomain operation.
	//
	// Update a Domain.
	//
	// PATCH /v1/domains/{id}
	UpdateDomain(ctx context.Context, request *DomainUpdateSpec, params UpdateDomainParams) (UpdateDomainRes, error)
	// UpdateEdgeCluster invokes updateEdgeCluster operation.
	//
	// Expand or shrink an NSX Edge Cluster.
	//
	// PATCH /v1/edge-clusters/{id}
	UpdateEdgeCluster(ctx context.Context, request *EdgeClusterUpdateSpec, params UpdateEdgeClusterParams) (UpdateEdgeClusterRes, error)
	// UpdateLicenseKey invokes updateLicenseKey operation.
	//
	// Update the license key.
	//
	// PATCH /v1/license-keys/{key}
	UpdateLicenseKey(ctx context.Context, request *LicenseKeyUpdateSpec, params UpdateLicenseKeyParams) (UpdateLicenseKeyRes, error)
	// UpdateLocalUserPassword invokes updateLocalUserPassword operation.
	//
	// Update the password for local account only if the old password is correct, or if user configures
	// the local account for the first time.
	//
	// PATCH /v1/users/local/admin
	UpdateLocalUserPassword(ctx context.Context, request *LocalAccountPasswordInfo) (UpdateLocalUserPasswordRes, error)
	// UpdateNetworkPool invokes updateNetworkPool operation.
	//
	// Update a Network Pool by ID, if it exists.
	//
	// PATCH /v1/network-pools/{id}
	UpdateNetworkPool(ctx context.Context, request *NetworkPoolUpdateSpec, params UpdateNetworkPoolParams) (UpdateNetworkPoolRes, error)
	// UpdateOrRotatePasswords invokes updateOrRotatePasswords operation.
	//
	// Update passwords for given list of resources by supplying new passwords or rotate the passwords
	// using system generated passwords.
	//
	// PATCH /v1/credentials
	UpdateOrRotatePasswords(ctx context.Context, request *CredentialsUpdateSpec) (UpdateOrRotatePasswordsRes, error)
	// UpdateReleaseByDomainID invokes updateReleaseByDomainID operation.
	//
	// Update last selected upgrade version for the domain.
	//
	// PATCH /v1/releases/domains/{domainId}
	UpdateReleaseByDomainID(ctx context.Context, request OptDomainRelease, params UpdateReleaseByDomainIDParams) (UpdateReleaseByDomainIDRes, error)
	// UpdateResourcesFunctionalities invokes updateResourcesFunctionalities operation.
	//
	// Update Resources Functionalities.
	//
	// PATCH /v1/resource-functionalities
	UpdateResourcesFunctionalities(ctx context.Context, request *ResourceFunctionalitiesUpdateSpec) (UpdateResourcesFunctionalitiesRes, error)
	// UpdateResourcesFunctionalities1 invokes updateResourcesFunctionalities_1 operation.
	//
	// Update Resources Functionalities Is Allowed Global Configuration.
	//
	// PATCH /v1/resource-functionalities/global
	UpdateResourcesFunctionalities1(ctx context.Context, request *ResourceFunctionalitiesGlobalUpdateSpec) (UpdateResourcesFunctionalities1Res, error)
	// UpdateSystemConfiguration invokes updateSystemConfiguration operation.
	//
	// Updates paramters of the system configuration.
	//
	// PATCH /v1/system
	UpdateSystemConfiguration(ctx context.Context, request *SystemUpdateSpec) (UpdateSystemConfigurationRes, error)
	// UpdateUpgradeSchedule invokes updateUpgradeSchedule operation.
	//
	// Commit/Reschedule an existing upgrade. It moves the upgrade from DRAFT state to SCHEDULED state
	// and/or changes the upgrade scheduled date/time.
	//
	// PATCH /v1/upgrades/{upgradeId}
	UpdateUpgradeSchedule(ctx context.Context, request *UpgradeCommitSpec, params UpdateUpgradeScheduleParams) (UpdateUpgradeScheduleRes, error)
	// UpdateVasaProvider invokes updateVasaProvider operation.
	//
	// Update a VASA Provider.
	//
	// PATCH /v1/vasa-providers/{id}
	UpdateVasaProvider(ctx context.Context, request *VasaProviderUpdateSpec, params UpdateVasaProviderParams) (UpdateVasaProviderRes, error)
	// UpdateVasaProviderStorageContainer invokes updateVasaProviderStorageContainer operation.
	//
	// Update the storage container of a VASA Provider.
	//
	// PATCH /v1/vasa-providers/{id}/storage-containers/{storageContainerId}
	UpdateVasaProviderStorageContainer(ctx context.Context, request *StorageContainerUpdateSpec, params UpdateVasaProviderStorageContainerParams) (UpdateVasaProviderStorageContainerRes, error)
	// UpdateVasaProviderUser invokes updateVasaProviderUser operation.
	//
	// Update the user of a VASA Provider.
	//
	// PATCH /v1/vasa-providers/{id}/users/{userId}
	UpdateVasaProviderUser(ctx context.Context, request *VasaUserUpdateSpec, params UpdateVasaProviderUserParams) (UpdateVasaProviderUserRes, error)
	// UpdateVersionAliasConfiguration invokes updateVersionAliasConfiguration operation.
	//
	// Update Version Alias Configuration.
	//
	// PUT /v1/system/settings/version-aliases/{bundleComponentType}/{version}
	UpdateVersionAliasConfiguration(ctx context.Context, request *AliasSpec, params UpdateVersionAliasConfigurationParams) (UpdateVersionAliasConfigurationRes, error)
	// UpdateVersionAliasConfigurations invokes updateVersionAliasConfigurations operation.
	//
	// Update Version Alias Configurations.
	//
	// PUT /v1/system/settings/version-aliases
	UpdateVersionAliasConfigurations(ctx context.Context, request *VersionAliasesForBundleComponentTypeSpec) (UpdateVersionAliasConfigurationsRes, error)
	// UpdateVrslcmVersionByIdInInventory invokes updateVrslcmVersionByIdInInventory operation.
	//
	// Updates VMware Aria Suite Lifecycle version.
	//
	// PUT /v1/vrslcms/{id}
	UpdateVrslcmVersionByIdInInventory(ctx context.Context, request *Vrslcm, params UpdateVrslcmVersionByIdInInventoryParams) (UpdateVrslcmVersionByIdInInventoryRes, error)
	// UpdateVrslcmVersionInInventory invokes updateVrslcmVersionInInventory operation.
	//
	// Updates VMware Aria Suite Lifecycle version in VCF inventory.
	//
	// PUT /v1/vrslcm
	UpdateVrslcmVersionInInventory(ctx context.Context, request *Vrslcm) (UpdateVrslcmVersionInInventoryRes, error)
	// UpdateVsanHclConfiguration invokes updateVsanHclConfiguration operation.
	//
	// Update vSAN HCL configuration.
	//
	// PATCH /v1/vsan-hcl/configuration
	UpdateVsanHclConfiguration(ctx context.Context, request *VsanHclConfiguration) (UpdateVsanHclConfigurationRes, error)
	// UpdateVsanHealthCheckByDomain invokes updateVsanHealthCheckByDomain operation.
	//
	// Update vSAN health check status for domain.
	//
	// PATCH /v1/domains/{domainId}/health-checks
	UpdateVsanHealthCheckByDomain(ctx context.Context, request []HealthCheckSpec, params UpdateVsanHealthCheckByDomainParams) (UpdateVsanHealthCheckByDomainRes, error)
	// UploadBundle invokes uploadBundle operation.
	//
	// Upload Bundle to SDDC Manager. Used when you do not have internet connectivity for downloading
	// bundles from VMWare/VxRail to SDDC Manager. The Bundles are manually downloaded from Depot using
	// Bundle Transfer utility.
	//
	// POST /v1/bundles
	UploadBundle(ctx context.Context, request *BundleUploadSpec) (UploadBundleRes, error)
	// UploadCertificates invokes uploadCertificates operation.
	//
	// Upload certificates to the certificate store.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PUT /v1/domains/{id}/certificates/uploads
	UploadCertificates(ctx context.Context, request OptUploadCertificatesReq, params UploadCertificatesParams) (UploadCertificatesRes, error)
	// UploadCustomIso invokes uploadCustomIso operation.
	//
	// Upload Custom ISO to SDDC Manager.
	//
	// POST /v1/custom-isos/file
	UploadCustomIso(ctx context.Context, request OptUploadCustomIsoReq, params UploadCustomIsoParams) (UploadCustomIsoRes, error)
	// UploadPersonality invokes uploadPersonality operation.
	//
	// Upload Personality to SDDC Manager.
	//
	// POST /v1/personalities
	UploadPersonality(ctx context.Context, request *PersonalityUploadSpec) (UploadPersonalityRes, error)
	// UploadPersonalityFiles invokes uploadPersonalityFiles operation.
	//
	// Upload personality files to SDDC Manager.
	//
	// PUT /v1/personalities/files
	UploadPersonalityFiles(ctx context.Context, request OptUploadPersonalityFilesReq) (UploadPersonalityFilesRes, error)
	// UploadProductVersionCatalog invokes uploadProductVersionCatalog operation.
	//
	// Upload product version catalog. Make sure product version is a valid one.
	//
	// POST /v1/product-version-catalog
	UploadProductVersionCatalog(ctx context.Context, request *ProductVersionCatalog) (UploadProductVersionCatalogRes, error)
	// ValidateALBClusterCreationSpec invokes validateALBClusterCreationSpec operation.
	//
	// Perform validiation of the NsxAlbControllerClusterSpec specification.
	//
	// POST /v1/nsx-alb-clusters/validations
	ValidateALBClusterCreationSpec(ctx context.Context, request *NsxAlbControllerClusterSpec, params ValidateALBClusterCreationSpecParams) (ValidateALBClusterCreationSpecRes, error)
	// ValidateAvnSpec invokes validateAvnSpec operation.
	//
	// Returns Validation report.
	//
	// POST /v1/avns/validations
	ValidateAvnSpec(ctx context.Context, request *AvnsCreationSpec) (ValidateAvnSpecRes, error)
	// ValidateBackupConfigurationsOperations invokes validateBackupConfigurationsOperations operation.
	//
	// Validation API for backup configuration for SDDC Manager and NSX Manager.
	//
	// POST /v1/system/backup-configuration/validations
	ValidateBackupConfigurationsOperations(ctx context.Context, request *BackupConfigurationSpec) (ValidateBackupConfigurationsOperationsRes, error)
	// ValidateBringupSpec invokes validateBringupSpec operation.
	//
	// SDDC specification incorporates all the client inputs regarding VMW component parameters
	// constituting the SDDC: NTP, DNS spec, ESXi, VC, VSAN, NSX spec et al.
	//
	// POST /v1/sddcs/validations
	ValidateBringupSpec(ctx context.Context, request *SddcSpec, params ValidateBringupSpecParams) (ValidateBringupSpecRes, error)
	// ValidateClusterCreationSpec invokes validateClusterCreationSpec operation.
	//
	// Perform validation of the ClusterCreationSpec specification.
	//
	// POST /v1/clusters/validations
	ValidateClusterCreationSpec(ctx context.Context, request *ClusterCreationSpec, params ValidateClusterCreationSpecParams) (ValidateClusterCreationSpecRes, error)
	// ValidateClusterUpdateSpec invokes validateClusterUpdateSpec operation.
	//
	// Perform validation of the ClusterUpdateSpec specification.
	//
	// POST /v1/clusters/{id}/validations
	ValidateClusterUpdateSpec(ctx context.Context, request *ClusterUpdateSpec, params ValidateClusterUpdateSpecParams) (ValidateClusterUpdateSpecRes, error)
	// ValidateCommissionHosts invokes validateCommissionHosts operation.
	//
	// Validate the input specification to commission the Hosts.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /v1/hosts/validations/commissions
	ValidateCommissionHosts(ctx context.Context, request []HostCommissionSpec) (ValidateCommissionHostsRes, error)
	// ValidateDnsConfiguration invokes validateDnsConfiguration operation.
	//
	// Perform validation of the DnsConfiguration specification.
	//
	// POST /v1/system/dns-configuration/validations
	ValidateDnsConfiguration(ctx context.Context, request *DnsConfiguration) (ValidateDnsConfigurationRes, error)
	// ValidateDomainCreationSpec invokes validateDomainCreationSpec operation.
	//
	// Perform validation of the DomainCreationSpec specification.
	//
	// POST /v1/domains/validations
	ValidateDomainCreationSpec(ctx context.Context, request *DomainCreationSpec, params ValidateDomainCreationSpecParams) (ValidateDomainCreationSpecRes, error)
	// ValidateDomainUpdateSpec invokes validateDomainUpdateSpec operation.
	//
	// Perform validation of the DomainUpdateSpec specification.
	//
	// POST /v1/domains/{id}/validations
	ValidateDomainUpdateSpec(ctx context.Context, request *DomainUpdateSpec, params ValidateDomainUpdateSpecParams) (ValidateDomainUpdateSpecRes, error)
	// ValidateEdgeClusterCreationSpec invokes validateEdgeClusterCreationSpec operation.
	//
	// Perform validiation of the EdgeClusterCreationSpec specification.
	//
	// POST /v1/edge-clusters/validations
	ValidateEdgeClusterCreationSpec(ctx context.Context, request *EdgeClusterCreationSpec) (ValidateEdgeClusterCreationSpecRes, error)
	// ValidateEdgeClusterUpdateSpec invokes validateEdgeClusterUpdateSpec operation.
	//
	// Perform validation of the EdgeClusterUpdateSpec specification.
	//
	// POST /v1/edge-clusters/{id}/validations
	ValidateEdgeClusterUpdateSpec(ctx context.Context, request *EdgeClusterUpdateSpec, params ValidateEdgeClusterUpdateSpecParams) (ValidateEdgeClusterUpdateSpecRes, error)
	// ValidateHostCommissionSpec invokes validateHostCommissionSpec operation.
	//
	// Perform validation of the  HostCommissionSpec specification.
	//
	// POST /v1/hosts/validations
	ValidateHostCommissionSpec(ctx context.Context, request []HostCommissionSpec) (ValidateHostCommissionSpecRes, error)
	// ValidateIpPool invokes validateIpPool operation.
	//
	// POST /v1/nsxt-clusters/ip-address-pools/validations
	ValidateIpPool(ctx context.Context, request *NsxtIpAddressPoolValidationSpec) (*Validation, error)
	// ValidateNsxALBCompatibility invokes validateNsxALBCompatibility operation.
	//
	// Validate NSX ALB compatibility version.
	//
	// POST /v1/nsx-alb-clusters/validations/version
	ValidateNsxALBCompatibility(ctx context.Context, request *NsxAlbVersionValidationSpec) (ValidateNsxALBCompatibilityRes, error)
	// ValidateNtpConfiguration invokes validateNtpConfiguration operation.
	//
	// Perform validation of the NtpConfiguration specification.
	//
	// POST /v1/system/ntp-configuration/validations
	ValidateNtpConfiguration(ctx context.Context, request *NtpConfiguration) (ValidateNtpConfigurationRes, error)
	// ValidateReleaseByDomainID invokes validateReleaseByDomainID operation.
	//
	// Validate the target selected upgrade release BOM or custom BOM for a domain by its ID.
	//
	// POST /v1/releases/domains/{domainId}/validations
	ValidateReleaseByDomainID(ctx context.Context, request *DomainRelease, params ValidateReleaseByDomainIDParams) (ValidateReleaseByDomainIDRes, error)
	// ValidateResourceCertificates invokes validateResourceCertificates operation.
	//
	// Validate resource certificates.
	//
	// PUT /v1/domains/{id}/resource-certificates/validations
	ValidateResourceCertificates(ctx context.Context, request []ResourceCertificateSpec, params ValidateResourceCertificatesParams) (ValidateResourceCertificatesRes, error)
	// ValidateVasaProviderSpec invokes validateVasaProviderSpec operation.
	//
	// Validate VasaProvider input specification.
	//
	// POST /v1/vasa-providers/validations
	ValidateVasaProviderSpec(ctx context.Context, request *VasaProvider) (ValidateVasaProviderSpecRes, error)
	// ValidateVrslcm invokes validateVrslcm operation.
	//
	// Triggers VMware Aria Suite Lifecycle deployment specification validation workflow.
	//
	// POST /v1/vrslcms/validations
	ValidateVrslcm(ctx context.Context, request *VrslcmDeploymentSpec) (ValidateVrslcmRes, error)
	// ValidateVsanRemoteDatastoreMountSpec invokes validateVsanRemoteDatastoreMountSpec operation.
	//
	// Perform validation of the DatastoreMountSpec specification.
	//
	// POST /v1/clusters/{clusterId}/datastores/validations
	ValidateVsanRemoteDatastoreMountSpec(ctx context.Context, request *DatastoreMountSpec, params ValidateVsanRemoteDatastoreMountSpecParams) (ValidateVsanRemoteDatastoreMountSpecRes, error)
	// ValidateVsanRemoteDatastoreSpec invokes validateVsanRemoteDatastoreSpec operation.
	//
	// Perform validation of the DatastoreMountSpec specification.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /v1/clusters/{clusterId}/datastores/validation
	ValidateVsanRemoteDatastoreSpec(ctx context.Context, request *DatastoreMountSpec, params ValidateVsanRemoteDatastoreSpecParams) (ValidateVsanRemoteDatastoreSpecRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddDatastoreToCluster invokes addDatastoreToCluster operation.
//
// Mount a datastore to a cluster.
//
// POST /v1/clusters/{id}/datastores
func (c *Client) AddDatastoreToCluster(ctx context.Context, request *DatastoreMountSpec, params AddDatastoreToClusterParams) (AddDatastoreToClusterRes, error) {
	res, err := c.sendAddDatastoreToCluster(ctx, request, params)
	return res, err
}

func (c *Client) sendAddDatastoreToCluster(ctx context.Context, request *DatastoreMountSpec, params AddDatastoreToClusterParams) (res AddDatastoreToClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddDatastoreToClusterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddDatastoreToClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddIpPoolToNetworkOfNetworkPool invokes addIpPoolToNetworkOfNetworkPool operation.
//
// Add an IP Pool to a Network of a Network Pool.
//
// POST /v1/network-pools/{id}/networks/{networkId}/ip-pools
func (c *Client) AddIpPoolToNetworkOfNetworkPool(ctx context.Context, request *IpPool, params AddIpPoolToNetworkOfNetworkPoolParams) (AddIpPoolToNetworkOfNetworkPoolRes, error) {
	res, err := c.sendAddIpPoolToNetworkOfNetworkPool(ctx, request, params)
	return res, err
}

func (c *Client) sendAddIpPoolToNetworkOfNetworkPool(ctx context.Context, request *IpPool, params AddIpPoolToNetworkOfNetworkPoolParams) (res AddIpPoolToNetworkOfNetworkPoolRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/network-pools/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/networks/"
	{
		// Encode "networkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "networkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NetworkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/ip-pools"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddIpPoolToNetworkOfNetworkPoolRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddIpPoolToNetworkOfNetworkPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddLicenseKey invokes addLicenseKey operation.
//
// Add a a new license key.
//
// POST /v1/license-keys
func (c *Client) AddLicenseKey(ctx context.Context, request *LicenseKey) (AddLicenseKeyRes, error) {
	res, err := c.sendAddLicenseKey(ctx, request)
	return res, err
}

func (c *Client) sendAddLicenseKey(ctx context.Context, request *LicenseKey) (res AddLicenseKeyRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/license-keys"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddLicenseKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddLicenseKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddUsers invokes addUsers operation.
//
// Add list of users.
//
// POST /v1/users
func (c *Client) AddUsers(ctx context.Context, request []User) (AddUsersRes, error) {
	res, err := c.sendAddUsers(ctx, request)
	return res, err
}

func (c *Client) sendAddUsers(ctx context.Context, request []User) (res AddUsersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddVasaProvider invokes addVasaProvider operation.
//
// Add a VASA Provider.
//
// POST /v1/vasa-providers
func (c *Client) AddVasaProvider(ctx context.Context, request *VasaProvider) (AddVasaProviderRes, error) {
	res, err := c.sendAddVasaProvider(ctx, request)
	return res, err
}

func (c *Client) sendAddVasaProvider(ctx context.Context, request *VasaProvider) (res AddVasaProviderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vasa-providers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddVasaProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddVasaProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddVasaProviderStorageContainer invokes addVasaProviderStorageContainer operation.
//
// Add the storage containers to a VASA Provider.
//
// POST /v1/vasa-providers/{id}/storage-containers
func (c *Client) AddVasaProviderStorageContainer(ctx context.Context, request []StorageContainer, params AddVasaProviderStorageContainerParams) (AddVasaProviderStorageContainerRes, error) {
	res, err := c.sendAddVasaProviderStorageContainer(ctx, request, params)
	return res, err
}

func (c *Client) sendAddVasaProviderStorageContainer(ctx context.Context, request []StorageContainer, params AddVasaProviderStorageContainerParams) (res AddVasaProviderStorageContainerRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/vasa-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/storage-containers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddVasaProviderStorageContainerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddVasaProviderStorageContainerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddVasaProviderUser invokes addVasaProviderUser operation.
//
// Add the users to a VASA Provider.
//
// POST /v1/vasa-providers/{id}/users
func (c *Client) AddVasaProviderUser(ctx context.Context, request []VasaUser, params AddVasaProviderUserParams) (AddVasaProviderUserRes, error) {
	res, err := c.sendAddVasaProviderUser(ctx, request, params)
	return res, err
}

func (c *Client) sendAddVasaProviderUser(ctx context.Context, request []VasaUser, params AddVasaProviderUserParams) (res AddVasaProviderUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/vasa-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddVasaProviderUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddVasaProviderUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignTagsToCluster invokes assignTagsToCluster operation.
//
// Assign Tags to Cluster.
//
// PUT /v1/clusters/{id}/tags
func (c *Client) AssignTagsToCluster(ctx context.Context, request *TagsSpec, params AssignTagsToClusterParams) (AssignTagsToClusterRes, error) {
	res, err := c.sendAssignTagsToCluster(ctx, request, params)
	return res, err
}

func (c *Client) sendAssignTagsToCluster(ctx context.Context, request *TagsSpec, params AssignTagsToClusterParams) (res AssignTagsToClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignTagsToClusterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAssignTagsToClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignTagsToDomain invokes assignTagsToDomain operation.
//
// Assign tags to a domain.
//
// PUT /v1/domains/{id}/tags
func (c *Client) AssignTagsToDomain(ctx context.Context, request *TagsSpec, params AssignTagsToDomainParams) (AssignTagsToDomainRes, error) {
	res, err := c.sendAssignTagsToDomain(ctx, request, params)
	return res, err
}

func (c *Client) sendAssignTagsToDomain(ctx context.Context, request *TagsSpec, params AssignTagsToDomainParams) (res AssignTagsToDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignTagsToDomainRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAssignTagsToDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignTagsToHost invokes assignTagsToHost operation.
//
// Assign tags to a host.
//
// PUT /v1/hosts/{id}/tags
func (c *Client) AssignTagsToHost(ctx context.Context, request *TagsSpec, params AssignTagsToHostParams) (AssignTagsToHostRes, error) {
	res, err := c.sendAssignTagsToHost(ctx, request, params)
	return res, err
}

func (c *Client) sendAssignTagsToHost(ctx context.Context, request *TagsSpec, params AssignTagsToHostParams) (res AssignTagsToHostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/hosts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignTagsToHostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAssignTagsToHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CancelCredentialsTask invokes cancelCredentialsTask operation.
//
// Cancel a failed credential task by its ID.
//
// DELETE /v1/credentials/tasks/{id}
func (c *Client) CancelCredentialsTask(ctx context.Context, params CancelCredentialsTaskParams) (CancelCredentialsTaskRes, error) {
	res, err := c.sendCancelCredentialsTask(ctx, params)
	return res, err
}

func (c *Client) sendCancelCredentialsTask(ctx context.Context, params CancelCredentialsTaskParams) (res CancelCredentialsTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/credentials/tasks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCancelCredentialsTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CancelTask invokes cancelTask operation.
//
// Cancel a Task by ID, if it exists.
//
// DELETE /v1/tasks/{id}
func (c *Client) CancelTask(ctx context.Context, params CancelTaskParams) (CancelTaskRes, error) {
	res, err := c.sendCancelTask(ctx, params)
	return res, err
}

func (c *Client) sendCancelTask(ctx context.Context, params CancelTaskParams) (res CancelTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/tasks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCancelTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CommissionHosts invokes commissionHosts operation.
//
// Commission the Hosts.
//
// POST /v1/hosts
func (c *Client) CommissionHosts(ctx context.Context, request []HostCommissionSpec) (CommissionHostsRes, error) {
	res, err := c.sendCommissionHosts(ctx, request)
	return res, err
}

func (c *Client) sendCommissionHosts(ctx context.Context, request []HostCommissionSpec) (res CommissionHostsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCommissionHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCommissionHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplianceAudit invokes complianceAudit operation.
//
// Compliance audit of resource.
//
// POST /v1/domains/{id}/compliance-audits
func (c *Client) ComplianceAudit(ctx context.Context, request *ComplianceAuditSpec, params ComplianceAuditParams) (ComplianceAuditRes, error) {
	res, err := c.sendComplianceAudit(ctx, request, params)
	return res, err
}

func (c *Client) sendComplianceAudit(ctx context.Context, request *ComplianceAuditSpec, params ComplianceAuditParams) (res ComplianceAuditRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/compliance-audits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeComplianceAuditRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeComplianceAuditResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigureCertificateAuthority invokes configureCertificateAuthority operation.
//
// Update the configuration of a Certificate Authority.
//
// PATCH /v1/certificate-authorities
func (c *Client) ConfigureCertificateAuthority(ctx context.Context, request *CertificateAuthorityCreationSpec) (ConfigureCertificateAuthorityRes, error) {
	res, err := c.sendConfigureCertificateAuthority(ctx, request)
	return res, err
}

func (c *Client) sendConfigureCertificateAuthority(ctx context.Context, request *CertificateAuthorityCreationSpec) (res ConfigureCertificateAuthorityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/certificate-authorities"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigureCertificateAuthorityRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigureCertificateAuthorityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigureDns invokes configureDns operation.
//
// Update the DNS configuration.
//
// PUT /v1/system/dns-configuration
func (c *Client) ConfigureDns(ctx context.Context, request *DnsConfiguration) (ConfigureDnsRes, error) {
	res, err := c.sendConfigureDns(ctx, request)
	return res, err
}

func (c *Client) sendConfigureDns(ctx context.Context, request *DnsConfiguration) (res ConfigureDnsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/dns-configuration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigureDnsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigureDnsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigureNtp invokes configureNtp operation.
//
// Update the NTP configuration.
//
// PUT /v1/system/ntp-configuration
func (c *Client) ConfigureNtp(ctx context.Context, request *NtpConfiguration) (ConfigureNtpRes, error) {
	res, err := c.sendConfigureNtp(ctx, request)
	return res, err
}

func (c *Client) sendConfigureNtp(ctx context.Context, request *NtpConfiguration) (res ConfigureNtpRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/ntp-configuration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigureNtpRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigureNtpResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConnectOpenId invokes connectOpenId operation.
//
// POST /v1/nsxt-clusters/oidcs
func (c *Client) ConnectOpenId(ctx context.Context, request *NsxtOidcSpec) error {
	_, err := c.sendConnectOpenId(ctx, request)
	return err
}

func (c *Client) sendConnectOpenId(ctx context.Context, request *NsxtOidcSpec) (res *ConnectOpenIdOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nsxt-clusters/oidcs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConnectOpenIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConnectOpenIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConnectVrliWithDomain invokes connectVrliWithDomain operation.
//
// Connect or disconnect a domain with VMware Aria Operations for Logs.
//
// PUT /v1/vrli/domains
func (c *Client) ConnectVrliWithDomain(ctx context.Context, request *DomainIntegration) (*Task, error) {
	res, err := c.sendConnectVrliWithDomain(ctx, request)
	return res, err
}

func (c *Client) sendConnectVrliWithDomain(ctx context.Context, request *DomainIntegration) (res *Task, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrli/domains"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConnectVrliWithDomainRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConnectVrliWithDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConnectVropsWithDomain invokes connectVropsWithDomain operation.
//
// Connects/disconnects a workload domains with VMware Aria Operations.
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /v1/vrops/domains
func (c *Client) ConnectVropsWithDomain(ctx context.Context, request *DomainIntegration) (ConnectVropsWithDomainRes, error) {
	res, err := c.sendConnectVropsWithDomain(ctx, request)
	return res, err
}

func (c *Client) sendConnectVropsWithDomain(ctx context.Context, request *DomainIntegration) (res ConnectVropsWithDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrops/domains"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConnectVropsWithDomainRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConnectVropsWithDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAvns invokes createAvns operation.
//
// Create Application Virtual Networks (AVN).
//
// POST /v1/avns
func (c *Client) CreateAvns(ctx context.Context, request *AvnsCreationSpec) (CreateAvnsRes, error) {
	res, err := c.sendCreateAvns(ctx, request)
	return res, err
}

func (c *Client) sendCreateAvns(ctx context.Context, request *AvnsCreationSpec) (res CreateAvnsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/avns"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAvnsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateAvnsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCertificateAuthority invokes createCertificateAuthority operation.
//
// Creates a certificate authority. This is required to generate signed certificates by supporting
// CAs.
//
// PUT /v1/certificate-authorities
func (c *Client) CreateCertificateAuthority(ctx context.Context, request *CertificateAuthorityCreationSpec) (CreateCertificateAuthorityRes, error) {
	res, err := c.sendCreateCertificateAuthority(ctx, request)
	return res, err
}

func (c *Client) sendCreateCertificateAuthority(ctx context.Context, request *CertificateAuthorityCreationSpec) (res CreateCertificateAuthorityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/certificate-authorities"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCertificateAuthorityRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateCertificateAuthorityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCluster invokes createCluster operation.
//
// Create a cluster and add to an existing domain.
//
// POST /v1/clusters
func (c *Client) CreateCluster(ctx context.Context, request *ClusterCreationSpec) (CreateClusterRes, error) {
	res, err := c.sendCreateCluster(ctx, request)
	return res, err
}

func (c *Client) sendCreateCluster(ctx context.Context, request *ClusterCreationSpec) (res CreateClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/clusters"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateClusterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDomain invokes createDomain operation.
//
// Create a domain.
//
// POST /v1/domains
func (c *Client) CreateDomain(ctx context.Context, request *DomainCreationSpec) (CreateDomainRes, error) {
	res, err := c.sendCreateDomain(ctx, request)
	return res, err
}

func (c *Client) sendCreateDomain(ctx context.Context, request *DomainCreationSpec) (res CreateDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/domains"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDomainRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEdgeCluster invokes createEdgeCluster operation.
//
// Create an NSX Edge Cluster.
//
// POST /v1/edge-clusters
func (c *Client) CreateEdgeCluster(ctx context.Context, request *EdgeClusterCreationSpec) (CreateEdgeClusterRes, error) {
	res, err := c.sendCreateEdgeCluster(ctx, request)
	return res, err
}

func (c *Client) sendCreateEdgeCluster(ctx context.Context, request *EdgeClusterCreationSpec) (res CreateEdgeClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/edge-clusters"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEdgeClusterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateEdgeClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateNetworkPool invokes createNetworkPool operation.
//
// Create a Network Pool.
//
// POST /v1/network-pools
func (c *Client) CreateNetworkPool(ctx context.Context, request *NetworkPool) (CreateNetworkPoolRes, error) {
	res, err := c.sendCreateNetworkPool(ctx, request)
	return res, err
}

func (c *Client) sendCreateNetworkPool(ctx context.Context, request *NetworkPool) (res CreateNetworkPoolRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/network-pools"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateNetworkPoolRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateNetworkPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateResourceWarning invokes createResourceWarning operation.
//
// Create a new Resource Warning.
//
// POST /v1/resource-warnings
func (c *Client) CreateResourceWarning(ctx context.Context, request *ResourceWarningCreationSpec) (CreateResourceWarningRes, error) {
	res, err := c.sendCreateResourceWarning(ctx, request)
	return res, err
}

func (c *Client) sendCreateResourceWarning(ctx context.Context, request *ResourceWarningCreationSpec) (res CreateResourceWarningRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/resource-warnings"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateResourceWarningRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateResourceWarningResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateToken invokes createToken operation.
//
// Creates access token and refresh token for user access.
//
// POST /v1/tokens
func (c *Client) CreateToken(ctx context.Context, request *TokenCreationSpec) (CreateTokenRes, error) {
	res, err := c.sendCreateToken(ctx, request)
	return res, err
}

func (c *Client) sendCreateToken(ctx context.Context, request *TokenCreationSpec) (res CreateTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DecommissionHosts invokes decommissionHosts operation.
//
// Decommission the Hosts.
//
// DELETE /v1/hosts
func (c *Client) DecommissionHosts(ctx context.Context, request []HostDecommissionSpec) (DecommissionHostsRes, error) {
	res, err := c.sendDecommissionHosts(ctx, request)
	return res, err
}

func (c *Client) sendDecommissionHosts(ctx context.Context, request []HostDecommissionSpec) (res DecommissionHostsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDecommissionHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDecommissionHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteALBCluster invokes deleteALBCluster operation.
//
// Deletes an NSX ALB Cluster by its ID.
//
// DELETE /v1/nsx-alb-clusters/{id}
func (c *Client) DeleteALBCluster(ctx context.Context, params DeleteALBClusterParams) (DeleteALBClusterRes, error) {
	res, err := c.sendDeleteALBCluster(ctx, params)
	return res, err
}

func (c *Client) sendDeleteALBCluster(ctx context.Context, params DeleteALBClusterParams) (res DeleteALBClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/nsx-alb-clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "forceDelete" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceDelete",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceDelete.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteALBClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAliasVersionsBySoftwareTypeAndBaseVersion invokes deleteAliasVersionsBySoftwareTypeAndBaseVersion operation.
//
// Delete Version Alias Configuration by bundle component type, version, and aliases.
//
// DELETE /v1/system/settings/version-aliases/{bundleComponentType}/{version}
func (c *Client) DeleteAliasVersionsBySoftwareTypeAndBaseVersion(ctx context.Context, request []string, params DeleteAliasVersionsBySoftwareTypeAndBaseVersionParams) (DeleteAliasVersionsBySoftwareTypeAndBaseVersionRes, error) {
	res, err := c.sendDeleteAliasVersionsBySoftwareTypeAndBaseVersion(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteAliasVersionsBySoftwareTypeAndBaseVersion(ctx context.Context, request []string, params DeleteAliasVersionsBySoftwareTypeAndBaseVersionParams) (res DeleteAliasVersionsBySoftwareTypeAndBaseVersionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/system/settings/version-aliases/"
	{
		// Encode "bundleComponentType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bundleComponentType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BundleComponentType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "version" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "version",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteAliasVersionsBySoftwareTypeAndBaseVersionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteAliasVersionsBySoftwareTypeAndBaseVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteBundle invokes deleteBundle operation.
//
// Delete a Bundle by bundle ID.
//
// DELETE /v1/bundles/{id}
func (c *Client) DeleteBundle(ctx context.Context, params DeleteBundleParams) (DeleteBundleRes, error) {
	res, err := c.sendDeleteBundle(ctx, params)
	return res, err
}

func (c *Client) sendDeleteBundle(ctx context.Context, params DeleteBundleParams) (res DeleteBundleRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/bundles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteBundleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCluster invokes deleteCluster operation.
//
// Delete a cluster from a domain if it has been previously initialized for deletion.
//
// DELETE /v1/clusters/{id}
func (c *Client) DeleteCluster(ctx context.Context, params DeleteClusterParams) (DeleteClusterRes, error) {
	res, err := c.sendDeleteCluster(ctx, params)
	return res, err
}

func (c *Client) sendDeleteCluster(ctx context.Context, params DeleteClusterParams) (res DeleteClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "force" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "force",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Force.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCustomIsoById invokes deleteCustomIsoById operation.
//
// Delete the Custom ISO based on ID.
//
// DELETE /v1/custom-isos/{custom_iso_id}
func (c *Client) DeleteCustomIsoById(ctx context.Context, params DeleteCustomIsoByIdParams) (DeleteCustomIsoByIdRes, error) {
	res, err := c.sendDeleteCustomIsoById(ctx, params)
	return res, err
}

func (c *Client) sendDeleteCustomIsoById(ctx context.Context, params DeleteCustomIsoByIdParams) (res DeleteCustomIsoByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/custom-isos/"
	{
		// Encode "custom_iso_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "custom_iso_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CustomIsoID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteCustomIsoByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDepotSettings invokes deleteDepotSettings operation.
//
// Delete the depot configuration if such is present within VCF.
//
// DELETE /v1/system/settings/depot
func (c *Client) DeleteDepotSettings(ctx context.Context, params DeleteDepotSettingsParams) (DeleteDepotSettingsRes, error) {
	res, err := c.sendDeleteDepotSettings(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDepotSettings(ctx context.Context, params DeleteDepotSettingsParams) (res DeleteDepotSettingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/settings/depot"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "depotType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "depotType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DepotType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteDepotSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDomain invokes deleteDomain operation.
//
// Remove a domain if it has been previously initialized for deletion.
//
// DELETE /v1/domains/{id}
func (c *Client) DeleteDomain(ctx context.Context, params DeleteDomainParams) (DeleteDomainRes, error) {
	res, err := c.sendDeleteDomain(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDomain(ctx context.Context, params DeleteDomainParams) (res DeleteDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteIpPoolFromNetworkOfNetworkPool invokes deleteIpPoolFromNetworkOfNetworkPool operation.
//
// Delete an IP Pool from a Network of a Network Pool.
//
// DELETE /v1/network-pools/{id}/networks/{networkId}/ip-pools
func (c *Client) DeleteIpPoolFromNetworkOfNetworkPool(ctx context.Context, request *IpPool, params DeleteIpPoolFromNetworkOfNetworkPoolParams) (DeleteIpPoolFromNetworkOfNetworkPoolRes, error) {
	res, err := c.sendDeleteIpPoolFromNetworkOfNetworkPool(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteIpPoolFromNetworkOfNetworkPool(ctx context.Context, request *IpPool, params DeleteIpPoolFromNetworkOfNetworkPoolParams) (res DeleteIpPoolFromNetworkOfNetworkPoolRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/network-pools/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/networks/"
	{
		// Encode "networkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "networkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NetworkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/ip-pools"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteIpPoolFromNetworkOfNetworkPoolRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteIpPoolFromNetworkOfNetworkPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteNetworkPool invokes deleteNetworkPool operation.
//
// Delete the Network Pool by the ID, if it exists and is unused.
//
// DELETE /v1/network-pools/{id}
func (c *Client) DeleteNetworkPool(ctx context.Context, params DeleteNetworkPoolParams) (DeleteNetworkPoolRes, error) {
	res, err := c.sendDeleteNetworkPool(ctx, params)
	return res, err
}

func (c *Client) sendDeleteNetworkPool(ctx context.Context, params DeleteNetworkPoolParams) (res DeleteNetworkPoolRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/network-pools/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "force" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "force",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Force.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteNetworkPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePersonality invokes deletePersonality operation.
//
// Delete the personality based on either name or id.
//
// DELETE /v1/personalities
func (c *Client) DeletePersonality(ctx context.Context, params DeletePersonalityParams) (DeletePersonalityRes, error) {
	res, err := c.sendDeletePersonality(ctx, params)
	return res, err
}

func (c *Client) sendDeletePersonality(ctx context.Context, params DeletePersonalityParams) (res DeletePersonalityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/personalities"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "personalityId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "personalityId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PersonalityId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "personalityName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "personalityName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PersonalityName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeletePersonalityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteReleaseByDomainID invokes deleteReleaseByDomainID operation.
//
// Delete last selected upgrade version for the domain.
//
// DELETE /v1/releases/domains/{domainId}
func (c *Client) DeleteReleaseByDomainID(ctx context.Context, params DeleteReleaseByDomainIDParams) (DeleteReleaseByDomainIDRes, error) {
	res, err := c.sendDeleteReleaseByDomainID(ctx, params)
	return res, err
}

func (c *Client) sendDeleteReleaseByDomainID(ctx context.Context, params DeleteReleaseByDomainIDParams) (res DeleteReleaseByDomainIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/releases/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteReleaseByDomainIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTrustedCertificate invokes deleteTrustedCertificate operation.
//
// Delete a trusted certificate from the SDDC Manager.
//
// DELETE /v1/sddc-manager/trusted-certificates/{alias}
func (c *Client) DeleteTrustedCertificate(ctx context.Context, params DeleteTrustedCertificateParams) (DeleteTrustedCertificateRes, error) {
	res, err := c.sendDeleteTrustedCertificate(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTrustedCertificate(ctx context.Context, params DeleteTrustedCertificateParams) (res DeleteTrustedCertificateRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/sddc-manager/trusted-certificates/"
	{
		// Encode "alias" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alias",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Alias))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTrustedCertificateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVersionAliasBySoftwareType invokes deleteVersionAliasBySoftwareType operation.
//
// Removes Version Alias Configuration by component type.
//
// DELETE /v1/system/settings/version-aliases/{bundleComponentType}
func (c *Client) DeleteVersionAliasBySoftwareType(ctx context.Context, params DeleteVersionAliasBySoftwareTypeParams) (DeleteVersionAliasBySoftwareTypeRes, error) {
	res, err := c.sendDeleteVersionAliasBySoftwareType(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVersionAliasBySoftwareType(ctx context.Context, params DeleteVersionAliasBySoftwareTypeParams) (res DeleteVersionAliasBySoftwareTypeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/system/settings/version-aliases/"
	{
		// Encode "bundleComponentType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bundleComponentType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BundleComponentType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteVersionAliasBySoftwareTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeployVrslcm invokes deployVrslcm operation.
//
// Triggers the VMware Aria Suite Lifecycle deployment operation and returns an URL in the headers to
// track the operation status.
//
// POST /v1/vrslcms
func (c *Client) DeployVrslcm(ctx context.Context, request *VrslcmDeploymentSpec) (DeployVrslcmRes, error) {
	res, err := c.sendDeployVrslcm(ctx, request)
	return res, err
}

func (c *Client) sendDeployVrslcm(ctx context.Context, request *VrslcmDeploymentSpec) (res DeployVrslcmRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrslcms"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeployVrslcmRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeployVrslcmResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DisableLocalAccount invokes disableLocalAccount operation.
//
// Disable local account.
//
// DELETE /v1/users/local/admin
func (c *Client) DisableLocalAccount(ctx context.Context) (DisableLocalAccountRes, error) {
	res, err := c.sendDisableLocalAccount(ctx)
	return res, err
}

func (c *Client) sendDisableLocalAccount(ctx context.Context) (res DisableLocalAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/users/local/admin"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDisableLocalAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainCreateValidation invokes domainCreateValidation operation.
//
// Gets the status of given domain create validation workflow by given validation id.
//
// GET /v1/domains/validations/{id}
func (c *Client) DomainCreateValidation(ctx context.Context, params DomainCreateValidationParams) (DomainCreateValidationRes, error) {
	res, err := c.sendDomainCreateValidation(ctx, params)
	return res, err
}

func (c *Client) sendDomainCreateValidation(ctx context.Context, params DomainCreateValidationParams) (res DomainCreateValidationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/domains/validations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDomainCreateValidationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DownloadCSR invokes downloadCSR operation.
//
// Download available CSR(s) in tar.gz format.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /v1/domains/{id}/csrs/downloads
func (c *Client) DownloadCSR(ctx context.Context, params DownloadCSRParams) (DownloadCSRRes, error) {
	res, err := c.sendDownloadCSR(ctx, params)
	return res, err
}

func (c *Client) sendDownloadCSR(ctx context.Context, params DownloadCSRParams) (res DownloadCSRRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/csrs/downloads"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDownloadCSRResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DownloadVsanHcl invokes downloadVsanHcl operation.
//
// Download vSAN HCL if online connectivity is available. Timestamp of vSAN HCL on SDDC Manager is
// checked with what is available online before download. vSAN HCL is downloaded only if new data is
// available.
//
// PATCH /v1/vsan-hcl
func (c *Client) DownloadVsanHcl(ctx context.Context) (DownloadVsanHclRes, error) {
	res, err := c.sendDownloadVsanHcl(ctx)
	return res, err
}

func (c *Client) sendDownloadVsanHcl(ctx context.Context) (res DownloadVsanHclRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vsan-hcl"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDownloadVsanHclResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExportBringupDetailReport invokes exportBringupDetailReport operation.
//
// Returns the bringup report. Reports are generated in PDF and CSV formats.
//
// GET /v1/sddcs/{id}/detail-report
func (c *Client) ExportBringupDetailReport(ctx context.Context, params ExportBringupDetailReportParams) (ExportBringupDetailReportRes, error) {
	res, err := c.sendExportBringupDetailReport(ctx, params)
	return res, err
}

func (c *Client) sendExportBringupDetailReport(ctx context.Context, params ExportBringupDetailReportParams) (res ExportBringupDetailReportRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/sddcs/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/detail-report"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Format.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeExportBringupDetailReportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExportBringupValidationReport invokes exportBringupValidationReport operation.
//
// Returns the bringup report for a validation. Reports are generated in PDF format.
//
// GET /v1/sddcs/validations/{validationId}/report
func (c *Client) ExportBringupValidationReport(ctx context.Context, params ExportBringupValidationReportParams) (ExportBringupValidationReportRes, error) {
	res, err := c.sendExportBringupValidationReport(ctx, params)
	return res, err
}

func (c *Client) sendExportBringupValidationReport(ctx context.Context, params ExportBringupValidationReportParams) (res ExportBringupValidationReportRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/sddcs/validations/"
	{
		// Encode "validationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "validationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ValidationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/report"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "startTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "startTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartTime.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "curClientTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "curClientTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CurClientTime.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeExportBringupValidationReportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateCertificates invokes generateCertificates operation.
//
// Generate certificate(s) for the selected resource(s) in a domain. CA must be configured and CSR
// must be generated beforehand.
//
// PUT /v1/domains/{id}/certificates
func (c *Client) GenerateCertificates(ctx context.Context, request *CertificatesGenerationSpec, params GenerateCertificatesParams) (GenerateCertificatesRes, error) {
	res, err := c.sendGenerateCertificates(ctx, request, params)
	return res, err
}

func (c *Client) sendGenerateCertificates(ctx context.Context, request *CertificatesGenerationSpec, params GenerateCertificatesParams) (res GenerateCertificatesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/certificates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGenerateCertificatesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGenerateCertificatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateSyncClientToken invokes generateSyncClientToken operation.
//
// Generates a new sync client token.
//
// POST /v1/identity-providers/{id}/sync-client
func (c *Client) GenerateSyncClientToken(ctx context.Context, params GenerateSyncClientTokenParams) (GenerateSyncClientTokenRes, error) {
	res, err := c.sendGenerateSyncClientToken(ctx, params)
	return res, err
}

func (c *Client) sendGenerateSyncClientToken(ctx context.Context, params GenerateSyncClientTokenParams) (res GenerateSyncClientTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/identity-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/sync-client"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "syncClientTokenTTL" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "syncClientTokenTTL",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SyncClientTokenTTL.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGenerateSyncClientTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GeneratesCSRs invokes generatesCSRs operation.
//
// Generate CSR(s) for the selected resource(s) in the domain.
// *Warning:*
// _Avoid using wildcard certificates. Instead, use subdomain-specific certificates that are rotated
// often. A compromised wildcard certificate can lead to security repercussions_.
//
// PUT /v1/domains/{id}/csrs
func (c *Client) GeneratesCSRs(ctx context.Context, request *CsrsGenerationSpec, params GeneratesCSRsParams) (GeneratesCSRsRes, error) {
	res, err := c.sendGeneratesCSRs(ctx, request, params)
	return res, err
}

func (c *Client) sendGeneratesCSRs(ctx context.Context, request *CsrsGenerationSpec, params GeneratesCSRsParams) (res GeneratesCSRsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/csrs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGeneratesCSRsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGeneratesCSRsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetALBCluster invokes getALBCluster operation.
//
// Retrieve an NSX ALB Cluster by its ID.
//
// GET /v1/nsx-alb-clusters/{id}
func (c *Client) GetALBCluster(ctx context.Context, params GetALBClusterParams) (GetALBClusterRes, error) {
	res, err := c.sendGetALBCluster(ctx, params)
	return res, err
}

func (c *Client) sendGetALBCluster(ctx context.Context, params GetALBClusterParams) (res GetALBClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/nsx-alb-clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetALBClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetALBClusters invokes getALBClusters operation.
//
// Retrieve a list of NSX ALB Clusters.
//
// GET /v1/nsx-alb-clusters
func (c *Client) GetALBClusters(ctx context.Context, params GetALBClustersParams) (GetALBClustersRes, error) {
	res, err := c.sendGetALBClusters(ctx, params)
	return res, err
}

func (c *Client) sendGetALBClusters(ctx context.Context, params GetALBClustersParams) (res GetALBClustersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nsx-alb-clusters"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "domainId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DomainId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetALBClustersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetALBClustersFormFactors invokes getALBClustersFormFactors operation.
//
// Retrieve a list of NSX ALB Clusters Form Factors.
//
// GET /v1/nsx-alb-clusters/form-factors
func (c *Client) GetALBClustersFormFactors(ctx context.Context) (GetALBClustersFormFactorsRes, error) {
	res, err := c.sendGetALBClustersFormFactors(ctx)
	return res, err
}

func (c *Client) sendGetALBClustersFormFactors(ctx context.Context) (res GetALBClustersFormFactorsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nsx-alb-clusters/form-factors"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetALBClustersFormFactorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAssignableTagForHost invokes getAssignableTagForHost operation.
//
// Get tags assignable to a host.
//
// GET /v1/hosts/{id}/tags/assignable-tags
func (c *Client) GetAssignableTagForHost(ctx context.Context, params GetAssignableTagForHostParams) (GetAssignableTagForHostRes, error) {
	res, err := c.sendGetAssignableTagForHost(ctx, params)
	return res, err
}

func (c *Client) sendGetAssignableTagForHost(ctx context.Context, params GetAssignableTagForHostParams) (res GetAssignableTagForHostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/hosts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags/assignable-tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAssignableTagForHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAssignableTagsForDomain invokes getAssignableTagsForDomain operation.
//
// Get tags assignable to a domain.
//
// GET /v1/domains/{id}/tags/assignable-tags
func (c *Client) GetAssignableTagsForDomain(ctx context.Context, params GetAssignableTagsForDomainParams) (GetAssignableTagsForDomainRes, error) {
	res, err := c.sendGetAssignableTagsForDomain(ctx, params)
	return res, err
}

func (c *Client) sendGetAssignableTagsForDomain(ctx context.Context, params GetAssignableTagsForDomainParams) (res GetAssignableTagsForDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags/assignable-tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAssignableTagsForDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAvns invokes getAvns operation.
//
// Returns all matching AVNs.
//
// GET /v1/avns
func (c *Client) GetAvns(ctx context.Context, params GetAvnsParams) (GetAvnsRes, error) {
	res, err := c.sendGetAvns(ctx, params)
	return res, err
}

func (c *Client) sendGetAvns(ctx context.Context, params GetAvnsParams) (res GetAvnsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/avns"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "regionType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "regionType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RegionType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAvnsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBackupConfiguration invokes getBackupConfiguration operation.
//
// Retrieve the backup configuration for SDDC Manager and NSX Manager.
//
// GET /v1/system/backup-configuration
func (c *Client) GetBackupConfiguration(ctx context.Context) (GetBackupConfigurationRes, error) {
	res, err := c.sendGetBackupConfiguration(ctx)
	return res, err
}

func (c *Client) sendGetBackupConfiguration(ctx context.Context) (res GetBackupConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/backup-configuration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBackupConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBackupLocation invokes getBackupLocation operation.
//
// Retrieve the backup location details.
//
// GET /v1/system/backup-configuration/backup-locations
func (c *Client) GetBackupLocation(ctx context.Context, params GetBackupLocationParams) (GetBackupLocationRes, error) {
	res, err := c.sendGetBackupLocation(ctx, params)
	return res, err
}

func (c *Client) sendGetBackupLocation(ctx context.Context, params GetBackupLocationParams) (res GetBackupLocationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/backup-configuration/backup-locations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "serverIP" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "serverIP",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ServerIP))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "port" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "port",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Port))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBackupLocationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBringupAppInfo invokes getBringupAppInfo operation.
//
// GET Method to retrieve information about Bringup app.
//
// GET /v1/sddcs/about
func (c *Client) GetBringupAppInfo(ctx context.Context) (GetBringupAppInfoRes, error) {
	res, err := c.sendGetBringupAppInfo(ctx)
	return res, err
}

func (c *Client) sendGetBringupAppInfo(ctx context.Context) (res GetBringupAppInfoRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sddcs/about"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBringupAppInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBringupTaskByID invokes getBringupTaskByID operation.
//
// Get a bringup task by its id.
//
// GET /v1/sddcs/{id}
func (c *Client) GetBringupTaskByID(ctx context.Context, params GetBringupTaskByIDParams) (GetBringupTaskByIDRes, error) {
	res, err := c.sendGetBringupTaskByID(ctx, params)
	return res, err
}

func (c *Client) sendGetBringupTaskByID(ctx context.Context, params GetBringupTaskByIDParams) (res GetBringupTaskByIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/sddcs/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBringupTaskByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBringupTasks invokes getBringupTasks operation.
//
// Retrieve all bringup tasks.
//
// GET /v1/sddcs
func (c *Client) GetBringupTasks(ctx context.Context) (GetBringupTasksRes, error) {
	res, err := c.sendGetBringupTasks(ctx)
	return res, err
}

func (c *Client) sendGetBringupTasks(ctx context.Context) (res GetBringupTasksRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sddcs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBringupTasksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBringupValidation invokes getBringupValidation operation.
//
// Retrieve the results of a bringup validation by its ID.
//
// GET /v1/sddcs/validations/{id}
func (c *Client) GetBringupValidation(ctx context.Context, params GetBringupValidationParams) (GetBringupValidationRes, error) {
	res, err := c.sendGetBringupValidation(ctx, params)
	return res, err
}

func (c *Client) sendGetBringupValidation(ctx context.Context, params GetBringupValidationParams) (res GetBringupValidationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/sddcs/validations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBringupValidationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBringupValidations invokes getBringupValidations operation.
//
// Retrieve a list of bringup validations.
//
// GET /v1/sddcs/validations
func (c *Client) GetBringupValidations(ctx context.Context) (GetBringupValidationsRes, error) {
	res, err := c.sendGetBringupValidations(ctx)
	return res, err
}

func (c *Client) sendGetBringupValidations(ctx context.Context) (res GetBringupValidationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sddcs/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBringupValidationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBundle invokes getBundle operation.
//
// Get a Bundle.
//
// GET /v1/bundles/{id}
func (c *Client) GetBundle(ctx context.Context, params GetBundleParams) (GetBundleRes, error) {
	res, err := c.sendGetBundle(ctx, params)
	return res, err
}

func (c *Client) sendGetBundle(ctx context.Context, params GetBundleParams) (res GetBundleRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/bundles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBundleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBundles invokes getBundles operation.
//
// Get all Bundles i.e uploaded bundles and also bundles available via depot access.
//
// GET /v1/bundles
func (c *Client) GetBundles(ctx context.Context, params GetBundlesParams) (GetBundlesRes, error) {
	res, err := c.sendGetBundles(ctx, params)
	return res, err
}

func (c *Client) sendGetBundles(ctx context.Context, params GetBundlesParams) (res GetBundlesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/bundles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "productType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "productType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProductType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "isCompliant" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "isCompliant",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsCompliant.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "bundleType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "bundleType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BundleType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBundlesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBundlesForSkipUpgrade invokes getBundlesForSkipUpgrade operation.
//
// Get bundles for skip upgrade a domain from current version to target version.
//
// GET /v1/bundles/domains/{id}
func (c *Client) GetBundlesForSkipUpgrade(ctx context.Context, params GetBundlesForSkipUpgradeParams) (GetBundlesForSkipUpgradeRes, error) {
	res, err := c.sendGetBundlesForSkipUpgrade(ctx, params)
	return res, err
}

func (c *Client) sendGetBundlesForSkipUpgrade(ctx context.Context, params GetBundlesForSkipUpgradeParams) (res GetBundlesForSkipUpgradeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/bundles/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "targetVersion" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "targetVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TargetVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBundlesForSkipUpgradeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCSRs invokes getCSRs operation.
//
// Get available CSR(s) in json format.
//
// GET /v1/domains/{id}/csrs
func (c *Client) GetCSRs(ctx context.Context, params GetCSRsParams) (GetCSRsRes, error) {
	res, err := c.sendGetCSRs(ctx, params)
	return res, err
}

func (c *Client) sendGetCSRs(ctx context.Context, params GetCSRsParams) (res GetCSRsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/csrs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCSRsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCeipStatus invokes getCeipStatus operation.
//
// Get CEIP status and instance id.
//
// GET /v1/system/ceip
func (c *Client) GetCeipStatus(ctx context.Context) (GetCeipStatusRes, error) {
	res, err := c.sendGetCeipStatus(ctx)
	return res, err
}

func (c *Client) sendGetCeipStatus(ctx context.Context) (res GetCeipStatusRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/ceip"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCeipStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCertificateAuthorities invokes getCertificateAuthorities operation.
//
// Get certificate authorities information.
//
// GET /v1/certificate-authorities
func (c *Client) GetCertificateAuthorities(ctx context.Context) (GetCertificateAuthoritiesRes, error) {
	res, err := c.sendGetCertificateAuthorities(ctx)
	return res, err
}

func (c *Client) sendGetCertificateAuthorities(ctx context.Context) (res GetCertificateAuthoritiesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/certificate-authorities"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCertificateAuthoritiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCertificateAuthorityById invokes getCertificateAuthorityById operation.
//
// Get certificate authority information.
//
// GET /v1/certificate-authorities/{id}
func (c *Client) GetCertificateAuthorityById(ctx context.Context, params GetCertificateAuthorityByIdParams) (GetCertificateAuthorityByIdRes, error) {
	res, err := c.sendGetCertificateAuthorityById(ctx, params)
	return res, err
}

func (c *Client) sendGetCertificateAuthorityById(ctx context.Context, params GetCertificateAuthorityByIdParams) (res GetCertificateAuthorityByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/certificate-authorities/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCertificateAuthorityByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCertificatesByDomain invokes getCertificatesByDomain operation.
//
// View detailed metadata about the certificate(s) of all the resources in a domain.
//
// GET /v1/domains/{id}/resource-certificates
func (c *Client) GetCertificatesByDomain(ctx context.Context, params GetCertificatesByDomainParams) (GetCertificatesByDomainRes, error) {
	res, err := c.sendGetCertificatesByDomain(ctx, params)
	return res, err
}

func (c *Client) sendGetCertificatesByDomain(ctx context.Context, params GetCertificatesByDomainParams) (res GetCertificatesByDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/resource-certificates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCertificatesByDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCluster invokes getCluster operation.
//
// Get a cluster by its ID.
//
// GET /v1/clusters/{id}
func (c *Client) GetCluster(ctx context.Context, params GetClusterParams) (GetClusterRes, error) {
	res, err := c.sendGetCluster(ctx, params)
	return res, err
}

func (c *Client) sendGetCluster(ctx context.Context, params GetClusterParams) (res GetClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClusterCreateValidation invokes getClusterCreateValidation operation.
//
// Gets the status of given cluster create validation workflow by given validation id.
//
// GET /v1/clusters/validations/{id}
func (c *Client) GetClusterCreateValidation(ctx context.Context, params GetClusterCreateValidationParams) (GetClusterCreateValidationRes, error) {
	res, err := c.sendGetClusterCreateValidation(ctx, params)
	return res, err
}

func (c *Client) sendGetClusterCreateValidation(ctx context.Context, params GetClusterCreateValidationParams) (res GetClusterCreateValidationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/clusters/validations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClusterCreateValidationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClusterCriteria invokes getClusterCriteria operation.
//
// Get all cluster criteria.
//
// GET /v1/domains/{domainId}/clusters/criteria
func (c *Client) GetClusterCriteria(ctx context.Context, params GetClusterCriteriaParams) (*PageOfClusterCriterion, error) {
	res, err := c.sendGetClusterCriteria(ctx, params)
	return res, err
}

func (c *Client) sendGetClusterCriteria(ctx context.Context, params GetClusterCriteriaParams) (res *PageOfClusterCriterion, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/clusters/criteria"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClusterCriteriaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClusterCriterion invokes getClusterCriterion operation.
//
// Get a criterion to query for cluster.
//
// GET /v1/domains/{domainId}/clusters/criteria/{name}
func (c *Client) GetClusterCriterion(ctx context.Context, params GetClusterCriterionParams) (GetClusterCriterionRes, error) {
	res, err := c.sendGetClusterCriterion(ctx, params)
	return res, err
}

func (c *Client) sendGetClusterCriterion(ctx context.Context, params GetClusterCriterionParams) (res GetClusterCriterionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/clusters/criteria/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClusterCriterionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClusterDatastores invokes getClusterDatastores operation.
//
// Get the list of all datastores associated with the cluster.
//
// GET /v1/clusters/{id}/datastores
func (c *Client) GetClusterDatastores(ctx context.Context, params GetClusterDatastoresParams) (GetClusterDatastoresRes, error) {
	res, err := c.sendGetClusterDatastores(ctx, params)
	return res, err
}

func (c *Client) sendGetClusterDatastores(ctx context.Context, params GetClusterDatastoresParams) (res GetClusterDatastoresRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClusterDatastoresResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClusterNetworkConfiguration invokes getClusterNetworkConfiguration operation.
//
// Get cluster network configuration.
//
// POST /v1/clusters/{id}/network/queries
func (c *Client) GetClusterNetworkConfiguration(ctx context.Context, request *ClusterNetworkConfigurationCriterion, params GetClusterNetworkConfigurationParams) (GetClusterNetworkConfigurationRes, error) {
	res, err := c.sendGetClusterNetworkConfiguration(ctx, request, params)
	return res, err
}

func (c *Client) sendGetClusterNetworkConfiguration(ctx context.Context, request *ClusterNetworkConfigurationCriterion, params GetClusterNetworkConfigurationParams) (res GetClusterNetworkConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/network/queries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetClusterNetworkConfigurationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClusterNetworkConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClusterNetworkConfigurationQueryResponse invokes getClusterNetworkConfigurationQueryResponse operation.
//
// The response retrieved is only applicable for pure L2 domain clusters.
//
// GET /v1/clusters/{id}/network/queries/{queryId}
func (c *Client) GetClusterNetworkConfigurationQueryResponse(ctx context.Context, params GetClusterNetworkConfigurationQueryResponseParams) (GetClusterNetworkConfigurationQueryResponseRes, error) {
	res, err := c.sendGetClusterNetworkConfigurationQueryResponse(ctx, params)
	return res, err
}

func (c *Client) sendGetClusterNetworkConfigurationQueryResponse(ctx context.Context, params GetClusterNetworkConfigurationQueryResponseParams) (res GetClusterNetworkConfigurationQueryResponseRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/network/queries/"
	{
		// Encode "queryId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queryId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QueryId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClusterNetworkConfigurationQueryResponseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClusterQueryResponse invokes getClusterQueryResponse operation.
//
// Get cluster query response.
//
// GET /v1/domains/{domainId}/clusters/{clusterName}/queries/{queryId}
func (c *Client) GetClusterQueryResponse(ctx context.Context, params GetClusterQueryResponseParams) (GetClusterQueryResponseRes, error) {
	res, err := c.sendGetClusterQueryResponse(ctx, params)
	return res, err
}

func (c *Client) sendGetClusterQueryResponse(ctx context.Context, params GetClusterQueryResponseParams) (res GetClusterQueryResponseRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/clusters/"
	{
		// Encode "clusterName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/queries/"
	{
		// Encode "queryId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queryId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QueryId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClusterQueryResponseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClusterTagManagerUrl invokes getClusterTagManagerUrl operation.
//
// Get Cluster Tag Manager Url.
//
// GET /v1/clusters/{id}/tags/tag-manager
func (c *Client) GetClusterTagManagerUrl(ctx context.Context, params GetClusterTagManagerUrlParams) (GetClusterTagManagerUrlRes, error) {
	res, err := c.sendGetClusterTagManagerUrl(ctx, params)
	return res, err
}

func (c *Client) sendGetClusterTagManagerUrl(ctx context.Context, params GetClusterTagManagerUrlParams) (res GetClusterTagManagerUrlRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags/tag-manager"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClusterTagManagerUrlResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClusterUpdateValidation invokes getClusterUpdateValidation operation.
//
// Gets the status of given cluster updates validation workflow by given validation id.
//
// GET /v1/clusters/{id}/validations/{validationId}
func (c *Client) GetClusterUpdateValidation(ctx context.Context, params GetClusterUpdateValidationParams) (GetClusterUpdateValidationRes, error) {
	res, err := c.sendGetClusterUpdateValidation(ctx, params)
	return res, err
}

func (c *Client) sendGetClusterUpdateValidation(ctx context.Context, params GetClusterUpdateValidationParams) (res GetClusterUpdateValidationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validations/"
	{
		// Encode "validationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "validationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ValidationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "useAsyncValidation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "useAsyncValidation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UseAsyncValidation.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClusterUpdateValidationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClusters invokes getClusters operation.
//
// Retrieve a list of clusters.
//
// GET /v1/clusters
func (c *Client) GetClusters(ctx context.Context, params GetClustersParams) (GetClustersRes, error) {
	res, err := c.sendGetClusters(ctx, params)
	return res, err
}

func (c *Client) sendGetClusters(ctx context.Context, params GetClustersParams) (res GetClustersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/clusters"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "isStretched" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "isStretched",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsStretched.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "isImageBased" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "isImageBased",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsImageBased.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "domainId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DomainId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClustersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClustersQueryResponse invokes getClustersQueryResponse operation.
//
// Get clusters query response.
//
// GET /v1/domains/{domainId}/clusters/queries/{queryId}
func (c *Client) GetClustersQueryResponse(ctx context.Context, params GetClustersQueryResponseParams) (GetClustersQueryResponseRes, error) {
	res, err := c.sendGetClustersQueryResponse(ctx, params)
	return res, err
}

func (c *Client) sendGetClustersQueryResponse(ctx context.Context, params GetClustersQueryResponseParams) (res GetClustersQueryResponseRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/clusters/queries/"
	{
		// Encode "queryId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queryId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QueryId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClustersQueryResponseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCompatibilityMatrices invokes getCompatibilityMatrices operation.
//
// Get Compatibility Matrices.
//
// GET /v1/compatibility-matrices
func (c *Client) GetCompatibilityMatrices(ctx context.Context) (GetCompatibilityMatricesRes, error) {
	res, err := c.sendGetCompatibilityMatrices(ctx)
	return res, err
}

func (c *Client) sendGetCompatibilityMatrices(ctx context.Context) (res GetCompatibilityMatricesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/compatibility-matrices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCompatibilityMatricesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCompatibilityMatrix invokes getCompatibilityMatrix operation.
//
// Get Compatibility Matrix.
//
// GET /v1/compatibility-matrices/{compatibilityMatrixSource}
func (c *Client) GetCompatibilityMatrix(ctx context.Context, params GetCompatibilityMatrixParams) (GetCompatibilityMatrixRes, error) {
	res, err := c.sendGetCompatibilityMatrix(ctx, params)
	return res, err
}

func (c *Client) sendGetCompatibilityMatrix(ctx context.Context, params GetCompatibilityMatrixParams) (res GetCompatibilityMatrixRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/compatibility-matrices/"
	{
		// Encode "compatibilityMatrixSource" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "compatibilityMatrixSource",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CompatibilityMatrixSource))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCompatibilityMatrixResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCompatibilityMatrixContent invokes getCompatibilityMatrixContent operation.
//
// Get Compatibility Matrix content.
//
// GET /v1/compatibility-matrices/{compatibilityMatrixSource}/content
func (c *Client) GetCompatibilityMatrixContent(ctx context.Context, params GetCompatibilityMatrixContentParams) (GetCompatibilityMatrixContentRes, error) {
	res, err := c.sendGetCompatibilityMatrixContent(ctx, params)
	return res, err
}

func (c *Client) sendGetCompatibilityMatrixContent(ctx context.Context, params GetCompatibilityMatrixContentParams) (res GetCompatibilityMatrixContentRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/compatibility-matrices/"
	{
		// Encode "compatibilityMatrixSource" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "compatibilityMatrixSource",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CompatibilityMatrixSource))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/content"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCompatibilityMatrixContentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCompatibilityMatrixMetadata invokes getCompatibilityMatrixMetadata operation.
//
// Get Compatibility Matrix Metadata.
//
// GET /v1/compatibility-matrices/{compatibilityMatrixSource}/metadata
func (c *Client) GetCompatibilityMatrixMetadata(ctx context.Context, params GetCompatibilityMatrixMetadataParams) (GetCompatibilityMatrixMetadataRes, error) {
	res, err := c.sendGetCompatibilityMatrixMetadata(ctx, params)
	return res, err
}

func (c *Client) sendGetCompatibilityMatrixMetadata(ctx context.Context, params GetCompatibilityMatrixMetadataParams) (res GetCompatibilityMatrixMetadataRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/compatibility-matrices/"
	{
		// Encode "compatibilityMatrixSource" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "compatibilityMatrixSource",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CompatibilityMatrixSource))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/metadata"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCompatibilityMatrixMetadataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetComplianceAudit invokes getComplianceAudit operation.
//
// Get compliance audit.
//
// GET /v1/compliance-audits/{complianceAuditId}
func (c *Client) GetComplianceAudit(ctx context.Context, params GetComplianceAuditParams) (GetComplianceAuditRes, error) {
	res, err := c.sendGetComplianceAudit(ctx, params)
	return res, err
}

func (c *Client) sendGetComplianceAudit(ctx context.Context, params GetComplianceAuditParams) (res GetComplianceAuditRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/compliance-audits/"
	{
		// Encode "complianceAuditId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "complianceAuditId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ComplianceAuditId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetComplianceAuditResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetComplianceAuditForADomain invokes getComplianceAuditForADomain operation.
//
// Get compliance audit for a domain.
//
// GET /v1/domains/{id}/compliance-audits/{complianceAuditId}
func (c *Client) GetComplianceAuditForADomain(ctx context.Context, params GetComplianceAuditForADomainParams) (GetComplianceAuditForADomainRes, error) {
	res, err := c.sendGetComplianceAuditForADomain(ctx, params)
	return res, err
}

func (c *Client) sendGetComplianceAuditForADomain(ctx context.Context, params GetComplianceAuditForADomainParams) (res GetComplianceAuditForADomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/compliance-audits/"
	{
		// Encode "complianceAuditId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "complianceAuditId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ComplianceAuditId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetComplianceAuditForADomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetComplianceAuditHistory invokes getComplianceAuditHistory operation.
//
// Get compliance audit history.
//
// GET /v1/compliance-audits
func (c *Client) GetComplianceAuditHistory(ctx context.Context) (GetComplianceAuditHistoryRes, error) {
	res, err := c.sendGetComplianceAuditHistory(ctx)
	return res, err
}

func (c *Client) sendGetComplianceAuditHistory(ctx context.Context) (res GetComplianceAuditHistoryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/compliance-audits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetComplianceAuditHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetComplianceAuditHistoryForADomain invokes getComplianceAuditHistoryForADomain operation.
//
// Get compliance audit history for a domain.
//
// GET /v1/domains/{id}/compliance-audits
func (c *Client) GetComplianceAuditHistoryForADomain(ctx context.Context, params GetComplianceAuditHistoryForADomainParams) (GetComplianceAuditHistoryForADomainRes, error) {
	res, err := c.sendGetComplianceAuditHistoryForADomain(ctx, params)
	return res, err
}

func (c *Client) sendGetComplianceAuditHistoryForADomain(ctx context.Context, params GetComplianceAuditHistoryForADomainParams) (res GetComplianceAuditHistoryForADomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/compliance-audits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetComplianceAuditHistoryForADomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetComplianceAuditItems invokes getComplianceAuditItems operation.
//
// Get compliance audit items.
//
// GET /v1/compliance-audits/{complianceAuditId}/compliance-audit-items
func (c *Client) GetComplianceAuditItems(ctx context.Context, params GetComplianceAuditItemsParams) (GetComplianceAuditItemsRes, error) {
	res, err := c.sendGetComplianceAuditItems(ctx, params)
	return res, err
}

func (c *Client) sendGetComplianceAuditItems(ctx context.Context, params GetComplianceAuditItemsParams) (res GetComplianceAuditItemsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/compliance-audits/"
	{
		// Encode "complianceAuditId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "complianceAuditId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ComplianceAuditId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/compliance-audit-items"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetComplianceAuditItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetComplianceAuditItemsForADomain invokes getComplianceAuditItemsForADomain operation.
//
// Get compliance audit items for a domain.
//
// GET /v1/domains/{id}/compliance-audits/{complianceAuditId}/compliance-audit-items
func (c *Client) GetComplianceAuditItemsForADomain(ctx context.Context, params GetComplianceAuditItemsForADomainParams) (GetComplianceAuditItemsForADomainRes, error) {
	res, err := c.sendGetComplianceAuditItemsForADomain(ctx, params)
	return res, err
}

func (c *Client) sendGetComplianceAuditItemsForADomain(ctx context.Context, params GetComplianceAuditItemsForADomainParams) (res GetComplianceAuditItemsForADomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/compliance-audits/"
	{
		// Encode "complianceAuditId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "complianceAuditId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ComplianceAuditId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/compliance-audit-items"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetComplianceAuditItemsForADomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetComplianceAuditTask invokes getComplianceAuditTask operation.
//
// Get compliance audit task.
//
// GET /v1/domains/{id}/compliance-audits/tasks/{taskId}
func (c *Client) GetComplianceAuditTask(ctx context.Context, params GetComplianceAuditTaskParams) (GetComplianceAuditTaskRes, error) {
	res, err := c.sendGetComplianceAuditTask(ctx, params)
	return res, err
}

func (c *Client) sendGetComplianceAuditTask(ctx context.Context, params GetComplianceAuditTaskParams) (res GetComplianceAuditTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/compliance-audits/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetComplianceAuditTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetComplianceConfigurations invokes getComplianceConfigurations operation.
//
// Get a list of all compliance configurations.
//
// GET /v1/compliance-configurations
func (c *Client) GetComplianceConfigurations(ctx context.Context, params GetComplianceConfigurationsParams) (GetComplianceConfigurationsRes, error) {
	res, err := c.sendGetComplianceConfigurations(ctx, params)
	return res, err
}

func (c *Client) sendGetComplianceConfigurations(ctx context.Context, params GetComplianceConfigurationsParams) (res GetComplianceConfigurationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/compliance-configurations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "standardType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "standardType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StandardType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "standardVersion" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "standardVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StandardVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "resourceType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResourceType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "resourceVersion" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResourceVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetComplianceConfigurationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetComplianceStandards invokes getComplianceStandards operation.
//
// Get a list of all compliance standards.
//
// GET /v1/compliance-standards
func (c *Client) GetComplianceStandards(ctx context.Context) (GetComplianceStandardsRes, error) {
	res, err := c.sendGetComplianceStandards(ctx)
	return res, err
}

func (c *Client) sendGetComplianceStandards(ctx context.Context) (res GetComplianceStandardsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/compliance-standards"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetComplianceStandardsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConfigs invokes getConfigs operation.
//
// Get configs associated with the given criteria, all if no criteria is provided.
//
// GET /v1/config-drifts
func (c *Client) GetConfigs(ctx context.Context, params GetConfigsParams) (GetConfigsRes, error) {
	res, err := c.sendGetConfigs(ctx, params)
	return res, err
}

func (c *Client) sendGetConfigs(ctx context.Context, params GetConfigsParams) (res GetConfigsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/config-drifts"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "resourceId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResourceId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "resourceType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResourceType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "configId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "configId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ConfigId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "driftType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "driftType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DriftType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetConfigsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCredential invokes getCredential operation.
//
// Retrieve a credential by its ID.
//
// GET /v1/credentials/{id}
func (c *Client) GetCredential(ctx context.Context, params GetCredentialParams) (GetCredentialRes, error) {
	res, err := c.sendGetCredential(ctx, params)
	return res, err
}

func (c *Client) sendGetCredential(ctx context.Context, params GetCredentialParams) (res GetCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/credentials/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCredentialTaskByResourceID invokes getCredentialTaskByResourceID operation.
//
// Retriece a credential taks by resource ID.
//
// GET /v1/credentials/tasks/{id}/resource-credentials
func (c *Client) GetCredentialTaskByResourceID(ctx context.Context, params GetCredentialTaskByResourceIDParams) (GetCredentialTaskByResourceIDRes, error) {
	res, err := c.sendGetCredentialTaskByResourceID(ctx, params)
	return res, err
}

func (c *Client) sendGetCredentialTaskByResourceID(ctx context.Context, params GetCredentialTaskByResourceIDParams) (res GetCredentialTaskByResourceIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/credentials/tasks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/resource-credentials"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCredentialTaskByResourceIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCredentials invokes getCredentials operation.
//
// Retrieve a list of credentials.
//
// GET /v1/credentials
func (c *Client) GetCredentials(ctx context.Context, params GetCredentialsParams) (GetCredentialsRes, error) {
	res, err := c.sendGetCredentials(ctx, params)
	return res, err
}

func (c *Client) sendGetCredentials(ctx context.Context, params GetCredentialsParams) (res GetCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/credentials"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "resourceName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResourceName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "resourceIp" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceIp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResourceIp.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "resourceType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResourceType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "domainName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "domainName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DomainName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageNumber" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "accountType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "accountType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AccountType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCredentialsSubTask invokes getCredentialsSubTask operation.
//
// Retrieve a credential sub task by its ID.
//
// GET /v1/credentials/tasks/{id}/subtasks/{subtaskId}
func (c *Client) GetCredentialsSubTask(ctx context.Context, params GetCredentialsSubTaskParams) (GetCredentialsSubTaskRes, error) {
	res, err := c.sendGetCredentialsSubTask(ctx, params)
	return res, err
}

func (c *Client) sendGetCredentialsSubTask(ctx context.Context, params GetCredentialsSubTaskParams) (res GetCredentialsSubTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/credentials/tasks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subtasks/"
	{
		// Encode "subtaskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "subtaskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SubtaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCredentialsSubTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCredentialsTask invokes getCredentialsTask operation.
//
// Retrieve a credential task by ID.
//
// GET /v1/credentials/tasks/{id}
func (c *Client) GetCredentialsTask(ctx context.Context, params GetCredentialsTaskParams) (GetCredentialsTaskRes, error) {
	res, err := c.sendGetCredentialsTask(ctx, params)
	return res, err
}

func (c *Client) sendGetCredentialsTask(ctx context.Context, params GetCredentialsTaskParams) (res GetCredentialsTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/credentials/tasks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCredentialsTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCredentialsTasks invokes getCredentialsTasks operation.
//
// Retrieve a list of credential tasks.
//
// GET /v1/credentials/tasks
func (c *Client) GetCredentialsTasks(ctx context.Context, params GetCredentialsTasksParams) (GetCredentialsTasksRes, error) {
	res, err := c.sendGetCredentialsTasks(ctx, params)
	return res, err
}

func (c *Client) sendGetCredentialsTasks(ctx context.Context, params GetCredentialsTasksParams) (res GetCredentialsTasksRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/credentials/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCredentialsTasksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCriteria invokes getCriteria operation.
//
// Get all criteria.
//
// GET /v1/hosts/criteria
func (c *Client) GetCriteria(ctx context.Context) (*PageOfHostCriterion, error) {
	res, err := c.sendGetCriteria(ctx)
	return res, err
}

func (c *Client) sendGetCriteria(ctx context.Context) (res *PageOfHostCriterion, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hosts/criteria"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCriteriaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCriterion invokes getCriterion operation.
//
// Get a criterion.
//
// GET /v1/hosts/criteria/{name}
func (c *Client) GetCriterion(ctx context.Context, params GetCriterionParams) (GetCriterionRes, error) {
	res, err := c.sendGetCriterion(ctx, params)
	return res, err
}

func (c *Client) sendGetCriterion(ctx context.Context, params GetCriterionParams) (res GetCriterionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hosts/criteria/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCriterionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomIsoById invokes getCustomIsoById operation.
//
// Get the Custom ISO based matching the ID.
//
// GET /v1/custom-isos/{custom_iso_id}
func (c *Client) GetCustomIsoById(ctx context.Context, params GetCustomIsoByIdParams) (GetCustomIsoByIdRes, error) {
	res, err := c.sendGetCustomIsoById(ctx, params)
	return res, err
}

func (c *Client) sendGetCustomIsoById(ctx context.Context, params GetCustomIsoByIdParams) (res GetCustomIsoByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/custom-isos/"
	{
		// Encode "custom_iso_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "custom_iso_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CustomIsoID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCustomIsoByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomIsos invokes getCustomIsos operation.
//
// Get all Custom ISOs or Custom ISOs that match specified parameters.
//
// GET /v1/custom-isos
func (c *Client) GetCustomIsos(ctx context.Context, params GetCustomIsosParams) (GetCustomIsosRes, error) {
	res, err := c.sendGetCustomIsos(ctx, params)
	return res, err
}

func (c *Client) sendGetCustomIsos(ctx context.Context, params GetCustomIsosParams) (res GetCustomIsosRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/custom-isos"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vendor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vendor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Vendor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "domainId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DomainId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "targetVersion" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "targetVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TargetVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCustomIsosResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomPatches invokes getCustomPatches operation.
//
// Filter applicable patches (current/target vcf releases) per product type per domain.
//
// GET /v1/releases/domains/{domainId}/custom-patches
func (c *Client) GetCustomPatches(ctx context.Context, params GetCustomPatchesParams) (*FlexibleProductPatches, error) {
	res, err := c.sendGetCustomPatches(ctx, params)
	return res, err
}

func (c *Client) sendGetCustomPatches(ctx context.Context, params GetCustomPatchesParams) (res *FlexibleProductPatches, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/releases/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/custom-patches"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "vcfRelease" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vcfRelease",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VcfRelease.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vxrailReleaseVersion" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vxrailReleaseVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VxrailReleaseVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "productType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "productType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProductType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCustomPatchesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatastoreCriterion invokes getDatastoreCriterion operation.
//
// Get a criterion to query for datastore.
//
// GET /v1/domains/{domainId}/datastores/criteria/{name}
func (c *Client) GetDatastoreCriterion(ctx context.Context, params GetDatastoreCriterionParams) (GetDatastoreCriterionRes, error) {
	res, err := c.sendGetDatastoreCriterion(ctx, params)
	return res, err
}

func (c *Client) sendGetDatastoreCriterion(ctx context.Context, params GetDatastoreCriterionParams) (res GetDatastoreCriterionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores/criteria/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDatastoreCriterionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatastoreCriterion1 invokes getDatastoreCriterion_1 operation.
//
// Get a criterion to query for datastore.
//
// GET /v1/clusters/{id}/datastores/criteria/{name}
func (c *Client) GetDatastoreCriterion1(ctx context.Context, params GetDatastoreCriterion1Params) (GetDatastoreCriterion1Res, error) {
	res, err := c.sendGetDatastoreCriterion1(ctx, params)
	return res, err
}

func (c *Client) sendGetDatastoreCriterion1(ctx context.Context, params GetDatastoreCriterion1Params) (res GetDatastoreCriterion1Res, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores/criteria/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDatastoreCriterion1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatastoreQueryResponse invokes getDatastoreQueryResponse operation.
//
// Get Datastore query response.
//
// GET /v1/domains/{domainId}/datastores/queries/{queryId}
func (c *Client) GetDatastoreQueryResponse(ctx context.Context, params GetDatastoreQueryResponseParams) (GetDatastoreQueryResponseRes, error) {
	res, err := c.sendGetDatastoreQueryResponse(ctx, params)
	return res, err
}

func (c *Client) sendGetDatastoreQueryResponse(ctx context.Context, params GetDatastoreQueryResponseParams) (res GetDatastoreQueryResponseRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores/queries/"
	{
		// Encode "queryId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queryId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QueryId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDatastoreQueryResponseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatastoreQueryResponse1 invokes getDatastoreQueryResponse_1 operation.
//
// Get Datastore query response.
//
// GET /v1/clusters/{clusterId}/datastores/queries/{queryId}
func (c *Client) GetDatastoreQueryResponse1(ctx context.Context, params GetDatastoreQueryResponse1Params) (GetDatastoreQueryResponse1Res, error) {
	res, err := c.sendGetDatastoreQueryResponse1(ctx, params)
	return res, err
}

func (c *Client) sendGetDatastoreQueryResponse1(ctx context.Context, params GetDatastoreQueryResponse1Params) (res GetDatastoreQueryResponse1Res, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "clusterId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores/queries/"
	{
		// Encode "queryId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queryId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QueryId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDatastoreQueryResponse1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatastoresCriteria invokes getDatastoresCriteria operation.
//
// Get all datastore criteria.
//
// GET /v1/domains/{domainId}/datastores/criteria
func (c *Client) GetDatastoresCriteria(ctx context.Context, params GetDatastoresCriteriaParams) (*PageOfDatastoreCriterion, error) {
	res, err := c.sendGetDatastoresCriteria(ctx, params)
	return res, err
}

func (c *Client) sendGetDatastoresCriteria(ctx context.Context, params GetDatastoresCriteriaParams) (res *PageOfDatastoreCriterion, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores/criteria"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDatastoresCriteriaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatastoresCriteria1 invokes getDatastoresCriteria_1 operation.
//
// Get all datastore criteria.
//
// GET /v1/clusters/{id}/datastores/criteria
func (c *Client) GetDatastoresCriteria1(ctx context.Context, params GetDatastoresCriteria1Params) (*PageOfDatastoreCriterion, error) {
	res, err := c.sendGetDatastoresCriteria1(ctx, params)
	return res, err
}

func (c *Client) sendGetDatastoresCriteria1(ctx context.Context, params GetDatastoresCriteria1Params) (res *PageOfDatastoreCriterion, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores/criteria"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDatastoresCriteria1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDepotSettings invokes getDepotSettings operation.
//
// Get the depot configuration. In a fresh setup, this would be empty.
//
// GET /v1/system/settings/depot
func (c *Client) GetDepotSettings(ctx context.Context) (GetDepotSettingsRes, error) {
	res, err := c.sendGetDepotSettings(ctx)
	return res, err
}

func (c *Client) sendGetDepotSettings(ctx context.Context) (res GetDepotSettingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/settings/depot"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDepotSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDnsConfiguration invokes getDnsConfiguration operation.
//
// Retrieve the DNS configuration.
//
// GET /v1/system/dns-configuration
func (c *Client) GetDnsConfiguration(ctx context.Context) (GetDnsConfigurationRes, error) {
	res, err := c.sendGetDnsConfiguration(ctx)
	return res, err
}

func (c *Client) sendGetDnsConfiguration(ctx context.Context) (res GetDnsConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/dns-configuration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDnsConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDomain invokes getDomain operation.
//
// Get a domain by its ID.
//
// GET /v1/domains/{id}
func (c *Client) GetDomain(ctx context.Context, params GetDomainParams) (GetDomainRes, error) {
	res, err := c.sendGetDomain(ctx, params)
	return res, err
}

func (c *Client) sendGetDomain(ctx context.Context, params GetDomainParams) (res GetDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDomainCertificates invokes getDomainCertificates operation.
//
// Get latest generated certificate(s) in a domain.
//
// GET /v1/domains/{id}/certificates
func (c *Client) GetDomainCertificates(ctx context.Context, params GetDomainCertificatesParams) (GetDomainCertificatesRes, error) {
	res, err := c.sendGetDomainCertificates(ctx, params)
	return res, err
}

func (c *Client) sendGetDomainCertificates(ctx context.Context, params GetDomainCertificatesParams) (res GetDomainCertificatesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/certificates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDomainCertificatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDomainEndpoints invokes getDomainEndpoints operation.
//
// Retrieve a list of endpoints or URLs for a domain by its ID.
//
// GET /v1/domains/{id}/endpoints
func (c *Client) GetDomainEndpoints(ctx context.Context, params GetDomainEndpointsParams) (GetDomainEndpointsRes, error) {
	res, err := c.sendGetDomainEndpoints(ctx, params)
	return res, err
}

func (c *Client) sendGetDomainEndpoints(ctx context.Context, params GetDomainEndpointsParams) (res GetDomainEndpointsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/endpoints"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDomainEndpointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDomainIsolationPrecheckStatus invokes getDomainIsolationPrecheckStatus operation.
//
// Get the status of the Domain Isolation Precheck.
//
// GET /v1/domains/{domainId}/isolation-prechecks/{precheckId}
func (c *Client) GetDomainIsolationPrecheckStatus(ctx context.Context, params GetDomainIsolationPrecheckStatusParams) (GetDomainIsolationPrecheckStatusRes, error) {
	res, err := c.sendGetDomainIsolationPrecheckStatus(ctx, params)
	return res, err
}

func (c *Client) sendGetDomainIsolationPrecheckStatus(ctx context.Context, params GetDomainIsolationPrecheckStatusParams) (res GetDomainIsolationPrecheckStatusRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/isolation-prechecks/"
	{
		// Encode "precheckId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "precheckId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PrecheckId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDomainIsolationPrecheckStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDomainReleaseViewValidation invokes getDomainReleaseViewValidation operation.
//
// Monitor the progress of domain target state validation task by the validation id.
//
// GET /v1/releases/domains/validations/{validationId}
func (c *Client) GetDomainReleaseViewValidation(ctx context.Context, params GetDomainReleaseViewValidationParams) (GetDomainReleaseViewValidationRes, error) {
	res, err := c.sendGetDomainReleaseViewValidation(ctx, params)
	return res, err
}

func (c *Client) sendGetDomainReleaseViewValidation(ctx context.Context, params GetDomainReleaseViewValidationParams) (res GetDomainReleaseViewValidationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/releases/domains/validations/"
	{
		// Encode "validationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "validationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ValidationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDomainReleaseViewValidationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDomainTagManagerUrl invokes getDomainTagManagerUrl operation.
//
// Get Domain Tag Manager Url.
//
// GET /v1/domains/{id}/tags/tag-manager
func (c *Client) GetDomainTagManagerUrl(ctx context.Context, params GetDomainTagManagerUrlParams) (GetDomainTagManagerUrlRes, error) {
	res, err := c.sendGetDomainTagManagerUrl(ctx, params)
	return res, err
}

func (c *Client) sendGetDomainTagManagerUrl(ctx context.Context, params GetDomainTagManagerUrlParams) (res GetDomainTagManagerUrlRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags/tag-manager"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDomainTagManagerUrlResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDomainUpdateValidation invokes getDomainUpdateValidation operation.
//
// Gets the status of given domain update validation workflow by given validation id.
//
// GET /v1/domains/{id}/validations/{validationId}
func (c *Client) GetDomainUpdateValidation(ctx context.Context, params GetDomainUpdateValidationParams) (GetDomainUpdateValidationRes, error) {
	res, err := c.sendGetDomainUpdateValidation(ctx, params)
	return res, err
}

func (c *Client) sendGetDomainUpdateValidation(ctx context.Context, params GetDomainUpdateValidationParams) (res GetDomainUpdateValidationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validations/"
	{
		// Encode "validationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "validationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ValidationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDomainUpdateValidationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDomains invokes getDomains operation.
//
// Retrieve a list of domains.
//
// GET /v1/domains
func (c *Client) GetDomains(ctx context.Context, params GetDomainsParams) (GetDomainsRes, error) {
	res, err := c.sendGetDomains(ctx, params)
	return res, err
}

func (c *Client) sendGetDomains(ctx context.Context, params GetDomainsParams) (res GetDomainsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/domains"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDomainsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEdgeCluster invokes getEdgeCluster operation.
//
// Retrieve an NSX Edge Cluster by its ID.
//
// GET /v1/edge-clusters/{id}
func (c *Client) GetEdgeCluster(ctx context.Context, params GetEdgeClusterParams) (GetEdgeClusterRes, error) {
	res, err := c.sendGetEdgeCluster(ctx, params)
	return res, err
}

func (c *Client) sendGetEdgeCluster(ctx context.Context, params GetEdgeClusterParams) (res GetEdgeClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/edge-clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEdgeClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEdgeClusterQueryCriteria invokes getEdgeClusterQueryCriteria operation.
//
// Get the Edge Cluster criterion list for the NSX query.
//
// GET /v1/edge-clusters/{edgeClusterId}/criteria
func (c *Client) GetEdgeClusterQueryCriteria(ctx context.Context, params GetEdgeClusterQueryCriteriaParams) (GetEdgeClusterQueryCriteriaRes, error) {
	res, err := c.sendGetEdgeClusterQueryCriteria(ctx, params)
	return res, err
}

func (c *Client) sendGetEdgeClusterQueryCriteria(ctx context.Context, params GetEdgeClusterQueryCriteriaParams) (res GetEdgeClusterQueryCriteriaRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/edge-clusters/"
	{
		// Encode "edgeClusterId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "edgeClusterId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EdgeClusterId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/criteria"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEdgeClusterQueryCriteriaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEdgeClusterValidationByID invokes getEdgeClusterValidationByID operation.
//
// Retrieve the results of a NSX Edge Cluster validation by its ID.
//
// GET /v1/edge-clusters/validations/{id}
func (c *Client) GetEdgeClusterValidationByID(ctx context.Context, params GetEdgeClusterValidationByIDParams) (GetEdgeClusterValidationByIDRes, error) {
	res, err := c.sendGetEdgeClusterValidationByID(ctx, params)
	return res, err
}

func (c *Client) sendGetEdgeClusterValidationByID(ctx context.Context, params GetEdgeClusterValidationByIDParams) (res GetEdgeClusterValidationByIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/edge-clusters/validations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEdgeClusterValidationByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEdgeClusters invokes getEdgeClusters operation.
//
// Retrieve a list of NSX Edge Clusters.
//
// GET /v1/edge-clusters
func (c *Client) GetEdgeClusters(ctx context.Context, params GetEdgeClustersParams) (GetEdgeClustersRes, error) {
	res, err := c.sendGetEdgeClusters(ctx, params)
	return res, err
}

func (c *Client) sendGetEdgeClusters(ctx context.Context, params GetEdgeClustersParams) (res GetEdgeClustersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/edge-clusters"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "clusterId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "clusterId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ClusterId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEdgeClustersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFIPSConfiguration invokes getFIPSConfiguration operation.
//
// Retrieve VCF security FIPS mode.
//
// GET /v1/system/security/fips
func (c *Client) GetFIPSConfiguration(ctx context.Context) (GetFIPSConfigurationRes, error) {
	res, err := c.sendGetFIPSConfiguration(ctx)
	return res, err
}

func (c *Client) sendGetFIPSConfiguration(ctx context.Context) (res GetFIPSConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/security/fips"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetFIPSConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFutureReleases invokes getFutureReleases operation.
//
// Returns all known to the system future target versions for a domain. If some of them are not
// allowed (e.g. stepping stone) includes message why. If the domain does not have a product
// configured at that point, that product will not be included in the BOM or patch bundle list in
// each release.
//
// GET /v1/releases/domains/{domainId}/future-releases
func (c *Client) GetFutureReleases(ctx context.Context, params GetFutureReleasesParams) (GetFutureReleasesRes, error) {
	res, err := c.sendGetFutureReleases(ctx, params)
	return res, err
}

func (c *Client) sendGetFutureReleases(ctx context.Context, params GetFutureReleasesParams) (res GetFutureReleasesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/releases/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/future-releases"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetFutureReleasesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHealthCheckStatus invokes getHealthCheckStatus operation.
//
// Retrieve the status of the Health Check operations.
//
// GET /v1/system/health-summary/{id}
func (c *Client) GetHealthCheckStatus(ctx context.Context, params GetHealthCheckStatusParams) (GetHealthCheckStatusRes, error) {
	res, err := c.sendGetHealthCheckStatus(ctx, params)
	return res, err
}

func (c *Client) sendGetHealthCheckStatus(ctx context.Context, params GetHealthCheckStatusParams) (res GetHealthCheckStatusRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/system/health-summary/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHealthCheckStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHealthCheckTask invokes getHealthCheckTask operation.
//
// Retieve a list of Health Check tasks.
//
// GET /v1/system/health-summary
func (c *Client) GetHealthCheckTask(ctx context.Context) (GetHealthCheckTaskRes, error) {
	res, err := c.sendGetHealthCheckTask(ctx)
	return res, err
}

func (c *Client) sendGetHealthCheckTask(ctx context.Context) (res GetHealthCheckTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/health-summary"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHealthCheckTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHost invokes getHost operation.
//
// Get a host by its ID.
//
// GET /v1/hosts/{id}
func (c *Client) GetHost(ctx context.Context, params GetHostParams) (GetHostRes, error) {
	res, err := c.sendGetHost(ctx, params)
	return res, err
}

func (c *Client) sendGetHost(ctx context.Context, params GetHostParams) (res GetHostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hosts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHostCommissionValidationByID invokes getHostCommissionValidationByID operation.
//
// Retrieve the results of a host commission validation by its ID.
//
// GET /v1/hosts/validations/{id}
func (c *Client) GetHostCommissionValidationByID(ctx context.Context, params GetHostCommissionValidationByIDParams) (GetHostCommissionValidationByIDRes, error) {
	res, err := c.sendGetHostCommissionValidationByID(ctx, params)
	return res, err
}

func (c *Client) sendGetHostCommissionValidationByID(ctx context.Context, params GetHostCommissionValidationByIDParams) (res GetHostCommissionValidationByIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hosts/validations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHostCommissionValidationByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHostCriteria invokes getHostCriteria operation.
//
// Get all host criteria.
//
// GET /v1/clusters/{id}/hosts/criteria
func (c *Client) GetHostCriteria(ctx context.Context, params GetHostCriteriaParams) (*PageOfHostCriterion, error) {
	res, err := c.sendGetHostCriteria(ctx, params)
	return res, err
}

func (c *Client) sendGetHostCriteria(ctx context.Context, params GetHostCriteriaParams) (res *PageOfHostCriterion, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hosts/criteria"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHostCriteriaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHostCriterion invokes getHostCriterion operation.
//
// Get a criterion to query for host.
//
// GET /v1/clusters/{id}/hosts/criteria/{name}
func (c *Client) GetHostCriterion(ctx context.Context, params GetHostCriterionParams) (GetHostCriterionRes, error) {
	res, err := c.sendGetHostCriterion(ctx, params)
	return res, err
}

func (c *Client) sendGetHostCriterion(ctx context.Context, params GetHostCriterionParams) (res GetHostCriterionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hosts/criteria/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHostCriterionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHostQueryResponse invokes getHostQueryResponse operation.
//
// Get query response.
//
// GET /v1/hosts/queries/{id}
func (c *Client) GetHostQueryResponse(ctx context.Context, params GetHostQueryResponseParams) (GetHostQueryResponseRes, error) {
	res, err := c.sendGetHostQueryResponse(ctx, params)
	return res, err
}

func (c *Client) sendGetHostQueryResponse(ctx context.Context, params GetHostQueryResponseParams) (res GetHostQueryResponseRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hosts/queries/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHostQueryResponseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHostQueryResponse1 invokes getHostQueryResponse_1 operation.
//
// Get query response.
//
// GET /v1/clusters/{clusterId}/hosts/queries/{queryId}
func (c *Client) GetHostQueryResponse1(ctx context.Context, params GetHostQueryResponse1Params) (GetHostQueryResponse1Res, error) {
	res, err := c.sendGetHostQueryResponse1(ctx, params)
	return res, err
}

func (c *Client) sendGetHostQueryResponse1(ctx context.Context, params GetHostQueryResponse1Params) (res GetHostQueryResponse1Res, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "clusterId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hosts/queries/"
	{
		// Encode "queryId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queryId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QueryId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHostQueryResponse1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHostTagManagerUrl invokes getHostTagManagerUrl operation.
//
// Get Host Tag Manager Url.
//
// GET /v1/hosts/{id}/tags/tag-manager
func (c *Client) GetHostTagManagerUrl(ctx context.Context, params GetHostTagManagerUrlParams) (GetHostTagManagerUrlRes, error) {
	res, err := c.sendGetHostTagManagerUrl(ctx, params)
	return res, err
}

func (c *Client) sendGetHostTagManagerUrl(ctx context.Context, params GetHostTagManagerUrlParams) (res GetHostTagManagerUrlRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/hosts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags/tag-manager"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHostTagManagerUrlResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHosts invokes getHosts operation.
//
// Get all hosts.
//
// GET /v1/hosts
func (c *Client) GetHosts(ctx context.Context, params GetHostsParams) (GetHostsRes, error) {
	res, err := c.sendGetHosts(ctx, params)
	return res, err
}

func (c *Client) sendGetHosts(ctx context.Context, params GetHostsParams) (res GetHostsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "domainId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DomainId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "clusterId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "clusterId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ClusterId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "networkpoolId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "networkpoolId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NetworkpoolId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "storageType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "storageType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StorageType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "datastoreName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "datastoreName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DatastoreName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHostsPrechecksResponse invokes getHostsPrechecksResponse operation.
//
// Get host(s) prechecks response.
//
// GET /v1/hosts/prechecks/{id}
func (c *Client) GetHostsPrechecksResponse(ctx context.Context, params GetHostsPrechecksResponseParams) (GetHostsPrechecksResponseRes, error) {
	res, err := c.sendGetHostsPrechecksResponse(ctx, params)
	return res, err
}

func (c *Client) sendGetHostsPrechecksResponse(ctx context.Context, params GetHostsPrechecksResponseParams) (res GetHostsPrechecksResponseRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hosts/prechecks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHostsPrechecksResponseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetIdentityPrecheckResult invokes getIdentityPrecheckResult operation.
//
// Get a list precheck result with warnings/errors.
//
// GET /v1/identity-broker/prechecks
func (c *Client) GetIdentityPrecheckResult(ctx context.Context, params GetIdentityPrecheckResultParams) (GetIdentityPrecheckResultRes, error) {
	res, err := c.sendGetIdentityPrecheckResult(ctx, params)
	return res, err
}

func (c *Client) sendGetIdentityPrecheckResult(ctx context.Context, params GetIdentityPrecheckResultParams) (res GetIdentityPrecheckResultRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/identity-broker/prechecks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetIdentityPrecheckResultResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetIdentityProviderById invokes getIdentityProviderById operation.
//
// Get a specific identity irovider using its id.
//
// GET /v1/identity-providers/{id}
func (c *Client) GetIdentityProviderById(ctx context.Context, params GetIdentityProviderByIdParams) (GetIdentityProviderByIdRes, error) {
	res, err := c.sendGetIdentityProviderById(ctx, params)
	return res, err
}

func (c *Client) sendGetIdentityProviderById(ctx context.Context, params GetIdentityProviderByIdParams) (res GetIdentityProviderByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/identity-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetIdentityProviderByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetIdentityProviders invokes getIdentityProviders operation.
//
// Get a list of all identity providers.
//
// GET /v1/identity-providers
func (c *Client) GetIdentityProviders(ctx context.Context) (GetIdentityProvidersRes, error) {
	res, err := c.sendGetIdentityProviders(ctx)
	return res, err
}

func (c *Client) sendGetIdentityProviders(ctx context.Context) (res GetIdentityProvidersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/identity-providers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetIdentityProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLastAssessmentRunInfo invokes getLastAssessmentRunInfo operation.
//
// Get information about the last assessment run.
//
// GET /v1/system/check-sets
func (c *Client) GetLastAssessmentRunInfo(ctx context.Context, params GetLastAssessmentRunInfoParams) (GetLastAssessmentRunInfoRes, error) {
	res, err := c.sendGetLastAssessmentRunInfo(ctx, params)
	return res, err
}

func (c *Client) sendGetLastAssessmentRunInfo(ctx context.Context, params GetLastAssessmentRunInfoParams) (res GetLastAssessmentRunInfoRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/check-sets"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "domainId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DomainId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLastAssessmentRunInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLicenseKey invokes getLicenseKey operation.
//
// Retrieve a license key.
//
// GET /v1/license-keys/{key}
func (c *Client) GetLicenseKey(ctx context.Context, params GetLicenseKeyParams) (GetLicenseKeyRes, error) {
	res, err := c.sendGetLicenseKey(ctx, params)
	return res, err
}

func (c *Client) sendGetLicenseKey(ctx context.Context, params GetLicenseKeyParams) (res GetLicenseKeyRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/license-keys/"
	{
		// Encode "key" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Key))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLicenseKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLicenseKeys invokes getLicenseKeys operation.
//
// Retrieve a list of license keys.
//
// GET /v1/license-keys
func (c *Client) GetLicenseKeys(ctx context.Context, params GetLicenseKeysParams) (GetLicenseKeysRes, error) {
	res, err := c.sendGetLicenseKeys(ctx, params)
	return res, err
}

func (c *Client) sendGetLicenseKeys(ctx context.Context, params GetLicenseKeysParams) (res GetLicenseKeysRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/license-keys"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "productType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "productType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.ProductType != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.ProductType {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "licenseKeyStatus" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "licenseKeyStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.LicenseKeyStatus != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.LicenseKeyStatus {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "licenseUnit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "licenseUnit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.LicenseUnit != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.LicenseUnit {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "productVersion" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "productVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProductVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLicenseKeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLicenseProductTypes invokes getLicenseProductTypes operation.
//
// Get product types.
//
// GET /v1/license-keys/product-types
func (c *Client) GetLicenseProductTypes(ctx context.Context) (GetLicenseProductTypesRes, error) {
	res, err := c.sendGetLicenseProductTypes(ctx)
	return res, err
}

func (c *Client) sendGetLicenseProductTypes(ctx context.Context) (res GetLicenseProductTypesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/license-keys/product-types"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLicenseProductTypesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLocalAccount invokes getLocalAccount operation.
//
// Get information on the local account.
//
// GET /v1/users/local/admin
func (c *Client) GetLocalAccount(ctx context.Context) (GetLocalAccountRes, error) {
	res, err := c.sendGetLocalAccount(ctx)
	return res, err
}

func (c *Client) sendGetLocalAccount(ctx context.Context) (res GetLocalAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/users/local/admin"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLocalAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLocalOsUserAccounts invokes getLocalOsUserAccounts operation.
//
// Returns a list of local OS user accounts from the SDDC Manager appliance.
//
// GET /v1/sddc-manager/local-os-user-accounts
func (c *Client) GetLocalOsUserAccounts(ctx context.Context) (GetLocalOsUserAccountsRes, error) {
	res, err := c.sendGetLocalOsUserAccounts(ctx)
	return res, err
}

func (c *Client) sendGetLocalOsUserAccounts(ctx context.Context) (res GetLocalOsUserAccountsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sddc-manager/local-os-user-accounts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLocalOsUserAccountsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNetworkOfNetworkPool invokes getNetworkOfNetworkPool operation.
//
// Get a Network that is part of a Network Pool.
//
// GET /v1/network-pools/{id}/networks/{networkId}
func (c *Client) GetNetworkOfNetworkPool(ctx context.Context, params GetNetworkOfNetworkPoolParams) (GetNetworkOfNetworkPoolRes, error) {
	res, err := c.sendGetNetworkOfNetworkPool(ctx, params)
	return res, err
}

func (c *Client) sendGetNetworkOfNetworkPool(ctx context.Context, params GetNetworkOfNetworkPoolParams) (res GetNetworkOfNetworkPoolRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/network-pools/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/networks/"
	{
		// Encode "networkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "networkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NetworkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNetworkOfNetworkPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNetworkPool invokes getNetworkPool operation.
//
// Get the Network Pools.
//
// GET /v1/network-pools
func (c *Client) GetNetworkPool(ctx context.Context) (GetNetworkPoolRes, error) {
	res, err := c.sendGetNetworkPool(ctx)
	return res, err
}

func (c *Client) sendGetNetworkPool(ctx context.Context) (res GetNetworkPoolRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/network-pools"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNetworkPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNetworkPoolByID invokes getNetworkPoolByID operation.
//
// Get a Network Pool by ID, if it exists.
//
// GET /v1/network-pools/{id}
func (c *Client) GetNetworkPoolByID(ctx context.Context, params GetNetworkPoolByIDParams) (GetNetworkPoolByIDRes, error) {
	res, err := c.sendGetNetworkPoolByID(ctx, params)
	return res, err
}

func (c *Client) sendGetNetworkPoolByID(ctx context.Context, params GetNetworkPoolByIDParams) (res GetNetworkPoolByIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/network-pools/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNetworkPoolByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNetworksOfNetworkPool invokes getNetworksOfNetworkPool operation.
//
// Get the Networks that are part of a Network Pool.
//
// GET /v1/network-pools/{id}/networks
func (c *Client) GetNetworksOfNetworkPool(ctx context.Context, params GetNetworksOfNetworkPoolParams) (GetNetworksOfNetworkPoolRes, error) {
	res, err := c.sendGetNetworksOfNetworkPool(ctx, params)
	return res, err
}

func (c *Client) sendGetNetworksOfNetworkPool(ctx context.Context, params GetNetworksOfNetworkPoolParams) (res GetNetworksOfNetworkPoolRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/network-pools/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/networks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNetworksOfNetworkPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNsxCluster invokes getNsxCluster operation.
//
// Retrieve the details of an NSX cluster by its ID.
//
// GET /v1/nsxt-clusters/{id}
func (c *Client) GetNsxCluster(ctx context.Context, params GetNsxClusterParams) (GetNsxClusterRes, error) {
	res, err := c.sendGetNsxCluster(ctx, params)
	return res, err
}

func (c *Client) sendGetNsxCluster(ctx context.Context, params GetNsxClusterParams) (res GetNsxClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/nsxt-clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNsxClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNsxClusterQueryResponse invokes getNsxClusterQueryResponse operation.
//
// Get NSX cluster query response.
//
// GET /v1/nsxt-clusters/queries/{id}
func (c *Client) GetNsxClusterQueryResponse(ctx context.Context, params GetNsxClusterQueryResponseParams) (GetNsxClusterQueryResponseRes, error) {
	res, err := c.sendGetNsxClusterQueryResponse(ctx, params)
	return res, err
}

func (c *Client) sendGetNsxClusterQueryResponse(ctx context.Context, params GetNsxClusterQueryResponseParams) (res GetNsxClusterQueryResponseRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/nsxt-clusters/queries/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNsxClusterQueryResponseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNsxClusters invokes getNsxClusters operation.
//
// Retrieve a list of NSX clusters.
//
// GET /v1/nsxt-clusters
func (c *Client) GetNsxClusters(ctx context.Context, params GetNsxClustersParams) (GetNsxClustersRes, error) {
	res, err := c.sendGetNsxClusters(ctx, params)
	return res, err
}

func (c *Client) sendGetNsxClusters(ctx context.Context, params GetNsxClustersParams) (res GetNsxClustersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nsxt-clusters"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "isShareable" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "isShareable",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsShareable.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNsxClustersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNsxCriteria invokes getNsxCriteria operation.
//
// Get all NSX criteria.
//
// GET /v1/nsxt-clusters/criteria
func (c *Client) GetNsxCriteria(ctx context.Context) (*PageOfNsxTCriterion, error) {
	res, err := c.sendGetNsxCriteria(ctx)
	return res, err
}

func (c *Client) sendGetNsxCriteria(ctx context.Context) (res *PageOfNsxTCriterion, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nsxt-clusters/criteria"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNsxCriteriaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNsxCriterion invokes getNsxCriterion operation.
//
// Get a NSX criterion.
//
// GET /v1/nsxt-clusters/criteria/{name}
func (c *Client) GetNsxCriterion(ctx context.Context, params GetNsxCriterionParams) (GetNsxCriterionRes, error) {
	res, err := c.sendGetNsxCriterion(ctx, params)
	return res, err
}

func (c *Client) sendGetNsxCriterion(ctx context.Context, params GetNsxCriterionParams) (res GetNsxCriterionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/nsxt-clusters/criteria/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNsxCriterionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNsxIpAddressPool invokes getNsxIpAddressPool operation.
//
// Retrieve an NSX IP Address Pool by its name.
//
// GET /v1/nsxt-clusters/{nsxt-cluster-id}/ip-address-pools/{name}
func (c *Client) GetNsxIpAddressPool(ctx context.Context, params GetNsxIpAddressPoolParams) (GetNsxIpAddressPoolRes, error) {
	res, err := c.sendGetNsxIpAddressPool(ctx, params)
	return res, err
}

func (c *Client) sendGetNsxIpAddressPool(ctx context.Context, params GetNsxIpAddressPoolParams) (res GetNsxIpAddressPoolRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/nsxt-clusters/"
	{
		// Encode "nsxt-cluster-id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "nsxt-cluster-id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NsxtClusterID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/ip-address-pools/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNsxIpAddressPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNsxIpAddressPools invokes getNsxIpAddressPools operation.
//
// Retrive a list of NSX IP Address Pools by the NSX cluster ID.
//
// GET /v1/nsxt-clusters/{nsxt-cluster-id}/ip-address-pools
func (c *Client) GetNsxIpAddressPools(ctx context.Context, params GetNsxIpAddressPoolsParams) (GetNsxIpAddressPoolsRes, error) {
	res, err := c.sendGetNsxIpAddressPools(ctx, params)
	return res, err
}

func (c *Client) sendGetNsxIpAddressPools(ctx context.Context, params GetNsxIpAddressPoolsParams) (res GetNsxIpAddressPoolsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/nsxt-clusters/"
	{
		// Encode "nsxt-cluster-id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "nsxt-cluster-id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NsxtClusterID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/ip-address-pools"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNsxIpAddressPoolsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNsxTransportZones invokes getNsxTransportZones operation.
//
// Retrieve list of all NSX transport zones.
//
// GET /v1/nsxt-clusters/{nsxt-cluster-id}/transport-zones
func (c *Client) GetNsxTransportZones(ctx context.Context, params GetNsxTransportZonesParams) (GetNsxTransportZonesRes, error) {
	res, err := c.sendGetNsxTransportZones(ctx, params)
	return res, err
}

func (c *Client) sendGetNsxTransportZones(ctx context.Context, params GetNsxTransportZonesParams) (res GetNsxTransportZonesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/nsxt-clusters/"
	{
		// Encode "nsxt-cluster-id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "nsxt-cluster-id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NsxtClusterID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/transport-zones"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNsxTransportZonesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNsxUpgradeResources invokes getNsxUpgradeResources operation.
//
// Get the list NSX upgradable reosurce with resource metadata info.
//
// GET /v1/upgradables/domains/{domainId}/nsxt
func (c *Client) GetNsxUpgradeResources(ctx context.Context, params GetNsxUpgradeResourcesParams) (GetNsxUpgradeResourcesRes, error) {
	res, err := c.sendGetNsxUpgradeResources(ctx, params)
	return res, err
}

func (c *Client) sendGetNsxUpgradeResources(ctx context.Context, params GetNsxUpgradeResourcesParams) (res GetNsxUpgradeResourcesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/upgradables/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/nsxt"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "bundleId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "bundleId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BundleId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNsxUpgradeResourcesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNtpConfiguration invokes getNtpConfiguration operation.
//
// Retrieve the NTP configuration.
//
// GET /v1/system/ntp-configuration
func (c *Client) GetNtpConfiguration(ctx context.Context) (GetNtpConfigurationRes, error) {
	res, err := c.sendGetNtpConfiguration(ctx)
	return res, err
}

func (c *Client) sendGetNtpConfiguration(ctx context.Context) (res GetNtpConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/ntp-configuration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNtpConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPasswordExpiration invokes getPasswordExpiration operation.
//
// Fetch expiration details of passwords for a list of credentials.
//
// POST /v1/credentials/expirations
func (c *Client) GetPasswordExpiration(ctx context.Context, request *CredentialsExpirationSpec) (GetPasswordExpirationRes, error) {
	res, err := c.sendGetPasswordExpiration(ctx, request)
	return res, err
}

func (c *Client) sendGetPasswordExpiration(ctx context.Context, request *CredentialsExpirationSpec) (res GetPasswordExpirationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/credentials/expirations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetPasswordExpirationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPasswordExpirationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPasswordExpirationByTaskID invokes getPasswordExpirationByTaskID operation.
//
// Retrive a password expiration task by ID.
//
// GET /v1/credentials/expirations/{id}
func (c *Client) GetPasswordExpirationByTaskID(ctx context.Context, params GetPasswordExpirationByTaskIDParams) (GetPasswordExpirationByTaskIDRes, error) {
	res, err := c.sendGetPasswordExpirationByTaskID(ctx, params)
	return res, err
}

func (c *Client) sendGetPasswordExpirationByTaskID(ctx context.Context, params GetPasswordExpirationByTaskIDParams) (res GetPasswordExpirationByTaskIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/credentials/expirations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPasswordExpirationByTaskIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPersonalities invokes getPersonalities operation.
//
// Get the Personalities which are available via depot access.
//
// GET /v1/personalities
func (c *Client) GetPersonalities(ctx context.Context, params GetPersonalitiesParams) (GetPersonalitiesRes, error) {
	res, err := c.sendGetPersonalities(ctx, params)
	return res, err
}

func (c *Client) sendGetPersonalities(ctx context.Context, params GetPersonalitiesParams) (res GetPersonalitiesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/personalities"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "baseOSVersion" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "baseOSVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BaseOSVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "addOnName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "addOnName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AddOnName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "addOnVendorName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "addOnVendorName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AddOnVendorName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "componentName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "componentName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ComponentName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "componentVendorName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "componentVendorName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ComponentVendorName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "personalityName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "personalityName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PersonalityName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPersonalitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPersonality invokes getPersonality operation.
//
// Get the Personality for id.
//
// GET /v1/personalities/{personalityId}
func (c *Client) GetPersonality(ctx context.Context, params GetPersonalityParams) (GetPersonalityRes, error) {
	res, err := c.sendGetPersonality(ctx, params)
	return res, err
}

func (c *Client) sendGetPersonality(ctx context.Context, params GetPersonalityParams) (res GetPersonalityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/personalities/"
	{
		// Encode "personalityId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "personalityId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PersonalityId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPersonalityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPrecheckTask invokes getPrecheckTask operation.
//
// Monitor the progress of precheck task by the precheck task ID. As this API is deprecated, please
// use the new LCM Prechecks API - /v1/system/check-sets/{taskId}.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /v1/system/prechecks/tasks/{id}
func (c *Client) GetPrecheckTask(ctx context.Context, params GetPrecheckTaskParams) (GetPrecheckTaskRes, error) {
	res, err := c.sendGetPrecheckTask(ctx, params)
	return res, err
}

func (c *Client) sendGetPrecheckTask(ctx context.Context, params GetPrecheckTaskParams) (res GetPrecheckTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/system/prechecks/tasks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPrecheckTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProductVersionCatalog invokes getProductVersionCatalog operation.
//
// Get product version catalog. There should be only one valid product version catalog in the System.
//
// GET /v1/product-version-catalog
func (c *Client) GetProductVersionCatalog(ctx context.Context) (GetProductVersionCatalogRes, error) {
	res, err := c.sendGetProductVersionCatalog(ctx)
	return res, err
}

func (c *Client) sendGetProductVersionCatalog(ctx context.Context) (res GetProductVersionCatalogRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/product-version-catalog"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetProductVersionCatalogResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProxyConfiguration invokes getProxyConfiguration operation.
//
// Get the current Proxy configuration.
//
// GET /v1/system/proxy-configuration
func (c *Client) GetProxyConfiguration(ctx context.Context) (GetProxyConfigurationRes, error) {
	res, err := c.sendGetProxyConfiguration(ctx)
	return res, err
}

func (c *Client) sendGetProxyConfiguration(ctx context.Context) (res GetProxyConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/proxy-configuration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetProxyConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPsc invokes getPsc operation.
//
// Retrieve details of a Platform Service Controller (PSC).
//
// GET /v1/pscs/{id}
func (c *Client) GetPsc(ctx context.Context, params GetPscParams) (GetPscRes, error) {
	res, err := c.sendGetPsc(ctx, params)
	return res, err
}

func (c *Client) sendGetPsc(ctx context.Context, params GetPscParams) (res GetPscRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/pscs/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPscResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPscs invokes getPscs operation.
//
// Retrieve a list of Platform Service Controller (PSC).
//
// GET /v1/pscs
func (c *Client) GetPscs(ctx context.Context) (GetPscsRes, error) {
	res, err := c.sendGetPscs(ctx)
	return res, err
}

func (c *Client) sendGetPscs(ctx context.Context) (res GetPscsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/pscs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPscsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetReconciliationTask invokes getReconciliationTask operation.
//
// Get config reconciliation task associated with the given task Id.
//
// GET /v1/config-drift-reconciliations/{taskId}
func (c *Client) GetReconciliationTask(ctx context.Context, params GetReconciliationTaskParams) (GetReconciliationTaskRes, error) {
	res, err := c.sendGetReconciliationTask(ctx, params)
	return res, err
}

func (c *Client) sendGetReconciliationTask(ctx context.Context, params GetReconciliationTaskParams) (res GetReconciliationTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/config-drift-reconciliations/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetReconciliationTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetReleaseByDomain invokes getReleaseByDomain operation.
//
// Get last selected upgrade version for the domain.
//
// GET /v1/releases/domains/{domainId}
func (c *Client) GetReleaseByDomain(ctx context.Context, params GetReleaseByDomainParams) (GetReleaseByDomainRes, error) {
	res, err := c.sendGetReleaseByDomain(ctx, params)
	return res, err
}

func (c *Client) sendGetReleaseByDomain(ctx context.Context, params GetReleaseByDomainParams) (res GetReleaseByDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/releases/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetReleaseByDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetReleaseByDomains invokes getReleaseByDomains operation.
//
// Get last selected upgrade version for WLDs.
//
// GET /v1/releases/domains
func (c *Client) GetReleaseByDomains(ctx context.Context) (GetReleaseByDomainsRes, error) {
	res, err := c.sendGetReleaseByDomains(ctx)
	return res, err
}

func (c *Client) sendGetReleaseByDomains(ctx context.Context) (res GetReleaseByDomainsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/releases/domains"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetReleaseByDomainsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetReleases invokes getReleases operation.
//
// Get all Releases, with option to get current release for a domain, get release by version or get
// future releases for a versionor get all the applicable target release.
//
// GET /v1/releases
func (c *Client) GetReleases(ctx context.Context, params GetReleasesParams) (GetReleasesRes, error) {
	res, err := c.sendGetReleases(ctx, params)
	return res, err
}

func (c *Client) sendGetReleases(ctx context.Context, params GetReleasesParams) (res GetReleasesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/releases"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "domainId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DomainId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "versionEq" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "versionEq",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VersionEq.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vxRailVersionEq" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vxRailVersionEq",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VxRailVersionEq.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "versionGt" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "versionGt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VersionGt.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vxRailVersionGt" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vxRailVersionGt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VxRailVersionGt.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "applicableForVersion" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "applicableForVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ApplicableForVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "applicableForVxRailVersion" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "applicableForVxRailVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ApplicableForVxRailVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "getFutureReleases" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "getFutureReleases",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GetFutureReleases.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetReleasesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetResourceCertificatesValidationByID invokes getResourceCertificatesValidationByID operation.
//
// Get the resource certificate validation result.
//
// GET /v1/domains/{id}/resource-certificates/validations/{validationId}
func (c *Client) GetResourceCertificatesValidationByID(ctx context.Context, params GetResourceCertificatesValidationByIDParams) (GetResourceCertificatesValidationByIDRes, error) {
	res, err := c.sendGetResourceCertificatesValidationByID(ctx, params)
	return res, err
}

func (c *Client) sendGetResourceCertificatesValidationByID(ctx context.Context, params GetResourceCertificatesValidationByIDParams) (res GetResourceCertificatesValidationByIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/resource-certificates/validations/"
	{
		// Encode "validationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "validationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ValidationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetResourceCertificatesValidationByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetResourceFunctionalities invokes getResourceFunctionalities operation.
//
// Get Resource Functionalities.
//
// GET /v1/resource-functionalities
func (c *Client) GetResourceFunctionalities(ctx context.Context, params GetResourceFunctionalitiesParams) (GetResourceFunctionalitiesRes, error) {
	res, err := c.sendGetResourceFunctionalities(ctx, params)
	return res, err
}

func (c *Client) sendGetResourceFunctionalities(ctx context.Context, params GetResourceFunctionalitiesParams) (res GetResourceFunctionalitiesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/resource-functionalities"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "resourceType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResourceType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "functionalityType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "functionalityType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FunctionalityType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "resourceIds" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceIds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.ResourceIds != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.ResourceIds {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "isAllowed" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "isAllowed",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsAllowed.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "parentResourceType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "parentResourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ParentResourceType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetResourceFunctionalitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetResourceWarning invokes getResourceWarning operation.
//
// Get a Resource Warning by ID.
//
// GET /v1/resource-warnings/{id}
func (c *Client) GetResourceWarning(ctx context.Context, params GetResourceWarningParams) (GetResourceWarningRes, error) {
	res, err := c.sendGetResourceWarning(ctx, params)
	return res, err
}

func (c *Client) sendGetResourceWarning(ctx context.Context, params GetResourceWarningParams) (res GetResourceWarningRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/resource-warnings/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetResourceWarningResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetResourceWarnings invokes getResourceWarnings operation.
//
// Get Resource Warnings.
//
// GET /v1/resource-warnings
func (c *Client) GetResourceWarnings(ctx context.Context, params GetResourceWarningsParams) (GetResourceWarningsRes, error) {
	res, err := c.sendGetResourceWarnings(ctx, params)
	return res, err
}

func (c *Client) sendGetResourceWarnings(ctx context.Context, params GetResourceWarningsParams) (res GetResourceWarningsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/resource-warnings"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "resourceType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResourceType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "resourceIds" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceIds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.ResourceIds != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.ResourceIds {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "resourceNames" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceNames",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.ResourceNames != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.ResourceNames {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetResourceWarningsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetResourcesFunctionalitiesAllowedGlobal invokes getResourcesFunctionalitiesAllowedGlobal operation.
//
// Get Resource Functionalities Allowed Global Configuration.
//
// GET /v1/resource-functionalities/global
func (c *Client) GetResourcesFunctionalitiesAllowedGlobal(ctx context.Context) (GetResourcesFunctionalitiesAllowedGlobalRes, error) {
	res, err := c.sendGetResourcesFunctionalitiesAllowedGlobal(ctx)
	return res, err
}

func (c *Client) sendGetResourcesFunctionalitiesAllowedGlobal(ctx context.Context) (res GetResourcesFunctionalitiesAllowedGlobalRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/resource-functionalities/global"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetResourcesFunctionalitiesAllowedGlobalResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRestoreTask invokes getRestoreTask operation.
//
// Retrieve the restore task.
//
// GET /v1/restores/tasks/{id}
func (c *Client) GetRestoreTask(ctx context.Context, params GetRestoreTaskParams) (GetRestoreTaskRes, error) {
	res, err := c.sendGetRestoreTask(ctx, params)
	return res, err
}

func (c *Client) sendGetRestoreTask(ctx context.Context, params GetRestoreTaskParams) (res GetRestoreTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/restores/tasks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRestoreTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetResult invokes getResult operation.
//
// Get the result for a given check run.
//
// GET /v1/system/check-sets/{runId}
func (c *Client) GetResult(ctx context.Context, params GetResultParams) (GetResultRes, error) {
	res, err := c.sendGetResult(ctx, params)
	return res, err
}

func (c *Client) sendGetResult(ctx context.Context, params GetResultParams) (res GetResultRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/system/check-sets/"
	{
		// Encode "runId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RunId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetResultResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRoles invokes getRoles operation.
//
// Get a list of all roles.
//
// GET /v1/roles
func (c *Client) GetRoles(ctx context.Context) (GetRolesRes, error) {
	res, err := c.sendGetRoles(ctx)
	return res, err
}

func (c *Client) sendGetRoles(ctx context.Context) (res GetRolesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/roles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRolesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSSODomainEntities invokes getSSODomainEntities operation.
//
// Get a list of all entities in the SSO domain.
//
// GET /v1/sso-domains/{sso-domain}/entities
func (c *Client) GetSSODomainEntities(ctx context.Context, params GetSSODomainEntitiesParams) (GetSSODomainEntitiesRes, error) {
	res, err := c.sendGetSSODomainEntities(ctx, params)
	return res, err
}

func (c *Client) sendGetSSODomainEntities(ctx context.Context, params GetSSODomainEntitiesParams) (res GetSSODomainEntitiesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/sso-domains/"
	{
		// Encode "sso-domain" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sso-domain",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SSODomain))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/entities"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "entityName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "entityName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EntityName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSSODomainEntitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSSODomains invokes getSSODomains operation.
//
// Get a list of all SSO domains.
//
// GET /v1/sso-domains
func (c *Client) GetSSODomains(ctx context.Context) (GetSSODomainsRes, error) {
	res, err := c.sendGetSSODomains(ctx)
	return res, err
}

func (c *Client) sendGetSSODomains(ctx context.Context) (res GetSSODomainsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sso-domains"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSSODomainsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSddcManager invokes getSddcManager operation.
//
// Retrieve the details of an SDDC Manager by its id.
//
// GET /v1/sddc-managers/{id}
func (c *Client) GetSddcManager(ctx context.Context, params GetSddcManagerParams) (GetSddcManagerRes, error) {
	res, err := c.sendGetSddcManager(ctx, params)
	return res, err
}

func (c *Client) sendGetSddcManager(ctx context.Context, params GetSddcManagerParams) (res GetSddcManagerRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/sddc-managers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSddcManagerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSddcManagerHistory invokes getSddcManagerHistory operation.
//
// Retrieve the history of SDDC Manager by its id.
//
// GET /v1/sddc-managers/{id}/history
func (c *Client) GetSddcManagerHistory(ctx context.Context, params GetSddcManagerHistoryParams) (GetSddcManagerHistoryRes, error) {
	res, err := c.sendGetSddcManagerHistory(ctx, params)
	return res, err
}

func (c *Client) sendGetSddcManagerHistory(ctx context.Context, params GetSddcManagerHistoryParams) (res GetSddcManagerHistoryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/sddc-managers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/history"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSddcManagerHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSddcManagerInfo invokes getSddcManagerInfo operation.
//
// Retrieves the details of SDDC Manager VM.
//
// GET /v1/sddcs/{id}/sddc-manager
func (c *Client) GetSddcManagerInfo(ctx context.Context, params GetSddcManagerInfoParams) (GetSddcManagerInfoRes, error) {
	res, err := c.sendGetSddcManagerInfo(ctx, params)
	return res, err
}

func (c *Client) sendGetSddcManagerInfo(ctx context.Context, params GetSddcManagerInfoParams) (res GetSddcManagerInfoRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/sddcs/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/sddc-manager"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSddcManagerInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSddcManagers invokes getSddcManagers operation.
//
// Retrieve a list of SDDC Managers.
//
// GET /v1/sddc-managers
func (c *Client) GetSddcManagers(ctx context.Context) (GetSddcManagersRes, error) {
	res, err := c.sendGetSddcManagers(ctx)
	return res, err
}

func (c *Client) sendGetSddcManagers(ctx context.Context) (res GetSddcManagersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sddc-managers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSddcManagersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSddcWs1bOidcInfo invokes getSddcWs1bOidcInfo operation.
//
// Get the SDDC Manager WS1B OIDC Information.
//
// GET /v1/identity-broker/sddc-manager-oidc
func (c *Client) GetSddcWs1bOidcInfo(ctx context.Context) (GetSddcWs1bOidcInfoRes, error) {
	res, err := c.sendGetSddcWs1bOidcInfo(ctx)
	return res, err
}

func (c *Client) sendGetSddcWs1bOidcInfo(ctx context.Context) (res GetSddcWs1bOidcInfoRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/identity-broker/sddc-manager-oidc"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSddcWs1bOidcInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSupportBundleStatus invokes getSupportBundleStatus operation.
//
// Retrive the status of the Support Bundle operation.
//
// GET /v1/system/support-bundles/{id}
func (c *Client) GetSupportBundleStatus(ctx context.Context, params GetSupportBundleStatusParams) (GetSupportBundleStatusRes, error) {
	res, err := c.sendGetSupportBundleStatus(ctx, params)
	return res, err
}

func (c *Client) sendGetSupportBundleStatus(ctx context.Context, params GetSupportBundleStatusParams) (res GetSupportBundleStatusRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/system/support-bundles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSupportBundleStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSupportBundleTask invokes getSupportBundleTask operation.
//
// Retrieve a list of Support Bundle tasks.
//
// GET /v1/system/support-bundles
func (c *Client) GetSupportBundleTask(ctx context.Context) (GetSupportBundleTaskRes, error) {
	res, err := c.sendGetSupportBundleTask(ctx)
	return res, err
}

func (c *Client) sendGetSupportBundleTask(ctx context.Context) (res GetSupportBundleTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/support-bundles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSupportBundleTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSystemConfiguration invokes getSystemConfiguration operation.
//
// Retrieve the system configuration.
//
// GET /v1/system
func (c *Client) GetSystemConfiguration(ctx context.Context) (GetSystemConfigurationRes, error) {
	res, err := c.sendGetSystemConfiguration(ctx)
	return res, err
}

func (c *Client) sendGetSystemConfiguration(ctx context.Context) (res GetSystemConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSystemConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSystemRelease invokes getSystemRelease operation.
//
// Returns release for the lowest deployed VCF version for a domain on the environment.If Management
// domain is ahead of WLD domain, VCF BOM version for the WLDdomain will be returned.
//
// GET /v1/releases/system
func (c *Client) GetSystemRelease(ctx context.Context) (GetSystemReleaseRes, error) {
	res, err := c.sendGetSystemRelease(ctx)
	return res, err
}

func (c *Client) sendGetSystemRelease(ctx context.Context) (res GetSystemReleaseRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/releases/system"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSystemReleaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTagAssignableForCluster invokes getTagAssignableForCluster operation.
//
// Get tags assignable to a cluster.
//
// GET /v1/clusters/{id}/tags/assignable-tags
func (c *Client) GetTagAssignableForCluster(ctx context.Context, params GetTagAssignableForClusterParams) (GetTagAssignableForClusterRes, error) {
	res, err := c.sendGetTagAssignableForCluster(ctx, params)
	return res, err
}

func (c *Client) sendGetTagAssignableForCluster(ctx context.Context, params GetTagAssignableForClusterParams) (res GetTagAssignableForClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags/assignable-tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTagAssignableForClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTagsAssignedToCluster invokes getTagsAssignedToCluster operation.
//
// Get tags assigned to a cluster by its ID.
//
// GET /v1/clusters/{id}/tags
func (c *Client) GetTagsAssignedToCluster(ctx context.Context, params GetTagsAssignedToClusterParams) (GetTagsAssignedToClusterRes, error) {
	res, err := c.sendGetTagsAssignedToCluster(ctx, params)
	return res, err
}

func (c *Client) sendGetTagsAssignedToCluster(ctx context.Context, params GetTagsAssignedToClusterParams) (res GetTagsAssignedToClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTagsAssignedToClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTagsAssignedToClusters invokes getTagsAssignedToClusters operation.
//
// Get tags assigned to clusters.
//
// GET /v1/clusters/tags
func (c *Client) GetTagsAssignedToClusters(ctx context.Context) (GetTagsAssignedToClustersRes, error) {
	res, err := c.sendGetTagsAssignedToClusters(ctx)
	return res, err
}

func (c *Client) sendGetTagsAssignedToClusters(ctx context.Context) (res GetTagsAssignedToClustersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/clusters/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTagsAssignedToClustersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTagsAssignedToDomain invokes getTagsAssignedToDomain operation.
//
// Get tags assigned to a domain.
//
// GET /v1/domains/{id}/tags
func (c *Client) GetTagsAssignedToDomain(ctx context.Context, params GetTagsAssignedToDomainParams) (GetTagsAssignedToDomainRes, error) {
	res, err := c.sendGetTagsAssignedToDomain(ctx, params)
	return res, err
}

func (c *Client) sendGetTagsAssignedToDomain(ctx context.Context, params GetTagsAssignedToDomainParams) (res GetTagsAssignedToDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTagsAssignedToDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTagsAssignedToDomains invokes getTagsAssignedToDomains operation.
//
// Get tags assigned to all domains.
//
// GET /v1/domains/tags
func (c *Client) GetTagsAssignedToDomains(ctx context.Context) (GetTagsAssignedToDomainsRes, error) {
	res, err := c.sendGetTagsAssignedToDomains(ctx)
	return res, err
}

func (c *Client) sendGetTagsAssignedToDomains(ctx context.Context) (res GetTagsAssignedToDomainsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/domains/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTagsAssignedToDomainsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTagsAssignedToHost invokes getTagsAssignedToHost operation.
//
// Get Tags assigned to Host.
//
// GET /v1/hosts/{id}/tags
func (c *Client) GetTagsAssignedToHost(ctx context.Context, params GetTagsAssignedToHostParams) (GetTagsAssignedToHostRes, error) {
	res, err := c.sendGetTagsAssignedToHost(ctx, params)
	return res, err
}

func (c *Client) sendGetTagsAssignedToHost(ctx context.Context, params GetTagsAssignedToHostParams) (res GetTagsAssignedToHostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/hosts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTagsAssignedToHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTagsAssignedToHosts invokes getTagsAssignedToHosts operation.
//
// Get Tags assigned to Hosts.
//
// GET /v1/hosts/tags
func (c *Client) GetTagsAssignedToHosts(ctx context.Context) (GetTagsAssignedToHostsRes, error) {
	res, err := c.sendGetTagsAssignedToHosts(ctx)
	return res, err
}

func (c *Client) sendGetTagsAssignedToHosts(ctx context.Context) (res GetTagsAssignedToHostsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hosts/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTagsAssignedToHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTask invokes getTask operation.
//
// Get a Task by ID, if it exists.
//
// GET /v1/tasks/{id}
func (c *Client) GetTask(ctx context.Context, params GetTaskParams) (GetTaskRes, error) {
	res, err := c.sendGetTask(ctx, params)
	return res, err
}

func (c *Client) sendGetTask(ctx context.Context, params GetTaskParams) (res GetTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/tasks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTasks invokes getTasks operation.
//
// Get the tasks.
//
// GET /v1/tasks
func (c *Client) GetTasks(ctx context.Context, params GetTasksParams) (GetTasksRes, error) {
	res, err := c.sendGetTasks(ctx, params)
	return res, err
}

func (c *Client) sendGetTasks(ctx context.Context, params GetTasksParams) (res GetTasksRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "taskStatus" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "taskStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TaskStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "taskType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "taskType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TaskType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "resourceId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResourceId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "resourceType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resourceType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResourceType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "completedAfter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "completedAfter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CompletedAfter.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageNumber" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "orderDirection" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "orderDirection",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OrderDirection.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "orderBy" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "orderBy",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OrderBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "taskName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "taskName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TaskName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTasksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTrustedCertificates invokes getTrustedCertificates operation.
//
// Retrieve all trusted certificates from SDDC Manager.
//
// GET /v1/sddc-manager/trusted-certificates
func (c *Client) GetTrustedCertificates(ctx context.Context) (GetTrustedCertificatesRes, error) {
	res, err := c.sendGetTrustedCertificates(ctx)
	return res, err
}

func (c *Client) sendGetTrustedCertificates(ctx context.Context) (res GetTrustedCertificatesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sddc-manager/trusted-certificates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTrustedCertificatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUiUsers invokes getUiUsers operation.
//
// Retrieve a list of users assigned access via SDDC Manager.
//
// GET /v1/users/ui
func (c *Client) GetUiUsers(ctx context.Context) (GetUiUsersRes, error) {
	res, err := c.sendGetUiUsers(ctx)
	return res, err
}

func (c *Client) sendGetUiUsers(ctx context.Context) (res GetUiUsersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/users/ui"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUiUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUpgradables invokes getUpgradables operation.
//
// Fetches the list of Upgradables in the System. Only one Upgradable becomes AVAILABLE for Upgrade.
// The Upgradables provides information that can be use for Precheck API and also in the actual
// Upgrade API call.
//
// GET /v1/system/upgradables
func (c *Client) GetUpgradables(ctx context.Context) (GetUpgradablesRes, error) {
	res, err := c.sendGetUpgradables(ctx)
	return res, err
}

func (c *Client) sendGetUpgradables(ctx context.Context) (res GetUpgradablesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/upgradables"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUpgradablesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUpgradablesByDomain invokes getUpgradablesByDomain operation.
//
// Fetches the list of Upgradables for a given domain. If a target version is provided, Upgradables
// that are required for given target version become Available. The Upgradables providesinformation
// that can be use for Precheck API and also in the actual Upgrade API call.This API is used only for
// management domain, for all cases please use v1/system/upgradables.
//
// GET /v1/upgradables/domains/{domainId}
func (c *Client) GetUpgradablesByDomain(ctx context.Context, params GetUpgradablesByDomainParams) (GetUpgradablesByDomainRes, error) {
	res, err := c.sendGetUpgradablesByDomain(ctx, params)
	return res, err
}

func (c *Client) sendGetUpgradablesByDomain(ctx context.Context, params GetUpgradablesByDomainParams) (res GetUpgradablesByDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/upgradables/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "targetVersion" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "targetVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TargetVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUpgradablesByDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUpgradablesClusters invokes getUpgradablesClusters operation.
//
// Fetches the list of available hardware support managers and configured hardware support managers
// for the give resource along with the hardware support packages and Software details.
//
// GET /v1/upgradables/domains/{domainId}/clusters
func (c *Client) GetUpgradablesClusters(ctx context.Context, params GetUpgradablesClustersParams) (GetUpgradablesClustersRes, error) {
	res, err := c.sendGetUpgradablesClusters(ctx, params)
	return res, err
}

func (c *Client) sendGetUpgradablesClusters(ctx context.Context, params GetUpgradablesClustersParams) (res GetUpgradablesClustersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/upgradables/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/clusters"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUpgradablesClustersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUpgradeById invokes getUpgradeById operation.
//
// Retrieve an upgrade by ID.
//
// GET /v1/upgrades/{upgradeId}
func (c *Client) GetUpgradeById(ctx context.Context, params GetUpgradeByIdParams) (GetUpgradeByIdRes, error) {
	res, err := c.sendGetUpgradeById(ctx, params)
	return res, err
}

func (c *Client) sendGetUpgradeById(ctx context.Context, params GetUpgradeByIdParams) (res GetUpgradeByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/upgrades/"
	{
		// Encode "upgradeId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "upgradeId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UpgradeId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUpgradeByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUpgradePrecheckByID invokes getUpgradePrecheckByID operation.
//
// Gets upgrade precheck details.
//
// GET /v1/upgrades/{upgradeId}/prechecks/{precheckId}
func (c *Client) GetUpgradePrecheckByID(ctx context.Context, params GetUpgradePrecheckByIDParams) (GetUpgradePrecheckByIDRes, error) {
	res, err := c.sendGetUpgradePrecheckByID(ctx, params)
	return res, err
}

func (c *Client) sendGetUpgradePrecheckByID(ctx context.Context, params GetUpgradePrecheckByIDParams) (res GetUpgradePrecheckByIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/upgrades/"
	{
		// Encode "upgradeId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "upgradeId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UpgradeId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/prechecks/"
	{
		// Encode "precheckId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "precheckId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PrecheckId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUpgradePrecheckByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUpgrades invokes getUpgrades operation.
//
// Retrieve a list of upgrades.
//
// GET /v1/upgrades
func (c *Client) GetUpgrades(ctx context.Context, params GetUpgradesParams) (GetUpgradesRes, error) {
	res, err := c.sendGetUpgrades(ctx, params)
	return res, err
}

func (c *Client) sendGetUpgrades(ctx context.Context, params GetUpgradesParams) (res GetUpgradesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/upgrades"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "bundleId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "bundleId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BundleId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "bundleType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "bundleType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BundleType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUpgradesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUsers invokes getUsers operation.
//
// Get a list of all users.
//
// GET /v1/users
func (c *Client) GetUsers(ctx context.Context) (GetUsersRes, error) {
	res, err := c.sendGetUsers(ctx)
	return res, err
}

func (c *Client) sendGetUsers(ctx context.Context) (res GetUsersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetValidationOfDnsConfiguration invokes getValidationOfDnsConfiguration operation.
//
// Retrieve the results of a DNS configuration validation by its ID.
//
// GET /v1/system/dns-configuration/validations/{id}
func (c *Client) GetValidationOfDnsConfiguration(ctx context.Context, params GetValidationOfDnsConfigurationParams) (GetValidationOfDnsConfigurationRes, error) {
	res, err := c.sendGetValidationOfDnsConfiguration(ctx, params)
	return res, err
}

func (c *Client) sendGetValidationOfDnsConfiguration(ctx context.Context, params GetValidationOfDnsConfigurationParams) (res GetValidationOfDnsConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/system/dns-configuration/validations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetValidationOfDnsConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetValidationOfNtpConfiguration invokes getValidationOfNtpConfiguration operation.
//
// Retrieve the results of a NTP configuration  validation by its ID.
//
// GET /v1/system/ntp-configuration/validations/{id}
func (c *Client) GetValidationOfNtpConfiguration(ctx context.Context, params GetValidationOfNtpConfigurationParams) (GetValidationOfNtpConfigurationRes, error) {
	res, err := c.sendGetValidationOfNtpConfiguration(ctx, params)
	return res, err
}

func (c *Client) sendGetValidationOfNtpConfiguration(ctx context.Context, params GetValidationOfNtpConfigurationParams) (res GetValidationOfNtpConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/system/ntp-configuration/validations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetValidationOfNtpConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetValidationResult invokes getValidationResult operation.
//
// GET /v1/nsxt-clusters/ip-address-pools/validations/{id}
func (c *Client) GetValidationResult(ctx context.Context, params GetValidationResultParams) (*Validation, error) {
	res, err := c.sendGetValidationResult(ctx, params)
	return res, err
}

func (c *Client) sendGetValidationResult(ctx context.Context, params GetValidationResultParams) (res *Validation, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/nsxt-clusters/ip-address-pools/validations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetValidationResultResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetValidationsOfDNSConfiguration invokes getValidationsOfDNSConfiguration operation.
//
// Retrieve a list of DNS configuation validations.
//
// GET /v1/system/dns-configuration/validations
func (c *Client) GetValidationsOfDNSConfiguration(ctx context.Context, params GetValidationsOfDNSConfigurationParams) (GetValidationsOfDNSConfigurationRes, error) {
	res, err := c.sendGetValidationsOfDNSConfiguration(ctx, params)
	return res, err
}

func (c *Client) sendGetValidationsOfDNSConfiguration(ctx context.Context, params GetValidationsOfDNSConfigurationParams) (res GetValidationsOfDNSConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/dns-configuration/validations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "executionStatus" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "executionStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExecutionStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetValidationsOfDNSConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetValidationsOfNtpConfiguration invokes getValidationsOfNtpConfiguration operation.
//
// Retrieve a list of NTP configuation validations.
//
// GET /v1/system/ntp-configuration/validations
func (c *Client) GetValidationsOfNtpConfiguration(ctx context.Context, params GetValidationsOfNtpConfigurationParams) (GetValidationsOfNtpConfigurationRes, error) {
	res, err := c.sendGetValidationsOfNtpConfiguration(ctx, params)
	return res, err
}

func (c *Client) sendGetValidationsOfNtpConfiguration(ctx context.Context, params GetValidationsOfNtpConfigurationParams) (res GetValidationsOfNtpConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/ntp-configuration/validations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "executionStatus" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "executionStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExecutionStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetValidationsOfNtpConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVasaProvider invokes getVasaProvider operation.
//
// Get a VASA Provider.
//
// GET /v1/vasa-providers/{id}
func (c *Client) GetVasaProvider(ctx context.Context, params GetVasaProviderParams) (GetVasaProviderRes, error) {
	res, err := c.sendGetVasaProvider(ctx, params)
	return res, err
}

func (c *Client) sendGetVasaProvider(ctx context.Context, params GetVasaProviderParams) (res GetVasaProviderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/vasa-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVasaProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVasaProviderStorageContainers invokes getVasaProviderStorageContainers operation.
//
// Get the storage containers of a VASA Provider.
//
// GET /v1/vasa-providers/{id}/storage-containers
func (c *Client) GetVasaProviderStorageContainers(ctx context.Context, params GetVasaProviderStorageContainersParams) (GetVasaProviderStorageContainersRes, error) {
	res, err := c.sendGetVasaProviderStorageContainers(ctx, params)
	return res, err
}

func (c *Client) sendGetVasaProviderStorageContainers(ctx context.Context, params GetVasaProviderStorageContainersParams) (res GetVasaProviderStorageContainersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/vasa-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/storage-containers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "protocolType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "protocolType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProtocolType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVasaProviderStorageContainersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVasaProviderUser invokes getVasaProviderUser operation.
//
// Get the users of a VASA Provider.
//
// GET /v1/vasa-providers/{id}/users
func (c *Client) GetVasaProviderUser(ctx context.Context, params GetVasaProviderUserParams) (GetVasaProviderUserRes, error) {
	res, err := c.sendGetVasaProviderUser(ctx, params)
	return res, err
}

func (c *Client) sendGetVasaProviderUser(ctx context.Context, params GetVasaProviderUserParams) (res GetVasaProviderUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/vasa-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVasaProviderUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVasaProviderValidation invokes getVasaProviderValidation operation.
//
// Get the status of the validation of the VASA Provider.
//
// GET /v1/vasa-providers/validations/{id}
func (c *Client) GetVasaProviderValidation(ctx context.Context, params GetVasaProviderValidationParams) (GetVasaProviderValidationRes, error) {
	res, err := c.sendGetVasaProviderValidation(ctx, params)
	return res, err
}

func (c *Client) sendGetVasaProviderValidation(ctx context.Context, params GetVasaProviderValidationParams) (res GetVasaProviderValidationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/vasa-providers/validations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVasaProviderValidationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVasaProviders invokes getVasaProviders operation.
//
// Get the VASA Providers.
//
// GET /v1/vasa-providers
func (c *Client) GetVasaProviders(ctx context.Context) (GetVasaProvidersRes, error) {
	res, err := c.sendGetVasaProviders(ctx)
	return res, err
}

func (c *Client) sendGetVasaProviders(ctx context.Context) (res GetVasaProvidersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vasa-providers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVasaProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVcenter invokes getVcenter operation.
//
// Retrieve a vCenter Server by its ID.
//
// GET /v1/vcenters/{id}
func (c *Client) GetVcenter(ctx context.Context, params GetVcenterParams) (GetVcenterRes, error) {
	res, err := c.sendGetVcenter(ctx, params)
	return res, err
}

func (c *Client) sendGetVcenter(ctx context.Context, params GetVcenterParams) (res GetVcenterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/vcenters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVcenterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVcenters invokes getVcenters operation.
//
// Retrieve a list of vCenter Servers.
//
// GET /v1/vcenters
func (c *Client) GetVcenters(ctx context.Context, params GetVcentersParams) (GetVcentersRes, error) {
	res, err := c.sendGetVcenters(ctx, params)
	return res, err
}

func (c *Client) sendGetVcenters(ctx context.Context, params GetVcentersParams) (res GetVcentersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vcenters"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "domainId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "domainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DomainId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVcentersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVcfService invokes getVcfService operation.
//
// Retrieve an SDDC Manager service by its ID.
//
// GET /v1/vcf-services/{id}
func (c *Client) GetVcfService(ctx context.Context, params GetVcfServiceParams) (GetVcfServiceRes, error) {
	res, err := c.sendGetVcfService(ctx, params)
	return res, err
}

func (c *Client) sendGetVcfService(ctx context.Context, params GetVcfServiceParams) (res GetVcfServiceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/vcf-services/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVcfServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVcfServices invokes getVcfServices operation.
//
// Retrieve a list of SDDC Manager services.
//
// GET /v1/vcf-services
func (c *Client) GetVcfServices(ctx context.Context) (GetVcfServicesRes, error) {
	res, err := c.sendGetVcfServices(ctx)
	return res, err
}

func (c *Client) sendGetVcfServices(ctx context.Context) (res GetVcfServicesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vcf-services"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVcfServicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVdses invokes getVdses operation.
//
// Get the list of VDSes of a cluster.
//
// GET /v1/clusters/{clusterId}/vdses
func (c *Client) GetVdses(ctx context.Context, params GetVdsesParams) (GetVdsesRes, error) {
	res, err := c.sendGetVdses(ctx, params)
	return res, err
}

func (c *Client) sendGetVdses(ctx context.Context, params GetVdsesParams) (res GetVdsesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "clusterId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/vdses"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVdsesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVersionAliasConfiguration invokes getVersionAliasConfiguration operation.
//
// Get the Version Alias Configuration.
//
// GET /v1/system/settings/version-aliases
func (c *Client) GetVersionAliasConfiguration(ctx context.Context) (GetVersionAliasConfigurationRes, error) {
	res, err := c.sendGetVersionAliasConfiguration(ctx)
	return res, err
}

func (c *Client) sendGetVersionAliasConfiguration(ctx context.Context) (res GetVersionAliasConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/settings/version-aliases"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVersionAliasConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVras invokes getVras operation.
//
// Retrieve a list of VMware Aria Automation instances.
//
// GET /v1/vras
func (c *Client) GetVras(ctx context.Context) (*PageOfVra, error) {
	res, err := c.sendGetVras(ctx)
	return res, err
}

func (c *Client) sendGetVras(ctx context.Context) (res *PageOfVra, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vras"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVrasResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVrliIntegratedDomains invokes getVrliIntegratedDomains operation.
//
// Retrieve a list of VMware Aria Operations for Logs integration status for domains.
//
// GET /v1/vrli/domains
func (c *Client) GetVrliIntegratedDomains(ctx context.Context) (*PageOfDomainIntegration, error) {
	res, err := c.sendGetVrliIntegratedDomains(ctx)
	return res, err
}

func (c *Client) sendGetVrliIntegratedDomains(ctx context.Context) (res *PageOfDomainIntegration, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrli/domains"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVrliIntegratedDomainsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVrlis invokes getVrlis operation.
//
// Retrieve a list of VMware Aria Operations for Logs instances.
//
// GET /v1/vrlis
func (c *Client) GetVrlis(ctx context.Context) (*PageOfVrli, error) {
	res, err := c.sendGetVrlis(ctx)
	return res, err
}

func (c *Client) sendGetVrlis(ctx context.Context) (res *PageOfVrli, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrlis"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVrlisResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVropsIntegratedDomains invokes getVropsIntegratedDomains operation.
//
// Retrieves the existing  domains and their connection status with Aria Operations.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /v1/vrops/domains
func (c *Client) GetVropsIntegratedDomains(ctx context.Context) (*PageOfDomainIntegration, error) {
	res, err := c.sendGetVropsIntegratedDomains(ctx)
	return res, err
}

func (c *Client) sendGetVropsIntegratedDomains(ctx context.Context) (res *PageOfDomainIntegration, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrops/domains"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVropsIntegratedDomainsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVropses invokes getVropses operation.
//
// Retrieve a list of VMware Aria Operations instances.
//
// GET /v1/vropses
func (c *Client) GetVropses(ctx context.Context) (*PageOfVrops, error) {
	res, err := c.sendGetVropses(ctx)
	return res, err
}

func (c *Client) sendGetVropses(ctx context.Context) (res *PageOfVrops, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vropses"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVropsesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVrslcm invokes getVrslcm operation.
//
// Gets the complete information about the existing VMware Aria Suite Lifecycle instance.
//
// GET /v1/vrslcm
func (c *Client) GetVrslcm(ctx context.Context) (GetVrslcmRes, error) {
	res, err := c.sendGetVrslcm(ctx)
	return res, err
}

func (c *Client) sendGetVrslcm(ctx context.Context) (res GetVrslcmRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrslcm"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVrslcmResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVrslcmStatus invokes getVrslcmStatus operation.
//
// Get status on the VMware Aria Suite Lifecycle product and availability of different actions.
//
// GET /v1/vrslcm/status
func (c *Client) GetVrslcmStatus(ctx context.Context) (GetVrslcmStatusRes, error) {
	res, err := c.sendGetVrslcmStatus(ctx)
	return res, err
}

func (c *Client) sendGetVrslcmStatus(ctx context.Context) (res GetVrslcmStatusRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrslcm/status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVrslcmStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVrslcmValidation invokes getVrslcmValidation operation.
//
// Gets the status of given VMware Aria Suite Lifecycle validation workflow by given validation id.
//
// GET /v1/vrslcms/validations/{id}
func (c *Client) GetVrslcmValidation(ctx context.Context, params GetVrslcmValidationParams) (GetVrslcmValidationRes, error) {
	res, err := c.sendGetVrslcmValidation(ctx, params)
	return res, err
}

func (c *Client) sendGetVrslcmValidation(ctx context.Context, params GetVrslcmValidationParams) (res GetVrslcmValidationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/vrslcms/validations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVrslcmValidationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVrslcms invokes getVrslcms operation.
//
// Get all existing VMware Aria Suite Lifecycle instances.
//
// GET /v1/vrslcms
func (c *Client) GetVrslcms(ctx context.Context) (*PageOfVrslcm, error) {
	res, err := c.sendGetVrslcms(ctx)
	return res, err
}

func (c *Client) sendGetVrslcms(ctx context.Context) (res *PageOfVrslcm, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrslcms"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVrslcmsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVsanHclAttributes invokes getVsanHclAttributes operation.
//
// Attributes of vSAN HCL data such as timestamp of last update.
//
// GET /v1/vsan-hcl/attributes
func (c *Client) GetVsanHclAttributes(ctx context.Context) (GetVsanHclAttributesRes, error) {
	res, err := c.sendGetVsanHclAttributes(ctx)
	return res, err
}

func (c *Client) sendGetVsanHclAttributes(ctx context.Context) (res GetVsanHclAttributesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vsan-hcl/attributes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVsanHclAttributesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVsanHclConfiguration invokes getVsanHclConfiguration operation.
//
// Get vSAN HCL configuration.
//
// GET /v1/vsan-hcl/configuration
func (c *Client) GetVsanHclConfiguration(ctx context.Context) (GetVsanHclConfigurationRes, error) {
	res, err := c.sendGetVsanHclConfiguration(ctx)
	return res, err
}

func (c *Client) sendGetVsanHclConfiguration(ctx context.Context) (res GetVsanHclConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vsan-hcl/configuration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVsanHclConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVsanHealthCheckByDomain invokes getVsanHealthCheckByDomain operation.
//
// Get vSAN health check status for all cluster on the domain.
//
// GET /v1/domains/{domainId}/health-checks
func (c *Client) GetVsanHealthCheckByDomain(ctx context.Context, params GetVsanHealthCheckByDomainParams) (GetVsanHealthCheckByDomainRes, error) {
	res, err := c.sendGetVsanHealthCheckByDomain(ctx, params)
	return res, err
}

func (c *Client) sendGetVsanHealthCheckByDomain(ctx context.Context, params GetVsanHealthCheckByDomainParams) (res GetVsanHealthCheckByDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/health-checks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVsanHealthCheckByDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVsanHealthCheckByQueryID invokes getVsanHealthCheckByQueryID operation.
//
// Get vSAN health check status for a given Query Id.
//
// GET /v1/domains/{domainId}/health-checks/queries/{queryId}
func (c *Client) GetVsanHealthCheckByQueryID(ctx context.Context, params GetVsanHealthCheckByQueryIDParams) (GetVsanHealthCheckByQueryIDRes, error) {
	res, err := c.sendGetVsanHealthCheckByQueryID(ctx, params)
	return res, err
}

func (c *Client) sendGetVsanHealthCheckByQueryID(ctx context.Context, params GetVsanHealthCheckByQueryIDParams) (res GetVsanHealthCheckByQueryIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/health-checks/queries/"
	{
		// Encode "queryId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queryId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QueryId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVsanHealthCheckByQueryIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVsanHealthCheckByTaskID invokes getVsanHealthCheckByTaskID operation.
//
// Get vSAN health check update task status for a given task Id.
//
// GET /v1/domains/{domainId}/health-checks/tasks/{taskId}
func (c *Client) GetVsanHealthCheckByTaskID(ctx context.Context, params GetVsanHealthCheckByTaskIDParams) (GetVsanHealthCheckByTaskIDRes, error) {
	res, err := c.sendGetVsanHealthCheckByTaskID(ctx, params)
	return res, err
}

func (c *Client) sendGetVsanHealthCheckByTaskID(ctx context.Context, params GetVsanHealthCheckByTaskIDParams) (res GetVsanHealthCheckByTaskIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/health-checks/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVsanHealthCheckByTaskIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWsas invokes getWsas operation.
//
// Retrieve a list of Workspace ONE Access instances.
//
// GET /v1/wsas
func (c *Client) GetWsas(ctx context.Context) (*PageOfWsa, error) {
	res, err := c.sendGetWsas(ctx)
	return res, err
}

func (c *Client) sendGetWsas(ctx context.Context) (res *PageOfWsa, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/wsas"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWsasResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ImportVdsToInventory invokes importVdsToInventory operation.
//
// Import Vds to inventory for the given cluster.
//
// POST /v1/clusters/{clusterId}/vdses
func (c *Client) ImportVdsToInventory(ctx context.Context, request *ImportVdsSpec, params ImportVdsToInventoryParams) (ImportVdsToInventoryRes, error) {
	res, err := c.sendImportVdsToInventory(ctx, request, params)
	return res, err
}

func (c *Client) sendImportVdsToInventory(ctx context.Context, request *ImportVdsSpec, params ImportVdsToInventoryParams) (res ImportVdsToInventoryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "clusterId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/vdses"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeImportVdsToInventoryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeImportVdsToInventoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InvalidateRefreshToken invokes invalidateRefreshToken operation.
//
// Invalidate the provided refresh token.
//
// DELETE /v1/tokens/refresh-token
func (c *Client) InvalidateRefreshToken(ctx context.Context, request string) error {
	_, err := c.sendInvalidateRefreshToken(ctx, request)
	return err
}

func (c *Client) sendInvalidateRefreshToken(ctx context.Context, request string) (res *InvalidateRefreshTokenNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/tokens/refresh-token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInvalidateRefreshTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInvalidateRefreshTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PerformDomainIsolationPrecheck invokes performDomainIsolationPrecheck operation.
//
// Perform Domain Isolation Prechecks.
//
// POST /v1/domains/{domainId}/isolation-prechecks
func (c *Client) PerformDomainIsolationPrecheck(ctx context.Context, request *IsolationSpec, params PerformDomainIsolationPrecheckParams) (PerformDomainIsolationPrecheckRes, error) {
	res, err := c.sendPerformDomainIsolationPrecheck(ctx, request, params)
	return res, err
}

func (c *Client) sendPerformDomainIsolationPrecheck(ctx context.Context, request *IsolationSpec, params PerformDomainIsolationPrecheckParams) (res PerformDomainIsolationPrecheckRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/isolation-prechecks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePerformDomainIsolationPrecheckRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePerformDomainIsolationPrecheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PerformUpgrade invokes performUpgrade operation.
//
// Schedule/Trigger Upgrade of a Resource. Ex: Resource can be DOMAIN, CLUSTER, UNMANAGED_HOST etc.
// Performing upgrades are supported on VMware Cloud Foundation 3.5 BOM resources and above. Supports
// scheduling/triggering of only 'parallel' upgrades and only Resource 'cluster' that are managed
// using both vSphere Lifecycle Manager Baselines and vSphere Lifecycle Manager Images in the same
// request.
//
// POST /v1/upgrades
func (c *Client) PerformUpgrade(ctx context.Context, request *UpgradeSpec) (PerformUpgradeRes, error) {
	res, err := c.sendPerformUpgrade(ctx, request)
	return res, err
}

func (c *Client) sendPerformUpgrade(ctx context.Context, request *UpgradeSpec) (res PerformUpgradeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/upgrades"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePerformUpgradeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePerformUpgradeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostClusterQuery invokes postClusterQuery operation.
//
// Post a cluster query.
//
// POST /v1/domains/{domainId}/clusters/{clusterName}/queries
func (c *Client) PostClusterQuery(ctx context.Context, request *ClusterCriterion, params PostClusterQueryParams) (PostClusterQueryRes, error) {
	res, err := c.sendPostClusterQuery(ctx, request, params)
	return res, err
}

func (c *Client) sendPostClusterQuery(ctx context.Context, request *ClusterCriterion, params PostClusterQueryParams) (res PostClusterQueryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/clusters/"
	{
		// Encode "clusterName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/queries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostClusterQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostClusterQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostClustersQuery invokes postClustersQuery operation.
//
// Post clusters query.
//
// POST /v1/domains/{domainId}/clusters/queries
func (c *Client) PostClustersQuery(ctx context.Context, request *ClusterCriterion, params PostClustersQueryParams) (PostClustersQueryRes, error) {
	res, err := c.sendPostClustersQuery(ctx, request, params)
	return res, err
}

func (c *Client) sendPostClustersQuery(ctx context.Context, request *ClusterCriterion, params PostClustersQueryParams) (res PostClustersQueryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/clusters/queries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostClustersQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostClustersQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostDatastoreQuery invokes postDatastoreQuery operation.
//
// Post a datastore query.
//
// POST /v1/domains/{domainId}/datastores/queries
func (c *Client) PostDatastoreQuery(ctx context.Context, request *DatastoreCriterion, params PostDatastoreQueryParams) (PostDatastoreQueryRes, error) {
	res, err := c.sendPostDatastoreQuery(ctx, request, params)
	return res, err
}

func (c *Client) sendPostDatastoreQuery(ctx context.Context, request *DatastoreCriterion, params PostDatastoreQueryParams) (res PostDatastoreQueryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores/queries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostDatastoreQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostDatastoreQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostDatastoreQuery1 invokes postDatastoreQuery_1 operation.
//
// Post a datastore query.
//
// POST /v1/clusters/{id}/datastores/queries
func (c *Client) PostDatastoreQuery1(ctx context.Context, request *DatastoreCriterion, params PostDatastoreQuery1Params) (PostDatastoreQuery1Res, error) {
	res, err := c.sendPostDatastoreQuery1(ctx, request, params)
	return res, err
}

func (c *Client) sendPostDatastoreQuery1(ctx context.Context, request *DatastoreCriterion, params PostDatastoreQuery1Params) (res PostDatastoreQuery1Res, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores/queries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostDatastoreQuery1Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostDatastoreQuery1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostHostQuery invokes postHostQuery operation.
//
// Post a host query.
//
// POST /v1/clusters/{id}/hosts/queries
func (c *Client) PostHostQuery(ctx context.Context, request *HostCriterion, params PostHostQueryParams) (PostHostQueryRes, error) {
	res, err := c.sendPostHostQuery(ctx, request, params)
	return res, err
}

func (c *Client) sendPostHostQuery(ctx context.Context, request *HostCriterion, params PostHostQueryParams) (res PostHostQueryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hosts/queries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostHostQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostHostQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostHostsPrechecks1 invokes postHostsPrechecks_1 operation.
//
// Post host(s) prechecks.
//
// POST /v1/hosts/prechecks
func (c *Client) PostHostsPrechecks1(ctx context.Context, request PostHostsPrechecks1Req) (PostHostsPrechecks1Res, error) {
	res, err := c.sendPostHostsPrechecks1(ctx, request)
	return res, err
}

func (c *Client) sendPostHostsPrechecks1(ctx context.Context, request PostHostsPrechecks1Req) (res PostHostsPrechecks1Res, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hosts/prechecks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostHostsPrechecks1Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostHostsPrechecks1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostQuery invokes postQuery operation.
//
// Post a query.
//
// POST /v1/hosts/queries
func (c *Client) PostQuery(ctx context.Context, request *HostCriterion) (PostQueryRes, error) {
	res, err := c.sendPostQuery(ctx, request)
	return res, err
}

func (c *Client) sendPostQuery(ctx context.Context, request *HostCriterion) (res PostQueryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hosts/queries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// QueryCheckSets invokes queryCheckSets operation.
//
// Query for check-sets for the given resources.
//
// POST /v1/system/check-sets/queries
func (c *Client) QueryCheckSets(ctx context.Context, request *CheckSetQueryInput) (QueryCheckSetsRes, error) {
	res, err := c.sendQueryCheckSets(ctx, request)
	return res, err
}

func (c *Client) sendQueryCheckSets(ctx context.Context, request *CheckSetQueryInput) (res QueryCheckSetsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/check-sets/queries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeQueryCheckSetsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeQueryCheckSetsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReconcileConfigs invokes reconcileConfigs operation.
//
// For selective reconciliation, provide a config spec.
//
// POST /v1/config-drift-reconciliations
func (c *Client) ReconcileConfigs(ctx context.Context, request *ConfigDriftApplySpec) (ReconcileConfigsRes, error) {
	res, err := c.sendReconcileConfigs(ctx, request)
	return res, err
}

func (c *Client) sendReconcileConfigs(ctx context.Context, request *ConfigDriftApplySpec) (res ReconcileConfigsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/config-drift-reconciliations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReconcileConfigsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReconcileConfigsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RefreshAccessToken invokes refreshAccessToken operation.
//
// Refresh the access token associated with the given refresh token.
//
// PATCH /v1/tokens/access-token/refresh
func (c *Client) RefreshAccessToken(ctx context.Context, request string) (RefreshAccessTokenRes, error) {
	res, err := c.sendRefreshAccessToken(ctx, request)
	return res, err
}

func (c *Client) sendRefreshAccessToken(ctx context.Context, request string) (res RefreshAccessTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/tokens/access-token/refresh"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRefreshAccessTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRefreshAccessTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveCertificateAuthority invokes removeCertificateAuthority operation.
//
// Deletes CA configuration file.
//
// DELETE /v1/certificate-authorities/{id}
func (c *Client) RemoveCertificateAuthority(ctx context.Context, params RemoveCertificateAuthorityParams) (RemoveCertificateAuthorityRes, error) {
	res, err := c.sendRemoveCertificateAuthority(ctx, params)
	return res, err
}

func (c *Client) sendRemoveCertificateAuthority(ctx context.Context, params RemoveCertificateAuthorityParams) (res RemoveCertificateAuthorityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/certificate-authorities/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveCertificateAuthorityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveDatastoreFromCluster invokes removeDatastoreFromCluster operation.
//
// Unmount a datastore from a cluster.
//
// DELETE /v1/clusters/{id}/datastores/{datastoreId}
func (c *Client) RemoveDatastoreFromCluster(ctx context.Context, params RemoveDatastoreFromClusterParams) (RemoveDatastoreFromClusterRes, error) {
	res, err := c.sendRemoveDatastoreFromCluster(ctx, params)
	return res, err
}

func (c *Client) sendRemoveDatastoreFromCluster(ctx context.Context, params RemoveDatastoreFromClusterParams) (res RemoveDatastoreFromClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores/"
	{
		// Encode "datastoreId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "datastoreId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatastoreId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveDatastoreFromClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveLicenseKey invokes removeLicenseKey operation.
//
// Remove a license key.
//
// DELETE /v1/license-keys/{key}
func (c *Client) RemoveLicenseKey(ctx context.Context, params RemoveLicenseKeyParams) (RemoveLicenseKeyRes, error) {
	res, err := c.sendRemoveLicenseKey(ctx, params)
	return res, err
}

func (c *Client) sendRemoveLicenseKey(ctx context.Context, params RemoveLicenseKeyParams) (res RemoveLicenseKeyRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/license-keys/"
	{
		// Encode "key" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Key))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveLicenseKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveTagsFromCluster invokes removeTagsFromCluster operation.
//
// Remove tags from a cluster.
//
// DELETE /v1/clusters/{id}/tags
func (c *Client) RemoveTagsFromCluster(ctx context.Context, request *TagsSpec, params RemoveTagsFromClusterParams) (RemoveTagsFromClusterRes, error) {
	res, err := c.sendRemoveTagsFromCluster(ctx, request, params)
	return res, err
}

func (c *Client) sendRemoveTagsFromCluster(ctx context.Context, request *TagsSpec, params RemoveTagsFromClusterParams) (res RemoveTagsFromClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRemoveTagsFromClusterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveTagsFromClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveTagsFromDomain invokes removeTagsFromDomain operation.
//
// Remove Tags From Domain.
//
// DELETE /v1/domains/{id}/tags
func (c *Client) RemoveTagsFromDomain(ctx context.Context, request *TagsSpec, params RemoveTagsFromDomainParams) (RemoveTagsFromDomainRes, error) {
	res, err := c.sendRemoveTagsFromDomain(ctx, request, params)
	return res, err
}

func (c *Client) sendRemoveTagsFromDomain(ctx context.Context, request *TagsSpec, params RemoveTagsFromDomainParams) (res RemoveTagsFromDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRemoveTagsFromDomainRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveTagsFromDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveTagsFromHost invokes removeTagsFromHost operation.
//
// Remove Tags From Host.
//
// DELETE /v1/hosts/{id}/tags
func (c *Client) RemoveTagsFromHost(ctx context.Context, request *TagsSpec, params RemoveTagsFromHostParams) (RemoveTagsFromHostRes, error) {
	res, err := c.sendRemoveTagsFromHost(ctx, request, params)
	return res, err
}

func (c *Client) sendRemoveTagsFromHost(ctx context.Context, request *TagsSpec, params RemoveTagsFromHostParams) (res RemoveTagsFromHostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/hosts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRemoveTagsFromHostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveTagsFromHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveUser invokes removeUser operation.
//
// Delete the user by the ID, if it exists.
//
// DELETE /v1/users/{id}
func (c *Client) RemoveUser(ctx context.Context, params RemoveUserParams) (RemoveUserRes, error) {
	res, err := c.sendRemoveUser(ctx, params)
	return res, err
}

func (c *Client) sendRemoveUser(ctx context.Context, params RemoveUserParams) (res RemoveUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/users/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveVasaProvider invokes removeVasaProvider operation.
//
// Delete a VASA Provider.
//
// DELETE /v1/vasa-providers/{id}
func (c *Client) RemoveVasaProvider(ctx context.Context, params RemoveVasaProviderParams) (RemoveVasaProviderRes, error) {
	res, err := c.sendRemoveVasaProvider(ctx, params)
	return res, err
}

func (c *Client) sendRemoveVasaProvider(ctx context.Context, params RemoveVasaProviderParams) (res RemoveVasaProviderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/vasa-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveVasaProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveVasaProviderStorageContainer invokes removeVasaProviderStorageContainer operation.
//
// Delete a storage container of a VASA Provider.
//
// DELETE /v1/vasa-providers/{id}/storage-containers/{storageContainerId}
func (c *Client) RemoveVasaProviderStorageContainer(ctx context.Context, params RemoveVasaProviderStorageContainerParams) (RemoveVasaProviderStorageContainerRes, error) {
	res, err := c.sendRemoveVasaProviderStorageContainer(ctx, params)
	return res, err
}

func (c *Client) sendRemoveVasaProviderStorageContainer(ctx context.Context, params RemoveVasaProviderStorageContainerParams) (res RemoveVasaProviderStorageContainerRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/vasa-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/storage-containers/"
	{
		// Encode "storageContainerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "storageContainerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StorageContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveVasaProviderStorageContainerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RenameCustomIsoById invokes renameCustomIsoById operation.
//
// Rename the Custom ISO corresponding to the ID.
//
// PATCH /v1/custom-isos/{custom_iso_id}
func (c *Client) RenameCustomIsoById(ctx context.Context, request *CustomIsoRenameSpec, params RenameCustomIsoByIdParams) (RenameCustomIsoByIdRes, error) {
	res, err := c.sendRenameCustomIsoById(ctx, request, params)
	return res, err
}

func (c *Client) sendRenameCustomIsoById(ctx context.Context, request *CustomIsoRenameSpec, params RenameCustomIsoByIdParams) (res RenameCustomIsoByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/custom-isos/"
	{
		// Encode "custom_iso_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "custom_iso_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CustomIsoID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRenameCustomIsoByIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRenameCustomIsoByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RenamePersonalityById invokes renamePersonalityById operation.
//
// Rename personality with the ID passed in the URL.
//
// PATCH /v1/personalities/{personalityId}
func (c *Client) RenamePersonalityById(ctx context.Context, request *Personality, params RenamePersonalityByIdParams) (RenamePersonalityByIdRes, error) {
	res, err := c.sendRenamePersonalityById(ctx, request, params)
	return res, err
}

func (c *Client) sendRenamePersonalityById(ctx context.Context, request *Personality, params RenamePersonalityByIdParams) (res RenamePersonalityByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/personalities/"
	{
		// Encode "personalityId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "personalityId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PersonalityId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRenamePersonalityByIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRenamePersonalityByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReplaceCertificates invokes replaceCertificates operation.
//
// Replace certificate(s) for the selected resource(s) in a domain.
//
// PATCH /v1/domains/{id}/certificates
func (c *Client) ReplaceCertificates(ctx context.Context, request *CertificateOperationSpec, params ReplaceCertificatesParams) (ReplaceCertificatesRes, error) {
	res, err := c.sendReplaceCertificates(ctx, request, params)
	return res, err
}

func (c *Client) sendReplaceCertificates(ctx context.Context, request *CertificateOperationSpec, params ReplaceCertificatesParams) (res ReplaceCertificatesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/certificates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReplaceCertificatesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReplaceCertificatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReplaceResourceCertificates invokes replaceResourceCertificates operation.
//
// Replace resource certificates.
//
// PUT /v1/domains/{id}/resource-certificates
func (c *Client) ReplaceResourceCertificates(ctx context.Context, request []ResourceCertificateSpec, params ReplaceResourceCertificatesParams) (ReplaceResourceCertificatesRes, error) {
	res, err := c.sendReplaceResourceCertificates(ctx, request, params)
	return res, err
}

func (c *Client) sendReplaceResourceCertificates(ctx context.Context, request []ResourceCertificateSpec, params ReplaceResourceCertificatesParams) (res ReplaceResourceCertificatesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/resource-certificates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReplaceResourceCertificatesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReplaceResourceCertificatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetryComplianceAuditTask invokes retryComplianceAuditTask operation.
//
// Retry compliance audit task.
//
// PATCH /v1/domains/{id}/compliance-audits/tasks/{taskId}
func (c *Client) RetryComplianceAuditTask(ctx context.Context, params RetryComplianceAuditTaskParams) (RetryComplianceAuditTaskRes, error) {
	res, err := c.sendRetryComplianceAuditTask(ctx, params)
	return res, err
}

func (c *Client) sendRetryComplianceAuditTask(ctx context.Context, params RetryComplianceAuditTaskParams) (res RetryComplianceAuditTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/compliance-audits/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetryComplianceAuditTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetryCredentialsTask invokes retryCredentialsTask operation.
//
// Retry a failed credentials task for a given ID.
//
// PATCH /v1/credentials/tasks/{id}
func (c *Client) RetryCredentialsTask(ctx context.Context, request *CredentialsUpdateSpec, params RetryCredentialsTaskParams) (RetryCredentialsTaskRes, error) {
	res, err := c.sendRetryCredentialsTask(ctx, request, params)
	return res, err
}

func (c *Client) sendRetryCredentialsTask(ctx context.Context, request *CredentialsUpdateSpec, params RetryCredentialsTaskParams) (res RetryCredentialsTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/credentials/tasks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRetryCredentialsTaskRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetryCredentialsTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrySddc invokes retrySddc operation.
//
// Retry failed SDDC creation.
//
// PATCH /v1/sddcs/{id}
func (c *Client) RetrySddc(ctx context.Context, request OptSddcSpec, params RetrySddcParams) (RetrySddcRes, error) {
	res, err := c.sendRetrySddc(ctx, request, params)
	return res, err
}

func (c *Client) sendRetrySddc(ctx context.Context, request OptSddcSpec, params RetrySddcParams) (res RetrySddcRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/sddcs/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRetrySddcRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrySddcResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetryTask invokes retryTask operation.
//
// Retry a failed Task by ID, if it exists.
//
// PATCH /v1/tasks/{id}
func (c *Client) RetryTask(ctx context.Context, params RetryTaskParams) (RetryTaskRes, error) {
	res, err := c.sendRetryTask(ctx, params)
	return res, err
}

func (c *Client) sendRetryTask(ctx context.Context, params RetryTaskParams) (res RetryTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/tasks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetryTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RollbackVrslcm invokes rollbackVrslcm operation.
//
// Triggers the VMware Aria Suite Lifecycle rollback operation and returns an URL in the headers to
// track the operation status.
//
// DELETE /v1/vrslcm
func (c *Client) RollbackVrslcm(ctx context.Context) (RollbackVrslcmRes, error) {
	res, err := c.sendRollbackVrslcm(ctx)
	return res, err
}

func (c *Client) sendRollbackVrslcm(ctx context.Context) (res RollbackVrslcmRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrslcm"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRollbackVrslcmResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetBackupConfiguration invokes setBackupConfiguration operation.
//
// Configure the backup configuration for SDDC Manager and NSX Manager.
//
// PUT /v1/system/backup-configuration
func (c *Client) SetBackupConfiguration(ctx context.Context, request *BackupConfigurationSpec) (SetBackupConfigurationRes, error) {
	res, err := c.sendSetBackupConfiguration(ctx, request)
	return res, err
}

func (c *Client) sendSetBackupConfiguration(ctx context.Context, request *BackupConfigurationSpec) (res SetBackupConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/backup-configuration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetBackupConfigurationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetBackupConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetCeipStatus invokes setCeipStatus operation.
//
// Opt-in or Opt-out of CEIP.
//
// PATCH /v1/system/ceip
func (c *Client) SetCeipStatus(ctx context.Context, request SetCeipStatusReq) (SetCeipStatusRes, error) {
	res, err := c.sendSetCeipStatus(ctx, request)
	return res, err
}

func (c *Client) sendSetCeipStatus(ctx context.Context, request SetCeipStatusReq) (res SetCeipStatusRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/ceip"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetCeipStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetCeipStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetLicenseKeyForResource invokes setLicenseKeyForResource operation.
//
// Update a license key for a resource.
//
// PUT /v1/resources/licensing-infos
func (c *Client) SetLicenseKeyForResource(ctx context.Context, request *LicensingSpec) (SetLicenseKeyForResourceRes, error) {
	res, err := c.sendSetLicenseKeyForResource(ctx, request)
	return res, err
}

func (c *Client) sendSetLicenseKeyForResource(ctx context.Context, request *LicensingSpec) (res SetLicenseKeyForResourceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/resources/licensing-infos"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetLicenseKeyForResourceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetLicenseKeyForResourceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartBackup invokes startBackup operation.
//
// Start a backup operation.
//
// POST /v1/backups/tasks
func (c *Client) StartBackup(ctx context.Context, request *BackupSpec) (StartBackupRes, error) {
	res, err := c.sendStartBackup(ctx, request)
	return res, err
}

func (c *Client) sendStartBackup(ctx context.Context, request *BackupSpec) (res StartBackupRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/backups/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartBackupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartBackupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartBringup invokes startBringup operation.
//
// Deploy a management domain.
//
// POST /v1/sddcs
func (c *Client) StartBringup(ctx context.Context, request *SddcSpec) (StartBringupRes, error) {
	res, err := c.sendStartBringup(ctx, request)
	return res, err
}

func (c *Client) sendStartBringup(ctx context.Context, request *SddcSpec) (res StartBringupRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sddcs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartBringupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartBringupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartBringupSpecConversion invokes startBringupSpecConversion operation.
//
// SDDC specification incorporates all the client inputs regarding VMW component parameters
// constituting the SDDC: NTP, DNS spec, ESXi, VC, VSAN, NSX spec et al.
//
// POST /v1/system/sddc-spec-converter
func (c *Client) StartBringupSpecConversion(ctx context.Context, request OptStartBringupSpecConversionReq, params StartBringupSpecConversionParams) (StartBringupSpecConversionRes, error) {
	res, err := c.sendStartBringupSpecConversion(ctx, request, params)
	return res, err
}

func (c *Client) sendStartBringupSpecConversion(ctx context.Context, request OptStartBringupSpecConversionReq, params StartBringupSpecConversionParams) (res StartBringupSpecConversionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/sddc-spec-converter"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "design" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "design",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Design.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartBringupSpecConversionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartBringupSpecConversionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartBundleDownloadByID invokes startBundleDownloadByID operation.
//
// Update a Bundle for scheduling/triggering download. Only one download can triggered for a Bundle.
//
// PATCH /v1/bundles/{id}
func (c *Client) StartBundleDownloadByID(ctx context.Context, request *BundleUpdateSpec, params StartBundleDownloadByIDParams) (StartBundleDownloadByIDRes, error) {
	res, err := c.sendStartBundleDownloadByID(ctx, request, params)
	return res, err
}

func (c *Client) sendStartBundleDownloadByID(ctx context.Context, request *BundleUpdateSpec, params StartBundleDownloadByIDParams) (res StartBundleDownloadByIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/bundles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartBundleDownloadByIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartBundleDownloadByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartHealthCheck invokes startHealthCheck operation.
//
// Start a Health Check operation using SoS.
//
// POST /v1/system/health-summary
func (c *Client) StartHealthCheck(ctx context.Context, request *HealthSummarySpec) (StartHealthCheckRes, error) {
	res, err := c.sendStartHealthCheck(ctx, request)
	return res, err
}

func (c *Client) sendStartHealthCheck(ctx context.Context, request *HealthSummarySpec) (res StartHealthCheckRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/health-summary"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartHealthCheckRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartHealthCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartNsxCriteriaQuery invokes startNsxCriteriaQuery operation.
//
// Start a query with NSX Criteria.
//
// POST /v1/nsxt-clusters/queries
func (c *Client) StartNsxCriteriaQuery(ctx context.Context, request *NsxTCriterion) (StartNsxCriteriaQueryRes, error) {
	res, err := c.sendStartNsxCriteriaQuery(ctx, request)
	return res, err
}

func (c *Client) sendStartNsxCriteriaQuery(ctx context.Context, request *NsxTCriterion) (res StartNsxCriteriaQueryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nsxt-clusters/queries"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartNsxCriteriaQueryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartNsxCriteriaQueryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartPrecheck invokes startPrecheck operation.
//
// Perform precheck of resource(ex: Domain, Cluster). If only resource is specified, all
// resources/software components under it are included. If resource(Domain, Cluster etc) and specific
// resources/software components are provided, only those are included in precheck. As this API is
// deprecated, please use the new LCM Prechecks API - /v1/system/check-sets/queries and
// /v1/system/check-sets.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /v1/system/prechecks
func (c *Client) StartPrecheck(ctx context.Context, request *PrecheckSpec) (StartPrecheckRes, error) {
	res, err := c.sendStartPrecheck(ctx, request)
	return res, err
}

func (c *Client) sendStartPrecheck(ctx context.Context, request *PrecheckSpec) (res StartPrecheckRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/prechecks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartPrecheckRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartPrecheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartRestore invokes startRestore operation.
//
// Start a restore operation.
//
// POST /v1/restores/tasks
func (c *Client) StartRestore(ctx context.Context, request *RestoreSpec) (StartRestoreRes, error) {
	res, err := c.sendStartRestore(ctx, request)
	return res, err
}

func (c *Client) sendStartRestore(ctx context.Context, request *RestoreSpec) (res StartRestoreRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/restores/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartRestoreRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartRestoreResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartSupportBundle invokes startSupportBundle operation.
//
// Start a Support Bundle operation using SoS.
//
// POST /v1/system/support-bundles
func (c *Client) StartSupportBundle(ctx context.Context, request *SupportBundleSpec) (StartSupportBundleRes, error) {
	res, err := c.sendStartSupportBundle(ctx, request)
	return res, err
}

func (c *Client) sendStartSupportBundle(ctx context.Context, request *SupportBundleSpec) (res StartSupportBundleRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/support-bundles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartSupportBundleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartSupportBundleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartUpgradePrecheck invokes startUpgradePrecheck operation.
//
// Perform Upgrade Prechecks.
//
// POST /v1/upgrades/{upgradeId}/prechecks
func (c *Client) StartUpgradePrecheck(ctx context.Context, params StartUpgradePrecheckParams) (StartUpgradePrecheckRes, error) {
	res, err := c.sendStartUpgradePrecheck(ctx, params)
	return res, err
}

func (c *Client) sendStartUpgradePrecheck(ctx context.Context, params StartUpgradePrecheckParams) (res StartUpgradePrecheckRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/upgrades/"
	{
		// Encode "upgradeId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "upgradeId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UpgradeId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/prechecks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartUpgradePrecheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TriggerCheckRun invokes triggerCheckRun operation.
//
// Trigger a run of the selected checks.
//
// POST /v1/system/check-sets
func (c *Client) TriggerCheckRun(ctx context.Context, request *CheckSetRunInput) (TriggerCheckRunRes, error) {
	res, err := c.sendTriggerCheckRun(ctx, request)
	return res, err
}

func (c *Client) sendTriggerCheckRun(ctx context.Context, request *CheckSetRunInput) (res TriggerCheckRunRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/check-sets"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTriggerCheckRunRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTriggerCheckRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TriggerPartialRetryOfCheckRun invokes triggerPartialRetryOfCheckRun operation.
//
// Trigger partial retry of a completed check run.
//
// PATCH /v1/system/check-sets/{runId}
func (c *Client) TriggerPartialRetryOfCheckRun(ctx context.Context, request *AssessmentPartialRetryInput, params TriggerPartialRetryOfCheckRunParams) (TriggerPartialRetryOfCheckRunRes, error) {
	res, err := c.sendTriggerPartialRetryOfCheckRun(ctx, request, params)
	return res, err
}

func (c *Client) sendTriggerPartialRetryOfCheckRun(ctx context.Context, request *AssessmentPartialRetryInput, params TriggerPartialRetryOfCheckRunParams) (res TriggerPartialRetryOfCheckRunRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/system/check-sets/"
	{
		// Encode "runId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RunId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTriggerPartialRetryOfCheckRunRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTriggerPartialRetryOfCheckRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateBackupConfiguration invokes updateBackupConfiguration operation.
//
// Update the backup configuration for SDDC Manager and NSX Manager.
//
// PATCH /v1/system/backup-configuration
func (c *Client) UpdateBackupConfiguration(ctx context.Context, request *BackupConfigurationSpec) (UpdateBackupConfigurationRes, error) {
	res, err := c.sendUpdateBackupConfiguration(ctx, request)
	return res, err
}

func (c *Client) sendUpdateBackupConfiguration(ctx context.Context, request *BackupConfigurationSpec) (res UpdateBackupConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/backup-configuration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateBackupConfigurationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateBackupConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateBundleCompatibilitySets invokes updateBundleCompatibilitySets operation.
//
// Update software compatibility sets for Bundles.
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /v1/bundles/
func (c *Client) UpdateBundleCompatibilitySets(ctx context.Context, request *BundleUpdateSpec) (UpdateBundleCompatibilitySetsRes, error) {
	res, err := c.sendUpdateBundleCompatibilitySets(ctx, request)
	return res, err
}

func (c *Client) sendUpdateBundleCompatibilitySets(ctx context.Context, request *BundleUpdateSpec) (res UpdateBundleCompatibilitySetsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/bundles/"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateBundleCompatibilitySetsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateBundleCompatibilitySetsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCluster invokes updateCluster operation.
//
// Update a Cluster by adding or removing Hosts, Stretching a standard vSAN cluster, Unstretching a
// stretched cluster or by marking for deletion.
//
// PATCH /v1/clusters/{id}
func (c *Client) UpdateCluster(ctx context.Context, request *ClusterUpdateSpec, params UpdateClusterParams) (UpdateClusterRes, error) {
	res, err := c.sendUpdateCluster(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateCluster(ctx context.Context, request *ClusterUpdateSpec, params UpdateClusterParams) (res UpdateClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateClusterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDepotSettings invokes updateDepotSettings operation.
//
// Update depot settings. Depot settings can be updated with VMware Depot account.
//
// PUT /v1/system/settings/depot
func (c *Client) UpdateDepotSettings(ctx context.Context, request *DepotSettings) (UpdateDepotSettingsRes, error) {
	res, err := c.sendUpdateDepotSettings(ctx, request)
	return res, err
}

func (c *Client) sendUpdateDepotSettings(ctx context.Context, request *DepotSettings) (res UpdateDepotSettingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/settings/depot"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDepotSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateDepotSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDomain invokes updateDomain operation.
//
// Update a Domain.
//
// PATCH /v1/domains/{id}
func (c *Client) UpdateDomain(ctx context.Context, request *DomainUpdateSpec, params UpdateDomainParams) (UpdateDomainRes, error) {
	res, err := c.sendUpdateDomain(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDomain(ctx context.Context, request *DomainUpdateSpec, params UpdateDomainParams) (res UpdateDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDomainRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateEdgeCluster invokes updateEdgeCluster operation.
//
// Expand or shrink an NSX Edge Cluster.
//
// PATCH /v1/edge-clusters/{id}
func (c *Client) UpdateEdgeCluster(ctx context.Context, request *EdgeClusterUpdateSpec, params UpdateEdgeClusterParams) (UpdateEdgeClusterRes, error) {
	res, err := c.sendUpdateEdgeCluster(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateEdgeCluster(ctx context.Context, request *EdgeClusterUpdateSpec, params UpdateEdgeClusterParams) (res UpdateEdgeClusterRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/edge-clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateEdgeClusterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateEdgeClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateLicenseKey invokes updateLicenseKey operation.
//
// Update the license key.
//
// PATCH /v1/license-keys/{key}
func (c *Client) UpdateLicenseKey(ctx context.Context, request *LicenseKeyUpdateSpec, params UpdateLicenseKeyParams) (UpdateLicenseKeyRes, error) {
	res, err := c.sendUpdateLicenseKey(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateLicenseKey(ctx context.Context, request *LicenseKeyUpdateSpec, params UpdateLicenseKeyParams) (res UpdateLicenseKeyRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/license-keys/"
	{
		// Encode "key" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Key))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateLicenseKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateLicenseKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateLocalUserPassword invokes updateLocalUserPassword operation.
//
// Update the password for local account only if the old password is correct, or if user configures
// the local account for the first time.
//
// PATCH /v1/users/local/admin
func (c *Client) UpdateLocalUserPassword(ctx context.Context, request *LocalAccountPasswordInfo) (UpdateLocalUserPasswordRes, error) {
	res, err := c.sendUpdateLocalUserPassword(ctx, request)
	return res, err
}

func (c *Client) sendUpdateLocalUserPassword(ctx context.Context, request *LocalAccountPasswordInfo) (res UpdateLocalUserPasswordRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/users/local/admin"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateLocalUserPasswordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateLocalUserPasswordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateNetworkPool invokes updateNetworkPool operation.
//
// Update a Network Pool by ID, if it exists.
//
// PATCH /v1/network-pools/{id}
func (c *Client) UpdateNetworkPool(ctx context.Context, request *NetworkPoolUpdateSpec, params UpdateNetworkPoolParams) (UpdateNetworkPoolRes, error) {
	res, err := c.sendUpdateNetworkPool(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateNetworkPool(ctx context.Context, request *NetworkPoolUpdateSpec, params UpdateNetworkPoolParams) (res UpdateNetworkPoolRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/network-pools/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateNetworkPoolRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateNetworkPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateOrRotatePasswords invokes updateOrRotatePasswords operation.
//
// Update passwords for given list of resources by supplying new passwords or rotate the passwords
// using system generated passwords.
//
// PATCH /v1/credentials
func (c *Client) UpdateOrRotatePasswords(ctx context.Context, request *CredentialsUpdateSpec) (UpdateOrRotatePasswordsRes, error) {
	res, err := c.sendUpdateOrRotatePasswords(ctx, request)
	return res, err
}

func (c *Client) sendUpdateOrRotatePasswords(ctx context.Context, request *CredentialsUpdateSpec) (res UpdateOrRotatePasswordsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/credentials"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateOrRotatePasswordsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateOrRotatePasswordsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateReleaseByDomainID invokes updateReleaseByDomainID operation.
//
// Update last selected upgrade version for the domain.
//
// PATCH /v1/releases/domains/{domainId}
func (c *Client) UpdateReleaseByDomainID(ctx context.Context, request OptDomainRelease, params UpdateReleaseByDomainIDParams) (UpdateReleaseByDomainIDRes, error) {
	res, err := c.sendUpdateReleaseByDomainID(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateReleaseByDomainID(ctx context.Context, request OptDomainRelease, params UpdateReleaseByDomainIDParams) (res UpdateReleaseByDomainIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/releases/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateReleaseByDomainIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateReleaseByDomainIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateResourcesFunctionalities invokes updateResourcesFunctionalities operation.
//
// Update Resources Functionalities.
//
// PATCH /v1/resource-functionalities
func (c *Client) UpdateResourcesFunctionalities(ctx context.Context, request *ResourceFunctionalitiesUpdateSpec) (UpdateResourcesFunctionalitiesRes, error) {
	res, err := c.sendUpdateResourcesFunctionalities(ctx, request)
	return res, err
}

func (c *Client) sendUpdateResourcesFunctionalities(ctx context.Context, request *ResourceFunctionalitiesUpdateSpec) (res UpdateResourcesFunctionalitiesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/resource-functionalities"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateResourcesFunctionalitiesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateResourcesFunctionalitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateResourcesFunctionalities1 invokes updateResourcesFunctionalities_1 operation.
//
// Update Resources Functionalities Is Allowed Global Configuration.
//
// PATCH /v1/resource-functionalities/global
func (c *Client) UpdateResourcesFunctionalities1(ctx context.Context, request *ResourceFunctionalitiesGlobalUpdateSpec) (UpdateResourcesFunctionalities1Res, error) {
	res, err := c.sendUpdateResourcesFunctionalities1(ctx, request)
	return res, err
}

func (c *Client) sendUpdateResourcesFunctionalities1(ctx context.Context, request *ResourceFunctionalitiesGlobalUpdateSpec) (res UpdateResourcesFunctionalities1Res, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/resource-functionalities/global"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateResourcesFunctionalities1Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateResourcesFunctionalities1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSystemConfiguration invokes updateSystemConfiguration operation.
//
// Updates paramters of the system configuration.
//
// PATCH /v1/system
func (c *Client) UpdateSystemConfiguration(ctx context.Context, request *SystemUpdateSpec) (UpdateSystemConfigurationRes, error) {
	res, err := c.sendUpdateSystemConfiguration(ctx, request)
	return res, err
}

func (c *Client) sendUpdateSystemConfiguration(ctx context.Context, request *SystemUpdateSpec) (res UpdateSystemConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSystemConfigurationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateSystemConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateUpgradeSchedule invokes updateUpgradeSchedule operation.
//
// Commit/Reschedule an existing upgrade. It moves the upgrade from DRAFT state to SCHEDULED state
// and/or changes the upgrade scheduled date/time.
//
// PATCH /v1/upgrades/{upgradeId}
func (c *Client) UpdateUpgradeSchedule(ctx context.Context, request *UpgradeCommitSpec, params UpdateUpgradeScheduleParams) (UpdateUpgradeScheduleRes, error) {
	res, err := c.sendUpdateUpgradeSchedule(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateUpgradeSchedule(ctx context.Context, request *UpgradeCommitSpec, params UpdateUpgradeScheduleParams) (res UpdateUpgradeScheduleRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/upgrades/"
	{
		// Encode "upgradeId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "upgradeId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UpgradeId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateUpgradeScheduleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateUpgradeScheduleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVasaProvider invokes updateVasaProvider operation.
//
// Update a VASA Provider.
//
// PATCH /v1/vasa-providers/{id}
func (c *Client) UpdateVasaProvider(ctx context.Context, request *VasaProviderUpdateSpec, params UpdateVasaProviderParams) (UpdateVasaProviderRes, error) {
	res, err := c.sendUpdateVasaProvider(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateVasaProvider(ctx context.Context, request *VasaProviderUpdateSpec, params UpdateVasaProviderParams) (res UpdateVasaProviderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/vasa-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVasaProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVasaProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVasaProviderStorageContainer invokes updateVasaProviderStorageContainer operation.
//
// Update the storage container of a VASA Provider.
//
// PATCH /v1/vasa-providers/{id}/storage-containers/{storageContainerId}
func (c *Client) UpdateVasaProviderStorageContainer(ctx context.Context, request *StorageContainerUpdateSpec, params UpdateVasaProviderStorageContainerParams) (UpdateVasaProviderStorageContainerRes, error) {
	res, err := c.sendUpdateVasaProviderStorageContainer(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateVasaProviderStorageContainer(ctx context.Context, request *StorageContainerUpdateSpec, params UpdateVasaProviderStorageContainerParams) (res UpdateVasaProviderStorageContainerRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/vasa-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/storage-containers/"
	{
		// Encode "storageContainerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "storageContainerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StorageContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVasaProviderStorageContainerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVasaProviderStorageContainerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVasaProviderUser invokes updateVasaProviderUser operation.
//
// Update the user of a VASA Provider.
//
// PATCH /v1/vasa-providers/{id}/users/{userId}
func (c *Client) UpdateVasaProviderUser(ctx context.Context, request *VasaUserUpdateSpec, params UpdateVasaProviderUserParams) (UpdateVasaProviderUserRes, error) {
	res, err := c.sendUpdateVasaProviderUser(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateVasaProviderUser(ctx context.Context, request *VasaUserUpdateSpec, params UpdateVasaProviderUserParams) (res UpdateVasaProviderUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/vasa-providers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVasaProviderUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVasaProviderUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVersionAliasConfiguration invokes updateVersionAliasConfiguration operation.
//
// Update Version Alias Configuration.
//
// PUT /v1/system/settings/version-aliases/{bundleComponentType}/{version}
func (c *Client) UpdateVersionAliasConfiguration(ctx context.Context, request *AliasSpec, params UpdateVersionAliasConfigurationParams) (UpdateVersionAliasConfigurationRes, error) {
	res, err := c.sendUpdateVersionAliasConfiguration(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateVersionAliasConfiguration(ctx context.Context, request *AliasSpec, params UpdateVersionAliasConfigurationParams) (res UpdateVersionAliasConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/system/settings/version-aliases/"
	{
		// Encode "bundleComponentType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bundleComponentType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BundleComponentType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "version" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "version",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVersionAliasConfigurationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVersionAliasConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVersionAliasConfigurations invokes updateVersionAliasConfigurations operation.
//
// Update Version Alias Configurations.
//
// PUT /v1/system/settings/version-aliases
func (c *Client) UpdateVersionAliasConfigurations(ctx context.Context, request *VersionAliasesForBundleComponentTypeSpec) (UpdateVersionAliasConfigurationsRes, error) {
	res, err := c.sendUpdateVersionAliasConfigurations(ctx, request)
	return res, err
}

func (c *Client) sendUpdateVersionAliasConfigurations(ctx context.Context, request *VersionAliasesForBundleComponentTypeSpec) (res UpdateVersionAliasConfigurationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/settings/version-aliases"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVersionAliasConfigurationsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVersionAliasConfigurationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVrslcmVersionByIdInInventory invokes updateVrslcmVersionByIdInInventory operation.
//
// Updates VMware Aria Suite Lifecycle version.
//
// PUT /v1/vrslcms/{id}
func (c *Client) UpdateVrslcmVersionByIdInInventory(ctx context.Context, request *Vrslcm, params UpdateVrslcmVersionByIdInInventoryParams) (UpdateVrslcmVersionByIdInInventoryRes, error) {
	res, err := c.sendUpdateVrslcmVersionByIdInInventory(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateVrslcmVersionByIdInInventory(ctx context.Context, request *Vrslcm, params UpdateVrslcmVersionByIdInInventoryParams) (res UpdateVrslcmVersionByIdInInventoryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/vrslcms/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVrslcmVersionByIdInInventoryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVrslcmVersionByIdInInventoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVrslcmVersionInInventory invokes updateVrslcmVersionInInventory operation.
//
// Updates VMware Aria Suite Lifecycle version in VCF inventory.
//
// PUT /v1/vrslcm
func (c *Client) UpdateVrslcmVersionInInventory(ctx context.Context, request *Vrslcm) (UpdateVrslcmVersionInInventoryRes, error) {
	res, err := c.sendUpdateVrslcmVersionInInventory(ctx, request)
	return res, err
}

func (c *Client) sendUpdateVrslcmVersionInInventory(ctx context.Context, request *Vrslcm) (res UpdateVrslcmVersionInInventoryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrslcm"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVrslcmVersionInInventoryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVrslcmVersionInInventoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVsanHclConfiguration invokes updateVsanHclConfiguration operation.
//
// Update vSAN HCL configuration.
//
// PATCH /v1/vsan-hcl/configuration
func (c *Client) UpdateVsanHclConfiguration(ctx context.Context, request *VsanHclConfiguration) (UpdateVsanHclConfigurationRes, error) {
	res, err := c.sendUpdateVsanHclConfiguration(ctx, request)
	return res, err
}

func (c *Client) sendUpdateVsanHclConfiguration(ctx context.Context, request *VsanHclConfiguration) (res UpdateVsanHclConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vsan-hcl/configuration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVsanHclConfigurationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVsanHclConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVsanHealthCheckByDomain invokes updateVsanHealthCheckByDomain operation.
//
// Update vSAN health check status for domain.
//
// PATCH /v1/domains/{domainId}/health-checks
func (c *Client) UpdateVsanHealthCheckByDomain(ctx context.Context, request []HealthCheckSpec, params UpdateVsanHealthCheckByDomainParams) (UpdateVsanHealthCheckByDomainRes, error) {
	res, err := c.sendUpdateVsanHealthCheckByDomain(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateVsanHealthCheckByDomain(ctx context.Context, request []HealthCheckSpec, params UpdateVsanHealthCheckByDomainParams) (res UpdateVsanHealthCheckByDomainRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/health-checks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVsanHealthCheckByDomainRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVsanHealthCheckByDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadBundle invokes uploadBundle operation.
//
// Upload Bundle to SDDC Manager. Used when you do not have internet connectivity for downloading
// bundles from VMWare/VxRail to SDDC Manager. The Bundles are manually downloaded from Depot using
// Bundle Transfer utility.
//
// POST /v1/bundles
func (c *Client) UploadBundle(ctx context.Context, request *BundleUploadSpec) (UploadBundleRes, error) {
	res, err := c.sendUploadBundle(ctx, request)
	return res, err
}

func (c *Client) sendUploadBundle(ctx context.Context, request *BundleUploadSpec) (res UploadBundleRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/bundles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadBundleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUploadBundleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadCertificates invokes uploadCertificates operation.
//
// Upload certificates to the certificate store.
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /v1/domains/{id}/certificates/uploads
func (c *Client) UploadCertificates(ctx context.Context, request OptUploadCertificatesReq, params UploadCertificatesParams) (UploadCertificatesRes, error) {
	res, err := c.sendUploadCertificates(ctx, request, params)
	return res, err
}

func (c *Client) sendUploadCertificates(ctx context.Context, request OptUploadCertificatesReq, params UploadCertificatesParams) (res UploadCertificatesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/certificates/uploads"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadCertificatesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUploadCertificatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadCustomIso invokes uploadCustomIso operation.
//
// Upload Custom ISO to SDDC Manager.
//
// POST /v1/custom-isos/file
func (c *Client) UploadCustomIso(ctx context.Context, request OptUploadCustomIsoReq, params UploadCustomIsoParams) (UploadCustomIsoRes, error) {
	res, err := c.sendUploadCustomIso(ctx, request, params)
	return res, err
}

func (c *Client) sendUploadCustomIso(ctx context.Context, request OptUploadCustomIsoReq, params UploadCustomIsoParams) (res UploadCustomIsoRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/custom-isos/file"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadCustomIsoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUploadCustomIsoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadPersonality invokes uploadPersonality operation.
//
// Upload Personality to SDDC Manager.
//
// POST /v1/personalities
func (c *Client) UploadPersonality(ctx context.Context, request *PersonalityUploadSpec) (UploadPersonalityRes, error) {
	res, err := c.sendUploadPersonality(ctx, request)
	return res, err
}

func (c *Client) sendUploadPersonality(ctx context.Context, request *PersonalityUploadSpec) (res UploadPersonalityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/personalities"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadPersonalityRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUploadPersonalityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadPersonalityFiles invokes uploadPersonalityFiles operation.
//
// Upload personality files to SDDC Manager.
//
// PUT /v1/personalities/files
func (c *Client) UploadPersonalityFiles(ctx context.Context, request OptUploadPersonalityFilesReq) (UploadPersonalityFilesRes, error) {
	res, err := c.sendUploadPersonalityFiles(ctx, request)
	return res, err
}

func (c *Client) sendUploadPersonalityFiles(ctx context.Context, request OptUploadPersonalityFilesReq) (res UploadPersonalityFilesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/personalities/files"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadPersonalityFilesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUploadPersonalityFilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadProductVersionCatalog invokes uploadProductVersionCatalog operation.
//
// Upload product version catalog. Make sure product version is a valid one.
//
// POST /v1/product-version-catalog
func (c *Client) UploadProductVersionCatalog(ctx context.Context, request *ProductVersionCatalog) (UploadProductVersionCatalogRes, error) {
	res, err := c.sendUploadProductVersionCatalog(ctx, request)
	return res, err
}

func (c *Client) sendUploadProductVersionCatalog(ctx context.Context, request *ProductVersionCatalog) (res UploadProductVersionCatalogRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/product-version-catalog"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadProductVersionCatalogRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUploadProductVersionCatalogResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateALBClusterCreationSpec invokes validateALBClusterCreationSpec operation.
//
// Perform validiation of the NsxAlbControllerClusterSpec specification.
//
// POST /v1/nsx-alb-clusters/validations
func (c *Client) ValidateALBClusterCreationSpec(ctx context.Context, request *NsxAlbControllerClusterSpec, params ValidateALBClusterCreationSpecParams) (ValidateALBClusterCreationSpecRes, error) {
	res, err := c.sendValidateALBClusterCreationSpec(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateALBClusterCreationSpec(ctx context.Context, request *NsxAlbControllerClusterSpec, params ValidateALBClusterCreationSpecParams) (res ValidateALBClusterCreationSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nsx-alb-clusters/validations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "skipCompatibilityCheck" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "skipCompatibilityCheck",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SkipCompatibilityCheck.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateALBClusterCreationSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateALBClusterCreationSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateAvnSpec invokes validateAvnSpec operation.
//
// Returns Validation report.
//
// POST /v1/avns/validations
func (c *Client) ValidateAvnSpec(ctx context.Context, request *AvnsCreationSpec) (ValidateAvnSpecRes, error) {
	res, err := c.sendValidateAvnSpec(ctx, request)
	return res, err
}

func (c *Client) sendValidateAvnSpec(ctx context.Context, request *AvnsCreationSpec) (res ValidateAvnSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/avns/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateAvnSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateAvnSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateBackupConfigurationsOperations invokes validateBackupConfigurationsOperations operation.
//
// Validation API for backup configuration for SDDC Manager and NSX Manager.
//
// POST /v1/system/backup-configuration/validations
func (c *Client) ValidateBackupConfigurationsOperations(ctx context.Context, request *BackupConfigurationSpec) (ValidateBackupConfigurationsOperationsRes, error) {
	res, err := c.sendValidateBackupConfigurationsOperations(ctx, request)
	return res, err
}

func (c *Client) sendValidateBackupConfigurationsOperations(ctx context.Context, request *BackupConfigurationSpec) (res ValidateBackupConfigurationsOperationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/backup-configuration/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateBackupConfigurationsOperationsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateBackupConfigurationsOperationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateBringupSpec invokes validateBringupSpec operation.
//
// SDDC specification incorporates all the client inputs regarding VMW component parameters
// constituting the SDDC: NTP, DNS spec, ESXi, VC, VSAN, NSX spec et al.
//
// POST /v1/sddcs/validations
func (c *Client) ValidateBringupSpec(ctx context.Context, request *SddcSpec, params ValidateBringupSpecParams) (ValidateBringupSpecRes, error) {
	res, err := c.sendValidateBringupSpec(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateBringupSpec(ctx context.Context, request *SddcSpec, params ValidateBringupSpecParams) (res ValidateBringupSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sddcs/validations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "redo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "redo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Redo.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateBringupSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateBringupSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateClusterCreationSpec invokes validateClusterCreationSpec operation.
//
// Perform validation of the ClusterCreationSpec specification.
//
// POST /v1/clusters/validations
func (c *Client) ValidateClusterCreationSpec(ctx context.Context, request *ClusterCreationSpec, params ValidateClusterCreationSpecParams) (ValidateClusterCreationSpecRes, error) {
	res, err := c.sendValidateClusterCreationSpec(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateClusterCreationSpec(ctx context.Context, request *ClusterCreationSpec, params ValidateClusterCreationSpecParams) (res ValidateClusterCreationSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/clusters/validations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "hostsOnly" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hostsOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HostsOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "skipHostSwitchValidation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "skipHostSwitchValidation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SkipHostSwitchValidation.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateClusterCreationSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateClusterCreationSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateClusterUpdateSpec invokes validateClusterUpdateSpec operation.
//
// Perform validation of the ClusterUpdateSpec specification.
//
// POST /v1/clusters/{id}/validations
func (c *Client) ValidateClusterUpdateSpec(ctx context.Context, request *ClusterUpdateSpec, params ValidateClusterUpdateSpecParams) (ValidateClusterUpdateSpecRes, error) {
	res, err := c.sendValidateClusterUpdateSpec(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateClusterUpdateSpec(ctx context.Context, request *ClusterUpdateSpec, params ValidateClusterUpdateSpecParams) (res ValidateClusterUpdateSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "useAsyncValidation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "useAsyncValidation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UseAsyncValidation.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateClusterUpdateSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateClusterUpdateSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateCommissionHosts invokes validateCommissionHosts operation.
//
// Validate the input specification to commission the Hosts.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /v1/hosts/validations/commissions
func (c *Client) ValidateCommissionHosts(ctx context.Context, request []HostCommissionSpec) (ValidateCommissionHostsRes, error) {
	res, err := c.sendValidateCommissionHosts(ctx, request)
	return res, err
}

func (c *Client) sendValidateCommissionHosts(ctx context.Context, request []HostCommissionSpec) (res ValidateCommissionHostsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hosts/validations/commissions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateCommissionHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateCommissionHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateDnsConfiguration invokes validateDnsConfiguration operation.
//
// Perform validation of the DnsConfiguration specification.
//
// POST /v1/system/dns-configuration/validations
func (c *Client) ValidateDnsConfiguration(ctx context.Context, request *DnsConfiguration) (ValidateDnsConfigurationRes, error) {
	res, err := c.sendValidateDnsConfiguration(ctx, request)
	return res, err
}

func (c *Client) sendValidateDnsConfiguration(ctx context.Context, request *DnsConfiguration) (res ValidateDnsConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/dns-configuration/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateDnsConfigurationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateDnsConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateDomainCreationSpec invokes validateDomainCreationSpec operation.
//
// Perform validation of the DomainCreationSpec specification.
//
// POST /v1/domains/validations
func (c *Client) ValidateDomainCreationSpec(ctx context.Context, request *DomainCreationSpec, params ValidateDomainCreationSpecParams) (ValidateDomainCreationSpecRes, error) {
	res, err := c.sendValidateDomainCreationSpec(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateDomainCreationSpec(ctx context.Context, request *DomainCreationSpec, params ValidateDomainCreationSpecParams) (res ValidateDomainCreationSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/domains/validations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "hostsOnly" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hostsOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HostsOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "skipHostSwitchValidation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "skipHostSwitchValidation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SkipHostSwitchValidation.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateDomainCreationSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateDomainCreationSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateDomainUpdateSpec invokes validateDomainUpdateSpec operation.
//
// Perform validation of the DomainUpdateSpec specification.
//
// POST /v1/domains/{id}/validations
func (c *Client) ValidateDomainUpdateSpec(ctx context.Context, request *DomainUpdateSpec, params ValidateDomainUpdateSpecParams) (ValidateDomainUpdateSpecRes, error) {
	res, err := c.sendValidateDomainUpdateSpec(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateDomainUpdateSpec(ctx context.Context, request *DomainUpdateSpec, params ValidateDomainUpdateSpecParams) (res ValidateDomainUpdateSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateDomainUpdateSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateDomainUpdateSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateEdgeClusterCreationSpec invokes validateEdgeClusterCreationSpec operation.
//
// Perform validiation of the EdgeClusterCreationSpec specification.
//
// POST /v1/edge-clusters/validations
func (c *Client) ValidateEdgeClusterCreationSpec(ctx context.Context, request *EdgeClusterCreationSpec) (ValidateEdgeClusterCreationSpecRes, error) {
	res, err := c.sendValidateEdgeClusterCreationSpec(ctx, request)
	return res, err
}

func (c *Client) sendValidateEdgeClusterCreationSpec(ctx context.Context, request *EdgeClusterCreationSpec) (res ValidateEdgeClusterCreationSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/edge-clusters/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateEdgeClusterCreationSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateEdgeClusterCreationSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateEdgeClusterUpdateSpec invokes validateEdgeClusterUpdateSpec operation.
//
// Perform validation of the EdgeClusterUpdateSpec specification.
//
// POST /v1/edge-clusters/{id}/validations
func (c *Client) ValidateEdgeClusterUpdateSpec(ctx context.Context, request *EdgeClusterUpdateSpec, params ValidateEdgeClusterUpdateSpecParams) (ValidateEdgeClusterUpdateSpecRes, error) {
	res, err := c.sendValidateEdgeClusterUpdateSpec(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateEdgeClusterUpdateSpec(ctx context.Context, request *EdgeClusterUpdateSpec, params ValidateEdgeClusterUpdateSpecParams) (res ValidateEdgeClusterUpdateSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/edge-clusters/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateEdgeClusterUpdateSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateEdgeClusterUpdateSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateHostCommissionSpec invokes validateHostCommissionSpec operation.
//
// Perform validation of the  HostCommissionSpec specification.
//
// POST /v1/hosts/validations
func (c *Client) ValidateHostCommissionSpec(ctx context.Context, request []HostCommissionSpec) (ValidateHostCommissionSpecRes, error) {
	res, err := c.sendValidateHostCommissionSpec(ctx, request)
	return res, err
}

func (c *Client) sendValidateHostCommissionSpec(ctx context.Context, request []HostCommissionSpec) (res ValidateHostCommissionSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hosts/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateHostCommissionSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateHostCommissionSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateIpPool invokes validateIpPool operation.
//
// POST /v1/nsxt-clusters/ip-address-pools/validations
func (c *Client) ValidateIpPool(ctx context.Context, request *NsxtIpAddressPoolValidationSpec) (*Validation, error) {
	res, err := c.sendValidateIpPool(ctx, request)
	return res, err
}

func (c *Client) sendValidateIpPool(ctx context.Context, request *NsxtIpAddressPoolValidationSpec) (res *Validation, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nsxt-clusters/ip-address-pools/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateIpPoolRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateIpPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateNsxALBCompatibility invokes validateNsxALBCompatibility operation.
//
// Validate NSX ALB compatibility version.
//
// POST /v1/nsx-alb-clusters/validations/version
func (c *Client) ValidateNsxALBCompatibility(ctx context.Context, request *NsxAlbVersionValidationSpec) (ValidateNsxALBCompatibilityRes, error) {
	res, err := c.sendValidateNsxALBCompatibility(ctx, request)
	return res, err
}

func (c *Client) sendValidateNsxALBCompatibility(ctx context.Context, request *NsxAlbVersionValidationSpec) (res ValidateNsxALBCompatibilityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nsx-alb-clusters/validations/version"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateNsxALBCompatibilityRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateNsxALBCompatibilityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateNtpConfiguration invokes validateNtpConfiguration operation.
//
// Perform validation of the NtpConfiguration specification.
//
// POST /v1/system/ntp-configuration/validations
func (c *Client) ValidateNtpConfiguration(ctx context.Context, request *NtpConfiguration) (ValidateNtpConfigurationRes, error) {
	res, err := c.sendValidateNtpConfiguration(ctx, request)
	return res, err
}

func (c *Client) sendValidateNtpConfiguration(ctx context.Context, request *NtpConfiguration) (res ValidateNtpConfigurationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/system/ntp-configuration/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateNtpConfigurationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateNtpConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateReleaseByDomainID invokes validateReleaseByDomainID operation.
//
// Validate the target selected upgrade release BOM or custom BOM for a domain by its ID.
//
// POST /v1/releases/domains/{domainId}/validations
func (c *Client) ValidateReleaseByDomainID(ctx context.Context, request *DomainRelease, params ValidateReleaseByDomainIDParams) (ValidateReleaseByDomainIDRes, error) {
	res, err := c.sendValidateReleaseByDomainID(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateReleaseByDomainID(ctx context.Context, request *DomainRelease, params ValidateReleaseByDomainIDParams) (res ValidateReleaseByDomainIDRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/releases/domains/"
	{
		// Encode "domainId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DomainId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateReleaseByDomainIDRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateReleaseByDomainIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateResourceCertificates invokes validateResourceCertificates operation.
//
// Validate resource certificates.
//
// PUT /v1/domains/{id}/resource-certificates/validations
func (c *Client) ValidateResourceCertificates(ctx context.Context, request []ResourceCertificateSpec, params ValidateResourceCertificatesParams) (ValidateResourceCertificatesRes, error) {
	res, err := c.sendValidateResourceCertificates(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateResourceCertificates(ctx context.Context, request []ResourceCertificateSpec, params ValidateResourceCertificatesParams) (res ValidateResourceCertificatesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/domains/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/resource-certificates/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateResourceCertificatesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateResourceCertificatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateVasaProviderSpec invokes validateVasaProviderSpec operation.
//
// Validate VasaProvider input specification.
//
// POST /v1/vasa-providers/validations
func (c *Client) ValidateVasaProviderSpec(ctx context.Context, request *VasaProvider) (ValidateVasaProviderSpecRes, error) {
	res, err := c.sendValidateVasaProviderSpec(ctx, request)
	return res, err
}

func (c *Client) sendValidateVasaProviderSpec(ctx context.Context, request *VasaProvider) (res ValidateVasaProviderSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vasa-providers/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateVasaProviderSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateVasaProviderSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateVrslcm invokes validateVrslcm operation.
//
// Triggers VMware Aria Suite Lifecycle deployment specification validation workflow.
//
// POST /v1/vrslcms/validations
func (c *Client) ValidateVrslcm(ctx context.Context, request *VrslcmDeploymentSpec) (ValidateVrslcmRes, error) {
	res, err := c.sendValidateVrslcm(ctx, request)
	return res, err
}

func (c *Client) sendValidateVrslcm(ctx context.Context, request *VrslcmDeploymentSpec) (res ValidateVrslcmRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/vrslcms/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateVrslcmRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateVrslcmResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateVsanRemoteDatastoreMountSpec invokes validateVsanRemoteDatastoreMountSpec operation.
//
// Perform validation of the DatastoreMountSpec specification.
//
// POST /v1/clusters/{clusterId}/datastores/validations
func (c *Client) ValidateVsanRemoteDatastoreMountSpec(ctx context.Context, request *DatastoreMountSpec, params ValidateVsanRemoteDatastoreMountSpecParams) (ValidateVsanRemoteDatastoreMountSpecRes, error) {
	res, err := c.sendValidateVsanRemoteDatastoreMountSpec(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateVsanRemoteDatastoreMountSpec(ctx context.Context, request *DatastoreMountSpec, params ValidateVsanRemoteDatastoreMountSpecParams) (res ValidateVsanRemoteDatastoreMountSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "clusterId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores/validations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateVsanRemoteDatastoreMountSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateVsanRemoteDatastoreMountSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateVsanRemoteDatastoreSpec invokes validateVsanRemoteDatastoreSpec operation.
//
// Perform validation of the DatastoreMountSpec specification.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /v1/clusters/{clusterId}/datastores/validation
func (c *Client) ValidateVsanRemoteDatastoreSpec(ctx context.Context, request *DatastoreMountSpec, params ValidateVsanRemoteDatastoreSpecParams) (ValidateVsanRemoteDatastoreSpecRes, error) {
	res, err := c.sendValidateVsanRemoteDatastoreSpec(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateVsanRemoteDatastoreSpec(ctx context.Context, request *DatastoreMountSpec, params ValidateVsanRemoteDatastoreSpecParams) (res ValidateVsanRemoteDatastoreSpecRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/clusters/"
	{
		// Encode "clusterId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/datastores/validation"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateVsanRemoteDatastoreSpecRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeValidateVsanRemoteDatastoreSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
